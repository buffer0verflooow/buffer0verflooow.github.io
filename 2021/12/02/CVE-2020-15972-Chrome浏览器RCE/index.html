<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="漏洞原因 Chrome 的 WebAudio 组件中的UAF 影响范围 该错误已在 10 月份的 Chrome 86.0.4240.75版中修复。影响了 Chrome 85 稳定版的大部分。  原文链接：https:&#x2F;&#x2F;securitylab.github.com&#x2F;research&#x2F;one_day_short_of_a_fullchain_renderer&#x2F;  背景以前，网页对于音频的处理仅限于&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="CVE-2020-15972 Chrome浏览器RCE">
<meta property="og:url" content="https://buffer0verflooow.github.io/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:description" content="漏洞原因 Chrome 的 WebAudio 组件中的UAF 影响范围 该错误已在 10 月份的 Chrome 86.0.4240.75版中修复。影响了 Chrome 85 稳定版的大部分。  原文链接：https:&#x2F;&#x2F;securitylab.github.com&#x2F;research&#x2F;one_day_short_of_a_fullchain_renderer&#x2F;  背景以前，网页对于音频的处理仅限于&amp;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mdn.mozillademos.org/files/12241/webaudioAPI_en.svg">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/graph_pull.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph2.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph3.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/heap1.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/heap2.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/heap3.png">
<meta property="og:image" content="https://securitylab.github.com/assets/img/post-images/webaudio/call_func.png">
<meta property="article:published_time" content="2021-12-02T10:58:56.000Z">
<meta property="article:modified_time" content="2021-12-12T09:51:28.740Z">
<meta property="article:author" content="buffer0verflooow">
<meta property="article:tag" content="android">
<meta property="article:tag" content="chrome">
<meta property="article:tag" content="webaudio">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mdn.mozillademos.org/files/12241/webaudioAPI_en.svg">


<link rel="canonical" href="https://buffer0verflooow.github.io/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://buffer0verflooow.github.io/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/","path":"2021/12/02/CVE-2020-15972-Chrome浏览器RCE/","title":"CVE-2020-15972 Chrome浏览器RCE"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>CVE-2020-15972 Chrome浏览器RCE | buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">buffer0verflooow - Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E"><span class="nav-number">2.</span> <span class="nav-text">漏洞</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E7%AB%9E%E4%BA%89"><span class="nav-number">2.1.</span> <span class="nav-text">控制竞争</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E8%AF%AD"><span class="nav-number">2.2.</span> <span class="nav-text">漏洞原语</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="nav-number">2.3.</span> <span class="nav-text">信息泄露</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%80%89"><span class="nav-number">2.3.1.</span> <span class="nav-text">可选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="nav-number">2.3.2.</span> <span class="nav-text">获取信息泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RCE"><span class="nav-number">2.4.</span> <span class="nav-text">RCE</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="CVE-2020-15972 Chrome浏览器RCE | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CVE-2020-15972 Chrome浏览器RCE
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-02 18:58:56" itemprop="dateCreated datePublished" datetime="2021-12-02T18:58:56+08:00">2021-12-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-12 17:51:28" itemprop="dateModified" datetime="2021-12-12T17:51:28+08:00">2021-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>漏洞原因</p>
<p>Chrome 的 WebAudio 组件中的UAF</p>
<p>影响范围</p>
<p>该错误已在 10 月份的 Chrome <a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">86.0.4240.75</a>版中<a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">修复</a>。影响了 Chrome 85 稳定版的大部分。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/">https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以前，网页对于音频的处理仅限于<code>&lt;audio&gt;</code>标签，能力十分有限，为了实现更高级的操作，W3C设计实现了WebAudio API，通过这些API，我们几乎可以完成一个专业的音频处理软件的构建。</p>
<p>WebAudio API可以实现：</p>
<ul>
<li>实现高精度的音频计算。</li>
<li>音频混响器。</li>
<li>3D音频。</li>
<li>与<code>&lt;audio&gt;/WebRTC</code>的集成。</li>
</ul>
<p>设计思路：类似于标准IO函数，从某个地方（input）读取一个音频流，经过实时计算处理后发送去某个地方（destination），这个处理过程是effect。</p>
<p><img src="https://mdn.mozillademos.org/files/12241/webaudioAPI_en.svg"></p>
<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>由于音频处理是一项计算密集型任务，它将在单独的音频线程上完成，以便不阻塞浏览器的响应。WebAudio中的音频输入以128帧为单位进行处理，称为quantum。一旦一个quantum开始处理，整个quantum就必须完成，这意味着所有的节点都必须处理这128帧，即使有些节点被主线程删除和收集垃圾。</p>
<p>在下面的情况中，convolver实际上不会被删除，因为每个节点都持有对它所连接的输出节点的引用。然而，如果我们断开节点的连接，则convolver可能会被删除，但音频图仍然在被处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> soundSource1 = audioContext.<span class="title function_">createConstantSource</span>();</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource1.<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();       <span class="comment">//&lt;-------- start processing the audio graph</span></span><br><span class="line">soundSource1.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br></pre></td></tr></table></figure>

<p>那么一个死去的节点如何继续处理音频数据呢？在WebAudio中，AudioNode实际上只是javascript的一个接口，实际的处理是由它拥有的AudioHandler处理的。当一个AudioNode被销毁时，它将使用IsPullingAudioGraph函数检查此刻是否正在处理一个quantum。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_AUDIONODE_REFERENCES</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[%16p]: %16p: %2d: AudioNode::dispose %16p @%g\n&quot;</span>, <span class="built_in">context</span>(),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">Handler</span>().<span class="built_in">GetNodeType</span>(), handler_.<span class="built_in">get</span>(),</span><br><span class="line">          <span class="built_in">context</span>()-&gt;<span class="built_in">currentTime</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function">BaseAudioContext::GraphAutoLocker <span class="title">locker</span><span class="params">(context())</span></span>;</span><br><span class="line">  <span class="built_in">Handler</span>().<span class="built_in">Dispose</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果上下文被拉到音频图上，就把处理程序添加到孤儿列表中。 </span></span><br><span class="line">  <span class="comment">// 这将使处理程序保持运行，直到它可以在一个安全点（在处理程序任务的前/后）被删除。 </span></span><br><span class="line">  <span class="comment">// 如果图没有被拉动，我们现在就可以删除处理程序，因为音频线程上没有任何东西会接触到它。</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">context</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify the inspector that this node is going away. The actual clean up</span></span><br><span class="line">  <span class="comment">// will be done in the subclass implementation.</span></span><br><span class="line">  <span class="built_in">ReportWillBeDestroyed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个quantum正在被处理，它将把AudioHandler（handler_）的所有权转移到由AudioContext本身拥有的<code>deferred_task_handler_</code>。然后DeferredTaskHandler将确保AudioHandler保持运行，直到quantum的处理完成，然后清理孤儿AudioHandler。</p>
<p>然而，有一个例外。如果包含音频图的javascript框架被破坏了，例如，当包含图的iframe被破坏时，那么DeferredTaskHandler将在quantum仍在处理时立即进行清理，调用ClearHandlersToBeDeleted函数，这将删除孤儿AudioHandler（之前有一个信号量可以解决这个问题，但该信号量在这次<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/e4c27b508976fb751ccd4d34e52b70b668618271?originalUrl=https//////:////////cs.chromium.org/">commit</a>中被删除了）。</p>
<h2 id="控制竞争"><a href="#控制竞争" class="headerlink" title="控制竞争"></a>控制竞争</h2><p>为了在竞争获取足够的时间，来操作AudioHandler，exp使用了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode"><code>AudioWorkletNode</code></a>，AudioWorkletNode允许节点运行用户自定义的JavaScript代码，具体如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet;</span><br><span class="line">worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>可以在tear-down.js中使用sleep函数，这样就有足够的时间删除和替换ConvolverNode：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AudioWorkletProcessor</span> &#123;</span><br><span class="line">  <span class="title function_">process</span> (inputs, outputs, parameters) &#123;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除ConvolverNode的例子如下（实际上，convolver需要运行在另一个不调用parent.removeFrame的函数的范围之内，这里只是举个例子）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">worklet.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<p>另一个有用的事实是，在这样做的时候，只有与所有输入断开连接的节点才会被删除，而与输入保持连接的节点即使在iframe被删除后也会保持活力，只有在处理完成后才会被删除。如下所示，当worklet完成处理时，convolver将保持运行直到gain结束为止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line"><span class="keyword">let</span> gain = audioContext.<span class="title function_">createGain</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">convolver.<span class="title function_">disconnect</span>();</span><br><span class="line">gain = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>每个AudioHandler拥有一个音频节点的输入和输出的列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioHandler</span> : public <span class="title class_">ThreadSafeRefCounted</span>&lt;<span class="title class_">AudioHandler</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeInput</span>&gt;&gt; inputs_;</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeOutput</span>&gt;&gt; outputs_;</span><br></pre></td></tr></table></figure>

<p>AudioNodeInput（AudioSummingJunction的一个子类）也持有一个连接到它的输出列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AudioSummingJunction</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// m_renderingOutputs is a copy of m_outputs which will never be modified</span></span><br><span class="line">  <span class="comment">// during the graph rendering on the audio thread.  This is the list which</span></span><br><span class="line">  <span class="comment">// is used by the rendering code.</span></span><br><span class="line">  <span class="comment">// Whenever m_outputs is modified, the context is told so it can later</span></span><br><span class="line">  <span class="comment">// update m_renderingOutputs from m_outputs at a safe time.  Most of the</span></span><br><span class="line">  <span class="comment">// time, m_renderingOutputs is identical to m_outputs.</span></span><br><span class="line">  <span class="comment">// These raw pointers are safe. Owner of this AudioSummingJunction has</span></span><br><span class="line">  <span class="comment">// strong references to owners of these AudioNodeOutput.</span></span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="title class_">AudioNodeOutput</span>*&gt; rendering_outputs_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AudioNodeOutput保留了一个与它相连的AudioNodeInput的列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioNodeOutput</span> final &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// This HashSet holds connection references. We must call</span></span><br><span class="line">  <span class="comment">// AudioNode::makeConnection when we add an AudioNodeInput to this, and must</span></span><br><span class="line">  <span class="comment">// call AudioNode::breakConnection() when we remove an AudioNodeInput from</span></span><br><span class="line">  <span class="comment">// this.</span></span><br><span class="line">  <span class="title class_">HashSet</span>&lt;<span class="title class_">AudioNodeInput</span>*&gt; inputs_;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，ConvolverHandler拥有一个AudioNodeInput和一个AudioNodeOutput，AudioNodeInput持有对worklet的AudioNodeOutput的引用，而AudioNodeOutput持有对gain的AudioNodeInput的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>当处理一个音频图时，代码实际上是从目的地开始向后传播，并调用AudioNodeInput::Pull，然后它将为每个连接到它的输出调用AudioNodeOutput::Pull。然后AudioNodeOutput::Pull调用拥有它的AudioHandler::ProcessIfNecessary，后者又会为它的输入调用AudioNodeInput::Pull，并将调用传播给连接到它的AudioHandler。这一直持续到没有输入的源节点，然后实际的处理将从调用AudioHandler::Process开始。在AudioHandler::Process完成后，它将通过AudioNodeOutput::Pull-&gt;AudioNodeInput::Pull-&gt;AudioHandler::PullInputs-&gt;AudioHandler::ProcessIfNecessary返回到下一个AudioHandler的AudioHandler::Process。下图以两个AudioHandler为例说明了这一点，下面的一个是AudioWorkletNode：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/graph_pull.png"></p>
<p>在上图中，每个大的矩形代表了对AudioHandler所拥有的对象的所有调用，里面的小矩形代表了被调用的函数。蓝色箭头代表控制流边缘，从一个AudioHandler跳到另一个。当用一个等待了很长时间的AudioWorkletHandler来触发UAF时，相关的跳转是在AudioHandler::Process完成之后，因为在那个时候，下一个AudioHandler会被删除和替换。在上图中，红色区域表示用对象进行的调用，这些对象在调用时将被删除。此时，代码将首先返回AudioWorkletHandler拥有的AudioNodeOutput::Pull，就在对ProcessIfNecessary的调用之后。下面是它随后将遵循的代码路径，以及一些利用的可能性。</p>
<ol>
<li>当Process返回时，它首先会返回到AudioWorkletHandler的ProcessIfNecessary，然后是它所拥有的AudioNodeOutput::Pull。这时，这些对象都不会被删除（对应于图中左下角灰色框中AudioHandler::Process之后的蓝色箭头部分）。如果AudioNodeOutput::Pull是从AudioNodeInput::Pull，而不是AudioNodeInput::SumAllConnections中调用的，那么它将跳回到已释放的 AudioHandler::PullInputs，这意味着inputs_将在循环仍在迭代时被删除。</li>
<li>如果上面的inputs_的大小是一个开始，那么循环就会直接退出，而ProcessIfNecessary将从PullInputs之后继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::ProcessIfNecessary</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PullInputs</span>(frames_to_process);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> silent_inputs = <span class="built_in">InputsAreSilent</span>();</span><br><span class="line">    <span class="keyword">if</span> (silent_inputs &amp;&amp; <span class="built_in">PropagatesSilence</span>()) &#123;</span><br><span class="line">      <span class="built_in">SilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">ProcessOnlyAudioParams</span>(frames_to_process);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">UnsilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">Process</span>(frames_to_process);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时，AudioHandler已经被释放了。根据InputsAreSilent的结果，虚函数PropagatesSilence或Process将被调用。</p>
<ol start="3">
<li>如果上一点中被删除的AudioHandler被另一个有效的AudioHandler替换了，这样虚拟函数的调用就不会崩溃，那么ProcessIfNecessary将返回到调用AudioNodeOutput::Pull。现在因为AudioNodeOutput和AudioHandler的大小不同，所以有可能AudioNodeOutput（在调用AudioNodeOutput::Pull）仍然被释放的情况下替换AudioHandler（堆栈&#x2F;注册表仍然存储指向被释放对象的指针，而不是替换后的AudioHandler的AudioNodeOutput）。然后，AudioNodeOutput::Pull函数将调用Bus并返回一个指向该AudioNodeOutput拥有的AudioBus对象的指针。这意味着返回值也将被释放，指向的对象（AudioBus）可以被替换成受控数据。然而，这只在从AudioNodeInput::SumAllConnections调用AudioNodeOutput::Pull的路径中才有意义，因为通过AudioNodeInput::Pull的路径并不利用返回值。</li>
</ol>
<p>虽然第二点可以通过伪造vtable来劫持控制流，但这需要有信息泄露来打败ASLR，并获得一个堆地址来存储假vtable，所以在这一点上我无法使用它。第一点有可能是非常强大的，因为它有可能让我用任何类型的指针向量来替换inputs_，导致AudioNodeInput和许多可能的类型之间的类型混淆。可以用一个简单的CodeQL查询来找到可能的类型。</p>
<h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p>先看第三种可能，当通过SumAllConnections调用时，输出的返回值output，现在已经被释放了，被传递给SumFrom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    AudioBus* connection_bus = output-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum, with unity-gain.</span></span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据summing_bus和connection_bus之间的通道数量，可以采取各种路径。最简单的路径只是调用AudioChannel::SumFrom</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioBus::SumFrom</span><span class="params">(<span class="type">const</span> AudioBus&amp; source_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ChannelInterpretation channel_interpretation)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (number_of_source_channels == number_of_destination_channels) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_source_channels; ++i)</span><br><span class="line">      <span class="built_in">Channel</span>(i)-&gt;<span class="built_in">SumFrom</span>(source_bus.<span class="built_in">Channel</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AudioChannel::SumFrom简单地将source_bus, (connection_bus)中的数据复制到summing_bus，使用summing_bus的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioChannel::SumFrom</span><span class="params">(<span class="type">const</span> AudioChannel* source_channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSilent</span>()) &#123;</span><br><span class="line">    <span class="built_in">CopyFrom</span>(source_channel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Copies using the length of `summing_bus` (`length()`)</span></span><br><span class="line">    vector_math::<span class="built_in">Vadd</span>(<span class="built_in">Data</span>(), <span class="number">1</span>, source_channel-&gt;<span class="built_in">Data</span>(), <span class="number">1</span>, <span class="built_in">MutableData</span>(), <span class="number">1</span>,</span><br><span class="line">                      <span class="built_in">length</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果可以用一个长度短于summing_bus的Bus来替换已释放的AudioNodeOutput，那么就可以得到一个越界的读取。通过安排堆，就可以利用这一点获得一个vtable和&#x2F;或堆指针的地址，这将能够使用第二点中的虚拟函数调用原语来实现远程代码执行。</p>
<p>然而，有几个问题。首先，即使可以替换掉已释放的AudioNodeOutput，我仍然需要有一个有效的指向connection_bus的指针，这个指针是一个有效的AudioBus。一个简单的方法是用另一个有短总线的AudioNodeOutput替换AudioNodeOutput。不幸的是，所有AudioNodeOutput的Bus都是相同的长度（128），这是有道理的，否则会一直有越界的读写。另一种可能性是，由于Bus为AudioNodeOutput所有，可以直接替换Bus，而让AudioNodeOutput空出来。由于用于分配AudioNodeOutput和Bus的内存分配器PartitionAlloc是一个桶分配器，AudioNodeOutput的大小为104，而AudioBus的大小为32，通过分别操作这两个桶，可以在释放AudioNodeOutput的同时替换Bus。虽然PartitionAlloc会把释放对象的前8个字节弄乱作为额外的保护，但这并不影响AudioNodeOutput::Bus返回的指针，所以connection_bus仍然会指向用来替换的对象。如果用一个长度较短的对象替换Bus，那么就会得到一个信息泄露。</p>
<p>现在的问题是如何创建一个具有任意长度的AudioBus。看看对AudioBus::Create的各种调用，ConvolverHandler::SetBuffer中的调用看起来很有希望，因为它可以通过指定ConvolverNode的buffer字段从javascript中轻松到达。不幸的是，创建的AudioBus只是本地的，并且在函数调用结束后会被删除，这使得它很难使用。最后，WebAudioBus::Initialize中的那个函数效果更好，因为它可以通过javascript中的decodeAudioData函数达到，创建的AudioBus的长度由输入ArrayBuffer（包含一些音频数据）的大小控制。通过使用ffmpeg来创建不同长度的MP3文件，我能够使用这个函数来创建不同长度的AudioBus。</p>
<p>下一个问题更难解决。虽然可以造成越界读取，并将结果复制到summing_bus的backing store中，但由于几个原因，没有办法将这些数据读出来：</p>
<ul>
<li>为了触发UAF，需要删除包含音频图的iframe，这意味着当越界读取发生时，所有的音频节点将无法到达，因此没有办法检索属于该图的AudioNodeInput的summing_bus中的数据。</li>
<li>如果summing_bus也被释放，那么也许可以用仍然可以到达的AudioNodeInput中的另一个AudioBus来代替它，然后也许有办法从该AudioNodeInput的summing_bus中读出数据。不幸的是，情况也不是这样的，因为summing_bus不是一个原始指针，而是一个共享所有权的scoped_refptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，即使现在所有的东西都被释放了，summing_bus仍将保持活力，至少在SumAllConnections调用完成之前，所以没有办法去替换summing_bus。</p>
<p><strong>实际的方式</strong></p>
<p>回到上一节第1点中的迭代器无效原语。如前所述，通过把一个接受多个输入的AudioNode，如ChannelMergerNode放在AudioWorkletNode之后，然后删除包含音频图的iframe来触发UAF，ChannelMergerNode和由此产生的inputs_将被删除，而AudioHandler::PullInputs的循环仍在迭代中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::PullInputs</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_)</span><br><span class="line">    input-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中，这意味着在完成input-&gt;Pull调用后，input迭代器将被递增，并指向现在被删除的<code>input_</code>的已释放backing store中的下一个位置。这将继续下去，直到达到<code>input_</code>的长度。因此，通过分配另一个与inputs_相同大小的Vector，我用新Vector的支持存储空间替换了已释放的backing store。虽然这可以用来造成类型混乱，并在许多不同类型的对象上调用AudioNodeInput::Pull，但应该用什么对象来替换AudioNodeInput并不明显。</p>
<p>将ChannelMergerNode换成另一个ChannelMergerNode，它运行在父帧的音频图上。因此，当这个错误触发时，它将继续运行另一个运行在父帧中的音频图。</p>
<p>下面的图展示了替换这个对象时会发生什么：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph.png"></p>
<p>破折号边框和边表示如果子iframe没有被删除，将会被运行的节点和边，而绿色节点表示实际被运行的节点。在处理完子iframe的顶部分支后，该框架被删除，ChannelMergerNode被替换成父帧中的节点。这导致父帧中的音频图的底部分支被代替运行。</p>
<p>当删除一个AudioNode时会发生什么？正如前面解释的那样，当一个AudioNode被垃圾回收时，为了防止底层的AudioHandler被删除，而它还在被用来处理音频图，AudioNode将通过调用AudioContext的IsPullingAudioGraph方法来检查它所属的音频图是否正在被处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>IsPullingAudioGraph检查音频图是否处于kRunning状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OfflineAudioContext::IsPullingAudioGraph</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ContextState</span>() == BaseAudioContext::kRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并转移AudioHandler的所有权（如果它是）。然而，在这种情况下，因为父帧中的音频图正在作为子框架中的图的一部分被处理，音频图不会处于kRunning状态，因为它没有从父帧中启动。(在实际利用中，将不得不启动然后暂停图形以使节点相互连接，但这没有什么区别，因为图形将处于kSuspended状态，所以IsPullingAudioGraph检查仍将通过)这意味着AudioHandler的所有权转移将不会发生，它将在图形被处理时被删除。</p>
<p>这意味着可以在这个图中引起同样类型的UAF，而不需要删除包含它的框架。这一点很重要，因为之前试图获得信息泄露的主要问题是，所有的节点和包含它们的iframe都被删除了，所以没有办法检索到泄露的数据。但现在可以在不删除包含节点的框架的情况下导致UAF，将能够在UAF触发后访问它们，并能够读取泄露的数据。</p>
<h3 id="获取信息泄露"><a href="#获取信息泄露" class="headerlink" title="获取信息泄露"></a>获取信息泄露</h3><p>第一步，在一个子iframe中触发UAF，并使用循环迭代器无效原语，使音频图的一个分支在父帧中运行。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph2.png"></p>
<p>上图显示了将用于替换的实际图形。它由两个ScriptProcessorNode夹着一个GainNode组成。ScriptProcessorNode就像AudioWorkletNode，它允许运行用户提供的脚本来处理音频数据。然而，在ScriptProcessorNode的情况下，脚本是在dom窗口的上下文中运行的，它允许我访问AudioContext和各种节点，这使得使用ScriptProcessorNode进行开发更容易，exp将在父框架图中使用它而不是AudioWorkletNode。</p>
<p>第二步，在ScriptProcessorNode脚本2的音频处理脚本中，移除跟随它的GainNode，并对其进行垃圾回收，这样它的AudioInputNode和AudioOutputNode，就被释放了。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph3.png"></p>
<p>为了构建信息泄露，还需要替换被删除的GainNode，以防止虚函数调用崩溃，同时让它的AudioOutputNode保持自由。可以通过操纵堆来创建额外的释放的AudioOutputNode，这样当GainNode被释放时，它的AudioOutputNode就不会在free列表的首位，不会被替换。我通过创建一个额外的ChannelMergerNode来做到这一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">createSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  let s = audioCtx.<span class="built_in">createChannelMerger</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个ScriptProcessorNode的音频处理器。</span></span><br><span class="line"><span class="function">function <span class="title">scriptProcess2</span><span class="params">(audioProcessingEvent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要为AudioOutputNode创建孔，使它们不会被回收。</span></span><br><span class="line">  <span class="built_in">createSource</span>();</span><br><span class="line">  ...</span><br><span class="line">  script<span class="number">2.</span><span class="built_in">disconnect</span>();  <span class="comment">//&lt;--- 移除GainNode的引用</span></span><br><span class="line">  <span class="built_in">gc</span>();                  <span class="comment">//&lt;--- 首先删除GainNode, 然后在createSource中创建ChannelMergerNode</span></span><br><span class="line">  <span class="comment">// 需要等待GC分配的小对象被清除。</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">4000</span>);</span><br><span class="line">  let gain = audioCtx<span class="number">2.</span><span class="built_in">createGain</span>();  							 <span class="comment">//&lt;---- 替换gain以获取虚函数调用</span></span><br><span class="line">  let src0 = audioCtx<span class="number">2.</span><span class="built_in">createChannelMerger</span>(<span class="number">1</span>); 		   <span class="comment">//&lt;--- 为AudioBus安排堆栈</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然对createSource的调用看起来是多余的，但是，在createSource中创建的ChannelMergerNode直到垃圾回收时才会被删除，到那时，它实际上会在GainNode之后被删除，在freelist的头部留下额外的AudioOutputNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap1.png"></p>
<p>当被删除的GainNode被另一个GainNode取代时，旧GainNode的已释放的AudioNodeOutput将不会被占用。这个被释放的GainNode将负责调用Bus并为我们提供一个被释放的AudioBus。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap2.png"></p>
<p>在图中，绿色箭头表示当另一个对象被删除时被释放的对象，红色箭头表示被创建的对象。</p>
<p>为了替换AudioNodeOutput拥有的大小为32的AudioBus，也需要对大小为32的桶进行操作。为此再次使用另一个ChannelMergerNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap3.png"></p>
<p>同时，还必须注意不要替换被删除的GainNode的AudioNodeOutput…</p>
<p>虽然有很多要求需要满足，而且AudioBus是从一个相当嘈杂的桶中分配的，但与其他情况不同的是，在其他情况下，堆经常被其他进程共享，而这些进程并不在我们的控制范围内，而渲染器在很大程度上是一个孤立的进程，完全拥有其堆。因此，只要脚本是从一个新的渲染器中运行的，就可以以非常精确和具体的方式进行渲染器堆的喷射（当从登录的上下文中点击一个链接时，如通过电子邮件或Twitter），所以这不会对漏洞的可靠性造成太大的问题。</p>
<p>一旦堆被放入正确的状态，使现在被删除的GainNode所拥有的AudioBus处于freelist的正确位置，AudioContext::decodeAudioData函数就可以用来创建一个适当长度的AudioBus来触发越界读取。这个函数接收一个音频文件的ArrayBuffer（例如mp3、ogg），并在后台线程中对其进行解码。它将创建一个具有适当长度的AudioBus来容纳解码后的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::DecodeOnBackgroundThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer* audio_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> sample_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  scoped_refptr&lt;AudioBus&gt; bus = <span class="built_in">CreateBusFromInMemoryAudioFile</span>(</span><br><span class="line">      audio_data-&gt;<span class="built_in">Data</span>(), audio_data-&gt;<span class="built_in">ByteLength</span>(), <span class="literal">false</span>, sample_rate);  <span class="comment">//&lt;----- 创建AudioBus</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    <span class="built_in">PostCrossThreadTask</span>(</span><br><span class="line">        *task_runner, FROM_HERE,</span><br><span class="line">        <span class="built_in">CrossThreadBindOnce</span>(&amp;AsyncAudioDecoder::NotifyComplete,</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(audio_data),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(success_callback),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(error_callback),</span><br><span class="line">                            WTF::<span class="built_in">RetainedRef</span>(std::<span class="built_in">move</span>(bus)),            <span class="comment">//&lt;------ 传入NotifyComplete</span></span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(resolver),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(context)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建的AudioBus被作为主线程上的一个任务传递给NotifyComplete，并在NotifyComplete完成后被删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::NotifyComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer*,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    AudioBus* audio_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  AudioBuffer* audio_buffer = AudioBuffer::<span class="built_in">CreateFromAudioBus</span>(audio_bus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the context is available, let the context finish the notification.</span></span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    context-&gt;<span class="built_in">HandleDecodeAudioData</span>(audio_buffer, resolver, success_callback,</span><br><span class="line">                                   error_callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于AudioBus在这里只是一个临时对象，在解码完成后会被删除，所以需要确保它的寿命足够长，以便发生越界读取。为了做到这一点，可以使用javascript函数setInterval来干扰任务队列。当调用setInterval时，它会创建一个延迟的任务。这个任务以及DecodeOnBackgroundThread发布的NotifyComplete任务被发布到同一个任务队列中，在主线程上执行。通过用setInterval创建任务，我可以使NotifyComplete的运行出现延迟，因为在NotifyComplete之前发布的任何任务都必须在NotifyComplete之前运行，而且它们都必须在主线程上运行。这将允许在足够长的时间内保持AudioBus的活力，这样当AudioNodeInput::SumAllConnections导致越界读取时，在音频线程中使用这个AudioBus，它将仍然活着。</p>
<p>通过使用ffmpeg来创建一个无声的mp3文件，创建一个最小长度为47的AudioBus。由于来自AudioNodeInput的AudioBus的长度是128，而且AudioBus的后备存储是浮点格式，有16个大小的padding（Android为16，x86为32），这意味着可以使用界外读原语来读取大小在204和528之间的对象。CodeQL查询，可以用来识别这样的对象，并选择适当的文件长度来使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FastMallocClass</span> extends Class &#123;</span><br><span class="line">    <span class="built_in">FastMallocClass</span>() &#123;</span><br><span class="line">        <span class="built_in">exists</span>(Operator op, Function fastMalloc | op.<span class="built_in">hasName</span>(<span class="string">&quot;operator new&quot;</span>) <span class="keyword">and</span></span><br><span class="line">          fastMalloc.<span class="built_in">hasName</span>(<span class="string">&quot;FastMalloc&quot;</span>) <span class="keyword">and</span> op.<span class="built_in">calls</span>(fastMalloc) <span class="keyword">and</span></span><br><span class="line">          op.<span class="built_in">getDeclaringType</span>() = <span class="keyword">this</span>.getABaseClass*()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FastMallocClass c</span><br><span class="line">where c.<span class="built_in">getSize</span>() &lt;= <span class="number">528</span> <span class="keyword">and</span> c.<span class="built_in">getSize</span>() &gt; <span class="number">204</span></span><br><span class="line">select c, c.<span class="built_in">getLocation</span>(), c.<span class="built_in">getSize</span>()</span><br></pre></td></tr></table></figure>

<p>在这里做了改进，只包括在FastMalloc分区中分配的对象，也就是分配AudioBus的备份存储（AudioArray）的地方。看了一下结果，BiquadDSPKernel特别有用。除了要泄露vtable之外，它还包含一个字段biquad_，存储了5个AudioDoubleArray。这意味着通过泄露BiquadDSPKernel类型的对象，就能同时泄露这些AudioDoubleArray的后备存储地址，然后可以用来存储一个假的vtable来劫持虚拟函数调用。</p>
<p>因此，通过安排堆，把BiquadDSPKernel放在AudioBus后面，然后触发bug导致越界读取，就能把BiquadDSPKernel对象泄漏到下一个AudioNodeInput的AudioBus中。为了读取输入数据，可以使用ScriptProcessorNode，它允许使用javascript函数来读取输入。然后，可以获得泄漏的vtable和各种AudioDoubleArray的地址。</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>在这一点上，其余的利用方法是相当标准的。一旦获得了BiquadDSPKernel的vtable的地址，就可以用它来找到libchrome.so的偏移。有了libchrome.so的偏移量，就可以找到里面的ROP小工具的地址，并在属于BiquadDSPKernel的AudioDoubleArray中创建一个假的vtable，这样，这个假vtable中的虚拟函数指针就会指向所选择的小工具。</p>
<p>之后，自由使用后的漏洞就可以再一次被触发了。这一次，它直接进入漏洞的第二节Primitives中的路径，调用一个虚拟函数。被释放的AudioHandler对象现在可以被一个适当大小的AudioArray所取代，这个AudioArray被填充了受控数据，这样它的vtable就指向了在上面创建的假vtable。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/call_func.png"></p>
<p>使用类似于<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/">这篇文章</a>中使用的小工具，调用OS::SetPermissions，将BiquadDSPKernel中的AudioDoubleArray的页面权限覆盖为rwx。一旦完成，就可以在这些AudioDoubleArray中放置shell代码，并再次触发这个bug来运行任意代码。在实际的漏洞中，一个延迟节点被用作免费的AudioHandler，IIRFilterNode的前馈系数被用来伪造DelayHandler。</p>
<p>完整的exp在<a target="_blank" rel="noopener" href="https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/blink/CVE-2020-15972">这里</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们再次看到，复杂的对象清理，加上多线程的微妙性，导致了WebAudio中的漏洞可以作为渲染器RCE来利用。虽然与v8中的漏洞相比，blink中的漏洞一般需要更多的时间来利用，但它仍然是Chrome中获得（沙盒）RCE的一个巨大而可行的攻击面。</p>
<p>就整个系列而言，我们还看到了沙盒架构，加上Chrome浏览器中漏洞的快速修复，确实有助于使其难以获得完整的链（并确保完整的链即使进入野外也不会持续太久）。本系列中使用的渲染器漏洞从首次报告到修复大约需要六周时间，而沙盒逃逸也需要类似的时间来修复，这对Chrome来说是相当标准的。这大大降低了渲染器漏洞与沙盒逃逸重叠的可能性。正如我们在这一系列案例中看到的那样，由于这种快速修复漏洞的方式，在稳定版本的Chrome浏览器中，渲染器漏洞并没有与沙盒逃逸重叠在一起。正是修复漏洞的效率使沙箱变得更加有效。另一方面，我们也从沙盒逃逸的帖子中看到了每次启动一次的ASLR（即从Zygote分叉的进程）如何大大降低了安卓系统中应用沙盒的有效性。虽然Chrome的基本地址在渲染器和浏览器之间仍然是随机的，但许多其他库不是，我仍然能够使用这些库中的小工具，不费吹灰之力就逃出Chrome的沙箱。虽然每次启动一次的ASLR对于缓解远程攻击仍然非常有用，但正如我们在这篇文章中所看到的，编写漏洞的大部分精力都花在了击败ASLR上，它对于本地权限升级没有什么用处。由于两个主要平台（Windows和Android）都实施了每次启动一次的ASLR，这仍然是Chrome沙箱的最大弱点之一。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/android/" rel="tag"># android</a>
              <a href="/tags/chrome/" rel="tag"># chrome</a>
              <a href="/tags/webaudio/" rel="tag"># webaudio</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/11/28/AFL-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/" rel="prev" title="AFL++ 阅读笔记 - 技术细节">
                  <i class="fa fa-angle-left"></i> AFL++ 阅读笔记 - 技术细节
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/06/Chrome-CVE-2020-6449-UAF/" rel="next" title="Chrome CVE-2020-6449 UAF">
                  Chrome CVE-2020-6449 UAF <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
