<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="buffer0verflooow - Blog">
<meta property="og:url" content="https://buffer0verflooow.github.io/page/22/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="buffer0verflooow">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://buffer0verflooow.github.io/page/22/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/22/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">buffer0verflooow - Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/22/Android-CVE-2021-0928/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/22/Android-CVE-2021-0928/" class="post-title-link" itemprop="url">Android-CVE-2021-0928</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-22 21:19:31 / Modified: 21:20:37" itemprop="dateCreated datePublished" datetime="2022-04-22T21:19:31+08:00">2022-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://github.com/michalbednarski/ReparcelBug2">https://github.com/michalbednarski/ReparcelBug2</a></p>
</blockquote>
<h1 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h1><p><code>android.hardware.camera2.params.OutputConfiguration.java</code>中的 <code>writeToParcel</code>&#x2F;<code>createFromParcel</code> 不匹配导致的。</p>
<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>Android 9 至 Android 11，Android 12 Developer Preview 3，在官方Android 12发布版中修复。</p>
<h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><p>Android 12 Beta 2 and 3</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>在Android的两个<code>activity</code>之间传递对象，则这个对象必须要进行序列化，在Android中实现序列化有两种方式，一是实现<code>Serializable</code>接口，二是实现<code>Parcelable</code>接口。<code>Parcelable</code>的方式要比<code>Serializable</code>的效率要高。</p>
<p>Android上的大部分IPC都是基于一个叫<code>Parcel</code>的类。基本的<code>Parcel</code>用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Parcel</span> <span class="variable">p</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">p.writeInt(<span class="number">1</span>);</span><br><span class="line">p.writeString(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后<code>Parcel</code>通过<code>Binder</code>将消息传递给其他进程，为了测试，可以调用<code>p.setDataPosition(0)</code>将消息设置为起始位置并开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> p.readInt(); <span class="comment">// a = 1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> p.readString(); <span class="comment">// b = &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，<code>Parcel</code>内部保存着读取的位置。<code>Parcel</code>类的使用者应当确保<code>read*</code>方法与之前使用的<code>write*</code>方法相匹配，否则后续的读取操作将来自缓冲区中的错误位置。</strong></p>
<p><code>Parcel</code>还支持自定义<code>object</code>，通过<code>Parcelable</code>接口来实现。</p>
<p>实现<code>Parcelable</code>接口需要实现接口中的两个方法：</p>
<ol>
<li><code>public int describeContents();</code>，内容接口描述，默认返回0即可；</li>
<li><code>public void writeToParcel(Parcel dest, int flags);</code>，将对象序列化成一个Parcel对象。</li>
</ol>
<p>然后，还需要实例化静态内部对象<code>CREATOR</code>来实现<code>Parcelable.Creator</code>，实现<code>CREATOR</code>时要实现其中的方法：</p>
<ol>
<li><code>createFromParcel</code>，从Parcel中读取前面序列化的对象。</li>
</ol>
<p>下面是一个实现该接口的例子（<code>WindowContainerTransaction</code>类被用作exp gadget利用链中的一部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.window;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowContainerTransaction</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;IBinder, Change&gt; mChanges = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;HierarchyOp&gt; mHierarchyOps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">WindowContainerTransaction</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        in.readMap(mChanges, <span class="literal">null</span> <span class="comment">/* loader */</span>);</span><br><span class="line">        in.readList(mHierarchyOps, <span class="literal">null</span> <span class="comment">/* loader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(<span class="meta">@NonNull</span> Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeMap(mChanges);</span><br><span class="line">        dest.writeList(mHierarchyOps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;WindowContainerTransaction&gt; CREATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;WindowContainerTransaction&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> WindowContainerTransaction <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowContainerTransaction</span>(in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在写的时候调用<code>writeToParcel()</code>函数，在读的时候调用<code>CREATOR.createFromParcel()</code>函数。<code>Parcelable</code>接口的实现需要确保<code>createFromParcel()</code>函数读取的数据与<code>writeToParcel()</code>函数写入的数据一致，否则后续的读取将要出错。</p>
<p>这样的类可以通过以下方式读取&#x2F;写入<code>Parcel</code>：</p>
<ul>
<li>直接调用 <code>obj.writeToParcel(parcel, 0)</code> &#x2F; <code>obj = WindowContainerTransaction.CREATOR.createFromParcel()</code>，这经常用于类是已知的，比如，当<code>Parcelable</code>拥有不同的<code>Parcelable</code>字段，或者当定义RPC方法时由AIDL生成的包含以<code>Parcelable</code>为参数的代码。</li>
<li>通过 <code>Parcel.writeParcelable</code>&#x2F;<code>readParcelable</code>。<code>writeParcelable</code>首先写入类的名称，然后调用<code>Parcelable</code>接口的<code>writeToParcel</code>方法。<code>readParcelable</code>读取写入的类的名称，在提供的<code>ClassLoader</code>或<code>BOOTCLASSPATH</code>（提供的参数为null）中查找该类名。一旦找到该类，则通过其静态字段<code>CREATOR</code>获取<code>Parcelable.Creator</code>实例（被用于读取这个类）<em>。另外， 当使用<code>readParcelable</code>方法时，它可以读取类路径中的任何<code>Parcelable</code>，因为要创建的对象的名称是从同一个<code>Parcel</code>中读取的。</em><ul>
<li><code>readParcelable</code>被许多其他的<code>Parcel</code>方法所使用，例如上面的例子中看到的<code>readList</code>通过<code>readValue</code>读取元素，这是<code>Parcel</code>中最通用的传输对象的方法，它使用的方式之一就是通过<code>readParcelable</code>。在上面的例子中，由于Java的类型清除，<code>ArrayList&lt;HierarchyOp&gt; mHierarchyOps</code>字段实际上可以包含<code>Parcel</code>支持的任何对象，而不仅仅是那些与通用类型声明中指定的类型兼容的对象。</li>
</ul>
</li>
</ul>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>从开发者角度来看，<code>BroadcastReceiver</code> 的工作方式如下：应用程序调用<code>sendBroadcast</code> 发送广播，当广播的Intent与 <code>AndroidManifest.xml</code>中定义的 <code>&lt;receiver&gt;</code> 匹配上以后，系统将启动接收该广播的应用程序， 将<code>&lt;receiver android:name&gt;</code>属性中定义的<code>BroadcastReceiver</code>子类实例化，然后调用<code>onReceive</code>方法。</p>
<p>接收广播的过程中与<code>system_server</code>发生的通信：</p>
<ol>
<li>当应用进程开始启动时，将调用<code>IActivityManager.attachApplication()</code>，通过这样，传递<code>ApplicationThread</code>句柄，系统用这个句柄来告诉应用进程要做什么。</li>
<li>当系统想在应用进程中执行清单中注册的<code>BroadcastReceiver</code>时，它使用上面提到的<code>IApplicationThread</code>调用<code>scheduleReceiver</code>方法。这个方法有多个参数，但这里最重要的是前两个：<ol>
<li><code>Intent intent</code>，在调用<code>sendBroadcast()</code>时传递给系统的。</li>
<li><code>ActivityInfo info</code>，它包含了要执行的组件的信息。这个参数的值是由系统从包管理器服务中获取的。最重要的是，在这个参数中传递的数据包括处理收到的广播的Java类的文件路径。</li>
</ol>
</li>
</ol>
<p><strong>利用路径：调用<code>sendBroadcast()</code>，传递一个<code>Intent</code>，这将导致导致调用<code>scheduleReceiver</code>的应用程序接收到一个被篡改的<code>ActivityInfo</code>。</strong></p>
<p><strong>需要注意的是，这种新的利用途径在Android 12中变得可行</strong>，因为以前没有办法在<code>Intent</code>中放入任意的<code>Parcelable</code>（<code>Intent</code>的<code>extra</code>不算，因为它们被放入<code>Bundle</code>中，<code>Bundle</code>的整个长度被写入<code>Parcel</code>中，并作为单个<code>blob</code>被读取，所以<code>extra</code>不会导致它们包含的<code>Intent</code>对象解析出错）。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="writeToParcel-createFromParcel"><a href="#writeToParcel-createFromParcel" class="headerlink" title="writeToParcel&#x2F;createFromParcel"></a>writeToParcel&#x2F;createFromParcel</h2><p>如上所述，<code>Parcelable</code>接口的实现需要确保<code>createFromParcel()</code>函数读取的数据与<code>writeToParcel()</code>函数写入的数据一致。每当<code>BOOTCLASSPATH</code>中存在一个可以违反该约定的<code>Parcelable</code>时，就会产生一个漏洞，因为可能导致以下情况的发生：</p>
<ol>
<li>恶意应用程序向<code>system_server</code>发送一个<code>Bundle</code> 或<code>Parcelable</code>，其中包含有问题的<code>Parcelable</code>实例以及专门构建的数据，这些数据将在步骤3中读取，但在步骤2中传递。</li>
<li><code>system_server</code>验证<code>Bundle</code>是安全的，然后转发，或者<code>system_server</code>将提供的<code>Parcelable</code>传递给AIDL方法，该方法的下一个参数中也有关键数据（如果该参数中收到的数据可能被修改，将导致安全问题）。</li>
<li>另一个应用程序从<code>system_server</code>接收数据并信任它，但由于错误的序列化，它实际看到的数据与<code>system_server</code>打算发送的数据不同。</li>
</ol>
<h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>大多数时候，<code>writeToParcel</code>&#x2F;<code>createFromParcel</code>不匹配的情况是，在这些方法中的一个字段被遗忘或写了两次，在这种情况下，发送这样的对象总是会触发不匹配。</p>
<p>接下来看看有漏洞的类（<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/hardware/camera2/params/OutputConfiguration.java;drc=46c390a1c695e2dc458cb889e40559f259f60aed">源码</a>如下，标有<code>//</code>的代码是手动添加的，因为在作者写writeup时它们还不在AOSP中）（这里是最初<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/a69b1bc58b0838e06deefb190e226774a34671e6%5E%21/#F10">引入漏洞的提交</a>，但它是在Android 12发布后发布的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.camera2.params;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OutputConfiguration</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">OutputConfiguration</span><span class="params">(<span class="meta">@NonNull</span> Parcel source)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rotation</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">surfaceSetId</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">surfaceType</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDeferred</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isShared</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Surface&gt; surfaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Surface&gt;();</span><br><span class="line">        source.readTypedList(surfaces, Surface.CREATOR);</span><br><span class="line">        <span class="type">String</span> <span class="variable">physicalCameraId</span> <span class="operator">=</span> source.readString();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMultiResolution</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>; <span class="comment">// New in Android 12</span></span><br><span class="line">        ArrayList&lt;Integer&gt; sensorPixelModesUsed = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">// New in Android 12</span></span><br><span class="line">        source.readList(sensorPixelModesUsed, Integer.class.getClassLoader()); <span class="comment">// New in Android 12</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// SNIP: copy values from variables set above to fields of this class</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="meta">@android</span>.annotation.NonNull Parcelable.Creator&lt;OutputConfiguration&gt; CREATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;OutputConfiguration&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> OutputConfiguration <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">OutputConfiguration</span> <span class="variable">outputConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputConfiguration</span>(source);</span><br><span class="line">                <span class="keyword">return</span> outputConfiguration;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Exception creating OutputConfiguration from parcel&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> OutputConfiguration[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OutputConfiguration</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;dest must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeInt(mRotation);</span><br><span class="line">        dest.writeInt(mSurfaceGroupId);</span><br><span class="line">        dest.writeInt(mSurfaceType);</span><br><span class="line">        dest.writeInt(mConfiguredSize.getWidth());</span><br><span class="line">        dest.writeInt(mConfiguredSize.getHeight());</span><br><span class="line">        dest.writeInt(mIsDeferredConfig ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        dest.writeInt(mIsShared ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        dest.writeTypedList(mSurfaces);</span><br><span class="line">        dest.writeString(mPhysicalCameraId);</span><br><span class="line">        dest.writeInt(mIsMultiResolution ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// New in Android 12</span></span><br><span class="line">        dest.writeList(mSensorPixelModesUsed); <span class="comment">// New in Android 12</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Surface&gt; mSurfaces;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mRotation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mSurfaceGroupId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mSurfaceType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size mConfiguredSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredFormat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredDataspace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredGenerationId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mIsDeferredConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsShared;</span><br><span class="line">    <span class="keyword">private</span> String mPhysicalCameraId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsMultiResolution; <span class="comment">// New in Android 12</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; mSensorPixelModesUsed; <span class="comment">// New in Android 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面讨论<code>WindowContainerTransaction</code>例子时所说，<code>readList</code>实际上可以用<code>Parcel</code>支持的任何对象来填充列表，而不仅仅是符合通用声明的对象（<code>ArrayList&lt;Integer&gt;</code>）。然而，由于我们只是将这个类作为序列化小工具链的一部分，而不是真正使用它，除了读写<code>Parcel</code>，这个字段不会被用于其他任何事情（而使用<code>ArrayList</code>中的元素，而这些元素与它的泛型声明不匹配，无论如何都只会导致<code>ClassCastException</code>）。</p>
<p>在这个类中，<code>createFromParcel</code>中也有一个<code>try-catch</code>，这意味着如果在读取过程中抛出一个异常，对<code>OutputConfiguration</code>的读取将被停止，对包含<code>OutputConfiguration</code>的对象的读取将继续进行。当这种情况发生时，整个<code>OutputConfiguration</code>将被写入<code>Parcel</code>，但它将<strong>只被读到异常发生的点</strong>。这就造成了不匹配。</p>
<p>为了构建这样的<code>Parcelable</code>，现在需要找到一些东西放在<code>mSensorPixelModesUsed</code>中，在<code>system_server</code>中成功读取（因为这个对象是通过<code>Parcel</code>从攻击者应用中接收的），在<code>system_server</code>中成功写入，然后在受害者应用中解析<code>Parcel</code>失败并抛出一个<code>Exception</code>。</p>
<p>其中一个方法是使用存在于<code>system_server</code>中但不在应用程序中的类，这样尝试反序列化它就会导致<code>ClassNotFoundException</code>。但是不能从<code>system_server</code>中<code>Parcelable</code>，因为<code>readParcelable</code>没有明确指定<code>ClassLoader</code>只会搜索<code>BOOTCLASSPATH</code>（<code>BOOTCLASSPATH</code>不包含<code>system_server</code>中特定的类）。解决方法是使用一个可序列化的类，因为<code>ObjectInputStream</code>会从堆栈中第一个非<code>BOOTCLASSPATH</code>方法中挑选<code>ClassLoader</code>。</p>
<p>这里选择<code>PackageManagerException</code>，然而在使用它之前，还需要做一件事。在<code>OutputConfiguration</code>构造函数中，当<code>readList</code>被调用时，参数<code>loader</code>被明确设置为<code>Integer.class.getClassLoader()</code>。<code>loader</code>被传播到<code>readValue()</code>，然后到<code>readSerializable()</code>，如果<code>loader</code>不为空的，它就会被用来代替来自<code>ObjectInputStream</code>的<code>resolveClass</code>（<code>c != null</code>检查没有任何作用，因为当<code>Class.forName</code>没有找到类时，它会抛出异常而不是返回空）。</p>
<p><strong>思路是将<code>PackageManagerException</code>包裹在一些<code>Parcelable</code>中，在不指定<code>ClassLoader</code>的情况下进行<code>readList</code>。</strong></p>
<p>因此有以下对象：</p>
<ul>
<li><code>OutputConfiguration</code><ul>
<li><code>mSensorPixelModesUsed.get(0) = WindowContainerTransaction</code><ul>
<li><code>mHierarchyOps.get(0) = PackageManagerException</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>现在这样的对象可以在<code>system_server</code>中成功反序列化：当<code>WindowContainerTransaction</code>调用<code>readList</code>时，它会尝试使用<code>system_server</code>的<code>ClassLoader</code>（不是<code>BootClassLoader</code>）找到<code>PackageManagerException</code>类，因为它可以在堆栈跟踪中找到它。该类加载器恰好出现在堆栈跟踪中，但以下所有方法都不在<code>system_server</code>类路径中：<code>Binder#execTransact()</code>、AIDL生成的<code>IActivityManager$Stub#onTransact()</code>以及所有使用的<code>Parcelable</code>类的方法，但在堆栈跟踪中，有一个在<code>system_server</code>中声明的方法：在<code>ActivityManagerService</code>中重写的<code>onTransact</code>。因此，<code>system_server</code>可以读取并随后将这样的对象写入<code>Parcel</code>，当目标应用程序试图读取它时，<code>PackageManagerException</code>类将不可用，因此<code>ClassNotFoundException</code>将被抛出，被包装成<code>RuntimeException</code>，然后被<code>OutputConfiguration</code>的 <code>CREATOR</code>捕获。</p>
<p>但是还没有触发<strong>不匹配</strong>，因为<code>OutputConfiguration.writeToParcel</code>没有留下任何未读数据时，异常被捕获了，但是可以很容易地在<code>mSensorPixelModesUsed</code>列表中添加另一个项目，该项目将通过<code>Parcel.writeValue</code>写入，并在读取<code>OutputConfiguration</code>后留下未读数据。</p>
<p><strong>从Intent对象中触发</strong></p>
<p>因为它将被<code>system_server</code>传递到AIDL方法中，该方法的第一个参数是<code>Intent</code>，第二个参数是执行信息，所以第一个参数中传递的<code>Intent</code>的序列化&#x2F;反序列化会导致第二个参数中的值被改变。</p>
<p>在<code>Intent.readFromParcel()</code>中，所有的值都是通过专门的类型方法来读取的，所以在这里不能指定自定义的<code>Parcelable</code>类。</p>
<p>在<code>Intent</code>中，有一个嵌套的<code>ClipData</code>，并且从Android 12开始，在<code>ClipData$Item</code>中有一个新的字段<code>ActivityInfo mActivityInfo</code>。（这里是引入这个字段的<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/c932060175133e266233f1c7667dc69470fbc62e%5E%21/#F2">提交</a>，这个字段是在<code>ClipData(Parcel in)</code>构造函数中通过<code>in.readTypedObject(ActivityInfo.CREATOR)</code>读取的）</p>
<p>然后在<code>ActivityInfo(Parcel source)</code>构造函数中，也没有办法放入自定义的<code>Parcelable</code>，但是由于<code>ActivityInfo</code>是从<code>ComponentInfo</code>扩展而来，它有<code>applicationInfo</code>字段。</p>
<p>最后，在 <code>ApplicationInfo</code> 中有一个<code> SparseArray&lt;int[]&gt; splitDependencies</code> 字段，它是通过<code> readSparseArray</code> 读取的，而后者又使用 <code>readValue</code> 来读取 <code>SparseArray</code> 项目。</p>
<p>可以将<code>OutputConfiguration</code>放在<code>splitDependencies</code>中，但是读取<code>splitDependencies</code>之后会有一些<code>readString8()</code>的调用，而且在发生不匹配之后，最好能完全控制未被接受的数据，这样我们就可以直接将空字符串放在那里，而不用担心未被接受的数据的不同解释。</p>
<p>要做到这一点，首先需要在<code>OutputConfiguration.mSensorPixelModesUsed</code>中放置一些原始数据，这些数据将通过<code>writeValue</code>写入。这里选择使用<code>Bundle</code>。这样，在未消耗的数据中，会留下：</p>
<ol>
<li><code>writeValue VAL_BUNDLE</code>标签</li>
<li>原始数据的长度（此链接也适用于此列表中的其余项目）</li>
<li><code>BUNDLE_MAGIC</code></li>
<li>通过<code>Parcel.appendFrom</code>逐字传递的原始数据</li>
</ol>
<p>所以我们有三个<code>Parcel.writeInt</code>的项目没有消耗掉，我们可以通过将<code>OutputConfiguration</code>包裹在一些<code>Parcelable</code>中，在读取时读取任意的<code>Parcelable</code>值和三个<code>ints</code>，来摆脱它们。<code>ZenPolicy CREATOR</code>中存在这样的方法。</p>
<p>最后，我们有以下对象的层次结构（存在于<code>system_server</code>中，并且它试图传递给<code>scheduleReceiver</code>）：</p>
<ul>
<li><code>Intent</code><ul>
<li><code>mClipData = ClipData</code><ul>
<li><code>mItems.get(0).mActivityInfo = ActivityInfo</code><ul>
<li><code>applicationInfo = ApplicationInfo</code><ul>
<li><code>splitDependencies.get(0) = ZenPolicy</code><ul>
<li><code>mVisualEffects.get(0) = OutputConfiguration</code><ul>
<li><code>mSensorPixelModesUsed.get(0) = WindowContainerTransaction</code><ul>
<li><code>mHierarchyOps.get(0) = PackageManagerException</code></li>
</ul>
</li>
<li><code>mSensorPixelModesUsed.get(1) = Bundle</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这是由<code>system_server</code>写的。然后，接收应用程序正常读取<code>PackageManagerException</code>的所有数据（包括<code>readSerializable</code>数据），然而在读取<code>PackageManagerException</code>的<code>Serializable</code>数据后，一个异常被抛出，并且取消了对<code>OutputConfiguration</code>以下所有数据的读取，留下<code>Bundle</code>未读。读取继续进行到<code>ZenPolicy</code>，它消耗了<code>Bundle</code>中原始数据之前的三个<code>ints</code>。然后<code>ApplicationInfo</code>的读取继续进行，读取的数据是之前在<code>Bundle</code>中逐字传递的原始数据。对原始数据的读取将在这个堆栈中的其他对象（<code>ApplicationInfo</code>、<code>ActivityInfo</code>、<code>ClipData</code>和<code>Intent</code>）中继续进行，然后这些原始数据将被用于读取下一个<code>handleReceiver</code>方法参数。</p>
<p><strong>handleReceiver</strong></p>
<p>正如刚才所说，现在剩下的<code>scheduleReceiver</code>参数是从攻击者控制的缓冲区中读取的。首先，<code>scheduleReceiver</code>将所有参数的值打包并使用<code>sendMessage()</code>将执行传递给主线程。接下来，在主线程上调用<code>handleReceiver</code>，<code>handleReceiver</code>调用<code>getPackageInfoNoCheck</code>，将其作为<code>ActivityInfo</code>的一部分传递给<code>scheduleReceiver</code>参数的<code>ApplicationInfo</code>。</p>
<p><code>getPackageInfo</code>检查给定名称的包是否已经存在于缓存中，如果没有，则构建新的<code>LoadedApk</code>实例，将先前收到的<code>ApplicationInfo</code>对象传递给它。（由于想要创建新的<code>LoadedApk</code>，所以在这个过程中使用了先前没有看到的包的包名）</p>
<p>然后使用<code>ContextImpl.getClassLoader()</code>方法，该方法首先委托给<code>mPackageInfo.getClassLoader()</code>，<code>mPackageInfo</code>是在上一段构建的<code>LoadedApk</code>。</p>
<p>然后是&#96;&#96;createOrUpdateClassLoaderLocked<code>，它调用</code>makePaths<code>将</code>ClassLoader<code>中要使用的路径填充到</code>zipPaths<code>中，然后将它们连接起来并分配给zip变量，再传递给</code>createClassLoader&#96;。</p>
<p><code>makePaths</code>使用<code>ApplicationInfo</code>的信息填充<code>zipPaths</code>，最重要的是，这包括<code>sourceDir</code>。攻击者应用程序使注入的<code>ApplicationInfo</code>与<code>sourceDir</code>设置为自己的<code>apk</code>的路径，因此<code>receiver</code>类将实际从攻击者<code>apk</code>中加载。这直接导致了在接收广播的应用程序中执行攻击者控制的代码。</p>
<p><strong>隐藏的API检查</strong></p>
<p>还有一件事需要被绕过：隐藏的API检查。但这些不是问题（因为应用程序可以使用NDK，并直接调用底层系统调用），但在这种情况下，通过手动将数据写入<code>Parcel</code>，然后使用<code>readParcelable</code>来构建精心制作的<code>ClipData</code>来绕过它们。这样的<code>ClipData</code>通常可以被附在<code>Intent上</code>，然后传递给<code>sendBroadcast()</code>，因此发送广播本身只需使用公共API即可完成。</p>
<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>Android 12发布：</p>
<ul>
<li>从<code>OutputConfiguration</code>和相关类中删除了异常捕获功能。</li>
<li><code>OutputConfiguration#mSensorPixelModesUsed</code>不再通过<code>writeValue</code>写入。</li>
<li><code>ClipData#mActivityInfo</code>不再被写入<code>Parcel</code>，除非在写入过程中明确要求（因此<code>Intent</code>不再包含来自<code>BOOTCLASSPATH</code>的任意<code>Parcelables</code>，消除了这种利用技术）。</li>
</ul>
<p>在写这篇文章时，只出现在主分支上，不在发布的版本中，可能会出现在Android 13中（不在12L中）：</p>
<ul>
<li>在<code>Parcel</code>上有新的List读取方法，可以检查元素的类型，没有类型的版本已经被标记为废弃。</li>
<li>新的方法<code>Parcel#enforceNoDataAvail()</code>，检查<code>Parcel</code>中是否有未读的数据，显然AIDL在读取RPC调用参数后会使用这个方法。</li>
<li>在<code>Bundle</code>中的每个项目都将单独保存其长度。这几乎扼杀了整个bug类。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/21/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/23/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
