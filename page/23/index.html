<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="buffer0verflooow - Blog">
<meta property="og:url" content="https://buffer0verflooow.github.io/page/23/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="buffer0verflooow">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://buffer0verflooow.github.io/page/23/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/23/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">buffer0verflooow - Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/17/syzkaller%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/17/syzkaller%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">syzkaller学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-17 20:48:35" itemprop="dateCreated datePublished" datetime="2022-04-17T20:48:35+08:00">2022-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-11-03 22:56:36" itemprop="dateModified" datetime="2024-11-03T22:56:36+08:00">2024-11-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过AFL++的源码，发现想要自己重新写的话还是很复杂，现在学习一下syzkaller，看看有没有可能进行定制。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>syzkaller系统的流程结构如下图所示；红色标签表示相应的配置选项。</p>
<img src="../pictures/process_structure.png" alt="process_structure" style="zoom: 67%;" />

<p><code>syz-manager</code>进程启动、监控和重启几个虚拟机实例，并在虚拟机内启动<code>syz-fuzzer</code>进程。<code>syz-manager</code>负责持久性语料库和崩溃存储。它运行在一个具有稳定内核的主机上，不会出现白噪声模糊器的负载。</p>
<p><code>syz-fuzzer</code>进程在可能不稳定的虚拟机中运行。<code>syz-fuzzer</code>指导模糊处理过程（输入生成、突变、最小化等），并通过RPC将触发新覆盖率的输入发送至<code>syz-manager</code>进程。它还会启动瞬时的<code>syz-executor</code>进程。</p>
<p>每个<code>syz-executor</code>进程执行一个输入（一连串的系统调用）。它从<code>syz-fuzzer</code>进程中接受要执行的程序，并将结果发送回来。它被设计成尽可能简单（不干扰模糊处理过程），用C++编写，编译成静态二进制，使用共享内存进行通信。</p>
<h2 id="系统调用描述"><a href="#系统调用描述" class="headerlink" title="系统调用描述"></a>系统调用描述</h2><p><code>syz-fuzzer</code>进程根据系统调用描述，生成由<code>syz-executor</code>执行的程序。</p>
<h2 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h2><p>Syzkaller是一个覆盖率导向的fuzzer。</p>
<h2 id="崩溃报告"><a href="#崩溃报告" class="headerlink" title="崩溃报告"></a>崩溃报告</h2><p>当<code>syzkaller</code>发现一个崩溃者时，它会将其信息保存到<code>workdir/crashes</code>目录中。该目录为每一个独特的崩溃类型包含一个子目录。每个子目录都包含一个描述文件，其中有一个唯一的字符串来标识崩溃（用于识别错误和重复计算）；还有多达100个<code>logN</code>和<code>reportN</code>文件，每个测试机崩溃一对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- crashes/</span><br><span class="line">  - 6e512290efa36515a7a27e53623304d20d1c3e</span><br><span class="line">    - description</span><br><span class="line">    - log0</span><br><span class="line">    - report0</span><br><span class="line">    - log1</span><br><span class="line">    - report1</span><br><span class="line">    ...</span><br><span class="line">  - 77c578906abe311d06227b9dc3bffa4c52676f</span><br><span class="line">    - description</span><br><span class="line">    - log0</span><br><span class="line">    - report0</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>描述是使用一组正则表达式来提取的。如果你使用的是不同的内核架构，或者只是看到了以前没有见过的内核错误信息，那么这个集合可能需要被扩展。</p>
<p><code>logN</code>文件包含原始的<code>syzkaller</code>日志，包括内核控制台输出以及崩溃前执行的程序。这些日志可以提供给<code>syz-repro</code>工具进行崩溃定位和最小化，或者提供给<code>syz-execprog</code>工具进行手动定位。<code>reportN</code>文件包含经过处理和符号化的内核崩溃报告（例如KASAN报告）。通常你只需要一对这样的文件（即<code>log0</code>和<code>report0</code>），因为它们都可能是描述同一个内核错误。然而，<code>syzkaller</code>会保存多达100个这样的文件，以应对崩溃重现性差的情况，或者你只是想看一组崩溃报告来推断一些相似性或差异。</p>
<p>有3种特殊的崩溃类型：</p>
<ol>
<li>测试机没有输出：测试机没有产生任何输出；</li>
<li>与测试机失去连接：与测试机的SSH连接意外地关闭了；</li>
<li>测试机没有执行程序：机器看起来还活着，但长时间没有执行测试程序。</li>
</ol>
<p>最有可能的是，你不会看到这些<code>reportN</code>文件（例如，如果测试机器没有输出，就没有什么可以写进报告）。有时这些崩溃表明<code>syzkaller</code>本身有错误（特别是当你在日志中看到<code>Go panic</code>消息时）。然而，通常情况下，它们意味着内核锁死或类似的坏情况（这里有几个这样发现的bug的例子：<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/zfuHHRXL7Zg/Tc5rK8bdCAAJ">1</a>，<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/kY_ml6TCm9A/wDd5fYFXBQAJ">2</a>，<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/OM7CXieBCoY/etzvFPX3AQAJ">3</a>）。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>git源码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/google/syzkaller</span><br></pre></td></tr></table></figure>

<p>直接make即可，但是由于没有设置SOURCEDIR，所以Executor无法编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor will not be built</span><br><span class="line">Native cross-compiler is missing/broken:</span><br><span class="line">SOURCEDIR is not <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>启动<code>syz-manager</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config my.cfg</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>json格式，具体包含哪些参数可以在<code>syzkaller/pkg/mgrconfig/config.go</code>中进行查看，示例文件如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;myhost.com:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/linux/&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./testdata/wheezy.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./testdata/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;disable_syscalls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;keyctl&quot;</span><span class="punctuation">,</span> <span class="string">&quot;add_key&quot;</span><span class="punctuation">,</span> <span class="string">&quot;request_key&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;suppressions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some known bug&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/linux/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;initrd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/initrd&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h3><p>一旦 syzkaller 在其中一个 VM 中检测到内核Crash，它将自动启动复现这个Crash的过程（除非配置文件中指定了<code>&quot;reproduce&quot;: false</code>）。默认情况下，syzkaller将使用 4 个虚拟机来复现Crash，然后最小化POC。由于可能所有虚拟机都在进行复现过程，从而使fuzz停止。</p>
<p>自动复现Crash的时间可能无法控制，所以可以选择手动复现。</p>
<p>如果复现成功，syzkaller将给出两种POC：syzkaller 程序或 C 程序，默认是C程序。如果是syzkaller 程序，则运行和调试的方法在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/reproducing_crashes.md">这里</a>。</p>
<h4 id="复现Crash"><a href="#复现Crash" class="headerlink" title="复现Crash"></a>复现Crash</h4><p>为<code>syzkaller bug</code>创建复制程序的过程是自动化的，然而它并不完美，所以syzkaller提供了一些手动执行和复制程序的工具。</p>
<p>在管理器<code>workdir</code>&#x2F;<code>crashes dir</code>中创建的崩溃日志包含了崩溃前刚刚执行的程序。在并行执行模式下（当管理器配置中的procs参数设置为大于1的值时），导致崩溃的程序不一定紧接在它之前；有罪的程序可能在之前的某个地方。有两个工具可以帮助你识别和减少导致崩溃的程序：<code>tools/sy-execprog</code>和<code>tools/sy-prog2c</code>。</p>
<p><code>tools/syz-execprog</code>执行单个syzkaller程序或一组不同模式的程序（一次或无限次循环；线程&#x2F;碰撞模式（见下文），有无覆盖率收集）。你可以先循环运行崩溃日志中的所有程序，检查其中至少有一个程序确实崩溃了内核：<code>./syz-execprog -executor=./syz-executor -repeat=0 -procs=16 -cover=0 crash-log</code>。然后尝试找出导致崩溃的单个程序，你可以用<code>./syz-execprog -executor=./syz-executor -repeat=0 -procs=16 -cover=0 file-with-a-single-program</code>测试程序。</p>
<p>注意：<code>syz-execprog</code>是在本地执行程序。所以你需要把<code>syz-execprog</code>和<code>syz-executor</code>复制到一个有测试内核的虚拟机中，并在那里运行它。</p>
<p>一旦有了一个导致崩溃的程序，试着从程序中删除个别的系统调用（可以在行首用#注释单行），并删除不必要的数据（例如用<code>&amp;(0x7f0000001000)=&quot;73656c6600 &quot;</code>系统调用参数替换<code>&amp;(0x7f0000001000)=nil</code>），从而使其最小化。你也可以尝试把所有的<code>mmap</code>调用凝聚成一个单一的<code>mmap</code>调用来映射整个需要的区域。同样，用<code>syz-execprog</code>工具测试最小化。</p>
<p>现在有了一个最小化的程序，用<code>./syz-execprog -threaded=0 -collide=0</code>标志检查崩溃是否还能重现。如果不是，那么你将需要在后面做一些额外的工作。</p>
<p>现在，对该程序运行<code>syz-prog2c</code>工具。它将给你可执行的C语言源代码。如果崩溃在<code>-threaded/collide=0</code>标记下重现，那么这个C程序也应该导致崩溃。</p>
<p>如果崩溃在<code>-threaded/collide=0</code>标记下不能重现，那么你需要最后一步。你可以把线程模式看作是每个系统调用都在自己的线程中执行。为了模拟这样的执行模式，将各个系统调用移到独立的线程中。你可以在这里看到一个例子：<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/fHZ42YrQM-Y/Z4Xf-BbUDgAJ%E3%80%82">https://groups.google.com/d/msg/syzkaller/fHZ42YrQM-Y/Z4Xf-BbUDgAJ。</a></p>
<p>这个过程在某种程度上在<code>syz-repro</code>工具中是自动化的。你需要给它你的管理器配置和崩溃报告文件。而且你可以参考配置文件的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./syz-repro -config my.cfg crash-qemu-1-145574545926572691</span><br></pre></td></tr></table></figure>

<p>它将试图找到违规的程序并将其最小化。但由于有很多因素会影响重现性，它并不总是有效。</p>
<h3 id="Hub"><a href="#Hub" class="headerlink" title="Hub"></a>Hub</h3><p>对于多个<code>syz-manager</code>实例，应该是对应的分布式fuzz。</p>
<p><code>syz-hub</code>程序可以用来把几个<code>syz-manager</code>连接在一起，让它们交换程序。</p>
<p>用<code>make hub</code>建立<code>syz-hub</code>。然后创建一个配置文件，其内容如下。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;:80&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;rpc&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;:55555&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6sCFsJVfyFQVhWVKJpKhHcHxpCH0gAxL&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FZFSjthHHf8nKm2cqqAcAYKM5a3XM4Ao&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fTrIBQCmkEq8NsvQXZiOUyop6uWLBuzf&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>bin/syz-hub -config hub.cfg</code>启动它。在每个管理器的<code>syz-manager</code>配置文件中添加以下附加参数。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hub_client&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hub_addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.2.3.4:55555&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hub_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6sCFsJVfyFQVhWVKJpKhHcHxpCH0gAxL&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>启动<code>syz-manager</code>。一旦他们对本地语料库进行分流，他们将连接到hub并开始交换输入。hub和<code>syz-manager</code>的网页都会显示他们从hub发送&#x2F;接收了多少输入。</p>
<h1 id="设置syzkaller"><a href="#设置syzkaller" class="headerlink" title="设置syzkaller"></a>设置syzkaller</h1><p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/akaros/README.md">Akaros</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/freebsd/README.md">FreeBSD</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/fuchsia/README.md">Fuchsia</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/netbsd/README.md">NetBSD</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/openbsd/setup.md">OpenBSD</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/windows/README.md">Windows</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/setup.md">Linux</a>。</p>
<p>运行，访问<code>http://127.0.0.1:56741</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/syz-manager -config=my.cfg</span><br><span class="line">2017/06/14 16:39:05 loading corpus...</span><br><span class="line">2017/06/14 16:39:05 loaded 0 programs (0 total, 0 deleted)</span><br><span class="line">2017/06/14 16:39:05 serving http on http://127.0.0.1:56741</span><br><span class="line">2017/06/14 16:39:05 serving rpc on tcp://127.0.0.1:34918</span><br><span class="line">2017/06/14 16:39:05 booting <span class="built_in">test</span> machines...</span><br><span class="line">2017/06/14 16:39:05 <span class="built_in">wait</span> <span class="keyword">for</span> the connection from <span class="built_in">test</span> machine...</span><br><span class="line">2017/06/14 16:39:59 received first connection from <span class="built_in">test</span> machine vm-9</span><br><span class="line">2017/06/14 16:40:05 executed 293, cover 43260, crashes 0, repro 0</span><br><span class="line">2017/06/14 16:40:15 executed 5992, cover 88463, crashes 0, repro 0</span><br><span class="line">2017/06/14 16:40:25 executed 10959, cover 116991, crashes 0, repro 0</span><br><span class="line">2017/06/14 16:40:35 executed 15504, cover 132403, crashes 0, repro 0</span><br></pre></td></tr></table></figure>

<h1 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h1><p>检查运行的 syzkaller 是否有问题：</p>
<ul>
<li>使用<code>-debug</code>命令行选项，使 syzkaller 从<code>syz-manager</code>顶层程序和<code>syz-fuzzer</code>实例打印所有可能的调试输出。使用此选项 syzkaller 将只运行一个 VM 实例。</li>
<li>使用<code>-vv N</code>命令行选项，增加<code>syz-manager</code>顶层程序和<code>syz-fuzzer</code>实例（转到<code>crashes</code>工作目录子目录中的输出文件）的日志输出量。N 值越高，输出越多。</li>
<li>如果日志记录表明执行程序存在问题（例如<code>executor failure</code>），尝试手动运行一小段系统调用：<ul>
<li>复制<code>syz-executor</code>和<code>syz-execprog</code>到正在运行的 VM中。</li>
<li>在 VM 中运行<code>./syz-execprog -executor ./syz-executor -debug sampleprog</code>，sampleprog 是一个简单的系统调用脚本（例如只包含<code>getpid()</code>）。</li>
<li>例如，如果报告<code>clone</code>失败，这可能表明测试内核不支持所有必需的命名空间。在这种情况下，<code>syz-execprog</code>使用该选项运行测试<code>-sandbox=setuid</code>可以解决问题，因此需要将主配置更新为设置<code>sandbox</code>为<code>setuid</code>.</li>
</ul>
</li>
</ul>
<p>有关 Linux 内核特定的故障排除建议，可以参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/troubleshooting.md">这里</a>。</p>
<h1 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h1><p>看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/research.md">这里</a>。</p>
<h1 id="技术会谈和文章"><a href="#技术会谈和文章" class="headerlink" title="技术会谈和文章"></a>技术会谈和文章</h1><p>看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/talks.md">这里</a>。</p>
<h1 id="syzbot"><a href="#syzbot" class="headerlink" title="syzbot"></a>syzbot</h1><p>这是一个机器人，用于持续的fuzz多个内核。详细的内容参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syzbot.md">这里</a>。</p>
<p>代码在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/dashboard/app">这里</a>。架构如下：</p>
<p><img src="https://github.com/google/syzkaller/blob/master/docs/syzbot_architecture.png?raw=true" alt="syzbot_architecture.png"></p>
<h1 id="syz-verifier"><a href="#syz-verifier" class="headerlink" title="syz_verifier"></a>syz_verifier</h1><p><code>syz-verifier</code>是一种差分模糊测试工具，可以交叉比较程序在不同版本的 Linux 内核上的执行情况，以检测语义错误。架构如下：</p>
<p><img src="https://github.com/google/syzkaller/raw/master/docs/syz_verifier_structure.png" alt="架构概述"></p>
<p><code>syz-verifier</code>进程启动并管理带有要进行交叉比较的内核的虚拟机实例。它也会启动虚拟机上的<code>syz-runner</code>进程。host和client之间的通信是通过RPC完成的。</p>
<p><code>syz-verifier</code>生成并通过RPC向<code>syz-runner</code>连续发送程序，而<code>syz-runner</code>则负责启动<code>syz-executor</code>进程，并将程序转化为这些程序的输入。<code>syz-executor</code>处理输入，从而触发内核中一系列的<code>syscall</code>。然后，<code>syz-runner</code>收集结果并将其送回host。</p>
<p>目前，这些结果包含了每个系统调用返回的<code>errnos</code>。当<code>syz-verifier</code>收到所有内核对某一特定程序的运行结果后，它会对其进行验证以确保它们是相同的。如果发现不相同，就在所有内核上重新运行该程序，以确保不相同不是片状的（即不是因为某些背景活动或外部状态而发生的）。如果在所有的重新运行中都出现了不匹配，<code>syz-verifier</code>就会为该程序创建一份报告，并将其写入<code>persistent storage</code>。</p>
<h2 id="如何使用syz-verifier"><a href="#如何使用syz-verifier" class="headerlink" title="如何使用syz-verifier"></a>如何使用<code>syz-verifier</code></h2><p>源码下载完后，直接<code>make</code>。</p>
<p>要开始使用该工具，需要为要包含在验证中的每个内核创建单独的配置文件。可以在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md#syzkaller">此处</a>找到 Linux 配置的示例。</p>
<p>如果想从一组特定的系统调用中生成程序，可以使用<code>enable_syscalls</code>选项在内核配置文件中列出这些调用。如果想禁用某些系统调用，可以使用<code>disable_syscalls</code>选项。</p>
<p>运行<code>syz-verifier</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-verifier -configs=kernel0.cfg,kernel1.cfg</span><br></pre></td></tr></table></figure>

<p><code>syz-verifier</code>在执行过程中会收集统计数据。默认情况下，这些数据会被打印到stdout，也可以用stat标志来指定文件。</p>
<h2 id="如何解释结果"><a href="#如何解释结果" class="headerlink" title="如何解释结果"></a>如何解释结果</h2><p>结果在<code>workdir/results</code>中。</p>
<p>当<code>syz-verifier</code>在程序中发现不匹配时，它将为该程序创建一个报告。该报告列出了每个系统调用返回的结果，由每个交叉比较的内核，突出显示发现不匹配的结果。系统调用按照它们在程序中出现的顺序列出。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ERRNO mismatches found <span class="keyword">for</span> program:</span><br><span class="line"></span><br><span class="line">[=] io_uring_register<span class="variable">$IORING_REGISTER_PERSONALITY</span>(0xffffffffffffffff, 0x9, 0x0, 0x0)</span><br><span class="line">        ↳ Pool: 0, Flags: 3, Errno: 9 (bad file descriptor)</span><br><span class="line">        ↳ Pool: 1, Flags: 3, Errno: 9 (bad file descriptor)</span><br><span class="line"></span><br><span class="line">[=] syz_genetlink_get_family_id<span class="variable">$devlink</span>(&amp;(0x7f0000000000), 0xffffffffffffffff)</span><br><span class="line">        ↳ Pool: 0, Flags: 3, Errno: 2 (no such file or directory)</span><br><span class="line">        ↳ Pool: 1, Flags: 3, Errno: 2 (no such file or directory)</span><br><span class="line"></span><br><span class="line">[!] r1 = io_uring_setup(0x238e, &amp;(0x7f0000000240)=&#123;0x0, 0xf39a, 0x20, 0x0, 0x146&#125;)</span><br><span class="line">        ↳ Pool: 0, Flags: 3, Errno: 6 (no such device or address)</span><br><span class="line">        ↳ Pool: 1, Flags: 3, Errno: 9 (bad file descriptor)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>结果的顺序是由配置文件传递的顺序决定的，所以<code>Pool: 0</code>表示使用<code>kernel0.cfg</code>创建的内核所产生的结果，以此类推。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/ipc/ipc.go#L82">Flags</a>可用于确定系统调用达到的状态：</p>
<ul>
<li><code>0</code>&#x3D; 系统调用甚至没有开始</li>
<li><code>1</code>&#x3D; 系统调用开始</li>
<li><code>3</code>&#x3D; 系统调用完成执行</li>
<li><code>7</code>&#x3D; 系统调用被阻止</li>
</ul>
<h1 id="syz-testbed"><a href="#syz-testbed" class="headerlink" title="syz-testbed"></a>syz-testbed</h1><p><code>syz-testbed</code>是一种评估不同 syzkaller 版本（或配置）性能的工具。该工具自动检查 syzkaller 存储库、构建它们、运行 <code>syz-manager</code>并收集&#x2F;总结它们的结果。详见<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syz_testbed.md">这里</a>。</p>
<h1 id="Syscall描述"><a href="#Syscall描述" class="headerlink" title="Syscall描述"></a>Syscall描述</h1><p><code>syzkaller</code>使用系统调用接口的声明性描述来操作程序（系统调用序列）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd</span><br><span class="line"><span class="title function_">read</span><span class="params">(fd fd, buf buffer[out], count len[buf])</span></span><br><span class="line"><span class="title function_">close</span><span class="params">(fd fd)</span></span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>

<p>描述包含在<code>sys/$OS/*.txt</code>文件中。例如，有关 Linux MIDI 接口的描述，参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/dev_snd_midi.txt">sys&#x2F;linux&#x2F;dev_snd_midi.txt</a>。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>然后使用翻译后的描述来生成、变异、执行、最小化、序列化和反序列化程序。程序是具有具体参数具体值的系统调用序列。这是一个程序的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r0 = open(&amp;(<span class="number">0x7f0000000000</span>)=<span class="string">&quot;./file0&quot;</span>, <span class="number">0x3</span>, <span class="number">0x9</span>)</span><br><span class="line">read(r0, &amp;(<span class="number">0x7f0000000000</span>), <span class="number">42</span>)</span><br><span class="line">close(r0)</span><br></pre></td></tr></table></figure>

<p>在实际操作中，<code>syzkaller</code>使用类似AST的内存表示法，由<code>prog/prog.go</code>中定义的<code>Call</code>和<code>Arg</code>值组成。这种表示法被用来<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/analysis.go">分析</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/rand.go">生成</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/mutation.go">变异</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/minimization.go">最小化</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/validation.go">验证</a>等程序。</p>
<p>内存中的表示法可以<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/encoding.go">转换</a>为文本形式，以存储在磁盘语料库中，并进行展示，等等。</p>
<p>还有另一种程序的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/decodeexec.go">二进制表示法</a>（称为exec），它更简单，不包含丰富的类型信息（不可逆），用于由<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/executor.cc"><code>executor</code></a>实际执行（解释）程序。</p>
<h2 id="描述新的系统调用"><a href="#描述新的系统调用" class="headerlink" title="描述新的系统调用"></a>描述新的系统调用</h2><p>本节介绍如何扩展 <code>syzkaller</code> 以允许对更多内核接口进行模糊测试。</p>
<p>目前，所有的系统调用描述都是手动编写的。有一个开放的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/issues/590">问题</a>是为这个过程提供一些帮助，以及一些正在进行的工作，但我们还没有达到完全自动化的方式来生成描述。有一个<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/headerparser_usage.md">headerparser</a>工具，可以从头文件中自动生成部分描述。</p>
<p>实现对一个新的内核接口的模糊处理。</p>
<ul>
<li><p>研究该接口，找出使用该接口需要哪些系统调用。有时除了源代码外，什么都没有，但以下的东西可能会有帮助：</p>
<ul>
<li>在互联网上搜索接口的名称和&#x2F;或一些独特的常数。</li>
<li>在内核中搜索<code>Documentation</code>&#x2F; <code>dir</code>。</li>
<li>搜索内核中的<code>tool</code>&#x2F;<code>testing</code>&#x2F; <code>dir</code>。</li>
<li>寻找源代码中的大型注释块。</li>
<li>通过<code>git blame</code>或<code>git log</code>找到添加接口的提交，并阅读提交描述。</li>
<li>阅读或追踪已知使用该接口的库或应用程序的源代码。</li>
</ul>
</li>
<li><p>以<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md">语法文档</a>和<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux">现有的描述</a>为例，在相应的文件中添加该接口的声明性描述：</p>
<ul>
<li><code>sys/linux/&lt;subsystem&gt;.txt</code>文件保存了特定内核子系统的系统调用，例如<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/bpf.txt"><code>bpf.txt</code></a>或<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/socket.txt"><code>socket.txt</code></a>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/sys.txt"><code>sys/linux/sys.txt</code></a>文件保存了更多通用系统调用的描述。</li>
<li>一个全新的子系统可以作为一个新的<code>sys/linux/&lt;new&gt;.txt</code>文件被添加。</li>
<li>如果子系统的描述被分割成多个文件，请在每个文件的名称前加上子系统的名称（例如，使用<code>dev_*.txt</code>描述<code>/dev/</code>设备，使用<code>socket_*.txt</code>描述<code>socket</code>，等等）。</li>
</ul>
</li>
<li><p>添加&#x2F;更改描述后运行。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make extract TARGETOS=linux SOURCEDIR=<span class="variable">$KSRC</span></span><br><span class="line">make generate</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>运行<code>syzkaller</code>。确保新添加的接口被<code>syzkaller</code>通过<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/coverage.md">覆盖</a>信息页面到达。</li>
</ul>
<p>在上面的说明中，<code>make extract</code>生成&#x2F;更新了<code>*.const</code>文件。<code>$KSRC</code>应该指向最新的内核。<br>注意：对于Linux来说，最新的内核通常是指主线树。<br>然而，在某些情况下，我们会添加一些尚未在主线树中出现的接口描述，所以如果<code>make extract</code>抱怨缺少头文件或常量在所有架构上都未定义，请尝试使用最新的<code>linux-next</code>树（或者如果它恰好在此时被破坏，请尝试稍旧的linux-next树）。<br>注意：<code>make extract</code>会覆盖<code>$KSRC</code>中的<code>.config</code>，而<code>mrproper</code>则会覆盖它。注意：<code>*.const</code>文件与<code>*.txt</code>的修改在同一提交中被<code>commit</code>。</p>
<p>然后<code>make generate</code>更新生成的代码，<code>make</code>重新构建二进制文件。<br>注意：<code>make generate</code>不需要任何内核源、本地编译器等，是纯文本处理。注意：<code>make generate</code>还会更新<code>executor/defs.h</code>下的<code>SYZ_REVISION</code>，这是运行<code>syz-manager</code>时机器检查所需要的。尤其是当你试图用你自己对系统调用的描述进行修改来重新建立数据库时，更应该注意这一点。</p>
<p>注意：<code>make extract</code>会提取所有需要安装交叉编译器的架构的常量。如果你遇到关于缺少编译器&#x2F;库的错误，请尝试<code>sudo make install_prerequisites</code>或者为你的发行版安装相应的软件包。注意：<code>sudo make install_prerequisites</code>即使在某些软件包安装失败的情况下也会成功，<code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code>可能是为了使其更有效。</p>
<p>如果你只想对你在本地描述的新子系统进行模糊处理，你可能会发现<code>enable_syscalls</code>配置参数对专门针对新的系统调用很有用。<code>enable_syscalls</code>列表中的所有系统调用都将被启用，如果它们的要求被满足的话（也就是说，如果它们在目标机器中被支持，并且任何其他需要运行以便为其提供输入的系统调用也被启用）。你也可以包括通配符定义，在一行中启用多个系统调用，例如。<code>&quot;ioctl &quot;</code>将启用所有符合要求的ioctls系统调用，<code>&quot;ioctl$UDMABUF_CREATE &quot;</code>只启用那个特定的<code>ioctl</code>调用，<code>&quot;write$UHID_*&quot;</code>启用所有以该描述标识符开头的写系统调用。</p>
<p>在更新现有的syzkaller描述时，请注意，除非某个特定的系统调用的描述有很大的变化，否则已经在语料库中的程序会被保留下来，除非你手动将它们清除掉（例如通过删除<code>corpus.db</code>文件）。</p>
<h2 id="Tips-and-FAQ"><a href="#Tips-and-FAQ" class="headerlink" title="Tips and FAQ"></a>Tips and FAQ</h2><h3 id="Syscall-struct-field-flags-名称"><a href="#Syscall-struct-field-flags-名称" class="headerlink" title="Syscall, struct, field, flags 名称"></a>Syscall, struct, field, flags 名称</h3><p>尽量使用现有的内核名称，如果可能，不要发明新的名称。</p>
<p>遵循既定的命名规则有以下好处。(1) 内核接口中使用的名字的一致性和熟悉性，这也使得能够在内核资源中搜索相关的名字；(2) 能够用<code>syz-check</code>对描述进行静态检查（例如，遗漏的标志或错误的字段）。</p>
<p>例如，如果在内核头文件中有一个现有的枚举<code>v4l2_buf_type</code>，那么在描述中也使用这个名字的标志。对于结构体、联合体、字段等也是如此。对于系统调用和结构的变体，在<code>$</code>符号后面加上变体名称。例如，<code>fcntl$F_GET_RW_HINT, ioctl$FIOCLEX</code>, <code>setsockopt$SO_TIMESTAMP</code>。</p>
<h3 id="系统调用的资源顺序"><a href="#系统调用的资源顺序" class="headerlink" title="系统调用的资源顺序"></a>系统调用的资源顺序</h3><p>资源和资源方向（<code>in</code>, <code>out</code>,<code>inout</code>）对参与的系统调用施加了隐含的排序约束。</p>
<p>如果一个系统调用接受一个特定类型的资源（例如，将<code>fd_cdrom</code>作为输入），那么它通常会被放在将该资源作为输出的系统调用之后，这样资源值就可以在系统调用之间传递。比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r0 = openat$cdrom(...)</span><br><span class="line">ioctl$CDROMPAUSE(r0, <span class="number">0x123</span>)</span><br><span class="line">close(r0)</span><br></pre></td></tr></table></figure>

<p>系统调用的参数总是输入的，返回值是输出的，指针间接性有明确的方向作为<code>ptr</code>类型属性。此外，还可以为结构字段单独指定方向属性，以考虑到更复杂的生产者&#x2F;消费者场景，包括输入&#x2F;输出资源的结构。</p>
<h3 id="使用意料之外的-未声明的值"><a href="#使用意料之外的-未声明的值" class="headerlink" title="使用意料之外的&#x2F;未声明的值"></a>使用意料之外的&#x2F;未声明的值</h3><p>当指定整数&#x2F;字符串标志或整数字段时，只坚持使用官方的预期值。</p>
<p>通常情况下，bug是由意外的输入触发的。考虑到这一点，在描述中引入一些意想不到的值（例如<code>-1</code>或<code>INT_MAX</code>）可能太诱人了。这是不被鼓励的，有几个原因。首先，这是一个跨领域的问题，这些特殊的意外值仅仅适用于任何标志和整数领域。手动指定它们数千次是不可扩展的，也是不可维护的。第二，模糊器很难想出正确的复杂的系统调用序列，而描述是为了帮助解决这个问题。想出出乎意料的整数值很容易，模糊器在这里不需要帮助。总的来说，我们的想法是改进通用的fuzzer逻辑，以更好地处理这些情况，这将有助于所有的描述，而不是对每个单独的整数单独进行过度的专门化。Fuzzer已经有几个技巧来处理这个问题，例如，比较操作数值的拦截和典型的魔法值列表。</p>
<p>注意：标志的一些值可能只是作为一种疏忽而没有记录。这些值应该被添加到描述中。</p>
<h3 id="Flags-enums"><a href="#Flags-enums" class="headerlink" title="Flags&#x2F;enums"></a>Flags&#x2F;enums</h3><p>标志类型用于所有的：</p>
<ul>
<li>相互排斥的值的集合，其中只应选择其中一个（像C枚举）。</li>
<li>位标志的集合，其中多个值可以用位向OR结合起来（像mmap标志）。</li>
<li>上述的任何组合。</li>
</ul>
<p>模糊器有区分枚举和位标志的逻辑，并产生相应的值。因此，一般的指导原则是只列举标志中的有意义的值，而不添加任何 “特殊 “值来 “帮助 “当前的模糊器逻辑。当&#x2F;如果模糊器的逻辑发生变化&#x2F;改进时，这些手动添加的东西可能变得没有必要，或者更糟糕的是，干扰模糊器生成良好值的能力。</p>
<h3 id="定义顺序"><a href="#定义顺序" class="headerlink" title="定义顺序"></a>定义顺序</h3><p>syzlang不要求在使用前声明实体（像C&#x2F;C++那样），实体可以引用后来声明的实体（像Go那样）。建议按照重要性的顺序来声明东西，这样读者就能先看到最重要的东西，然后再进行越来越细的实现细节。例如，系统调用通常应该放在这些系统调用中使用的标志声明之前。注意：这种顺序通常与C语言中的声明方式完全相反：最不重要的东西放在前面。</p>
<h3 id="汇编的内部结构"><a href="#汇编的内部结构" class="headerlink" title="汇编的内部结构"></a>汇编的内部结构</h3><p>将文本的系统调用描述编译成机器可使用的形式，由syzkaller实际生成程序，这个过程包括两个步骤：</p>
<ol>
<li><p>第一步是使用<code>syz-extract</code>工具从内核源中提取符号常量值。<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/syz-extract"><code>syz-extract</code></a>生成一个小的C程序，包括由<code>include</code>指令引用的内核头文件，定义由<code>define</code>指令指定的宏，并打印出符号常量值。结果存储在<code>.const</code>文件中，每个内核有一个。例如，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/dev_ptmx.txt"><code>sys/linux/dev_ptmx.txt</code></a>被翻译成<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/dev_ptmx.txt.const"><code>sys/linux/dev_ptmx.txt.const</code></a>。</p>
</li>
<li><p>第二步是使用<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/syz-sysgen"><code>syz-sysgen</code></a>工具将描述翻译成Go代码（实际的编译器代码存在于<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/ast"><code>pkg/ast</code></a>和<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/compiler"><code>pkg/compiler</code></a>中）。这一步使用系统调用描述和第一步中生成的<code>const</code>文件，并产生<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/types.go"><code>prog/types.go</code></a>中定义的<code>Syscall</code>和<code>Type</code>类型的实例化。你可以在<code>sys/akaros/gen/amd64.go</code>中看到一个<code>Akaros</code>的编译器输出的例子。这一步还为<code>Executor/syscalls.h</code>中的C++代码生成了一些最小的<code>Syscall</code>元数据。</p>
</li>
</ol>
<h3 id="非主线子系统"><a href="#非主线子系统" class="headerlink" title="非主线子系统"></a>非主线子系统</h3><p><code>make extract</code>可以提取所有<code>*.txt</code>文件和所有支持的架构的常量。对于那些不存在于主线内核中的子系统，或者如果你有本地内核编译器的问题，这可能不起作用。在这种情况下，<code>make extract</code>使用的<code>syz-extract</code>工具可以手动运行单个文件&#x2F;架构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make bin/syz-extract</span><br><span class="line">bin/syz-extract -os linux -<span class="built_in">arch</span> <span class="variable">$ARCH</span> -sourcedir <span class="variable">$KSRC</span> -builddir <span class="variable">$LINUXBLD</span> &lt;new&gt;.txt</span><br><span class="line">make generate</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><code>$ARCH</code>是<code>amd64</code>, <code>386</code>, <code>arm64</code>, <code>arm</code>, <code>ppc64le</code>, <code>mips64le</code>中的一种。如果子系统在几个架构上都支持，那么为每个架构运行<code>syz-extract</code>。<code>$LINUX</code>应该指向内核源码检出，它是为相应的<code>arch</code>配置的（也就是说，你需要先在那里运行<code>make ARCH=arch someconfig &amp;&amp; make ARCH=arch</code>，如果需要，记得添加<code>CROSS_COMPILE=arm-linux-gnueabi-/aarch64-linux-gnu-/powerpc64le-linux-gnu-</code>）。如果内核被建立在一个单独的目录中（用<code>make O=output_dir</code>，记得把<code>.config</code>放到<code>output_dir</code>，如果你想同时在不同的<code>arch</code>上工作，这将很有帮助），那么也要把<code>$LINUXBLD</code>设置为建立目录的位置。</p>
<h3 id="测试描述"><a href="#测试描述" class="headerlink" title="测试描述"></a>测试描述</h3><p>描述本身可能包含错误。在用新的描述运行<code>syz-manager</code>后，检查<code>syz-manager</code>网页界面上的内核代码覆盖率报告总是很有用的。该报告可以评估我们期望覆盖的东西是否真的被覆盖了，如果没有，那么模糊器就会卡在哪里。然而，这只是对描述正确性的一个有用但相当间接的评估。模糊器可以通过偏离描述的内容来解决描述中的一些错误，但这将大大增加模糊器的进展难度。</p>
<p>存储在<code>sys/OS/test/*</code>中的测试对描述提供了更直接的测试。每个测试只是一个带有检查的系统调用返回值的程序。这里简要介绍了程序的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/program_syntax.md">语法</a>。你也可以看一下<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test">现有的例子</a>和程序<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/encoding.go">反序列化代码</a>。AUTO关键字可以作为常量和指针的值，对于指针来说，它将导致一些合理的内存地址的顺序分配。</p>
<p>至少为子系统的 “主要成功场景 “添加一个测试总是好的。它将确保描述确实是正确的，并且模糊器有可能得出成功的方案。请看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test/io_uring"><code>io_uring</code></a>测试作为一个很好的例子。</p>
<p>测试可以用<code>syz-runtest</code>工具运行，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make runtest &amp;&amp; bin/syz-runtest -config manager.config</span><br></pre></td></tr></table></figure>

<p><code>syz-runtest</code>启动多个虚拟机并在虚拟机内以不同的执行模式运行这些测试。</p>
<p>然而，完整的<code>syz-runtest</code>运行需要时间，所以在开发测试的同时，使用<code>syz-execprog</code>工具来运行它更方便。要运行测试，请将<code>syz-execprog</code>、<code>syz-executor</code>和测试复制到一个手动启动的虚拟机中，然后在虚拟机中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syz-execprog -debug -threaded=0 mytest</span><br></pre></td></tr></table></figure>

<p>它将显示所有执行的系统调用的结果。它对于手动调试伪系统调用代码也很方便：如果你在伪系统调用中加入一些临时性的调试调用，<code>syz-execprog -debug</code>会显示它们的输出。</p>
<p>测试的语法可以通过下面的方式来检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run=TestParsing ./pkg/runtest</span><br></pre></td></tr></table></figure>

<h1 id="Syscall-描述语言"><a href="#Syscall-描述语言" class="headerlink" title="Syscall 描述语言"></a>Syscall 描述语言</h1><p>也叫 <code>syzlang</code> 。</p>
<p>系统调用描述的伪代码语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syscallname <span class="string">&quot;(&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;)&quot;</span> [<span class="built_in">type</span>] [<span class="string">&quot;(&quot;</span> attribute* <span class="string">&quot;)&quot;</span>]</span><br><span class="line">arg = argname <span class="built_in">type</span></span><br><span class="line">argname = identifier</span><br><span class="line"><span class="built_in">type</span> = typename [ <span class="string">&quot;[&quot;</span> type-options <span class="string">&quot;]&quot;</span> ]</span><br><span class="line">typename = <span class="string">&quot;const&quot;</span> | <span class="string">&quot;intN&quot;</span> | <span class="string">&quot;intptr&quot;</span> | <span class="string">&quot;flags&quot;</span> | <span class="string">&quot;array&quot;</span> | <span class="string">&quot;ptr&quot;</span> |</span><br><span class="line">	   <span class="string">&quot;string&quot;</span> | <span class="string">&quot;strconst&quot;</span> | <span class="string">&quot;filename&quot;</span> | <span class="string">&quot;glob&quot;</span> | <span class="string">&quot;len&quot;</span> |</span><br><span class="line">	   <span class="string">&quot;bytesize&quot;</span> | <span class="string">&quot;bytesizeN&quot;</span> | <span class="string">&quot;bitsize&quot;</span> | <span class="string">&quot;vma&quot;</span> | <span class="string">&quot;proc&quot;</span></span><br><span class="line">type-options = [type-opt [<span class="string">&quot;,&quot;</span> type-opt]]</span><br></pre></td></tr></table></figure>

<p>常见的类型选项包括：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;opt&quot;</span> - the argument is optional (like mmap fd argument, or accept peer argument)</span><br></pre></td></tr></table></figure>

<p>其余类型选项是特定于类型的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;const&quot;</span>: <span class="built_in">integer</span> constant, type-options:</span><br><span class="line">	value, underlying <span class="built_in">type</span> (one of <span class="string">&quot;intN&quot;</span>, <span class="string">&quot;intptr&quot;</span>)</span><br><span class="line"><span class="string">&quot;intN&quot;</span>/<span class="string">&quot;intptr&quot;</span>: an <span class="built_in">integer</span> without a particular meaning, type-options:</span><br><span class="line">	optional range of values (e.g. <span class="string">&quot;5:10&quot;</span>, or <span class="string">&quot;100:200&quot;</span>),</span><br><span class="line">	optionally followed by an alignment parameter</span><br><span class="line"><span class="string">&quot;flags&quot;</span>: a <span class="built_in">set</span> of values, type-options:</span><br><span class="line">	reference to flags description (see below), underlying int <span class="built_in">type</span> (e.g. <span class="string">&quot;int32&quot;</span>)</span><br><span class="line"><span class="string">&quot;array&quot;</span>: a variable/fixed-length array, type-options:</span><br><span class="line">	<span class="built_in">type</span> of elements, optional size (fixed <span class="string">&quot;5&quot;</span>, or ranged <span class="string">&quot;5:10&quot;</span>, boundaries inclusive)</span><br><span class="line"><span class="string">&quot;ptr&quot;</span>/<span class="string">&quot;ptr64&quot;</span>: a pointer to an object, type-options:</span><br><span class="line">	direction (<span class="keyword">in</span>/out/inout); <span class="built_in">type</span> of the object</span><br><span class="line">	ptr64 has size of 8 bytes regardless of target pointer size</span><br><span class="line"><span class="string">&quot;string&quot;</span>: a zero-terminated memory buffer (no pointer indirection implied), type-options:</span><br><span class="line">	either a string value <span class="keyword">in</span> quotes <span class="keyword">for</span> constant strings (e.g. <span class="string">&quot;foo&quot;</span> or `deadbeef` <span class="keyword">for</span> hex literal),</span><br><span class="line">	or a reference to string flags (special value `filename` produces file names),</span><br><span class="line">	optionally followed by a buffer size (string values will be padded with \x00 to that size)</span><br><span class="line"><span class="string">&quot;stringnoz&quot;</span>: a non-zero-terminated memory buffer (no pointer indirection implied), type-options:</span><br><span class="line">	either a string value <span class="keyword">in</span> quotes <span class="keyword">for</span> constant strings (e.g. <span class="string">&quot;foo&quot;</span> or `deadbeef` <span class="keyword">for</span> hex literal),</span><br><span class="line">	or a reference to string flags,</span><br><span class="line"><span class="string">&quot;glob&quot;</span>: glob pattern to match on the target files, type-options:</span><br><span class="line">	a pattern string <span class="keyword">in</span> quotes (syntax: https://golang.org/pkg/path/filepath/#Match)</span><br><span class="line">	(e.g. <span class="string">&quot;/sys/&quot;</span> or <span class="string">&quot;/sys/**/*&quot;</span>),</span><br><span class="line">	or include exclude glob too (e.g. <span class="string">&quot;/sys/**/*:-/sys/power/state&quot;</span>)</span><br><span class="line"><span class="string">&quot;fmt&quot;</span>: a string representation of an <span class="built_in">integer</span> (not zero-terminated), type-options:</span><br><span class="line">	format (one of <span class="string">&quot;dec&quot;</span>, <span class="string">&quot;hex&quot;</span>, <span class="string">&quot;oct&quot;</span>) and the value (a resource, int, flags, const or proc)</span><br><span class="line">	the resulting data is always fixed-size (formatted as <span class="string">&quot;%020llu&quot;</span>, <span class="string">&quot;0x%016llx&quot;</span> or <span class="string">&quot;%023llo&quot;</span>, respectively)</span><br><span class="line"><span class="string">&quot;len&quot;</span>: length of another field (<span class="keyword">for</span> array it is number of elements), type-options:</span><br><span class="line">	argname of the object</span><br><span class="line"><span class="string">&quot;bytesize&quot;</span>: similar to <span class="string">&quot;len&quot;</span>, but always denotes the size <span class="keyword">in</span> bytes, type-options:</span><br><span class="line">	argname of the object</span><br><span class="line"><span class="string">&quot;bitsize&quot;</span>: similar to <span class="string">&quot;len&quot;</span>, but always denotes the size <span class="keyword">in</span> bits, type-options:</span><br><span class="line">	argname of the object</span><br><span class="line"><span class="string">&quot;offsetof&quot;</span>: offset of the field from the beginning of the parent struct, type-options:</span><br><span class="line">	field</span><br><span class="line"><span class="string">&quot;vma&quot;</span>/<span class="string">&quot;vma64&quot;</span>: a pointer to a <span class="built_in">set</span> of pages (used as input <span class="keyword">for</span> mmap/munmap/mremap/madvise), type-options:</span><br><span class="line">	optional number of pages (e.g. vma[7]), or a range of pages (e.g. vma[2-4])</span><br><span class="line">	vma64 has size of 8 bytes regardless of target pointer size</span><br><span class="line"><span class="string">&quot;proc&quot;</span>: per process int (see description below), type-options:</span><br><span class="line">	value range start, how many values per process, underlying <span class="built_in">type</span></span><br><span class="line"><span class="string">&quot;text&quot;</span>: machine code of the specified <span class="built_in">type</span>, type-options:</span><br><span class="line">	text <span class="built_in">type</span> (x86_real, x86_16, x86_32, x86_64, arm64)</span><br><span class="line"><span class="string">&quot;void&quot;</span>: <span class="built_in">type</span> with static size 0</span><br><span class="line">	mostly useful inside of templates and varlen unions, can<span class="string">&#x27;t be syscall argument</span></span><br></pre></td></tr></table></figure>

<p>当在<code>structs</code>&#x2F;<code>unions</code>&#x2F;<code>pointers</code>中使用时，<code>flags</code>&#x2F;<code>len</code>&#x2F;<code>flags</code>也有尾部的底层类型<code>type-option</code>。</p>
<p>标志描述为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = const [<span class="string">&quot;,&quot;</span> const]*</span><br></pre></td></tr></table></figure>

<p>或字符串标志为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = <span class="string">&quot;\&quot;&quot;</span> literal <span class="string">&quot;\&quot;&quot;</span> [<span class="string">&quot;,&quot;</span> <span class="string">&quot;\&quot;&quot;</span> literal <span class="string">&quot;\&quot;&quot;</span>]*</span><br></pre></td></tr></table></figure>

<p>调用属性为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;disabled&quot;</span>: 调用将不会被用于模糊测试；对于临时禁用某些调用或禁止某些参数组合来说是非常有用的。或禁止特定的参数组合。</span><br><span class="line"><span class="string">&quot;timeout[N]&quot;</span>: 在一些默认值的基础上，调用的额外执行超时（ms）。</span><br><span class="line"><span class="string">&quot;prog_timeout[N]&quot;</span>: 额外的执行超时（ms），如果整个程序包含这个调用。如果一个程序包含几个这样的调用，则使用最大值。</span><br><span class="line"><span class="string">&quot;ignore_return&quot;</span>: 在fallback feedback中忽略该系统调用的返回值；需要用于那些不返回固定错误代码而是返回其他东西（如当前时间）的调用。</span><br><span class="line"><span class="string">&quot;breaks_returns&quot;</span>: 在fallback feedback中忽略程序中所有后续调用的返回值（不能被信任）。</span><br></pre></td></tr></table></figure>

<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p><code>int8</code>, <code>int16</code>,<code>int32</code>和<code>int64</code>表示相应大小的整数。 <code>intptr</code>表示指针大小的整数，即C的<code>long</code>类型。加<code>be</code>后缀（例如<code>int16be</code>），表示大端。可以为一个整数指定一个值的范围，格式为<code>int32[0:100]</code>或<code>int32[0:4096, 512]</code>（表示512对齐的int）。用<code>int64:N</code>来表示一个大小为N的位域。</p>
<p>可以将这些不同类型的整数用作<code>const</code>、<code>flags</code>和<code>len</code>的基本类型<code>proc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example_struct &#123;</span><br><span class="line">	f0	int8			<span class="meta"># random 1-byte integer</span></span><br><span class="line">	f1	<span class="type">const</span>[<span class="number">0x42</span>, int16be]	<span class="meta"># const 2-byte integer with value 0x4200 (big-endian 0x42)</span></span><br><span class="line">	f2	int32[<span class="number">0</span>:<span class="number">100</span>]		<span class="meta"># random 4-byte integer with values from 0 to 100 inclusive</span></span><br><span class="line">	f3	int32[<span class="number">1</span>:<span class="number">10</span>, <span class="number">2</span>]		<span class="meta"># random 4-byte integer with values &#123;1, 3, 5, 7, 9&#125;</span></span><br><span class="line">	f4	int64:<span class="number">20</span>		<span class="meta"># random 20-bit bitfield</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>结构描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structname <span class="string">&quot;&#123;&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">	(fieldname type (<span class="string">&quot;(&quot;</span> fieldattribute* <span class="string">&quot;)&quot;</span>)? <span class="string">&quot;\n&quot;</span>)+</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span> (<span class="string">&quot;[&quot;</span> attribute* <span class="string">&quot;]&quot;</span>)?</span><br></pre></td></tr></table></figure>

<p>可以在字段后面的括号中指定属性，与它们的类型无关。<code>in/out/inout</code>属性指定每个字段的方向，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo &#123;</span><br><span class="line">	field0	<span class="type">const</span>[<span class="number">1</span>, int32]	(in)</span><br><span class="line">	field1	<span class="title function_">int32</span>		<span class="params">(inout)</span></span><br><span class="line">	field2	<span class="title function_">fd</span>		<span class="params">(out)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>out_overlay</code>属性允许对结构进行单独的输入和输出布局。<code>out_overlay</code>字段之前的字段为输入，从<code>out_overlay</code>开始的字段为输出。输入和输出字段在内存中重叠（都是从内存中的结构开始）。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo &#123;</span><br><span class="line">	in0	<span class="type">const</span>[<span class="number">1</span>, int32]</span><br><span class="line">	in1	flags[bar, int8]</span><br><span class="line">	in2	ptr[in, <span class="built_in">string</span>]</span><br><span class="line">	out0	<span class="title function_">fd</span>	<span class="params">(out_overlay)</span></span><br><span class="line">	out1	int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体可以在结构体后的方括号中指定属性。属性是：</p>
<ul>
<li><code>packed</code>: 这个结构在字段之间没有填充物，并且有对齐方式1；这类似于<code>GNU C __attribute__((packed))</code>；结构的对齐方式可以用<code>align</code>属性覆盖。</li>
<li><code>align[N]</code>: 这个结构的对齐方式是N，并且填充物是N的倍数；填充物的内容没有指定（不过经常是零）；类似于<code>GNU C __attribute__((aligned(N))</code></li>
<li><code>size[N]</code>: 结构被填充到指定的大小N；填充的内容没有指定（尽管经常是零）。</li>
</ul>
<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unionname <span class="string">&quot;[&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">	(fieldname type <span class="string">&quot;\n&quot;</span>)+</span><br><span class="line"><span class="string">&quot;]&quot;</span> (<span class="string">&quot;[&quot;</span> attribute* <span class="string">&quot;]&quot;</span>)?</span><br></pre></td></tr></table></figure>

<p>可以在<code>Union</code>之后的方括号中指定属性。属性是：</p>
<ul>
<li><code>varlen</code>：联合体的大小是所选择的特定选项的大小（不是静态的）；如果没有这个属性，联合体的大小是所有选项的最大值（类似于C的联合体）。</li>
<li><code>size[N]</code>: 联合体被填充到指定的大小N；填充的内容未被指定（不过，经常是零）。</li>
</ul>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>资源代表需要从一个系统调用的输出传递到另一个系统调用的输入的值。例如，<code>close</code>系统调用需要一个先前由<code>open</code>或<code>pipe</code>系统调用返回的输入值（fd）。为了实现这一点，fd被声明为一种资源。这是一种模拟系统调用之间依赖关系的方式，因为将一个系统调用定义为资源的生产者，将另一个系统调用定义为消费者，在它们之间定义了一种松散的排序。资源被描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;resource&quot;</span> identifier <span class="string">&quot;[&quot;</span> underlying_type <span class="string">&quot;]&quot;</span> [ <span class="string">&quot;:&quot;</span> <span class="type">const</span> (<span class="string">&quot;,&quot;</span> <span class="type">const</span>)* ]</span><br></pre></td></tr></table></figure>

<p><code>underlying_type</code>是<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>、<code>intptr</code>中的一种，或者是另一种资源（它是继承的模型，例如，<code>socket</code>是fd的一个子类型）。可选的常量集代表资源的特殊值，例如，<code>0xffffffffffffff(-1)</code>代表 “没有fd”，或者<code>AT_FDCWD</code>代表 “当前dir”。特殊值作为资源值偶尔使用一次。如果没有指定特殊值，则使用特殊值0。然后，资源可以作为类型使用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource fd[int32]: <span class="number">0xffffffffffffffff</span>, AT_FDCWD, <span class="number">1000000</span></span><br><span class="line">resource sock[fd]</span><br><span class="line">resource sock_unix[sock]</span><br><span class="line"></span><br><span class="line">socket(...) sock</span><br><span class="line"><span class="title function_">accept</span><span class="params">(fd sock, ...)</span> sock</span><br><span class="line"><span class="title function_">listen</span><span class="params">(fd sock, backlog int32)</span></span><br></pre></td></tr></table></figure>

<p>资源不一定要由系统调用返回。它们可以像其他任何数据类型一样被使用。比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource[int32]</span><br><span class="line"></span><br><span class="line">request_producer(..., arg ptr[out, my_resource])</span><br><span class="line">request_consumer(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">	...</span><br><span class="line">	attr	my_resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于更复杂的生产者&#x2F;消费者的情况，可以利用字段属性。比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource_1[int32]</span><br><span class="line">resource my_resource_2[int32]</span><br><span class="line"></span><br><span class="line">request_produce1_consume2(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">	...</span><br><span class="line">	field0	<span class="title function_">my_resource_1</span>	<span class="params">(out)</span></span><br><span class="line">	field1	<span class="title function_">my_resource_2</span>	<span class="params">(in)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种资源类型必须被至少一个系统调用 “生产”（作为输出）（在联合和可选指针之外）和被至少一个系统调用 “消费”（作为输入）。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>使用以下语法为经常重复的复杂类型赋予短类型别名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier underlying_type</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type signalno int32[<span class="number">0</span>:<span class="number">65</span>]</span><br><span class="line">type net_port proc[<span class="number">20000</span>, <span class="number">4</span>, int16be]</span><br></pre></td></tr></table></figure>

<p>然后，在任何情况下都可以使用类型别名来代替基础类型。底层类型需要像描述一个结构字段一样描述，也就是说，如果需要的话，可以使用底层类型。但是，类型别名也可以用作系统调用参数。底层类型目前仅限于整数类型<code>const</code>、 <code>proc</code>、<code>flags</code>、<code>ptr</code>和<code>ptr64</code>类型。</p>
<p>有一些内置类型别名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type bool8	int8[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool16	int16[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool32	int32[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool64	int64[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type boolptr	intptr[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line"></span><br><span class="line">type filename <span class="built_in">string</span>[filename]</span><br><span class="line"></span><br><span class="line">type buffer[DIR] ptr[DIR, <span class="built_in">array</span>[int8]]</span><br></pre></td></tr></table></figure>

<h2 id="类型模板"><a href="#类型模板" class="headerlink" title="类型模板"></a>类型模板</h2><p>类型模板可以声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type buffer[DIR] ptr[DIR, <span class="built_in">array</span>[int8]]</span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line">type nlattr[TYPE, PAYLOAD] &#123;</span><br><span class="line">	nla_len		len[parent, int16]</span><br><span class="line">	nla_type	<span class="type">const</span>[TYPE, int16]</span><br><span class="line">	payload		PAYLOAD</span><br><span class="line">&#125; [align_4]</span><br></pre></td></tr></table></figure>

<p>后来使用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])</span><br></pre></td></tr></table></figure>

<p>内置类型模板<code>optional</code>定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type optional[T] [</span><br><span class="line">	val	T</span><br><span class="line">	<span class="type">void</span>	<span class="type">void</span></span><br><span class="line">] [varlen]</span><br></pre></td></tr></table></figure>

<h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>你可以通过使用<code>len</code>、<code>bytesize</code>和<code>bitsize</code>等类型来指定结构中的特定字段或命名参数的长度，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write(fd fd, buf ptr[in, <span class="built_in">array</span>[int8]], count len[buf])</span><br><span class="line"></span><br><span class="line">sock_fprog &#123;</span><br><span class="line">	len	len[filter, int16]</span><br><span class="line">	filter	ptr[in, <span class="built_in">array</span>[sock_filter]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>len</code>的参数是指针，则使用指针参数的长度。</p>
<p>用<code>bytesizeN</code>来表示一个字段的长度，N的可能值是1、2、4和8。</p>
<p>要表示父结构的长度，可以使用<code>len[parent, int8]</code>。当结构被嵌入到另一个结构中时，为了表示上一级父结构的长度，可以指定特定父结构的类型名称：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">    f0      len[s2]  <span class="meta"># length of s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">    f0      s1</span><br><span class="line">    f1      <span class="built_in">array</span>[int32]</span><br><span class="line">    f2      len[parent, int32]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>len</code>参数也可以是一个路径表达式，允许更复杂的寻址。路径表达式类似于C语言的字段引用，但也允许引用父级和同级元素。在路径的开头使用一个特殊的引用系统调用，允许直接引用系统调用的参数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">	a	ptr[in, s2]</span><br><span class="line">	b	ptr[in, s3]</span><br><span class="line">	c	<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">	d	<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s3 &#123;</span><br><span class="line"># This refers to the <span class="built_in">array</span> c in the parent s1.</span><br><span class="line">	e	len[s1:c, int32]</span><br><span class="line"># This refers to the <span class="built_in">array</span> d in the sibling s2.</span><br><span class="line">	f	len[s1:a:d, int32]</span><br><span class="line"># This refers to the <span class="built_in">array</span> k in the child s4.</span><br><span class="line">	g	len[i:j, int32]</span><br><span class="line"># This refers to syscall argument l.</span><br><span class="line">	h	len[syscall:l, int32]</span><br><span class="line">	i	ptr[in, s4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s4 &#123;</span><br><span class="line">	j	<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(k ptr[in, s1], l ptr[in, <span class="built_in">array</span>[int8]])</span><br></pre></td></tr></table></figure>

<h2 id="Proc"><a href="#Proc" class="headerlink" title="Proc"></a>Proc</h2><p><code>proc</code>类型可以用来表示每个进程的整数。我们的想法是为每个执行者提供一个单独的数值范围，这样他们就不会相互干扰。</p>
<p>最简单的例子是一个端口号。<code>proc[20000, 4, int16be]</code>类型意味着我们要从<code>20000</code>开始生成一个<code>int16be</code>整数，并为每个进程分配4个值。因此，执行者编号n将得到<code>[20000 + n * 4, 20000 + (n + 1) * 4]</code>范围内的值。</p>
<h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以指定为十进制常量、<code>0x</code>前缀十六进制常量、<code>&#39;</code>字符常量或从内核头文件中提取或由<code>define</code>指令定义的符号常量。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(a <span class="type">const</span>[<span class="number">10</span>], b <span class="type">const</span>[<span class="number">-10</span>])</span><br><span class="line">foo(a <span class="type">const</span>[<span class="number">0xabcd</span>])</span><br><span class="line">foo(a int8[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">foo(a <span class="type">const</span>[PATH_MAX])</span><br><span class="line">foo(a ptr[in, <span class="built_in">array</span>[int8, MY_PATH_MAX]])</span><br><span class="line">define MY_PATH_MAX	PATH_MAX + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>描述文件还包含<code>include</code>引用 Linux 内核头文件的 <code>incdir</code>指令、引用自定义 <code>Linux</code> 内核头目录的<code>define</code>指令和定义符号常量值的指令。</p>
<p>syzkaller 执行器定义了一些<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/pseudo_syscalls.md">伪系统调用</a> ，可以用作描述文件中的任何其他系统调用。这些伪系统调用扩展为文字 C 代码，并且可以执行用户定义的自定义操作。<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">可以在executor&#x2F;common_linux.h</a>中找到一些示例 。关于如何写好一个描述文件可以参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#tips">这里</a>。</p>
<h1 id="伪系统调用"><a href="#伪系统调用" class="headerlink" title="伪系统调用"></a>伪系统调用</h1><p>除了常规系统调用，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md">系统调用描述</a>文件还可以包含伪系统调用。这些是在执行程序中定义的 C 函数。当测试程序使用伪系统调用时，执行器将在生成的 C 程序中生成伪系统调用函数代码。</p>
<p>这允许测试程序具有特定的代码块来执行某些操作，它们也可以用作原始系统调用的更易于测试的包装器。</p>
<p><strong>通常不鼓励</strong>使用伪系统调用，因为它们破坏了声明性描述的所有优点（声明性、简洁性、对所有方面的模糊控制、对逻辑进行全局改进的可能性、静态检查、更少的错误等），增加了维护负担，是不可重复使用并使 C 复制器更长。但是，syzlang 的表达能力不足以涵盖所有可能的情况，因此需要根据具体情况考虑使用伪系统调用（额外的好处、代码量、扩展 syzlang 以涵盖这种情况的可能性等） 。</p>
<h2 id="如何向执行程序添加伪系统调用"><a href="#如何向执行程序添加伪系统调用" class="headerlink" title="如何向执行程序添加伪系统调用"></a>如何向执行程序添加伪系统调用</h2><p>首先，考虑伪系统调用的范围以及它将与哪些系统和子系统相关。执行器包括一组固定的 C 头文件，其中包含伪系统调用的代码。在创建新文件之前检查新文件是否适合现有文件之一。这些头文件在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/csource/gen.go">gen.go</a>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">executorFilenames := []<span class="built_in">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;common_linux.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_akaros.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_bsd.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_fuchsia.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_windows.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_test.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_kvm_amd64.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_kvm_arm64.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_usb_linux.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_usb_netbsd.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_usb.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;android/android_seccomp.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm_amd64.S.h&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，如果我们的新伪系统调用是特定于 Linux 的，那么 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">common_linux.h</a>将是放置它的地方。</p>
<p>实际的伪系统调用函数可能如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SYZ_EXECUTOR || __NR_syz_mycall</span></span><br><span class="line"><span class="comment">/* Add all the necessary #include and #define headers */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">syz_mycall</span><span class="params">(<span class="keyword">volatile</span> <span class="type">long</span> a0, <span class="keyword">volatile</span> <span class="type">long</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Function body */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>确保所有的函数要求都满足，并且可以编译。注意，函数名必须以 “syz_”开头。它也可以接受不同数量的参数。参数类型必须是<code>volatile long</code>，返回类型–<code>long</code>。<code>long</code>是必须的，以避免潜在的调用约定问题，因为它被投到了一个接受<code>long</code>的函数指针上。<code>volatile</code>的原因很有趣：很多<code>libc</code>函数都有各种参数约束的注释（例如，这个参数不应该是<code>NULL</code>，或者这个参数必须是有效的文件描述符）；C重现者可能会用常量参数调用这些函数，编译器可能会发现其中一些约束被违反了（例如，把<code>NULL</code>传给非<code>NULL</code>参数，或者把<code>-1</code>传成文件描述符），从而产生错误&#x2F;警告。<code> volatile</code>可以防止这种情况。</p>
<p>现在，为了正确处理伪系统调用，我们必须更新<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/host/syscalls_linux.go"><code>syscalls_linux.go</code></a>中的<code>isSupportedSyzkall</code>，并为这个系统调用添加一个特殊情况，在必要时启用它。如果我们想无条件地启用它，我们可以简单地让<code>isSupportedSyzkall</code>返回<code>true,&quot;&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">isSupportedSyzkall</span><span class="params">(sandbox <span class="built_in">string</span>, c *prog.Syscall)</span> <span class="params">(<span class="type">bool</span>, <span class="built_in">string</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> c.CallName &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;syz_mycall&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>, <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，运行<code>make generate</code>。现在您可以在系统调用描述文件中使用它，就像它是常规系统调用一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syz_mycall(arg0 pid, arg1 <span class="type">const</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>实现不得使用任何外部库或外部头文件，除了最基本和标准的（如<code>&lt;unistd.h&gt;</code>和 <code>&lt;sys/mman.h&gt;</code>）。特别是，它不能依赖于附加软件包安装的库&#x2F;头文件，也不能依赖于最近添加的内核子系统的头文件。外部依赖已被证明是脆弱的并且很容易导致构建损坏，因为在 fuzzer 和任何 C 复制器上的任何构建&#x2F;运行都需要所有依赖。例如，某些发行版上可能缺少包&#x2F;头文件、名称不同、版本错误、损坏或与其他头文件冲突。不幸的是，没有办法可靠地为 C 程序指定此类依赖项和要求。因此，如果伪系统调用需要定义某些结构、常量或辅助函数，则应在执行程序代码本身中尽可能少地描述这些内容（它们将成为 C 复制器的一部分）。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>每个新的伪系统调用应该在·sys&#x2F;OS&#x2F;test·中至少有一个测试。参见<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test">Linux</a>测试的例子。一个测试只是一个带有检查系统调用返回值的程序。至少应该有一个测试，包含使用伪系统调用的 “主要成功场景”。请看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test/io_uring"><code>io_uring</code></a>测试作为一个很好的例子。这样的测试很重要，因为它们可以确保伪系统调用代码不包含 “愚蠢 “的bug（例如，每次在<code>NULL-deref</code>时崩溃），确保fuzzer有可能想出成功的场景（作为伪系统调用和周围描述的组合），并确保它在未来继续工作。关于测试的细节，请参见<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#testing">描述的测试</a>。</p>
<h1 id="普罗米修斯指标"><a href="#普罗米修斯指标" class="headerlink" title="普罗米修斯指标"></a>普罗米修斯指标</h1><p><code>syz-manager</code>的指标在<code>http</code>端点的<code>URI /metrics</code>上公开。目前从管理器导出的普罗米修斯指标是<code>syz_exec_total</code>、<code>syz_corpus_cover</code>和<code>syz_crash_total</code>。</p>
<p>这些指标可以通过以下的普罗米修斯客户端配置来摄取：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">syzkaller</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">localhost:56741</span></span><br></pre></td></tr></table></figure>

<p>在<code>syz-manager</code>重启时，这些值被重置为零，只反映在当前执行的<code>syz-manager</code>中。</p>
<h1 id="程序语法"><a href="#程序语法" class="headerlink" title="程序语法"></a>程序语法</h1><p>Syzkaller使用一种紧凑的特定领域语言（DSL）来记录已执行的程序，测试其代码，并在语料库中持久保存程序。本页提供了相应语法的简要描述。一些有用的信息也可以在现有的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test">例子</a>和程序<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/encoding.go">反序列化代码</a>中找到。</p>
<p>与执行选项一起，DSL提供了syz-executor运行程序所需的一切。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r0 = syz_open_dev$loop(&amp;(<span class="number">0x7f00000011c0</span>), <span class="number">0x0</span>, <span class="number">0x0</span>)</span><br><span class="line">r1 = openat$<span class="number">6l</span>owpan_control(<span class="number">0xffffffffffffff9c</span>, &amp;(<span class="number">0x7f00000000c0</span>), <span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">ioctl$LOOP_SET_FD(r0, <span class="number">0x4c00</span>, r1)</span><br></pre></td></tr></table></figure>

<p>这个程序中的每一行都描述了一个特定的系统调用，前两次调用将结果保存在临时变量r0和r1中，这些变量被传递给第三个函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">line = assignment | call</span><br><span class="line">assignment = variable <span class="string">&quot; = &quot;</span> call</span><br><span class="line">call = syscall-name <span class="string">&quot;(&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;)&quot;</span>  [<span class="string">&quot;(&quot;</span> [call-prop [<span class="string">&quot;,&quot;</span> call-prop*] <span class="string">&quot;)&quot;</span>]</span><br><span class="line">arg = <span class="string">&quot;nil&quot;</span> | <span class="string">&quot;AUTO&quot;</span> | <span class="type">const</span>-arg | resource-arg | result-arg | pointer-arg | <span class="built_in">string</span>-arg | <span class="keyword">struct</span>-arg | <span class="built_in">array</span>-arg | <span class="keyword">union</span>-arg</span><br><span class="line"><span class="type">const</span>-arg = <span class="string">&quot;0x&quot;</span> hex-integer</span><br><span class="line">resource-arg = variable [<span class="string">&quot;/&quot;</span> hex-integer] [<span class="string">&quot;+&quot;</span> hex-integer]</span><br><span class="line">result-arg = <span class="string">&quot;&lt;&quot;</span> variable <span class="string">&quot;=&gt;&quot;</span> arg</span><br><span class="line">pointer-arg = <span class="string">&quot;&amp;&quot;</span> pointer-arg-addr [<span class="string">&quot;=ANY&quot;</span>] <span class="string">&quot;=&quot;</span> arg</span><br><span class="line">pointer-arg-addr = <span class="string">&quot;AUTO&quot;</span> | <span class="string">&quot;(&quot;</span> pointer-addr [<span class="string">&quot;/&quot;</span> region-size] <span class="string">&quot;)&quot;</span></span><br><span class="line"><span class="built_in">string</span>-arg = <span class="string">&quot;&#x27;&quot;</span> escaped-<span class="built_in">string</span> <span class="string">&quot;&#x27;&quot;</span> | <span class="string">&quot;\&quot;&quot;</span> escaped-<span class="built_in">string</span> <span class="string">&quot;\&quot;&quot;</span></span><br><span class="line"><span class="keyword">struct</span>-arg =  <span class="string">&quot;&#123;&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">array</span>-arg = <span class="string">&quot;[&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;]&quot;</span></span><br><span class="line"><span class="keyword">union</span>-arg = <span class="string">&quot;@&quot;</span> field-name [<span class="string">&quot;=&quot;</span> arg]</span><br><span class="line">call-prop = prop-name <span class="string">&quot;: &quot;</span> prop-value</span><br><span class="line">variable = <span class="string">&quot;r&quot;</span> dec-integer</span><br><span class="line">pointer-addr = hex-integer</span><br><span class="line">region-size = hex-integer</span><br></pre></td></tr></table></figure>

<p>也可以添加注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Obtain a file handle</span><br><span class="line">r0 = openat(<span class="number">0xffffffffffffff9c</span>, &amp;AUTO=<span class="string">&#x27;./file1\x00&#x27;</span>, <span class="number">0x42</span>, <span class="number">0x1ff</span>)</span><br><span class="line"></span><br><span class="line"># Perform a write operation</span><br><span class="line">write(r0, &amp;AUTO=<span class="string">&quot;01010101&quot;</span>, <span class="number">0x4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理是由syzkaller本身执行的。它将分配必要大小的虚拟内存区域并设置指针参数的最终值。</p>
<p>通过使用AUTO关键字，程序可以让syzkaller完全控制数据的存储。这可能很方便，例如，当一个参数必须通过引用传递，但其值的确切位置并不特别重要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r1 = syz_genetlink_get_family_id$nl80211(&amp;AUTO=<span class="string">&#x27;nl80211\x00&#x27;</span>, <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">ioctl$sock_SIOCGIFINDEX_80211(r0, <span class="number">0x8933</span>, &amp;AUTO=&#123;<span class="string">&#x27;wlan0\x00&#x27;</span>, &lt;r2=&gt;<span class="number">0x0</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>另外，一些数据可以被 “锚定 “在特定的地址上。当一个内存区域必须在多个调用之间共享时，这可能特别重要。在这种情况下，指针地址必须在<code>0x7f0000000000</code>偏移处给出。在实际执行之前，syzkaller会将指针调整到实际<code>mmaped</code>区域的起点。</p>
<h2 id="调用属性"><a href="#调用属性" class="headerlink" title="调用属性"></a>调用属性</h2><p>调用属性指定了关于必须如何执行一个特定调用的额外信息。一个程序中的每个调用都有自己的调用属性。如果没有提供属性，syzkaller会采用默认的属性。</p>
<p>目前，syzkaller支持以下调用属性。</p>
<h3 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h3><p>语法： <code>fail_nth: N</code>。</p>
<p>它需要一个整数的参数N，如果该参数为非负数，则将在第N个场合注入一个故障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r0 = openat$<span class="number">6l</span>owpan_control(<span class="number">0xffffffffffffff9c</span>, &amp;(<span class="number">0x7f00000000c0</span>), <span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">ioctl$LOOP_SET_FD(r0, <span class="number">0x4c00</span>, r0) (fail_nth: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><p>语法： <code>async</code>。</p>
<p>指示syz-executor不要等到调用完成，立即进行下一个调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r0 = openat(<span class="number">0xffffffffffffff9c</span>, &amp;AUTO=<span class="string">&#x27;./file1\x00&#x27;</span>, <span class="number">0x42</span>, <span class="number">0x1ff</span>)</span><br><span class="line">write(r0, &amp;AUTO=<span class="string">&quot;01010101&quot;</span>, <span class="number">0x4</span>) (async)</span><br><span class="line">read(r0, &amp;AUTO=<span class="string">&quot;&quot;</span>/<span class="number">4</span>, <span class="number">0x4</span>)</span><br><span class="line">close(r0)</span><br></pre></td></tr></table></figure>

<p>在设置 <code>async</code> 标志的时候要注意以下几点：</p>
<ul>
<li>这样的程序只能在线程模式下执行（即syz-executor必须设置<code>-threaded</code>标志）。</li>
<li>每个<code>async</code>调用都在一个单独的线程中执行，而且可用的线程数量有限（<code>kMaxThreads = 16</code>）。</li>
<li>如果一个<code>async</code>调用产生了一个资源，其他的调用可能会把它作为输入，如果产生资源的调用到那时还没有完成，syz-executor将直接传0。</li>
</ul>
<h1 id="Headerparser"><a href="#Headerparser" class="headerlink" title="Headerparser"></a>Headerparser</h1><p><code>headerparser</code>是一个协助<code>syzkaller</code>编写设备系统调用描述的工具。为了使<code>syzkaller</code>在对设备节点进行模糊处理时更加智能，你可以向它提供它所期望的ioctl参数结构类型的信息。为了减轻编写ioctl参数类型描述文件的工作量，<code>headerlib</code>会尽力为你生成这些文件。但仍然需要从描述语言的类型列表中手动选择合适的<code>syzkaller</code>数据类型。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycparser</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python headerparser.py --filenames=./test_headers/th_b.h</span><br><span class="line">B &#123;</span><br><span class="line">          B1     len|fileoff|flags|intN     <span class="comment">#(unsigned long)</span></span><br><span class="line">          B2     len|fileoff|flags|intN     <span class="comment">#(unsigned long)</span></span><br><span class="line">&#125;</span><br><span class="line">struct_containing_union &#123;</span><br><span class="line">          something          len|fileoff|flags|int32                   <span class="comment">#(int)</span></span><br><span class="line">          a_union.a_char     ptr[<span class="keyword">in</span>|out, string]|ptr[<span class="keyword">in</span>, filename]     <span class="comment">#(char*)</span></span><br><span class="line">          a_union.B_ptr      ptr|buffer|array                          <span class="comment">#(struct B*)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把结构元数据下面的内容复制粘贴到你的syzkaller设备描述上。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>下面尝试解析<code>test_headers/th_a.h</code>头文件以生成参数结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python headerparser.py --filenames=./test_headers/th_a.h</span><br><span class="line">ERROR:root:HeaderFilePreprocessorException: /tmp/tmpW8xzty/source.o:36:2: before: some_type</span><br><span class="line"></span><br><span class="line">$ python headerparser.py --filenames=./test_headers/th_a.h --debug</span><br><span class="line">DEBUG:GlobalHierarchy:load_header_files : [<span class="string">&#x27;./test_headers/th_a.h&#x27;</span>]</span><br><span class="line">DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor._mktempfiles: sourcefile=/tmp/tmpbBQYhR/source.cobjectfile=/tmp/tmpbBQYhR/source.o</span><br><span class="line">DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor.execute: <span class="built_in">cp</span> ./test_headers/th_a.h /tmp/tmpbBQYhR</span><br><span class="line">DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor.execute: gcc -I. -E -P -c /tmp/tmpbBQYhR/source.c &gt; /tmp/tmpbBQYhR/source.o</span><br><span class="line">ERROR:root:HeaderFilePreprocessorException: /tmp/tmpbBQYhR/source.o:36:2: before: some_type</span><br></pre></td></tr></table></figure>

<p>从错误信息中可以看到错误的发生是因为 <code>pycparser</code> 没有发现到 <code>some_type</code> 这个类型。我们可以通过让 <code>pycparser</code> 找到这个未知的类型来解决这个问题。因此，我们向 <code>headerparser</code> 提供了一个包含 C 声明和包含的文件，这些文件可以解决解析错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; include_file</span><br><span class="line">typedef int some_type;</span><br><span class="line">$ python headerparser.py --filenames=./test_headers/th_a.h --include=./include_file</span><br><span class="line">A &#123;</span><br><span class="line">          B_item              ptr|buffer|array                          <span class="comment">#(struct B*)</span></span><br><span class="line">          char_ptr            ptr[<span class="keyword">in</span>|out, string]|ptr[<span class="keyword">in</span>, filename]     <span class="comment">#(char*)</span></span><br><span class="line">          an_unsigned_int     len|fileoff|int32                         <span class="comment">#(unsigned int)</span></span><br><span class="line">          a_bool              _Bool                                     <span class="comment">#(_Bool)</span></span><br><span class="line">          another_bool        _Bool                                     <span class="comment">#(_Bool)</span></span><br><span class="line">          var                 some_type                                 <span class="comment">#(some_type)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行syzkaller程序"><a href="#执行syzkaller程序" class="headerlink" title="执行syzkaller程序"></a>执行syzkaller程序</h1><p>下面介绍如何执行现有的syzkaller程序以达到重现错误的目的。通过这种方式，你可以重放单个程序或者整个执行日志中的几个程序。</p>
<ol>
<li>设置Go工具链。</li>
<li>下载syzkaller源码。</li>
<li>编译syzkaller。</li>
<li>将二进制文件和程序复制到测试机上。</li>
<li>在测试机上运行程序：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./syz-execprog -repeat=0 -procs=8 program</span><br></pre></td></tr></table></figure>

<p>如果设置了<code>-threaded=0</code>，程序将作为一个简单的单线程的系统调用序列来执行。<code>-threaded=1</code>强制在一个单独的线程中执行每个系统调用，这样就可以在阻塞的系统调用上进行执行。</p>
<p>如果重放的是一个包含标题的复制器程序，其内容大致如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;Threaded:true Repeat:true RepeatTimes:0 Procs:8 Slowdown:1 Sandbox:none Leak:false NetInjection:true NetDevices:true NetReset:true Cgroups:true BinfmtMisc:true CloseFDs:true KCSAN:false DevlinkPCI:false USB:true VhciInjection:true Wifi:true IEEE802154:true Sysctl:true UseTmpDir:true HandleSegv:true Repro:false Trace:false LegacyOptions:&#123;Collide:false Fault:false FaultCall:0 FaultNth:0&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>根据头文件中的值来调整<code>syz-execprog</code>的标志。即，<code>Threaded/Procs/Sandbox</code>直接与<code>-threaded/-procs/-sandbox</code>的标志有关。如果<code>Repeat</code>设置为 <code>&quot;true&quot;</code>，则在<code>syz-execprog</code>中添加<code>-repeat=0</code>标志。</p>
<h1 id="覆盖率-1"><a href="#覆盖率-1" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>syzkaller使用<code>sanitizer</code>和<code>KCOV</code>进行覆盖率收集。gcc也支持<code>Sanitizer</code>，其他一些操作系统也支持<code>KCOV</code>。注意：<code>gVisor</code>的覆盖率是完全不同的。</p>
<p>覆盖率是基于对编译器插入目标代码的覆盖点的追踪。覆盖点通常是指一个基本的代码块或一个CFG边（这取决于编译器和编译过程中使用的插桩模式，例如Linux和clang的默认模式是CFG边，而gcc的默认模式是基本块）。覆盖点是由编译器在大量的转换和优化过程后在中间插入的。因此，覆盖率可能与源代码没什么关系。</p>
<h2 id="Web接口"><a href="#Web接口" class="headerlink" title="Web接口"></a>Web接口</h2><p>当点击<code>cover</code>时，会得到显示位于内核构建目录中的每个目录的视图。它显示的是<code>N</code>的<code>X%</code>或<code>---</code>。<code>N</code>的<code>X%</code>意味着到目前为止<code>N个</code>覆盖点中的<code>X%</code>被覆盖，<code>---</code>表示该目录中没有覆盖。</p>
<p>点击目录，可以看到文件和可能的子目录。在每一个源代码文件上都有<code>---</code>或覆盖率。</p>
<p>如果点击任何C文件，将看到源代码视图。在源代码视图中使用了一些颜色。颜色的定义可以在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/cover/report.go#L504"><code>coverTemplate</code></a>中找到。着色说明如下。</p>
<p>如果点击列出的源文件的百分比数字，将看到该源文件中每个函数的覆盖率。</p>
<h3 id="Covered-black-000000"><a href="#Covered-black-000000" class="headerlink" title="Covered: black (#000000)"></a>Covered: black (#000000)</h3><p>所有与该行相关的PC值都包括在内。左边的数字表明有多少程序已经触发了执行与该行有关的PC值。你可以点击这个数字，它将打开最后执行的程序。下面的例子显示了完全覆盖的单行是如何显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_covered.png" alt="coverage_covered"></p>
<h3 id="Both-orange-c86400"><a href="#Both-orange-c86400" class="headerlink" title="Both: orange (#c86400)"></a>Both: orange (#c86400)</h3><p>有几个与该行相关的PC值，并不是所有这些都被执行。同样，在源代码的左边有一个数字，可以点击它来打开最后一个触发相关PC值的程序。下面的例子显示了一个单行，它有被执行和未执行的PC值与之相关。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_both.png" alt="coverage_both"></p>
<h3 id="Weak-uncovered-crimson-red-c80000"><a href="#Weak-uncovered-crimson-red-c80000" class="headerlink" title="Weak-uncovered: crimson red (#c80000)"></a>Weak-uncovered: crimson red (#c80000)</h3><p>这一行所在的函数（符号）没有任何覆盖。也就是说，这个函数根本就没有被执行。如果编译器已经优化了某些符号，并使代码内联，那么与这一行相关的符号就是代码被编译的地方。这使得有时真的很难弄清着色的含义。下面的例子显示了与之相关的单行是如何被揭开的，而与之相关的PC值是在不被执行的函数中显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_weak-uncovered.png" alt="coverage_weak-uncovered"></p>
<h3 id="Uncovered-red-ff0000"><a href="#Uncovered-red-ff0000" class="headerlink" title="Uncovered: red (#ff0000)"></a>Uncovered: red (#ff0000)</h3><p>下面的例子显示了未被覆盖的单行是如何显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_uncovered.png" alt="coverage_uncovered"></p>
<h3 id="Not-instrumented-grey-505050"><a href="#Not-instrumented-grey-505050" class="headerlink" title="Not instrumented: grey (#505050)"></a>Not instrumented: grey (#505050)</h3><p>与该行相关的PC值没有被检测，或者源行根本没有生成代码。下面的例子显示了所有未检测的代码是如何显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_not_instrumented.png" alt="coverage_not_instrumented"></p>
<h2 id="syz-cover"><a href="#syz-cover" class="headerlink" title="syz-cover"></a>syz-cover</h2><p>在syzkaller资源库中，有一个小工具可以根据原始覆盖率数据生成覆盖率报告。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build <span class="string">&quot;-ldflags=-s -w&quot;</span> -o ./bin/syz-cover github.com/google/syzkaller/tools/syz-cover</span><br></pre></td></tr></table></figure>

<p>原始覆盖数据可以通过运行<code>syz-manager</code>获得。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://localhost:&lt;your syz-manager port&gt;/rawcover</span><br></pre></td></tr></table></figure>

<p>这些原始覆盖数据可以被送入<code>syz-cover</code>生成覆盖报告。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-cover --kernel_obj &lt;directory <span class="built_in">where</span> vmlinux is located&gt; rawcover</span><br></pre></td></tr></table></figure>

<p>导出覆盖率的CSV文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-cover --kernel_obj &lt;directory <span class="built_in">where</span> vmlinux is located&gt; --csv &lt;filename <span class="built_in">where</span> to <span class="built_in">export</span>&gt;  rawcover</span><br></pre></td></tr></table></figure>

<h1 id="Syz-bisect"><a href="#Syz-bisect" class="headerlink" title="Syz-bisect"></a>Syz-bisect</h1><p><code>syz-bisect</code>程序可以用来对<code>syzkaller</code>发现的崩溃和修复提交进行划分。它还可以识别触发崩溃的配置选项。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>用<code>make bisec</code>编译<code>syz-bisect</code>。</p>
<p>在<code>bisection</code>过程中，根据不同的内核版本会使用不同的编译器。这些编译器可以在<a target="_blank" rel="noopener" href="https://storage.googleapis.com/syzkaller/bisect_bin.tar.gz">这里</a>找到。</p>
<p>安装<code>ccache</code>以加快<code>bisecton</code>期间的内核编译速度。</p>
<p>使用<code>create-image.sh</code>创建用户空间（<code>chroot</code>）。</p>
<p>创建一个配置文件，并根据你的环境调整以下行数。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;bin_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/bisect_bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;ccache&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/ccache&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzkaller_repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/google/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;userspace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/image/chroot&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream-apparmor-kasan.config&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_baseline_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream-apparmor-kasan-base.config&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzctl&quot;</span><span class="punctuation">:</span> /home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream.sysctl<span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> /home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream.cmdline<span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;manager&quot;</span><span class="punctuation">:</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;bisect&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/workdir/image/image&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/workdir/image/key&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/go/src/github.com/google/syzkaller_bisect&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel_src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/syzkaller/linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		      <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/linux/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root=/dev/sda1 rw console=ttyS0 kaslr crashkernel=512M minnowboard_1:eth0::: security=none&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>bin/syz-bisect -config vm_bisect.cfg -crash /syzkaller/workdir/crashes/03ee30ae11dfd0ddd062af26566c34a8c853698d</code>运行<code>bisection</code>。</p>
<p><code>Syz-bisect</code>期望在给定的崩溃目录中找到 <code>repro.cprog</code> 或 <code>repro.prog</code>。它也会利用 <code>repro.opts</code>，但这并不是必须的。</p>
<h2 id="额外的参数"><a href="#额外的参数" class="headerlink" title="额外的参数"></a>额外的参数</h2><ul>
<li><code>-syzkaller_commit</code> 使用特定版本的syzkaller。</li>
<li><code>-kernel_commit</code> 内核提交，已知崩溃会重现。在修复提交时使用这个选项。</li>
<li><code>-fix</code> 如果想对一个修复提交进行分流，可以使用这个选项。</li>
</ul>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>在<code>syz-bisect</code>完成后，它会将结果转储到控制台，也会将结果存储到指定的崩溃目录中。</p>
<p><code>cause.commit</code> 确定了导致崩溃的原因，或者文本 “该崩溃已经发生在最早的测试版本上”。</p>
<p><code>fix.commit</code> 确定了修复崩溃的方法或文字<code>&quot;the crash still happens on HEAD&quot;</code>。</p>
<p><code>cause.config</code> 配置选项被确定为导致崩溃的一个触发因素。</p>
<p><code>original.config</code>、<code>baseline.config</code>、<code>minimized.config </code>文件用于配置分流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/22/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/22/">22</a><span class="page-number current">23</span><a class="page-number" href="/page/24/">24</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/24/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
