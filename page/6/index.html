<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-06T13:00:55.000Z" title="2021/12/6 21:00:55">2021-12-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-06T13:09:54.119Z" title="2021/12/6 21:09:54">2021-12-06</time></span><span class="level-item">a few seconds read (About 4 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/06/Chrome-CVE-2020-6449-UAF/">Chrome CVE-2020-6449 UAF</a></p><div class="content"><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-02T10:58:56.000Z" title="2021/12/2 18:58:56">2021-12-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-12T09:51:28.740Z" title="2021/12/12 17:51:28">2021-12-12</time></span><span class="level-item">an hour read (About 7267 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/">CVE-2020-15972 Chrome浏览器RCE</a></p><div class="content"><p>漏洞原因</p>
<p>Chrome 的 WebAudio 组件中的UAF</p>
<p>影响范围</p>
<p>该错误已在 10 月份的 Chrome <a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">86.0.4240.75</a>版中<a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">修复</a>。影响了 Chrome 85 稳定版的大部分。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/">https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以前，网页对于音频的处理仅限于<code>&lt;audio&gt;</code>标签，能力十分有限，为了实现更高级的操作，W3C设计实现了WebAudio API，通过这些API，我们几乎可以完成一个专业的音频处理软件的构建。</p>
<p>WebAudio API可以实现：</p>
<ul>
<li>实现高精度的音频计算。</li>
<li>音频混响器。</li>
<li>3D音频。</li>
<li>与<code>&lt;audio&gt;/WebRTC</code>的集成。</li>
</ul>
<p>设计思路：类似于标准IO函数，从某个地方（input）读取一个音频流，经过实时计算处理后发送去某个地方（destination），这个处理过程是effect。</p>
<p><img src="https://mdn.mozillademos.org/files/12241/webaudioAPI_en.svg"></p>
<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>由于音频处理是一项计算密集型任务，它将在单独的音频线程上完成，以便不阻塞浏览器的响应。WebAudio中的音频输入以128帧为单位进行处理，称为quantum。一旦一个quantum开始处理，整个quantum就必须完成，这意味着所有的节点都必须处理这128帧，即使有些节点被主线程删除和收集垃圾。</p>
<p>在下面的情况中，convolver实际上不会被删除，因为每个节点都持有对它所连接的输出节点的引用。然而，如果我们断开节点的连接，则convolver可能会被删除，但音频图仍然在被处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> soundSource1 = audioContext.<span class="title function_">createConstantSource</span>();</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource1.<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();       <span class="comment">//&lt;-------- start processing the audio graph</span></span><br><span class="line">soundSource1.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br></pre></td></tr></table></figure>

<p>那么一个死去的节点如何继续处理音频数据呢？在WebAudio中，AudioNode实际上只是javascript的一个接口，实际的处理是由它拥有的AudioHandler处理的。当一个AudioNode被销毁时，它将使用IsPullingAudioGraph函数检查此刻是否正在处理一个quantum。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_AUDIONODE_REFERENCES</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[%16p]: %16p: %2d: AudioNode::dispose %16p @%g\n&quot;</span>, <span class="built_in">context</span>(),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">Handler</span>().<span class="built_in">GetNodeType</span>(), handler_.<span class="built_in">get</span>(),</span><br><span class="line">          <span class="built_in">context</span>()-&gt;<span class="built_in">currentTime</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function">BaseAudioContext::GraphAutoLocker <span class="title">locker</span><span class="params">(context())</span></span>;</span><br><span class="line">  <span class="built_in">Handler</span>().<span class="built_in">Dispose</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果上下文被拉到音频图上，就把处理程序添加到孤儿列表中。 </span></span><br><span class="line">  <span class="comment">// 这将使处理程序保持运行，直到它可以在一个安全点（在处理程序任务的前/后）被删除。 </span></span><br><span class="line">  <span class="comment">// 如果图没有被拉动，我们现在就可以删除处理程序，因为音频线程上没有任何东西会接触到它。</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">context</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify the inspector that this node is going away. The actual clean up</span></span><br><span class="line">  <span class="comment">// will be done in the subclass implementation.</span></span><br><span class="line">  <span class="built_in">ReportWillBeDestroyed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个quantum正在被处理，它将把AudioHandler（handler_）的所有权转移到由AudioContext本身拥有的<code>deferred_task_handler_</code>。然后DeferredTaskHandler将确保AudioHandler保持运行，直到quantum的处理完成，然后清理孤儿AudioHandler。</p>
<p>然而，有一个例外。如果包含音频图的javascript框架被破坏了，例如，当包含图的iframe被破坏时，那么DeferredTaskHandler将在quantum仍在处理时立即进行清理，调用ClearHandlersToBeDeleted函数，这将删除孤儿AudioHandler（之前有一个信号量可以解决这个问题，但该信号量在这次<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/e4c27b508976fb751ccd4d34e52b70b668618271?originalUrl=https//////:////////cs.chromium.org/">commit</a>中被删除了）。</p>
<h2 id="控制竞争"><a href="#控制竞争" class="headerlink" title="控制竞争"></a>控制竞争</h2><p>为了在竞争获取足够的时间，来操作AudioHandler，exp使用了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode"><code>AudioWorkletNode</code></a>，AudioWorkletNode允许节点运行用户自定义的JavaScript代码，具体如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet;</span><br><span class="line">worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>可以在tear-down.js中使用sleep函数，这样就有足够的时间删除和替换ConvolverNode：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AudioWorkletProcessor</span> &#123;</span><br><span class="line">  <span class="title function_">process</span> (inputs, outputs, parameters) &#123;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除ConvolverNode的例子如下（实际上，convolver需要运行在另一个不调用parent.removeFrame的函数的范围之内，这里只是举个例子）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">worklet.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<p>另一个有用的事实是，在这样做的时候，只有与所有输入断开连接的节点才会被删除，而与输入保持连接的节点即使在iframe被删除后也会保持活力，只有在处理完成后才会被删除。如下所示，当worklet完成处理时，convolver将保持运行直到gain结束为止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line"><span class="keyword">let</span> gain = audioContext.<span class="title function_">createGain</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">convolver.<span class="title function_">disconnect</span>();</span><br><span class="line">gain = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>每个AudioHandler拥有一个音频节点的输入和输出的列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioHandler</span> : public <span class="title class_">ThreadSafeRefCounted</span>&lt;<span class="title class_">AudioHandler</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeInput</span>&gt;&gt; inputs_;</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeOutput</span>&gt;&gt; outputs_;</span><br></pre></td></tr></table></figure>

<p>AudioNodeInput（AudioSummingJunction的一个子类）也持有一个连接到它的输出列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AudioSummingJunction</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// m_renderingOutputs is a copy of m_outputs which will never be modified</span></span><br><span class="line">  <span class="comment">// during the graph rendering on the audio thread.  This is the list which</span></span><br><span class="line">  <span class="comment">// is used by the rendering code.</span></span><br><span class="line">  <span class="comment">// Whenever m_outputs is modified, the context is told so it can later</span></span><br><span class="line">  <span class="comment">// update m_renderingOutputs from m_outputs at a safe time.  Most of the</span></span><br><span class="line">  <span class="comment">// time, m_renderingOutputs is identical to m_outputs.</span></span><br><span class="line">  <span class="comment">// These raw pointers are safe. Owner of this AudioSummingJunction has</span></span><br><span class="line">  <span class="comment">// strong references to owners of these AudioNodeOutput.</span></span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="title class_">AudioNodeOutput</span>*&gt; rendering_outputs_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AudioNodeOutput保留了一个与它相连的AudioNodeInput的列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioNodeOutput</span> final &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// This HashSet holds connection references. We must call</span></span><br><span class="line">  <span class="comment">// AudioNode::makeConnection when we add an AudioNodeInput to this, and must</span></span><br><span class="line">  <span class="comment">// call AudioNode::breakConnection() when we remove an AudioNodeInput from</span></span><br><span class="line">  <span class="comment">// this.</span></span><br><span class="line">  <span class="title class_">HashSet</span>&lt;<span class="title class_">AudioNodeInput</span>*&gt; inputs_;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，ConvolverHandler拥有一个AudioNodeInput和一个AudioNodeOutput，AudioNodeInput持有对worklet的AudioNodeOutput的引用，而AudioNodeOutput持有对gain的AudioNodeInput的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>当处理一个音频图时，代码实际上是从目的地开始向后传播，并调用AudioNodeInput::Pull，然后它将为每个连接到它的输出调用AudioNodeOutput::Pull。然后AudioNodeOutput::Pull调用拥有它的AudioHandler::ProcessIfNecessary，后者又会为它的输入调用AudioNodeInput::Pull，并将调用传播给连接到它的AudioHandler。这一直持续到没有输入的源节点，然后实际的处理将从调用AudioHandler::Process开始。在AudioHandler::Process完成后，它将通过AudioNodeOutput::Pull-&gt;AudioNodeInput::Pull-&gt;AudioHandler::PullInputs-&gt;AudioHandler::ProcessIfNecessary返回到下一个AudioHandler的AudioHandler::Process。下图以两个AudioHandler为例说明了这一点，下面的一个是AudioWorkletNode：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/graph_pull.png"></p>
<p>在上图中，每个大的矩形代表了对AudioHandler所拥有的对象的所有调用，里面的小矩形代表了被调用的函数。蓝色箭头代表控制流边缘，从一个AudioHandler跳到另一个。当用一个等待了很长时间的AudioWorkletHandler来触发UAF时，相关的跳转是在AudioHandler::Process完成之后，因为在那个时候，下一个AudioHandler会被删除和替换。在上图中，红色区域表示用对象进行的调用，这些对象在调用时将被删除。此时，代码将首先返回AudioWorkletHandler拥有的AudioNodeOutput::Pull，就在对ProcessIfNecessary的调用之后。下面是它随后将遵循的代码路径，以及一些利用的可能性。</p>
<ol>
<li>当Process返回时，它首先会返回到AudioWorkletHandler的ProcessIfNecessary，然后是它所拥有的AudioNodeOutput::Pull。这时，这些对象都不会被删除（对应于图中左下角灰色框中AudioHandler::Process之后的蓝色箭头部分）。如果AudioNodeOutput::Pull是从AudioNodeInput::Pull，而不是AudioNodeInput::SumAllConnections中调用的，那么它将跳回到已释放的 AudioHandler::PullInputs，这意味着inputs_将在循环仍在迭代时被删除。</li>
<li>如果上面的inputs_的大小是一个开始，那么循环就会直接退出，而ProcessIfNecessary将从PullInputs之后继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::ProcessIfNecessary</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PullInputs</span>(frames_to_process);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> silent_inputs = <span class="built_in">InputsAreSilent</span>();</span><br><span class="line">    <span class="keyword">if</span> (silent_inputs &amp;&amp; <span class="built_in">PropagatesSilence</span>()) &#123;</span><br><span class="line">      <span class="built_in">SilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">ProcessOnlyAudioParams</span>(frames_to_process);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">UnsilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">Process</span>(frames_to_process);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时，AudioHandler已经被释放了。根据InputsAreSilent的结果，虚函数PropagatesSilence或Process将被调用。</p>
<ol start="3">
<li>如果上一点中被删除的AudioHandler被另一个有效的AudioHandler替换了，这样虚拟函数的调用就不会崩溃，那么ProcessIfNecessary将返回到调用AudioNodeOutput::Pull。现在因为AudioNodeOutput和AudioHandler的大小不同，所以有可能AudioNodeOutput（在调用AudioNodeOutput::Pull）仍然被释放的情况下替换AudioHandler（堆栈&#x2F;注册表仍然存储指向被释放对象的指针，而不是替换后的AudioHandler的AudioNodeOutput）。然后，AudioNodeOutput::Pull函数将调用Bus并返回一个指向该AudioNodeOutput拥有的AudioBus对象的指针。这意味着返回值也将被释放，指向的对象（AudioBus）可以被替换成受控数据。然而，这只在从AudioNodeInput::SumAllConnections调用AudioNodeOutput::Pull的路径中才有意义，因为通过AudioNodeInput::Pull的路径并不利用返回值。</li>
</ol>
<p>虽然第二点可以通过伪造vtable来劫持控制流，但这需要有信息泄露来打败ASLR，并获得一个堆地址来存储假vtable，所以在这一点上我无法使用它。第一点有可能是非常强大的，因为它有可能让我用任何类型的指针向量来替换inputs_，导致AudioNodeInput和许多可能的类型之间的类型混淆。可以用一个简单的CodeQL查询来找到可能的类型。</p>
<h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p>先看第三种可能，当通过SumAllConnections调用时，输出的返回值output，现在已经被释放了，被传递给SumFrom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    AudioBus* connection_bus = output-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum, with unity-gain.</span></span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据summing_bus和connection_bus之间的通道数量，可以采取各种路径。最简单的路径只是调用AudioChannel::SumFrom</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioBus::SumFrom</span><span class="params">(<span class="type">const</span> AudioBus&amp; source_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ChannelInterpretation channel_interpretation)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (number_of_source_channels == number_of_destination_channels) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_source_channels; ++i)</span><br><span class="line">      <span class="built_in">Channel</span>(i)-&gt;<span class="built_in">SumFrom</span>(source_bus.<span class="built_in">Channel</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AudioChannel::SumFrom简单地将source_bus, (connection_bus)中的数据复制到summing_bus，使用summing_bus的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioChannel::SumFrom</span><span class="params">(<span class="type">const</span> AudioChannel* source_channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSilent</span>()) &#123;</span><br><span class="line">    <span class="built_in">CopyFrom</span>(source_channel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Copies using the length of `summing_bus` (`length()`)</span></span><br><span class="line">    vector_math::<span class="built_in">Vadd</span>(<span class="built_in">Data</span>(), <span class="number">1</span>, source_channel-&gt;<span class="built_in">Data</span>(), <span class="number">1</span>, <span class="built_in">MutableData</span>(), <span class="number">1</span>,</span><br><span class="line">                      <span class="built_in">length</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果可以用一个长度短于summing_bus的Bus来替换已释放的AudioNodeOutput，那么就可以得到一个越界的读取。通过安排堆，就可以利用这一点获得一个vtable和&#x2F;或堆指针的地址，这将能够使用第二点中的虚拟函数调用原语来实现远程代码执行。</p>
<p>然而，有几个问题。首先，即使可以替换掉已释放的AudioNodeOutput，我仍然需要有一个有效的指向connection_bus的指针，这个指针是一个有效的AudioBus。一个简单的方法是用另一个有短总线的AudioNodeOutput替换AudioNodeOutput。不幸的是，所有AudioNodeOutput的Bus都是相同的长度（128），这是有道理的，否则会一直有越界的读写。另一种可能性是，由于Bus为AudioNodeOutput所有，可以直接替换Bus，而让AudioNodeOutput空出来。由于用于分配AudioNodeOutput和Bus的内存分配器PartitionAlloc是一个桶分配器，AudioNodeOutput的大小为104，而AudioBus的大小为32，通过分别操作这两个桶，可以在释放AudioNodeOutput的同时替换Bus。虽然PartitionAlloc会把释放对象的前8个字节弄乱作为额外的保护，但这并不影响AudioNodeOutput::Bus返回的指针，所以connection_bus仍然会指向用来替换的对象。如果用一个长度较短的对象替换Bus，那么就会得到一个信息泄露。</p>
<p>现在的问题是如何创建一个具有任意长度的AudioBus。看看对AudioBus::Create的各种调用，ConvolverHandler::SetBuffer中的调用看起来很有希望，因为它可以通过指定ConvolverNode的buffer字段从javascript中轻松到达。不幸的是，创建的AudioBus只是本地的，并且在函数调用结束后会被删除，这使得它很难使用。最后，WebAudioBus::Initialize中的那个函数效果更好，因为它可以通过javascript中的decodeAudioData函数达到，创建的AudioBus的长度由输入ArrayBuffer（包含一些音频数据）的大小控制。通过使用ffmpeg来创建不同长度的MP3文件，我能够使用这个函数来创建不同长度的AudioBus。</p>
<p>下一个问题更难解决。虽然可以造成越界读取，并将结果复制到summing_bus的backing store中，但由于几个原因，没有办法将这些数据读出来：</p>
<ul>
<li>为了触发UAF，需要删除包含音频图的iframe，这意味着当越界读取发生时，所有的音频节点将无法到达，因此没有办法检索属于该图的AudioNodeInput的summing_bus中的数据。</li>
<li>如果summing_bus也被释放，那么也许可以用仍然可以到达的AudioNodeInput中的另一个AudioBus来代替它，然后也许有办法从该AudioNodeInput的summing_bus中读出数据。不幸的是，情况也不是这样的，因为summing_bus不是一个原始指针，而是一个共享所有权的scoped_refptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，即使现在所有的东西都被释放了，summing_bus仍将保持活力，至少在SumAllConnections调用完成之前，所以没有办法去替换summing_bus。</p>
<p><strong>实际的方式</strong></p>
<p>回到上一节第1点中的迭代器无效原语。如前所述，通过把一个接受多个输入的AudioNode，如ChannelMergerNode放在AudioWorkletNode之后，然后删除包含音频图的iframe来触发UAF，ChannelMergerNode和由此产生的inputs_将被删除，而AudioHandler::PullInputs的循环仍在迭代中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::PullInputs</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_)</span><br><span class="line">    input-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中，这意味着在完成input-&gt;Pull调用后，input迭代器将被递增，并指向现在被删除的<code>input_</code>的已释放backing store中的下一个位置。这将继续下去，直到达到<code>input_</code>的长度。因此，通过分配另一个与inputs_相同大小的Vector，我用新Vector的支持存储空间替换了已释放的backing store。虽然这可以用来造成类型混乱，并在许多不同类型的对象上调用AudioNodeInput::Pull，但应该用什么对象来替换AudioNodeInput并不明显。</p>
<p>将ChannelMergerNode换成另一个ChannelMergerNode，它运行在父帧的音频图上。因此，当这个错误触发时，它将继续运行另一个运行在父帧中的音频图。</p>
<p>下面的图展示了替换这个对象时会发生什么：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph.png"></p>
<p>破折号边框和边表示如果子iframe没有被删除，将会被运行的节点和边，而绿色节点表示实际被运行的节点。在处理完子iframe的顶部分支后，该框架被删除，ChannelMergerNode被替换成父帧中的节点。这导致父帧中的音频图的底部分支被代替运行。</p>
<p>当删除一个AudioNode时会发生什么？正如前面解释的那样，当一个AudioNode被垃圾回收时，为了防止底层的AudioHandler被删除，而它还在被用来处理音频图，AudioNode将通过调用AudioContext的IsPullingAudioGraph方法来检查它所属的音频图是否正在被处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>IsPullingAudioGraph检查音频图是否处于kRunning状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OfflineAudioContext::IsPullingAudioGraph</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ContextState</span>() == BaseAudioContext::kRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并转移AudioHandler的所有权（如果它是）。然而，在这种情况下，因为父帧中的音频图正在作为子框架中的图的一部分被处理，音频图不会处于kRunning状态，因为它没有从父帧中启动。(在实际利用中，将不得不启动然后暂停图形以使节点相互连接，但这没有什么区别，因为图形将处于kSuspended状态，所以IsPullingAudioGraph检查仍将通过)这意味着AudioHandler的所有权转移将不会发生，它将在图形被处理时被删除。</p>
<p>这意味着可以在这个图中引起同样类型的UAF，而不需要删除包含它的框架。这一点很重要，因为之前试图获得信息泄露的主要问题是，所有的节点和包含它们的iframe都被删除了，所以没有办法检索到泄露的数据。但现在可以在不删除包含节点的框架的情况下导致UAF，将能够在UAF触发后访问它们，并能够读取泄露的数据。</p>
<h3 id="获取信息泄露"><a href="#获取信息泄露" class="headerlink" title="获取信息泄露"></a>获取信息泄露</h3><p>第一步，在一个子iframe中触发UAF，并使用循环迭代器无效原语，使音频图的一个分支在父帧中运行。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph2.png"></p>
<p>上图显示了将用于替换的实际图形。它由两个ScriptProcessorNode夹着一个GainNode组成。ScriptProcessorNode就像AudioWorkletNode，它允许运行用户提供的脚本来处理音频数据。然而，在ScriptProcessorNode的情况下，脚本是在dom窗口的上下文中运行的，它允许我访问AudioContext和各种节点，这使得使用ScriptProcessorNode进行开发更容易，exp将在父框架图中使用它而不是AudioWorkletNode。</p>
<p>第二步，在ScriptProcessorNode脚本2的音频处理脚本中，移除跟随它的GainNode，并对其进行垃圾回收，这样它的AudioInputNode和AudioOutputNode，就被释放了。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph3.png"></p>
<p>为了构建信息泄露，还需要替换被删除的GainNode，以防止虚函数调用崩溃，同时让它的AudioOutputNode保持自由。可以通过操纵堆来创建额外的释放的AudioOutputNode，这样当GainNode被释放时，它的AudioOutputNode就不会在free列表的首位，不会被替换。我通过创建一个额外的ChannelMergerNode来做到这一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">createSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  let s = audioCtx.<span class="built_in">createChannelMerger</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个ScriptProcessorNode的音频处理器。</span></span><br><span class="line"><span class="function">function <span class="title">scriptProcess2</span><span class="params">(audioProcessingEvent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要为AudioOutputNode创建孔，使它们不会被回收。</span></span><br><span class="line">  <span class="built_in">createSource</span>();</span><br><span class="line">  ...</span><br><span class="line">  script<span class="number">2.</span><span class="built_in">disconnect</span>();  <span class="comment">//&lt;--- 移除GainNode的引用</span></span><br><span class="line">  <span class="built_in">gc</span>();                  <span class="comment">//&lt;--- 首先删除GainNode, 然后在createSource中创建ChannelMergerNode</span></span><br><span class="line">  <span class="comment">// 需要等待GC分配的小对象被清除。</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">4000</span>);</span><br><span class="line">  let gain = audioCtx<span class="number">2.</span><span class="built_in">createGain</span>();  							 <span class="comment">//&lt;---- 替换gain以获取虚函数调用</span></span><br><span class="line">  let src0 = audioCtx<span class="number">2.</span><span class="built_in">createChannelMerger</span>(<span class="number">1</span>); 		   <span class="comment">//&lt;--- 为AudioBus安排堆栈</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然对createSource的调用看起来是多余的，但是，在createSource中创建的ChannelMergerNode直到垃圾回收时才会被删除，到那时，它实际上会在GainNode之后被删除，在freelist的头部留下额外的AudioOutputNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap1.png"></p>
<p>当被删除的GainNode被另一个GainNode取代时，旧GainNode的已释放的AudioNodeOutput将不会被占用。这个被释放的GainNode将负责调用Bus并为我们提供一个被释放的AudioBus。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap2.png"></p>
<p>在图中，绿色箭头表示当另一个对象被删除时被释放的对象，红色箭头表示被创建的对象。</p>
<p>为了替换AudioNodeOutput拥有的大小为32的AudioBus，也需要对大小为32的桶进行操作。为此再次使用另一个ChannelMergerNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap3.png"></p>
<p>同时，还必须注意不要替换被删除的GainNode的AudioNodeOutput…</p>
<p>虽然有很多要求需要满足，而且AudioBus是从一个相当嘈杂的桶中分配的，但与其他情况不同的是，在其他情况下，堆经常被其他进程共享，而这些进程并不在我们的控制范围内，而渲染器在很大程度上是一个孤立的进程，完全拥有其堆。因此，只要脚本是从一个新的渲染器中运行的，就可以以非常精确和具体的方式进行渲染器堆的喷射（当从登录的上下文中点击一个链接时，如通过电子邮件或Twitter），所以这不会对漏洞的可靠性造成太大的问题。</p>
<p>一旦堆被放入正确的状态，使现在被删除的GainNode所拥有的AudioBus处于freelist的正确位置，AudioContext::decodeAudioData函数就可以用来创建一个适当长度的AudioBus来触发越界读取。这个函数接收一个音频文件的ArrayBuffer（例如mp3、ogg），并在后台线程中对其进行解码。它将创建一个具有适当长度的AudioBus来容纳解码后的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::DecodeOnBackgroundThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer* audio_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> sample_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  scoped_refptr&lt;AudioBus&gt; bus = <span class="built_in">CreateBusFromInMemoryAudioFile</span>(</span><br><span class="line">      audio_data-&gt;<span class="built_in">Data</span>(), audio_data-&gt;<span class="built_in">ByteLength</span>(), <span class="literal">false</span>, sample_rate);  <span class="comment">//&lt;----- 创建AudioBus</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    <span class="built_in">PostCrossThreadTask</span>(</span><br><span class="line">        *task_runner, FROM_HERE,</span><br><span class="line">        <span class="built_in">CrossThreadBindOnce</span>(&amp;AsyncAudioDecoder::NotifyComplete,</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(audio_data),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(success_callback),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(error_callback),</span><br><span class="line">                            WTF::<span class="built_in">RetainedRef</span>(std::<span class="built_in">move</span>(bus)),            <span class="comment">//&lt;------ 传入NotifyComplete</span></span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(resolver),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(context)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建的AudioBus被作为主线程上的一个任务传递给NotifyComplete，并在NotifyComplete完成后被删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::NotifyComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer*,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    AudioBus* audio_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  AudioBuffer* audio_buffer = AudioBuffer::<span class="built_in">CreateFromAudioBus</span>(audio_bus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the context is available, let the context finish the notification.</span></span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    context-&gt;<span class="built_in">HandleDecodeAudioData</span>(audio_buffer, resolver, success_callback,</span><br><span class="line">                                   error_callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于AudioBus在这里只是一个临时对象，在解码完成后会被删除，所以需要确保它的寿命足够长，以便发生越界读取。为了做到这一点，可以使用javascript函数setInterval来干扰任务队列。当调用setInterval时，它会创建一个延迟的任务。这个任务以及DecodeOnBackgroundThread发布的NotifyComplete任务被发布到同一个任务队列中，在主线程上执行。通过用setInterval创建任务，我可以使NotifyComplete的运行出现延迟，因为在NotifyComplete之前发布的任何任务都必须在NotifyComplete之前运行，而且它们都必须在主线程上运行。这将允许在足够长的时间内保持AudioBus的活力，这样当AudioNodeInput::SumAllConnections导致越界读取时，在音频线程中使用这个AudioBus，它将仍然活着。</p>
<p>通过使用ffmpeg来创建一个无声的mp3文件，创建一个最小长度为47的AudioBus。由于来自AudioNodeInput的AudioBus的长度是128，而且AudioBus的后备存储是浮点格式，有16个大小的padding（Android为16，x86为32），这意味着可以使用界外读原语来读取大小在204和528之间的对象。CodeQL查询，可以用来识别这样的对象，并选择适当的文件长度来使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FastMallocClass</span> extends Class &#123;</span><br><span class="line">    <span class="built_in">FastMallocClass</span>() &#123;</span><br><span class="line">        <span class="built_in">exists</span>(Operator op, Function fastMalloc | op.<span class="built_in">hasName</span>(<span class="string">&quot;operator new&quot;</span>) <span class="keyword">and</span></span><br><span class="line">          fastMalloc.<span class="built_in">hasName</span>(<span class="string">&quot;FastMalloc&quot;</span>) <span class="keyword">and</span> op.<span class="built_in">calls</span>(fastMalloc) <span class="keyword">and</span></span><br><span class="line">          op.<span class="built_in">getDeclaringType</span>() = <span class="keyword">this</span>.getABaseClass*()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FastMallocClass c</span><br><span class="line">where c.<span class="built_in">getSize</span>() &lt;= <span class="number">528</span> <span class="keyword">and</span> c.<span class="built_in">getSize</span>() &gt; <span class="number">204</span></span><br><span class="line">select c, c.<span class="built_in">getLocation</span>(), c.<span class="built_in">getSize</span>()</span><br></pre></td></tr></table></figure>

<p>在这里做了改进，只包括在FastMalloc分区中分配的对象，也就是分配AudioBus的备份存储（AudioArray）的地方。看了一下结果，BiquadDSPKernel特别有用。除了要泄露vtable之外，它还包含一个字段biquad_，存储了5个AudioDoubleArray。这意味着通过泄露BiquadDSPKernel类型的对象，就能同时泄露这些AudioDoubleArray的后备存储地址，然后可以用来存储一个假的vtable来劫持虚拟函数调用。</p>
<p>因此，通过安排堆，把BiquadDSPKernel放在AudioBus后面，然后触发bug导致越界读取，就能把BiquadDSPKernel对象泄漏到下一个AudioNodeInput的AudioBus中。为了读取输入数据，可以使用ScriptProcessorNode，它允许使用javascript函数来读取输入。然后，可以获得泄漏的vtable和各种AudioDoubleArray的地址。</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>在这一点上，其余的利用方法是相当标准的。一旦获得了BiquadDSPKernel的vtable的地址，就可以用它来找到libchrome.so的偏移。有了libchrome.so的偏移量，就可以找到里面的ROP小工具的地址，并在属于BiquadDSPKernel的AudioDoubleArray中创建一个假的vtable，这样，这个假vtable中的虚拟函数指针就会指向所选择的小工具。</p>
<p>之后，自由使用后的漏洞就可以再一次被触发了。这一次，它直接进入漏洞的第二节Primitives中的路径，调用一个虚拟函数。被释放的AudioHandler对象现在可以被一个适当大小的AudioArray所取代，这个AudioArray被填充了受控数据，这样它的vtable就指向了在上面创建的假vtable。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/call_func.png"></p>
<p>使用类似于<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/">这篇文章</a>中使用的小工具，调用OS::SetPermissions，将BiquadDSPKernel中的AudioDoubleArray的页面权限覆盖为rwx。一旦完成，就可以在这些AudioDoubleArray中放置shell代码，并再次触发这个bug来运行任意代码。在实际的漏洞中，一个延迟节点被用作免费的AudioHandler，IIRFilterNode的前馈系数被用来伪造DelayHandler。</p>
<p>完整的exp在<a target="_blank" rel="noopener" href="https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/blink/CVE-2020-15972">这里</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们再次看到，复杂的对象清理，加上多线程的微妙性，导致了WebAudio中的漏洞可以作为渲染器RCE来利用。虽然与v8中的漏洞相比，blink中的漏洞一般需要更多的时间来利用，但它仍然是Chrome中获得（沙盒）RCE的一个巨大而可行的攻击面。</p>
<p>就整个系列而言，我们还看到了沙盒架构，加上Chrome浏览器中漏洞的快速修复，确实有助于使其难以获得完整的链（并确保完整的链即使进入野外也不会持续太久）。本系列中使用的渲染器漏洞从首次报告到修复大约需要六周时间，而沙盒逃逸也需要类似的时间来修复，这对Chrome来说是相当标准的。这大大降低了渲染器漏洞与沙盒逃逸重叠的可能性。正如我们在这一系列案例中看到的那样，由于这种快速修复漏洞的方式，在稳定版本的Chrome浏览器中，渲染器漏洞并没有与沙盒逃逸重叠在一起。正是修复漏洞的效率使沙箱变得更加有效。另一方面，我们也从沙盒逃逸的帖子中看到了每次启动一次的ASLR（即从Zygote分叉的进程）如何大大降低了安卓系统中应用沙盒的有效性。虽然Chrome的基本地址在渲染器和浏览器之间仍然是随机的，但许多其他库不是，我仍然能够使用这些库中的小工具，不费吹灰之力就逃出Chrome的沙箱。虽然每次启动一次的ASLR对于缓解远程攻击仍然非常有用，但正如我们在这篇文章中所看到的，编写漏洞的大部分精力都花在了击败ASLR上，它对于本地权限升级没有什么用处。由于两个主要平台（Windows和Android）都实施了每次启动一次的ASLR，这仍然是Chrome沙箱的最大弱点之一。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-28T14:18:21.000Z" title="2021/11/28 22:18:21">2021-11-28</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-09T13:12:30.587Z" title="2021/12/9 21:12:30">2021-12-09</time></span><span class="level-item">a minute read (About 125 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/28/AFL-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E6%8A%80%E6%9C%AF%E7%BB%86%E8%8A%82/">AFL++ 阅读笔记 - 技术细节</a></p><div class="content"><h1 id="代码覆盖率统计"><a href="#代码覆盖率统计" class="headerlink" title="代码覆盖率统计"></a>代码覆盖率统计</h1><p>插桩指令的功能是检测边缘覆盖率和分支命中计数，插桩指令等价于下面的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cur_location = &lt;COMPILE_TIME_RANDOM&gt;;</span><br><span class="line">shared_mem[cur_location ^ prev_location]++; </span><br><span class="line">prev_location = cur_location &gt;&gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>cur_location的值是随机生成的，shared_mem数组是一个64KB的SHM内存区域，数组中的每一个字节表示是否命中对应的( <code>branch_src</code>, <code>branch_dst</code>) 元组。最后一行的右移是为了使元组具有方向性。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-27T15:32:38.000Z" title="2021/11/27 23:32:38">2021-11-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-28T14:16:39.191Z" title="2021/11/28 22:16:39">2021-11-28</time></span><span class="level-item">22 minutes read (About 3350 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/27/AFL-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">AFL++ 阅读笔记</a></p><div class="content"><h1 id="afl-fuzz的环境变量"><a href="#afl-fuzz的环境变量" class="headerlink" title="afl-fuzz的环境变量"></a>afl-fuzz的环境变量</h1><ul>
<li>AFL_SKIP_CPUFREQ：跳过 CPU 扩展策略的检查（不知道是什么），看介绍是指在无法更改系统设置的情况下（如，不是root，没有权限更改），可以跳过检查。</li>
<li>AFL_EXIT_WHEN_DONE：模糊测试有一段时间没有更新了，停止fuzz，UI 中的循环计数器将变为绿色。</li>
<li>AFL_EXIT_ON_TIME：指定时间内（以秒为单位）没有新路径，停止fuzz。</li>
<li>AFL_EXIT_ON_SEED_ISSUES：恢复初始afl-fuzz行为，不允许-i种子中有crash或timeout种子。</li>
<li>AFL_MAP_SIZE：设置 afl-fuzz、afl-showmap、afl-tmin 和 afl-analyze 创建的共享内存的大小，以从目标收集检测数据。必须大于等于编译目标的大小。（这么大？？？）</li>
<li>AFL_CMPLOG_ONLY_NEW：只为新发现的测试用例执行昂贵的<em><strong>cmplog功能</strong></em>，而不是为启动时加载的测试用例 ( <code>-i in</code>) 执行。这是恢复fuzz会话时要设置的重要功能。</li>
<li>AFL_TESTCACHE_SIZE：修改config.h中<code>#define TESTCASE_CACHE</code> 的大小。推荐值为 50-250MB - 如果模糊测试发现了大量输入的路径，则建议使用更多。</li>
<li>AFL_DISABLE_TRIM：禁止afl-fuzz修剪测试用例，不推荐。</li>
<li>AFL_NO_AFFINITY：禁止尝试绑定Linux系统上的特定CPU内核，会减慢速度，但是能运行更多的测试用例。</li>
<li>AFL_TRY_AFFINITY：尝试绑定到 Linux 系统上的特定 CPU 内核，如果失败并不会终止。</li>
<li>AFL_NO_AUTODICT：不会加载编译到目标中的 LTO 生成的自动字典。</li>
<li>AFL_HANG_TMOUT：通过指定不同的超时时间来决定特定测试用例是否“挂起”。默认为1秒或<code>-t</code>参数的值，以较大者为准。如果非常关心缓慢的输入，或者如果不希望 AFL++ 花费太多时间对这些东西进行分类，而只是快速地将所有超时放入该 bin 中，则将值调低可能会很有用。</li>
<li>AFL_FORKSRV_INIT_TMOUT：允许你指定一个不同的超时时间来等待forkserver的启动。默认值是 <code>config.h</code> 中 <code>FORK_WAIT_MULT</code> 的 -t 值（通常是 10），所以对于<code> -t 100</code>，默认会等待 1000 毫秒。如果目标有非常慢的启动时间，例如在进行全系统模糊测试或仿真时，在这里设置不同的时间是很有用的。</li>
<li>AFL_NO_ARITH： AFL++ 跳过大多数确定性算术。这对于加速基于文本的文件格式的模糊测试很有用。</li>
<li>AFL_NO_SNAPSHOT：如果加载了快照 lkm，将建议 afl-fuzz 不要使用<em><strong>快照功能</strong></em>。</li>
<li>AFL_SHUFFLE_QUEUE：在启动时随机重新排序输入队列。什么用？</li>
<li>AFL_TMPDIR：是用来写.cur_input文件的，如果存在的话，则写在正常的输出目录中。你可以用它来指向ramdisk&#x2F;tmpfs。这可以使速度提高一点，同时也减少了对SSD的压力。</li>
<li>AFL_SKIP_BIN_CHECK：当在使用自定义的插桩方法时，你可以使用 AFL_SKIP_BIN_CHECK 阻止对非插桩的二进制文件和 shell 脚本的检查；以及 AFL_DUMB_FORKSRV 结合 -n 设置，指示 afl-fuzz 仍然遵循 fork 服务器协议而不期望任何插桩数据返回。注意，这也关闭了自动地图大小检测。</li>
<li>AFL_IMPORT_FIRST：当在-M或-S模式下运行时，设置AFL_IMPORT_FIRST会使fuzzer在做其他事情之前从其他实例导入测试案例。这使得用户界面中的 “own finds”计数器更加准确。除了计数器的美观，其他方面不应该有太大变化。</li>
<li>AFL_KILL_SIGNAL：设置超时时要传递给子进程的信号ID。除非是自己实现了目标或插桩，否则不需要设置它。默认情况下，在超时和退出时，SIGKILL（AFL_KILL_SIGNAL&#x3D;9）将被传递给子进程。</li>
<li>AFL_CUSTOM_MUTATOR_LIBRARY：设置为 afl_custom_fuzz() 的共享库，通过这个库创造额外的突变。如果 afl-fuzz 是用 Python 编译的（在构建 afl-fuzz 时会自动检测），将 AFL_PYTHON_MODULE 设置为一个 Python 模块也可以提供额外的突变。如果 AFL_CUSTOM_MUTATOR_ONLY 也被设置，所有的突变将只由自定义突变器执行。这个功能允许配置自定义突变器，例如对XML或其他高度灵活的结构化输入进行模糊处理。详见 <a target="_blank" rel="noopener" href="https://aflplus.plus/docs/env_variables/custom_mutators.md">custom_mutators.md</a>。</li>
<li>AFL_FAST_CAL：保持<em>校准阶段</em>大约2.5倍的速度（尽管不那么精确），这在开始对一个慢速目标的训练时可以起到帮助。AFL_CAL_FAST有同样的效果。</li>
<li>AFL_NO_CPU_RED：避免CPU红色警报。</li>
<li>AFL_PATH：在 QEMU 模式 (-Q) 和 Frida 模式 (-O)，AFL_PATH 将被搜索到 afl-qemu-trace 和 afl-frida-trace.so。</li>
<li>AFL_QEMU_CUSTOM_BIN：在 QEMU 模式（-Q），设置 AFL_QEMU_CUSTOM_BIN 会使 afl-fuzz 跳过预置 afl-qemu-trace 到你的命令行。如果你想使用一个自定义的 afl-qemu-trace 或需要修改 afl-qemu-trace 参数，请使用此选项。</li>
<li>AFL_CYCLE_SCHEDULES：每当一个周期结束，就会切换到不同的调度。</li>
<li>AFL_EXPAND_HAVOC_NOW：afl-fuzz在认为有用的情况下，会自动启用这个模式，包括昂贵的突变。</li>
<li>AFL_PRELOAD：导致 AFL++ 为目标二进制文件设置 LD_PRELOAD 而不中断 afl-fuzz 进程本身。除其他外，这对引导 libdislocator.so 是有用的。</li>
<li>AFL_TARGET_ENV：AFL++为目标二进制文件设置额外的环境变量。</li>
<li>AFL_NO_UI：取消用户界面，定期打印一些基本的统计数据。当 afl-fuzz 的输出被重定向到一个文件或管道时，这种行为也会自动触发。</li>
<li>AFL_NO_COLOR&#x2F;AFL_NO_COLOUR：当配置为 USE_COLOR 而不是 ALWAYS_COLORED 时，将省略控制台输出的着色控制序列。</li>
<li>AFL_FORCE_UI：强制在屏幕上绘制用户界面，即使没有检测到有效的终端（对于虚拟控制台）。</li>
<li>AFL_PERSISTENT_RECORD：如果你使用<em><strong>持久模式</strong></em>，一些目标会保持固有的状态，由于检测到的崩溃测试案例不会在测试案例给出时再次崩溃。为了能够重新触发这些崩溃，你可以使用AFL_PERSISTENT_RECORD变量，该变量的值是在崩溃前保留多少个先前的模糊测试案例。如果设置为例如10，那么先前的9个输入将作为RECORD:0000,cnt:0000到RECORD:0000,cnt:000008被写入out&#x2F;default&#x2F;rashes。注意：这个选项需要先在config.h中启用!</li>
<li>AFL_IGNORE_PROBLEMS：afl-fuzz 在摸索过程中遇到不正确的摸索设置（不是在启动时），它将终止。设置此选项将阻止afl-fuzz终止。</li>
<li>AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES：如果是Jakub（python-afl），可能需要设置此选项。此外，如果想禁用&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern检查，也可以设置此选项。</li>
<li>AFL_BENCH_JUST_ONE：仅限基准测试，fuzzer在处理第一个队列条目后退出。</li>
<li>AFL_BENCH_UNTIL_CRASH：仅限基准测试，fuzzer发现第一个崩溃后退出。</li>
<li>AFL_DEBUG_CHILD：将不会阻止子代的输出。这可以看到子系统的所有输出，使设置问题变得可见。例如，在unicornafl线束中，你可能会看到python的堆栈跟踪。你也可以通过这种方式看到其他日志，说明为什么forkerver不能启动。对于调试来说是很好的，需要注意的是，AFL_DEBUG_CHILD_OUTPUT已被废弃。</li>
<li>AFL_AUTORESUME：将恢复一个现有out文件夹的模糊测试（与提供-i -相同），即使提供了不同的-i。如果没有这个设置，afl-fuzz 将会拒绝执行一个long-fuzz的 out 目录。</li>
<li>AFL_MAX_DET_EXRAS：将改变 -x 词典和 LTO autodict（合并）中的元素数量的阈值，概率模式将启动。在概率模式下，并不是所有的字典条目都会被用于模糊突变，以避免减缓模糊突变的速度。默认计数为200个元素。因此，对于200+1个元素，有1&#x2F;201的机会，其中一个字典条目不会被直接使用。</li>
<li>AFL_NO_FORKSRV：禁用forkerver优化，对每一个被测试的输入恢复到fork + execve()调用。这在处理“不守规矩”的库时非常有用，这些库在初始化时创建线程或做其他疯狂的事情（在插桩指令有机会运行之前）。</li>
<li>AFL_STATSD：启用StatsD指标收集。默认情况下，AFL++将通过UDP发送这些指标到127.0.0.1:8125。主机和端口可以分别用AFL_STATSD_HOST和AFL_STATSD_PORT配置。要启用标签（banner和afl_version），你应该提供与你的StatsD服务器匹配的AFL_STATSD_TAGS_FLAVOR（见AFL_STATSD_TAGS_FLAVOR）。</li>
<li>AFL_STATSD_TAGS_FLAVOR：将AFL_STATSD_TAGS_FLAVOR设置为dogstatsd、librato、signalfx或influxdb中的一个，允许你为你的模糊测试实例添加标签。这在运行多个实例时特别有用（例如，-M&#x2F;-S）。应用的标签是banner和afl_version。banner对应于通过-M&#x2F;-S提供的fuzzer的名字。afl_version对应于当前运行的AFL版本（例如++3.0c）。默认（空&#x2F;不存在）将不给指标添加任何标签。更多信息见rpc_statsd.md。</li>
<li>AFL_CRASH_EXITCODE：设置AFL将退出代码视为崩溃。例如，如果设置了AFL_CRASH_EXITCODE&#x3D;’-1’，每一个导致-1返回代码的输入（即exit(-1)被调用），将被视为发生了崩溃的情况。</li>
</ul>
<h1 id="afl-的power-schedule"><a href="#afl-的power-schedule" class="headerlink" title="afl++的power schedule"></a>afl++的power schedule</h1><p>由于大多数的输入会触发同样的路径，导致某些路径被触发的频率较高，因此AFL++设计了几种搜索策略，以决定以何种顺序对种子进行模糊测试，以及巧妙地调节从种子生成的输入数量（即，对种子进行模糊测试所花费的时间）的<strong>power schedule</strong>。我们将种子产生的输入数量称为种子<strong>能量</strong>。</p>
<p>实现上，修改了种子性能得分 ( <code>calculate_score</code>)的计算，哪个种子被标记为最喜欢的 ( <code>update_bitmap_score</code>)，以及接下来从循环队列中选择哪个种子 ( <code>main</code>)。</p>
<p>实施的调度表（按效果顺序，最好在前）：</p>
<ul>
<li><code>-p explore</code></li>
</ul>
<p><img src="http://latex.codecogs.com/gif.latex?p(i)=%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D"></p>
<ul>
<li><code>-p fast</code> （默认）</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://latex.codecogs.com/gif.latex?p(i)=%5Cmin%5Cleft(%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D%5Ccdot%5Cfrac%7B2%5E%7Bs(i)%7D%7D%7Bf(i)%7D,M%5Cright">http://latex.codecogs.com/gif.latex?p(i)=%5Cmin%5Cleft(%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D%5Ccdot%5Cfrac%7B2%5E%7Bs(i)%7D%7D%7Bf(i)%7D,M%5Cright</a>)</p>
<ul>
<li><code>-p coe</code></li>
</ul>
<p><img src="http://latex.codecogs.com/gif.latex?p(i)=%5Cbegin%7Bcases%7D%200%20&%20%5Ctext%7B%20if%20%7D%20f(i)%20%3E%20%5Cmu%5C%5C%20%5Cmin%5Cleft(%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D%5Ccdot%202%5E%7Bs(i)%7D,%20M%5Cright)%20&%20%5Ctext%7B%20otherwise.%7D%20%5Cend%7Bcases%7D"></p>
<ul>
<li><code>-p quad</code></li>
</ul>
<p><img src="http://latex.codecogs.com/gif.latex?p(i)%20=%20%5Cmin%5Cleft(%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D%5Ccdot%5Cfrac%7Bs(i)%5E2%7D%7Bf(i)%7D,M%5Cright)"></p>
<ul>
<li><code>-p lin</code></li>
</ul>
<p><img src="http://latex.codecogs.com/gif.latex?p(i)%20=%20%5Cmin%5Cleft(%5Cfrac%7B%5Calpha(i)%7D%7B%5Cbeta%7D%5Ccdot%5Cfrac%7Bs(i)%7D%7Bf(i)%7D,M%5Cright)"></p>
<ul>
<li><code>-p exploit</code> (AFL)</li>
</ul>
<p><img src="http://latex.codecogs.com/gif.latex?p(i)%20=%20%5Calpha(i)"></p>
<ul>
<li><code>-p mmopt</code></li>
</ul>
<p>实验性：<code>explore</code>对运行时没有权重，并增加了最后 5 个队列条目的权重。</p>
<ul>
<li><code>-p rare</code></li>
</ul>
<p>实验性：<code>rare</code>将重点放在命中稀有边缘的队列条目上。</p>
<ul>
<li><code>-p seek</code></li>
</ul>
<p>实验性：<code>seek</code>是 EXPLORE 但忽略队列输入的运行时间，较少关注大小。</p>
<p>更多信息在<a target="_blank" rel="noopener" href="https://www.sigsac.org/ccs/CCS2016/accepted-papers/">23rd ACM Conference on Computer and Communications Security (CCS’16)</a>。</p>
<p>其中<em>α(i)<em>是 AFL 用于计算种子输入</em>i</em>的性能分数，<em>β(i)&gt;1</em>是一个常数，<em>s(i)<em>是从队列中选择种子</em>i</em>的次数，<em>f (i)<em>是执行与种子</em>i</em>相同路径的生成输入的数量，<em>μ</em>是执行路径的生成输入的平均数量。</p>
<p>在并行模式下（多个实例共享队列），建议使用exploit时间表（-p exploit）来运行主节点，用cut-exponential（-p coe）、exponential（-p fast；默认）和explore（-p explore）调度的组合来运行从节点。在单一模式下，默认设置就可以了。</p>
<p>在并行模式下，AFLFast似乎表现不佳，因为导入的种子的路径概率估计不正确。希望通过在不同实例间同步估算来解决这个问题。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-11-27T10:58:56.000Z" title="2021/11/27 18:58:56">2021-11-27</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-11-27T13:14:42.803Z" title="2021/11/27 21:14:42">2021-11-27</time></span><span class="level-item">2 minutes read (About 363 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/11/27/OnePlus-Nord-2%E6%BC%8F%E6%B4%9E-root-shell/">OnePlus Nord 2漏洞 - root shell</a></p><div class="content"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在手机生产时，厂商需要开启包括root访问权限在内的各种调试功能，在手机上线时关闭这些功能。</p>
<p>但OnePlus Nord 2的官方<a target="_blank" rel="noopener" href="https://www.xda-developers.com/tag/oxygenos/">OxygenOS</a>版本忘记关闭root功能了，这样就导致可以在OnePlus Nord 2的recovery环境获取到一个<strong>root shell</strong>。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>1.重启OnePlus Nord 2至recovery模式（也可以不进，因为漏洞出现在恢复模式之前）：同时按下音量和电源按钮，直到在屏幕左下角看到一个小小的“恢复模式”；</p>
<p>2.连接adb；</p>
<p>3.执行<code>adb root</code>命令，可能会超时，但adbd会以root身份运行；</p>
<p>4.执行<code>adb shell whoami</code>可以看到输出为root。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>1.取证，转储设备的每个分区。</p>
<p>2.上传可执行文件到<code>/data/local/tmp</code>并运行，加载执行其他漏洞利用。</p>
<p>3.以root身份调用setprop修改prop值，劫持特权OEM变量。</p>
<p>由于即使没有解锁开发者选项，在恢复模式或正常android中连接usb，也会提示usb调试访问请求，因此这个漏洞不仅仅局限于恢复模式。</p>
<h1 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h1><p>截至2021年11月26日，<a target="_blank" rel="noopener" href="https://www.xda-developers.com/oneplus-nord-2-oxygenos-november-2021-patches/">印度与欧洲的OxygenOS</a>都存在，可能还会影响部分后续固件。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-08-23T00:36:43.000Z" title="2021/8/23 08:36:43">2021-08-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-03-27T09:20:14.894Z" title="2022/3/27 17:20:14">2022-03-27</time></span><span class="level-item">32 minutes read (About 4777 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/23/11%20The%20Message%20is%20the%20Medium-Mach%20IPC(the%20user%20mode%20view)/">The Message is the Medium-Mach IPC(the user mode view)</a></p><div class="content"><h1 id="本章概览"><a href="#本章概览" class="headerlink" title="本章概览"></a>本章概览</h1><ul>
<li>A little history</li>
<li>Ma-xioms</li>
<li>Scenarios</li>
<li>Mach Port APIs</li>
<li>Message format</li>
<li>Sending and receiving message</li>
<li>The Mach Interface Generator</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>XNU有两个特性：一是，POSIX&#x2F;BSD，以及增加的syscall和功能，它是Mach的隐藏特性，但是，它驱动着大量的内核功能，包括下层的BSD层。其主要责任是传递信息。Mach IPC是有史以来开发的最快的IPC机制之一，也是三巨头中最快的。尽管XNU也支持经典的UNIX socket模型，在不考虑便携性的情况下，Mach被广泛地使用。</p>
<p>尽管它们十分重要，但Mach消息API通常被Apple轻视，Apple更愿意去提升高层次的框架wrapper以及最近的XPC。但是低层次上，是Mach消息通过Mach port传递消息。本章的主要目的是对这个奇幻的世界进行概述，而且这个世界从其他角度来看，是Darwin操作系统的一个独立方面。</p>
<p>本章先从介绍消息机制中十分基础的对象开始：端点(endpoint)或端口(port)。它提出了一套简单的设计选择，这些选择必须被接受为公理原则，信息传递将在此基础上进行。因此，出于这些公理原因，消息机制提出了三种常见的方式，以支持对等实体之间的通信建立。这些方式展示了一些端口提供的API，完整的集合在稍后给出。</p>
<p>在解释清楚端口定义之后，本章将聚焦于消息本身 - 介绍消息结构体和它在用户模式下的处理函数。主要聚焦于Mach接口生成器(Mach Interface Generator, MIG)，即处理器允许消息的快速代码生成。MIG有一个令人愉悦的简单接口，其隐藏了大量的不那么令人愉悦的代码。由于这段代码的本质和普遍性，我们将特别关注怎么理解整段代码 - 以及它在逆向时的产物。</p>
<blockquote>
<p>本章主要关注用户模式下的情况，其中Mach消息仅仅是能工作。这样能避免接触底层内核的实现方式，因为这需要了解错综复杂的内核结构 - 最好是放在Volume II 中进行解释。</p>
</blockquote>
<h2 id="A-little-history"><a href="#A-little-history" class="headerlink" title="A little history"></a>A little history</h2><p>XNU的基础是NeXTSTEP[1]，并且NeXTSTEP基于Mach。Mach微内核在其加入开源软件基金会之前，是Carnegie Mellon大学的一个研究小组在1985年至1994年之间开发的。Mach项目主页至今仍然在线，仍然保持着古老的WWW网页风格。Mach首次提出是在Usenix上。它一直处于学术范围内，并且，它的文档或者编程环境是十分受限的。Mach3内核准则文档是唯一存在的文档，另一本是绝版书。Carnegie Mellon还保留着一份已出版和未出版的Mach论文清单，提供了关于设计的深刻见解。</p>
<blockquote>
<p>[1]NeXTSTEP是由乔布斯在1985年离开苹果后创建的公司，系统基于Mach和BSD。</p>
</blockquote>
<p>作为一个微内核，Mach不得不依赖于消息传递机制。在微内核设计中，组件分散在不同的隔离的地址空间中，所以发送与接收消息是它们之间协作完成工作的唯一办法。Mach-er们开发了一个优雅的消息传递机制，主要强调效率和总体上的速度。在消息传递机制中，微内核主要负责接收消息 - 即一小块内存 - 从一个task，然后执行必需的操作将这块内存移动(共享)到另一个task。</p>
<p>NeXTSTEP严格的遵循了微内核的设计理念，但是仅有微内核不能构成一个系统。FreeBSD 4.3被作为一个高层吸纳进来，提供了类似UNIX&#x2F;POSIX中的进程、线程、信号、文件和套接字。但是在底层，Mach的API保持着可访问性，并允许在内核中单独分离出来，这就是后来的XNU。自此之后，由于XNU的逐步发展，更多的注意力被放在了它的BSD API上，但是Mach始终保持着驱动力。尽管大多数开发者都使用它的API(Apple更喜欢)，但他们的应用程序依然十分依赖于Mach，因为Apple自己的框架和库也是这么做的。</p>
<p>像它设计的效率性一样，这种方式不得不作出一些让步，到目前为止(在Chapter 2中所述的那样)，XNU是一个庞大的内核。但是，如果简单地将它与Linux和Windows庞大的内核归为一类 - 就好比是将苹果与橙子进行比较。在XNU的深处，消息的发送与接收 - 仅依赖于线程，而不是相分离的进程。</p>
<p>Mach依然像30年前那样前卫。Mach消息机制依然是有史以来开发的最快的IPC机制之一。它可以轻易的在用户模式进程、用户和内核、或者在内核中使用。很容易地认为Mach消息机制和其他IPC机制类似，如Linux的domain socket，或者Android的Binder。然而，这样想可能会导致误解。<strong>Mach的IPC设计是基于单向通信的，而不是双向的</strong>。不难思考的是，后者可以由前者模拟出来(通过建立两个单独的通道，一个用于发送，一个用于接收)。然而，这样做的过程比其他机制要复杂得多，并且需要无条件的接受其设计决策。即使如此，随着时间的流逝，决策背后的逻辑开始变得清晰(就像它的一些原始假设一样)。</p>
<blockquote>
<p>如果你是新入门Mach，本文所提出的概念即使不是很奇怪，但也不直观。我们试图去寻找其与UNIX IPC的相识之初 - 但是这两种机制是完全不同的。这需要在阅读的时候要谨慎，并且可能需要对于概念”sink in”进行重新阅读理解。</p>
</blockquote>
<h2 id="Mach-axioms"><a href="#Mach-axioms" class="headerlink" title="Mach-axioms"></a>Mach-axioms</h2><p>Mach消息机制能通过简单的场景进行演示，以观察两个对等实体之间通信所需的步骤。在我们开始之前，我们需要先了解一些创建Mach的设计决策。由于它们深植于Mach架构中(并且，Darwin也是如此)，所以更简单的接受它们的方式是，给出一些公理。</p>
<ul>
<li><p><strong>公理1: Mach允许通过port进行IPC:</strong> Mach IPC最基本的元素是<strong>端口</strong>。端口为IPC提供了一个端点。消息可以被发送给一个端口，或者从端口处进行接收。端口可以轻易的被用户空间和内核空间的任何人创建或销毁。如果这是Mach 端口的唯一细节，则读者可能会认为它只是另一个消息队列的实现，而不予理会，比如Windows或System V的msgsend和friend。但是它远不止这些，这将为我们引出下一条公理。</p>
</li>
<li><p><strong>公理2: 端口只能被端口权限访问:</strong> 端口的用户永远看不到端口本身，但是可以通过一种叫<strong>端口权限</strong>的东西间接进行访问。以下是一些已有的端口权限类型，这里介绍几个基础的：</p>
<ul>
<li><strong>SEND权限:</strong> 允许持有者向底层端口发送消息，但是不从它们那里接收消息。这是一个<strong>只写</strong>能力。它可能被任意数量的线程或task中的持有者所持有。它同样是及物的，因此可以被<strong>拷贝任意次</strong>(通过COPY_SEND)，并传递给其他持有者。</li>
<li><strong>SEND_ONCE:</strong> 和SEND类似，它拥有相同的能力 - 发送但不接收。不同的是，<strong>这个权限只能使用一次</strong> - 使用完后会立即被内核取消 - 想要再次向底层端口发送消息是不可能的(除非它获取到了其他权限)。同时，它<strong>不能被复制，但是可以被移动</strong>。和SEND类似，任意数量的持有者都可以拥有一项SEND_ONCE权限。</li>
<li><strong>RECEIVE:</strong> 允许它的持有者读取被发送到端口的任意消息。它在内部将它的持有者标记为端口的owner - 可以创建任意其他想要的权限。不像其他权限 - 一个端口仅有一个RECEIVE权限，并且端口仅存在于权限拥有者存活时。如果拥有者结束了(或取消分配端口)，所有SEND[ONCE]权限将变成DEAD_NAME。</li>
</ul>
<p>总结端口权限定义，我们给出以下的表格：</p>
<p>表 11- 1: Mach端口权限总结</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>数量</th>
<th>及物</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SEND</td>
<td>0+</td>
<td>MOVE，COPY</td>
<td>可以向端口发送任意数量的消息</td>
</tr>
<tr>
<td>SEND_ONCE</td>
<td>0+</td>
<td>仅MOVE</td>
<td>仅能向端口发送一次消息</td>
</tr>
<tr>
<td>DEAD_NAME</td>
<td>0+</td>
<td>—</td>
<td>SEND_ONCE使用后，或者SEND的接受者died&#x2F;deallocated</td>
</tr>
<tr>
<td>RECEIVE</td>
<td>1</td>
<td>仅MOVE</td>
<td>可以从端口接收消息，或者向端口插入其他权限</td>
</tr>
</tbody></table>
<p>因此，端口权限提供了几乎与其他IPC机制相同的能力 - 但是有一个主要的区别：权限和单向，然而大多数IPC机制是双向的。</p>
</li>
<li><p><strong>公理3: 端口权限可以通过消息进行传递:</strong> 当发送一个消息时，Mach允许发送者在消息中包含0+个端口权限，这是被消息接受者所授予的。这与UNIX的domain socket传递文件描述符的能力相似。</p>
</li>
</ul>
<h2 id="Mach-messaging-scenarios"><a href="#Mach-messaging-scenarios" class="headerlink" title="Mach messaging scenarios"></a>Mach messaging scenarios</h2><p>和几何学与其他科学类似，我们一旦接受了公理，就可以依据它建立更高层次、详细的结构。因此，同样的是Mach的案例。接下来，我们转向去考虑经典的A(lice)和B(ob)场景，将尝试在这两个对等实体之间建立通信。</p>
<h3 id="Scenario-1-Alice-and-Bob"><a href="#Scenario-1-Alice-and-Bob" class="headerlink" title="Scenario 1: Alice and Bob"></a>Scenario 1: Alice and Bob</h3><p>假设，在这一时刻，Alice先验地知道Bob的情况。用Mach的说法，Alice拥有一个端口的发送权限，这个端口的接收权限是被Bob所有。如果我们将这些作为前提条件，接下来的交互将使Alice和Bob之间建立双向通信：</p>
<ol>
<li>Alice创建一个短暂的端口，即一个她拥有接收权限的端口。她通过调用mach_port_allocate()函数实现。(公理 1)</li>
<li>作为新创建端口的所有者，Alice可以创建任意她想要的其他权限。因此，她接下来为端口创建一个SEND权限，通过mach_port_insert_right()函数实现。(公理 2)</li>
<li>Alice现在同时拥有了她新创建的端口的接收和发送权限。这对她有什么好处呢？不多，她可以单方面的发送和接收消息 - 给她自己。这几乎没什么用。但是，回忆一下，端口权限可通过消息进行传递。Alice紧接着创建一个消息给Bob，在消息中放入她的端口的发送权限，然后投递给Bob - 鉴于先验持有对Bob的发送权，我们假定她有。(假设+公理 3)</li>
<li>Bob通过拥有接收权限的端口收到Alice的消息。依据公理3，Bob拥有了Alice端口的SEND权限。现在双方可以进行双向通信。他们可以使用任一已有的端口权限 -  尽管两者都能进一步创建一个短暂的端口(通过Alice所使用的方式)，并赋予其他人发送权限 - 因此建立了另一条单向通信通道(并且，结果是，双向通道)。</li>
</ol>
<p>这个场景可能看上去不是很有效率(尤其是和UNIX的socket进行对比)，但是毫无疑问的是，它得到了自己想要的结果 - Alice和Bob能够自由地进行通信。事实上，不像socket，Alice享有socket不能提供的巨大的好处，即：</p>
<ul>
<li>Alice可能对和Bob之间的持续通信不感兴趣。她可能只需要Bob的一次性帮助，仅此而已。在这种情况下，Alice可以通过检查进程，将SEND权限替换为SEND_ONCE权限即可。<em>Bob仍然可以根据Alice的这个权限进行回复 - 一旦他回复了，他和Alice的连接就将终止。</em>不像socket，Bob不知道Alice的位置在哪，也没有任何形式的地址可以找到她。</li>
<li>Alice可能甚至不想给Bob一个回复的机会。当然，对等实体可以重置连接。但是其他人可以持续进行连接访问，以及重新初始化连接 - 这将导致从小问题变成完全的DoS攻击。Mach的SEND_ONCE权限提供了socket难以模拟的独特的功能。更进一步来说，发送消息但没有回复地址(实际上，是一个匿名消息)的能力是根本不存在的。</li>
</ul>
<hr>
<p>*- 这有点像POSIX的pip(2)系统调用，其创建了两个文件描述符并互相连接。在自己的进程中这样做是无用的，但是当两个文件描述符不在一起的时候，是十分有价值的 - 任意两个线程或进程 - 可以通过它们建立通信。</p>
<p>图 11-2: 第一个Mach消息场景</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/11-2_The first Mach messaging scenario.png" alt="11-2_The first Mach messaging scenario" style="zoom:33%;" />

<p>回顾一下以演示的场景，这里仍然有一个问题需要去考虑。我们先验地假设Alice已经知道了Bob。Alice拥有向Bob的RECEIVE端口SEND的权限。但是，这是一个很难的任务。Alice怎么知道Bob，他们是否以某种方式相互联系？更进一步，如果Alice已经有了一个Bob的SEND权限，并且相应的，Bob也拥有了一个Alice的SEND权限，那么所有这些复杂的交互都是无意义的。</p>
<h3 id="Scenario-2-The-Bootstrap-Server-Registration"><a href="#Scenario-2-The-Bootstrap-Server-Registration" class="headerlink" title="Scenario 2: The Bootstrap Server(Registration)"></a>Scenario 2: The Bootstrap Server(Registration)</h3><p>不存在一个简单的方式能够脱离Alice和Bob的先验性假设。它形成了一个环形的依赖关系，就像鸡和蛋问题，不是轻易能够解决的。相比于直接去击败它，我们可以将它转变为一个公理，将它变成我们的优点。因此有以下公理：</p>
<p><strong>公理4: 存在一个先验的实体，系统上所有的task都拥有对其的SEND权限</strong>。</p>
<p>将这个新的公理付诸实施是一个简单的问题。在对等实体之间无法建立可信联系时，一般会采用一个可信的第三方的方式。一些人喜欢叫这个第三方Trent，另一些人喜欢叫Raymond。而我们将这个实体叫做<strong>bootstrap server</strong>。</p>
<p>现在Alice和Bob的场景将略有不同 - 因为现在不是从Alice开始的，而是从Bob和bootstrap server开始。</p>
<ol>
<li>Bob拥有一个bootstrap server的SEND权限。(公理4)</li>
<li>使用这个权限，Bob能够和bootstrap server建立联系，然后通过简单的场景建立与bootstrap server之间的双向通信。(这是不是必需的，因为Bob可以在建立与server之间的联系之前，先执行下一阶段)</li>
<li>Bob创建一个拥有RECEIVE权限的临时端口。(公理1)</li>
<li>Bob为这个端口创建SEND权限。(公理2)</li>
<li>Bob通过消息将SNED权限发送给bootstrap server(公理3)。这个权限可能会被移动或拷贝(这没有什么问题，因为Bob可以重新创建权限)。</li>
<li>同时在这个消息中，Bob会要求bootstrap server将这个权限与公开的名称相关联起来(如，”com.apple.Bob”)。这被称为bootstrap_register()消息。</li>
</ol>
<p>过了一会儿，Alice出现了：</p>
<ol>
<li>Alice拥有一个bootstrap server的SEND权限。(公理4)</li>
<li>使用这个权限，Alice能够和bootstrap server建立联系，然后通过简单的场景建立与bootstrap server之间的双向通信。</li>
<li>Alice接着向bootstrap server发送一个消息，询问”com.apple.Bob”的位置，或者是其它她想要询问的名字。这被称为一个bootstrap_lookup()消息。</li>
<li>bootstrap server查询是否有人注册了这个名字。如果有(如前所述，Bob注册了)，就意味着，bootstrap server现在可以拷贝SEND权限给那个端口。这将为那个端口创建一个新的SEND权限，并将它传递给Alice。</li>
<li>Alice现在可以和Bob进行对话，按照简单的情况。</li>
</ol>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/11-3_The second messaging scenario.png" alt="11-3_The second messaging scenario" style="zoom: 33%;" />

<p>Bootstrap server对于连接建立来说是一个非常重要的角色，允许对等实体之间定位其他人的位置。用RPC的话来说，这被称为<strong>endpoint mapper</strong> - 接收者可能与SUNRPC的portmap(TCP 111)或Windows臭名昭著的rpcss.exe类似。在Android中，servicemanager进程提供了这个功能，然而那里的底层的传输机制是binder而不是TCP。</p>
<p>通过先验的假设知道所有的bootstrap server解决了在不知晓彼此的对等实体之间建立通信的巨大挑战。尽管这样做的一个明显的缺点是需要更多的信息交换，但在每个server的生命周期中注册消息仅需一次，并且查询消息在会话建立之前也仅需一次 - 所以这个缺点是微不足道的。</p>
<blockquote>
<p>在继续阅读之前，思考一下能否找出bootstrap server的注册消息是否存在其它的安全相关的问题。</p>
</blockquote>
<p>除了缺点之外，使用bootstrap server还是有很多优点的，最重要的是将连接建立集中起来。Bootstrap server可以选择控制连接查询(有益于系统性能)，或者直接拒绝查询特定的client(增强了系统安全性)。但是没有比bootstrap server提供的第二个方法 - Check in - 更大的优点了。</p>
<h3 id="Scenario-3-The-Bootstrap-Server-Check-in"><a href="#Scenario-3-The-Bootstrap-Server-Check-in" class="headerlink" title="Scenario 3: The Bootstrap Server(Check-in)"></a>Scenario 3: The Bootstrap Server(Check-in)</h3></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/5/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/7/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link is-current" href="/page/6/">6</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>