<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言最近RET2放出了Pwn2Own 2021上的不少好东西，先是Parallels Desktop的一个沙箱逃逸，然后就是这个macOS的RCE+EOP，都给了完整的利用代码，这不看一下实在是说不过去。 先上一下原文链接：https:&#x2F;&#x2F;blog.ret2.io&#x2F;2022&#x2F;06&#x2F;29&#x2F;pwn2own-2021-safari-sandbox-intel-graphics-exploit&#x2F;。 文章说">
<meta property="og:type" content="article">
<meta property="og:title" content="macOS Intel图形内核拓展RCE+EOP">
<meta property="og:url" content="https://buffer0verflooow.github.io/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:description" content="前言最近RET2放出了Pwn2Own 2021上的不少好东西，先是Parallels Desktop的一个沙箱逃逸，然后就是这个macOS的RCE+EOP，都给了完整的利用代码，这不看一下实在是说不过去。 先上一下原文链接：https:&#x2F;&#x2F;blog.ret2.io&#x2F;2022&#x2F;06&#x2F;29&#x2F;pwn2own-2021-safari-sandbox-intel-graphics-exploit&#x2F;。 文章说">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_iokit_diagram.png">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_sideband_format.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_footprint_before.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_footprint_after.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_leak_target_before.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_leak_target_after.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_fake_port_misalignment.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_kmsg_increment.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_osdata_leak.svg">
<meta property="og:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_osarray_corruption.svg">
<meta property="article:published_time" content="2022-07-01T13:59:36.000Z">
<meta property="article:modified_time" content="2022-07-03T12:49:17.408Z">
<meta property="article:author" content="buffer0verflooow">
<meta property="article:tag" content="macos">
<meta property="article:tag" content="intel">
<meta property="article:tag" content="safari">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://buffer0verflooow.github.io/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_iokit_diagram.png">


<link rel="canonical" href="https://buffer0verflooow.github.io/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://buffer0verflooow.github.io/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/","path":"2022/07/01/macOS-Intel图形内核拓展RCE-EOP/","title":"macOS Intel图形内核拓展RCE+EOP"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>macOS Intel图形内核拓展RCE+EOP | buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">buffer0verflooow - Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IOKit-%E5%9B%BE%E5%BD%A2%E5%8A%A0%E9%80%9F%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">IOKit 图形加速概述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#IntelAccelerator-IOAccelerator"><span class="nav-number">3.</span> <span class="nav-text">IntelAccelerator&#x2F;IOAccelerator</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Inspecting-a-User-Client"><span class="nav-number">4.</span> <span class="nav-text">Inspecting a User Client</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Sideband-Buffers"><span class="nav-number">5.</span> <span class="nav-text">Sideband Buffers</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Out-Of-Bounds-Write-in-VPHAL-Handler"><span class="nav-number">6.</span> <span class="nav-text">Out-Of-Bounds Write in VPHAL Handler</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Resource-Buffer-Allocation"><span class="nav-number">7.</span> <span class="nav-text">Resource Buffer Allocation</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Ensuring-Reliable-Allocation-Placement"><span class="nav-number">8.</span> <span class="nav-text">Ensuring Reliable Allocation Placement</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Identifying-Viable-Corruption-Targets-Victim-Objects"><span class="nav-number">9.</span> <span class="nav-text">Identifying Viable Corruption Targets &#x2F; Victim Objects</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Corpse-Footprints"><span class="nav-number">10.</span> <span class="nav-text">Corpse Footprints</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Wired-Kernel-Allocations"><span class="nav-number">11.</span> <span class="nav-text">Wired Kernel Allocations</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Initial-Kernel-Information-Leaks"><span class="nav-number">12.</span> <span class="nav-text">Initial Kernel Information Leaks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Circumventing-zone-id-require-with-a-Misaligned-Port"><span class="nav-number">13.</span> <span class="nav-text">Circumventing zone_id_require with a Misaligned Port</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Pseudo-arbitrary-Kernel-Memory-Read"><span class="nav-number">14.</span> <span class="nav-text">Pseudo-arbitrary Kernel Memory Read</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%951"><span class="nav-number">14.1.</span> <span class="nav-text">方法1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%952"><span class="nav-number">14.2.</span> <span class="nav-text">方法2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Arbitrary-Function-Call-Primitive"><span class="nav-number">15.</span> <span class="nav-text">Arbitrary Function Call Primitive</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Kernel-Shellcode-Execution"><span class="nav-number">16.</span> <span class="nav-text">Kernel Shellcode Execution</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">17.</span> <span class="nav-text">总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%A4%8D%E7%8E%B0%E6%83%85%E5%86%B5"><span class="nav-number">18.</span> <span class="nav-text">复现情况</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="macOS Intel图形内核拓展RCE+EOP | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          macOS Intel图形内核拓展RCE+EOP
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-01 21:59:36" itemprop="dateCreated datePublished" datetime="2022-07-01T21:59:36+08:00">2022-07-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-07-03 20:49:17" itemprop="dateModified" datetime="2022-07-03T20:49:17+08:00">2022-07-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近RET2放出了<a target="_blank" rel="noopener" href="https://www.zerodayinitiative.com/blog/2021/4/2/pwn2own-2021-schedule-and-live-results">Pwn2Own 2021</a>上的不少好东西，先是<a target="_blank" rel="noopener" href="https://www.parallels.com/">Parallels Desktop</a>的一个沙箱逃逸，然后就是这个macOS的RCE+EOP，都给了完整的利用代码，这不看一下实在是说不过去。</p>
<p>先上一下原文链接：<a target="_blank" rel="noopener" href="https://blog.ret2.io/2022/06/29/pwn2own-2021-safari-sandbox-intel-graphics-exploit/%E3%80%82">https://blog.ret2.io/2022/06/29/pwn2own-2021-safari-sandbox-intel-graphics-exploit/。</a></p>
<p>文章说“与英特尔图形相关的 CVE 在 Apple 的安全更新列表中变得越来越普遍”，依据之前看的Apple每月的安全更新来说，确实是这样，看来不管是什么系统，驱动都是很容易出问题的。</p>
<h1 id="IOKit-图形加速概述"><a href="#IOKit-图形加速概述" class="headerlink" title="IOKit 图形加速概述"></a>IOKit 图形加速概述</h1><p>与漏洞有关的两个内核驱动程序是：</p>
<ul>
<li><code>IOAcceleratorFamily2</code>：通用平台无关代码和类，例如<code>IOAccelContext2</code></li>
<li><code>AppleIntel*Graphics</code>：特定于硬件的代码和子类，例如<code>IGAccelGLContext</code></li>
</ul>
<p>加载的特定于硬件的内核拓展依赖于CPU代数：</p>
<ul>
<li><code>AppleIntelICLGraphics</code> 用于最新的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Ice_Lake_(microprocessor)">Ice Lake</a> 硬件</li>
<li><code>AppleIntelKBLGraphics</code> 用于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Kaby_Lake">Kaby Lake</a>&#x2F;<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Coffee_Lake">Coffee Lake</a></li>
<li><code>AppleIntelSKLGraphics</code> 用于 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Skylake_(microarchitecture)">Skylake</a></li>
<li>……更老的东西</li>
</ul>
<p>这些驱动程序通过IOKIT向用户空间开放功能，一般来讲，驱动程序实现了3个部分：</p>
<ul>
<li>服务</li>
<li>用户客户端</li>
<li>外部方法</li>
</ul>
<p>想要与驱动通信的用户空间程序需要先获得这个服务的一个端口，驱动程序随后通过一个数字ID标识一个特定的用户客户端，然后就可以通过用户客户端调用外部方法，通过数字ID选择方法，根据需要传入标量和或二进制blob参数，外部方法可以认为是对内核驱动的RPC调用。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_iokit_diagram.png" alt="p2o_2021_eop_iokit_diagram"></p>
<p>与用户客户端交互的另一种常见方式是通过共享内存（在用户空间和内核之间）。</p>
<h1 id="IntelAccelerator-IOAccelerator"><a href="#IntelAccelerator-IOAccelerator" class="headerlink" title="IntelAccelerator&#x2F;IOAccelerator"></a>IntelAccelerator&#x2F;IOAccelerator</h1><p>在基于Intel的Mac上，图形加速服务的名称为<code>IntelAccelerator</code>，或者是<code>IOAccelerator</code>，渲染器&#x2F;<code>WebContent</code>沙盒明确<a target="_blank" rel="noopener" href="https://github.com/WebKit/WebKit/blob/4445bdf30face773b63e3effc38f7691896e0ddb/Source/WebKit/WebProcess/com.apple.WebProcess.sb.in#L318">允许打开</a>这个服务，尽管<a target="_blank" rel="noopener" href="https://github.com/WebKit/WebKit/blob/4445bdf30face773b63e3effc38f7691896e0ddb/Source/WebKit/WebProcess/com.apple.WebProcess.sb.in#L123">有一些代码</a>用于限制允许的用户客户端和外部方法。虽然Safari有一个单独的GPU进程，但<code>IOAccelerator</code>可以被<code>WebContent</code>沙盒配置文件所允许（截至编写时）。</p>
<p>为了了解<code>IOAccelerator</code>的可用攻击面，需要通过逆向工程来列举该服务的用户客户端，寻找一个重载的<code>newUserClient</code>函数。这个函数将在用户空间调用<code>IOServiceOpen</code>时被调用。</p>
<p><code>AppleIntelICLGraphics</code>没有实现<code>IntelAccelerator::newUserClient</code>，所以要看一下<code>IOAcceleratorFamily2</code>中实现的超类。在那里找到了 <code>IOGraphicsAccelerator2::newUserClient</code>，它包含了对输入<code>ID</code>的切换案例，给了一个可以创建的用户客户端的集合（每个都实现为一个C++类）。</p>
<p>可以为感兴趣的每个用户客户端寻找外部方法。查找每个类重写的以下函数之一：</p>
<ul>
<li><code>externalMethod</code></li>
<li><code>getTargetAndMethodForIndex</code></li>
<li><code>getAsyncTargetAndMethodForIndex</code></li>
</ul>
<p>这些函数中的每一个都会接受一个数字选择器来识别外部方法，并且会直接调用实现，或者返回一个包含相关信息的结构（例如，一个函数指针和参数类型&#x2F;数量）。最终调用这些内核函数的相应的用户空间API是<code>IOConnectCallMethod</code>系列函数。</p>
<p>还有一些陷阱函数，可以使用<code>IOConnectTrap</code>函数之一来调用。其各自被重写的内核函数是<code>getTargetAndTrapForIndex</code>和<code>getExternalTrapForIndex</code>。</p>
<p>一些用户客户端还提供了将共享内存映射到用户空间的<code>IOConnectMapMemory</code>。这些用户客户端覆盖了<code>clientMemoryForType</code>的内核函数。</p>
<h1 id="Inspecting-a-User-Client"><a href="#Inspecting-a-User-Client" class="headerlink" title="Inspecting a User Client"></a>Inspecting a User Client</h1><p>以<code>IntelAccelerator</code>服务的类型为6的用户客户端 <code>IGAccelSharedUserClient</code>（继承自 <code>IOAccelSharedUserClient2</code>）为例，查看外部方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOExternalMethod* IOAccelSharedUserClient2::getTargetAndMethodForIndex(..., unsigned int index) &#123;</span><br><span class="line">  if ( index &lt; 20 )</span><br><span class="line">    return &amp;IOAccelSharedUserClient2::sSharedMethods[index];</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到在<code>data</code>区有一个外部方法的静态数组，这是常见的模式。</p>
<p> <code>IGAccelSharedUserClient</code>是一个用于排序以及创建多种供其他用户客户端使用的对象的一个帮助程序，一些外部方法如 <code>new_resource</code>， <code>create_shmem</code>， <code>allocate_fence_memory</code> 和 <code>set_resource_purgeable</code>。 创建的对象的 “命名空间 “可以通过用<code>IOConnectAddClient</code>连接另一个用户客户端以进行共享。</p>
<p><code>Resources</code> (也叫<code>textures</code>)，是由 <code>IGAccelResource</code>类表示的，这个类对利用来讲很有用，外部方法 <code>new_resource</code>创建一个用户指定属性的<code>resources</code> ，并将资源ID返回到用户空间，它还会将资源的后备缓冲区（用户指定大小）备份映射到进程地址空间中。</p>
<h1 id="Sideband-Buffers"><a href="#Sideband-Buffers" class="headerlink" title="Sideband Buffers"></a>Sideband Buffers</h1><p>有一些继承自 <code>IOAccelContext2</code>的用户客户端，这些<code>content</code>对象提供了一些类型的共享内存，类型0就是<code>Sideband Buffers</code>。</p>
<p><code>Sideband Buffers</code>可以通过外部方法2 （<code>IOAccelContext2::submit_data_buffers</code>）进行提交，这最终在<code>IOAccelContext2::processSidebandBuffer</code>中结束，它根据一个简单的二进制格式处理<code>Sideband Buffers</code>中的 “token”。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_sideband_format.svg" alt="p2o_2021_eop_sideband_format"></p>
<ul>
<li><code>token_id</code>，两个字节，一种操作码，将决定<code>Token Body</code>要如何处理；</li>
<li><code>token_size</code>，两个字节，<code>dowrd</code>表示的Token大小，即，一个有空<code>body</code>的<code>token</code>的大小为2.</li>
<li><code>db0_off</code>，表示进入 “数据缓冲区0 “的一个偏移。在这种情况下，数据缓冲区是一种特殊的资源类型（<code>IGAccelResource</code>）。一个操作码为0的令牌可以用来 “绑定 “数据缓冲区0；令牌<code>body</code>将包含需要绑定的资源ID。</li>
</ul>
<p>当迭代<code>Sideband Buffers</code>令牌时，一个辅助结构<code>IOAccelCommandStreamInfo</code>将包含描述命令流和当前令牌状态的某些字段。这为各种令牌处理程序访问公共字段提供了方便。字段<code>db0_ptr</code>，存储了一个进入数据缓冲区0的指针，在<code>db0_off</code>偏移。</p>
<p>函数<code>processSidebandBuffer</code>执行一些基本的边界检查，以确保<code>db0_off</code>和<code>token_size</code>不会太大，然后将<code>token</code>的处理推迟到一个虚拟方法<code>processSidebandToken</code>。</p>
<p>对于大多数的上下文对象来说，各种重载的实现都遵循类似的模式。如果上下文应该处理操作码，它就会传递给该操作码的令牌处理程序，否则它就推迟到超类的 <code>processSidebandToken</code> 函数。所有的令牌处理程序似乎都被统一命名为<code>process_token_*</code>，所以它们相对容易被列举出来。</p>
<h1 id="Out-Of-Bounds-Write-in-VPHAL-Handler"><a href="#Out-Of-Bounds-Write-in-VPHAL-Handler" class="headerlink" title="Out-Of-Bounds Write in VPHAL Handler"></a>Out-Of-Bounds Write in VPHAL Handler</h1><p>其中一个<code>IOAccelContext2</code>子类用户客户端：<code>IGAccelVideoContextMain</code>，有一个处理 <code>VPHAL </code>令牌的程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IGAccelVideoContextMain::process_token_VPHAL</span><span class="params">(</span></span><br><span class="line"><span class="params">        IGAccelVideoContextMain *this,</span></span><br><span class="line"><span class="params">        IOAccelCommandStreamInfo *info)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* cur = info-&gt;sb_cur; <span class="comment">// current token</span></span><br><span class="line">    IGAccelVideoContextMain::patch_vphal_command_buffer(this, info, cur+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">IGAccelVideoContextMain::patch_vphal_command_buffer</span><span class="params">(</span></span><br><span class="line"><span class="params">        IGAccelVideoContextMain *this,</span></span><br><span class="line"><span class="params">        IOAccelCommandStreamInfo *info,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// offset pointer into data buffer 0</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* db0 = info-&gt;db0_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// take a resource id from sb, get its &quot;gpu address&quot;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> gpu_addr;</span><br><span class="line">    this-&gt;bind_resource(this, info, *sb&gt;&gt;<span class="number">16</span>, &amp;gpu_addr, ...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get index from sb</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx = (*sb&gt;&gt;<span class="number">3</span>)&amp;<span class="number">0x7f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bounds check the index against dbuf0 base/length</span></span><br><span class="line">    <span class="keyword">if</span> (&amp;db0[idx+<span class="number">1</span>] &lt;= info-&gt;dbuf0_base + info-&gt;dbuf0_size) &#123; <span class="comment">// &lt;--- [1]</span></span><br><span class="line">        <span class="comment">// write low/high 32 bits</span></span><br><span class="line">        db0[idx] = gpu_addr;</span><br><span class="line">        db0[idx+<span class="number">1</span>] = gpu_addr&gt;&gt;<span class="number">32</span>; <span class="comment">// &lt;--- [2]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[1]处的边界检查是<code>off-by-one</code>。它确保<code>db0[idx]</code>在数据缓冲区0的范围内，然而在[2]处对<code>db0[idx+1]</code>的写入可能是越界的。这就给了我们一个对资源缓冲区后的4个字节的<code>out-of-bounds</code>写原语。</p>
<p>虽然我们只能猜测，但这个bug可能是在GPU地址变成64位而不是32位时引入的，而边界检查并没有更新以匹配。</p>
<p>资源可以用一个父资源和一个64位的偏移量来创建，这将子资源的GPU地址设置为父资源的地址加上偏移量。我们可以通过驱动程序的预期功能发现父资源的GPU地址，这样我们就可以知道偏移的数值。这样我们就可以完全控制写入界外的4个字节。</p>
<h1 id="Resource-Buffer-Allocation"><a href="#Resource-Buffer-Allocation" class="headerlink" title="Resource Buffer Allocation"></a>Resource Buffer Allocation</h1><p>我们的下一个任务是找到一个可以直接放在资源缓冲区后面的破坏目标，它的前4个字节对破坏是 “有用 “的。这将有助于了解资源缓冲区在内核内存中的分配方式和位置，以便我们能够可靠地控制在它周围分配的内容。</p>
<p>从Mach内核的角度来看，虚拟内存是通过<code>vm_map</code>对象的层次结构管理的。顶级地图，<code>kernel_map</code>，包含了整个内核的虚拟内存范围。子地图是在父地图（通常是<code>kernel_map</code>）中保留一个较小的虚拟地址范围。更多的信息可以<a target="_blank" rel="noopener" href="http://newosxbook.com/bonus/democratizingZones.pdf"><code>*OS Internals</code></a>中找到。</p>
<p>这样看，是不是还是应该啃一下<code>*OS Internals</code>这本书呢？</p>
<p>一个资源缓冲区被实现为一个<code>IOBufferMemoryDescriptor</code>，除此之外，还设置了<code>kIOMemoryPageable</code>选项。可分页内存描述符的后备缓冲区来自一组特殊的可分页<code>IOKit</code>分配的子地图，由全局结构<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/iokit/Kernel/IOLib.cpp.auto.html#:~:text=gIOKitPageableSpace"><code>gIOKitPageableSpace</code></a>管理。这个空间最多允许8个地图，每个512MB。</p>
<p>在可分页空间分配的主要入口是<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/iokit/Kernel/IOLib.cpp.auto.html#:~:text=IOIteratePageableMaps"><code>IOIteratePageableMaps</code></a>。这个算法非常简单：从有索引提示的子地图（上次成功分配的地图）开始，向后迭代，直到有地图能够为分配提供服务。如果没有足够的空间，就创建一个全新的512MB子地图。</p>
<h1 id="Ensuring-Reliable-Allocation-Placement"><a href="#Ensuring-Reliable-Allocation-Placement" class="headerlink" title="Ensuring Reliable Allocation Placement"></a>Ensuring Reliable Allocation Placement</h1><p>可分页空间似乎主要用于类似二进制<code>blob</code>的数据，所以我们选择在可分页空间之外的地方作为目标，即把资源缓冲区放在子地图的最末端，而把受害者对象紧随其后。</p>
<p>策略如下：</p>
<ol>
<li>用512MB的资源强制分配一个全新的512MB的子表；<ol>
<li>在正常使用的情况下，系统极不可能在<code>kernel_map</code>中存在一个512MB的空洞，这就有效地保证了我们的资源将被放置在虚拟内存的末端。</li>
</ol>
</li>
<li>将数据缓冲区0放置在新地图的末端<ol>
<li>释放512MB的资源</li>
<li>分配一个填充资源来填充地图的开始，大小为<code>512MB - &lt;dbuf0的大小&gt;</code>。</li>
<li>分配 <code>dbuf0</code></li>
</ol>
</li>
<li>分配受害者对象，为了保证可靠性，受害者对象应该足够大，可以放在虚拟内存的末端（即<code>kernel_map</code>中没有足够大的洞来容纳受害者对象）。</li>
</ol>
<p>现在需要找到一个 “大 “的受害者对象。</p>
<h1 id="Identifying-Viable-Corruption-Targets-Victim-Objects"><a href="#Identifying-Viable-Corruption-Targets-Victim-Objects" class="headerlink" title="Identifying Viable Corruption Targets &#x2F; Victim Objects"></a>Identifying Viable Corruption Targets &#x2F; Victim Objects</h1><p>内核中有几个常见的内存分配函数，例如<code>kernel_memory_allocate</code>和<code>kalloc</code>。<code>kalloc</code>是内核代码中动态分配内存的最常见方法。</p>
<p>对于<code>kalloc</code>来说，<code>0x4000</code>或更小的分配是由<code>zone</code>分配器处理的。<code>0x80000（512KB</code>）或更小的内存会被分配到<code>kalloc_map</code>，一个特殊的子<code>map</code>。更大的则直接从<code>kernel_map</code>分配。如果我们需要，我们可以完全填满<code>kalloc_map</code>，这样进一步的分配就会回到<code>kernel_map</code>。这意味着，如果我们要寻找通过<code>kalloc</code>分配的候选受害对象，我们应该寻找至少能达到<code>0x4001</code>字节的分配。</p>
<p><a target="_blank" rel="noopener" href="https://binary.ninja/">Binary Ninja</a>分析在这里相当有帮助，允许我们用脚本搜索任何对各种分配函数的调用，参数可能足够大。(分析将需要相当长的时间，你可能需要强制分析一些函数以使脚本工作，和&#x2F;或添加<code>__noreturn</code>以使其恐慌)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># if xref&#x27;ing kalloc, the internal kalloc function has no symbol name</span></span><br><span class="line"><span class="comment"># need to get the address manually (tailcalled from kalloc_external)</span></span><br><span class="line">xrefs = bv.get_callers(<span class="number">0xffffff800028c8d0</span>)</span><br><span class="line">minsize = <span class="number">0x4001</span></span><br><span class="line">sites = []</span><br><span class="line">sizes = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ref <span class="keyword">in</span> xrefs:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">repr</span>(ref))</span><br><span class="line">    mlil = ref.function.get_low_level_il_at(ref.address).mlil</span><br><span class="line">    <span class="keyword">if</span> mlil.operation <span class="keyword">not</span> <span class="keyword">in</span> (MLIL_CALL, MLIL_TAILCALL):</span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&quot;bad mlil&quot;</span>)</span><br><span class="line"></span><br><span class="line">    size = mlil.operands[<span class="number">2</span>][<span class="number">1</span>] <span class="comment"># change second index depending on which arg is size</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;size: &quot;</span>+<span class="built_in">repr</span>(size))</span><br><span class="line">    vals = size.possible_values</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> vals.<span class="built_in">type</span> <span class="keyword">in</span> (RegisterValueType.ConstantPointerValue, RegisterValueType.ConstantValue)\</span><br><span class="line">            <span class="keyword">and</span> vals.value &lt; minsize:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> vals.<span class="built_in">type</span> <span class="keyword">in</span> (RegisterValueType.UnsignedRangeValue, RegisterValueType.SignedRangeValue):</span><br><span class="line">        maxx = <span class="built_in">max</span>(r.end <span class="keyword">for</span> r <span class="keyword">in</span> vals.ranges)</span><br><span class="line">        <span class="keyword">if</span> maxx &lt; minsize:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> vals.<span class="built_in">type</span> == RegisterValueType.InSetOfValues:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">all</span>(v &lt; minsize <span class="keyword">for</span> v <span class="keyword">in</span> vals.values):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    sites.append(ref)</span><br><span class="line">    sizes.append(vals)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n\n&quot;</span>+<span class="string">&quot;=&quot;</span>*<span class="number">34</span>+<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sites)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;0x%016x %-48s %r&quot;</span>%(sites[i].address, sites[i].function.symbol.full_name, sizes[i]))</span><br></pre></td></tr></table></figure>

<h1 id="Corpse-Footprints"><a href="#Corpse-Footprints" class="headerlink" title="Corpse Footprints"></a>Corpse Footprints</h1><p>我们的漏洞所针对的受害者结构涉及<a target="_blank" rel="noopener" href="http://newosxbook.com/files/corpses.pdf"><code>corpse</code></a>。在XNU中，<code>corpse</code>是一个分叉的、死亡的任务版本，通常在某些异常情况下产生。也可以通过调用<code>task_generate_corpse</code>直接生成一个，它返回一个代表<code>corpse</code>的<code>mach</code>端口。</p>
<blockquote>
<p>注意：在<code>Pwn2Own 2021</code>之后，苹果更新了<code>WebContent</code>沙盒，以阻止这个接口。</p>
</blockquote>
<p>在创建一个<code>corpse</code>时，会以不同大小的二进制格式收集其内存足迹的一种快照。它在<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/vm/vm_map.c.auto.html#:~:text=kernel_memory_allocate"><code>vm_map_corpse_footprint_collect</code></a>中直接从<code>kernel_map</code>和<code>kernel_memory_allocate</code>中分配。其大小取决于任务的虚拟内存大小，最大为8MB。</p>
<p>该大小被存储在分配的第一个字段中，即<code>cf_size</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_map_corpse_footprint_header</span> &#123;</span></span><br><span class="line">    <span class="type">vm_size_t</span>       cf_size;        <span class="comment">/* allocated buffer size */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而在<code>vm_map_corpse_footprint_destroy</code>中销毁<code>corpse</code>时，<code>cf_size</code>被传递给<code>vm_deallocate</code>。</p>
<p>通过破坏<code>cf_size</code>，我们可以人为地扩大<code>Footprint</code>，使其与相邻的受害者分配重叠，然后这些分配将与<code>Footprint</code>一起被释放。</p>
<p>破坏前：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_footprint_before.svg" alt="p2o_2021_eop_footprint_before"></p>
<p>破坏后，<code>Footprint</code>覆盖了受害者：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_footprint_after.svg" alt="p2o_2021_eop_footprint_after"></p>
<p>这允许我们诱导受害者对象的UAF，尽管为了可靠起见，我们还是应该坚持使用足够大的分配。这种UAF技术有一个注意事项，即受害者对象必须是可分页内存，而不是 <code>wired</code>内存。</p>
<h1 id="Wired-Kernel-Allocations"><a href="#Wired-Kernel-Allocations" class="headerlink" title="Wired Kernel Allocations"></a>Wired Kernel Allocations</h1><p>绝大多数的内核分配是<code>wired</code>的。当用<code>vm_map_remove</code>删除这些映射时，一个标志<code>VM_MAP_REMOVE_KUNWIRE</code>表明虚拟内存条目的<code>wired</code>计数（一种<code>refcount</code>）应该被减去。无论哪种方式，在实际删除该条目之前，它都会等待<code>wired</code>计数为零。</p>
<p><code>corpse footprint</code>是罕见的可分页分配对象之一，因此在释放时，<code>unwire</code>标志将不会被使用。如果重叠的受害者分配是<code>wired</code>的，内核线程就会挂起，等待一个不会发生的<code>unwire</code>。在实际应用中，这意味着我们只能对一个可分页的受害者分配进行UAF。</p>
<p>方便的是，我们已经遇到了一个潜在的有用的可分页分配。<code>IOKit</code>可分页空间。在这个阶段的计划变成了：</p>
<ol>
<li>分配一个新的可分页<code>map</code>，结尾有一个数据缓冲区；</li>
<li>分配<code>corpse footprint</code>；</li>
<li>在<code>footprint</code>之后分配一个新的可分页<code>map</code>；</li>
<li>在新的<code>map</code>中分配第二个数据缓冲区；</li>
<li>触发<code>bug</code>，扩大<code>footprint</code>；</li>
<li>销毁<code>corpse</code>，释放<code>footprint</code>和新的<code>map</code>；</li>
<li>第二个数据缓冲区现在指向已释放的内存。</li>
</ol>
<p>使用<code>VPHAL</code>标记（但这次是用<code>in-bounds</code>偏移），我们可以很容易地将任意的64位值写入释放的数据缓冲区。然而，为了保证可靠性，最好是尝试用足够大的对象来回收释放的数据缓冲区内存。</p>
<h1 id="Initial-Kernel-Information-Leaks"><a href="#Initial-Kernel-Information-Leaks" class="headerlink" title="Initial Kernel Information Leaks"></a>Initial Kernel Information Leaks</h1><p>在这一点上，我们已经把4个字节的越界写入变成了任意破坏任何大型分配内容的能力。为了获得一些信息泄露，我们将滥用<code>mach</code>信息体，它的分配大小上限大约为64MB。</p>
<p>一些相关的背景：<code>Mach</code>消息体有一个头，后面是消息的其余部分。消息可以是 “简单的 “或 “复杂的”，由头字段中的一个比特<code>msgh_bits</code>表示。一个简单的消息是简单的原始字节。一个复杂的消息可以包含几个描述符，它们可以用来向消息接收者发送端口权限和&#x2F;或内存映射。在这两种情况下，报头字段<code>msgh_size</code>表示整个消息体的缓冲区大小。</p>
<p><code>Mach</code>消息在内核中由<code>ipc_kmsg</code>结构表示，其中包含一个字段<code>ikm_header</code>，指向从用户空间复制和转换过来的消息体。这个消息体将是我们的破坏目标。</p>
<p><code>mach_port_peek</code>允许 “偷看 “一个端口接收队列中的第一条消息。其中一个被偷看的值是消息的<code>trailer</code>，通常由<code>mach</code>内核附加到消息体上。<code>trailer</code>通常位于<code>ikm_header + ikm_header-&gt;msgh_size</code>，但通过破坏<code>msgh_size</code>，我们可以将<code>trailer</code>移到界外，以获得<code>out-of-bound</code>读。</p>
<blockquote>
<p>注意：<code>mach_port_peek</code>也不再被<code>WebContent</code>沙箱所允许。</p>
</blockquote>
<p>破坏前：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_leak_target_before.svg" alt="p2o_2021_eop_leak_target_before"></p>
<p>破坏后：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_leak_target_after.svg" alt="p2o_2021_eop_leak_target_after"></p>
<p>我们在两个不同的泄漏目标上使用这种技术：</p>
<ol>
<li>第一个是包含端口描述符的<code>mach</code>信息体。<ol>
<li>当从用户空间转换时，端口描述符中的数字<code>mach</code>端口被一个指向相应<code>ipc_port</code>对象的指针所取代。我们需要泄露两个紧邻的<code>ipc_port</code>对象。其原因将在下一节解释。</li>
</ol>
</li>
<li>第二个泄漏目标将是一个包含单个<code>OSData</code>对象的<code>OSArray</code>的内容。<ol>
<li>泄露<code>OSData</code>对象的地址将给我们提供一个位置，以便以后获得<code>text</code>泄露（<code>OSData</code>的第一个字段是<code>vtable</code>）。</li>
</ol>
</li>
</ol>
<p>在过去（<a target="_blank" rel="noopener" href="https://blog.siguza.net/v0rtex/">1</a>，<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/08/in-wild-ios-exploit-chain-1.html">2</a>），使用<code>OSObject</code>进行内核开发已经做过很多次了。通过将<code>OSObject</code>附加到<code>IOSurface</code>的属性名上，它们可以方便地被分配&#x2F;释放（这是我们在<code>WebContent</code>沙盒中允许做的）。这些对象在内核中从类似XML的文本格式或二进制格式被反序列化。</p>
<p>二进制格式（由<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/libkern/c++/OSSerializeBinary.cpp.auto.html#:~:text=OSUnserializeBinary"><code>OSUnserializeBinary</code></a>反序列化）允许对分配的大小进行更多的控制；例如，我们可以分配一个有65536个元素容量的<code>OSArray</code>，然后在其中放置一个<code>OSData</code>，其余部分为空。</p>
<h1 id="Circumventing-zone-id-require-with-a-Misaligned-Port"><a href="#Circumventing-zone-id-require-with-a-Misaligned-Port" class="headerlink" title="Circumventing zone_id_require with a Misaligned Port"></a>Circumventing <code>zone_id_require</code> with a Misaligned Port</h1><p>破坏<code>OSArray</code>的内容，使其包含一个假的<code>OSObject</code>指针，这将是相对简单的。由于这些是C++类，我们会立即通过一个假的<code>vtable</code>劫持控制流。然而，我们至少需要一个<code>text</code>泄漏（内核代码地址），以便有地方可以跳转到。我们还需要知道首先将假的<code>OSObject</code>指向哪里（然后它将包含假的<code>vtable</code>等）；或者换句话说，我们控制的数据的地址。</p>
<p>为了获得这些泄漏，我们需要对<code>mach</code>端口进行一些创意。我们要制作一个假的端口，目的是为了获得一个半任意的读取。创建一个假端口的最大挑战是绕过各种<code>zone_require/zone_id_require</code>调用。这个<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/06/a-survey-of-recent-ios-kernel-exploits.html"><code>Project Zero</code></a>的帖子很好地解释了这一点。</p>
<blockquote>
<p><code>zone_require</code>是<code>iOS 13</code>中引入的一个软件缓解措施，增加了对某些从预期的<code>zalloc</code>区域分配的指针，在使用前进行检查。iOS内核缓存中最常见的<code>zone_require</code>检查是对Mach端口的检查；例如，每次<code>ipc_port</code>被锁定时，<code>zone_require()</code>函数被调用，以检查包含Mach端口的分配是否位于<code>ipc.ports</code>区域（而不是，例如，用<code>kalloc()</code>分配的<code>OSData</code>缓冲区）。</p>
</blockquote>
<p>为了解决这个问题，我们可以利用<code>zone_require</code>不关心正确的对齐方式，只关心指针位于适当的区域内。我们将使用我们先前泄露的两个相邻的端口，并在这两个端口之间制作一个错位的假 <code>ipc_port</code>。</p>
<p>为了把这个假端口引入我们的<code>ipc</code>空间，我们将再次破坏一个<code>mach</code>消息体。我们不破坏消息体的<code>msgh_size</code>，而是进行几次写操作，把它变成一个复杂的消息体，包含一个端口描述符，有一个发送到我们假端口的权利。如果我们能在收到这个消息后存活下来，一个新的发送到假端口的发送权将被添加到我们的<code>ipc</code>空间。</p>
<ul>
<li><p>另一个附带说明：我们不确定是否有可能将这种技术应用于非x86平台，因为有一些签名验证代码在x86平台上基本上是被忽略的。在复制一个<code>mach</code>消息后，内核用<code>ikm_sign</code>计算出消息体和所有描述符的签名。当复制出消息时，它重新计算签名并检查是否匹配，否则就会<code>panic</code>。</p>
</li>
<li><p>理论上，当内核在计算签名之前还在复制描述符的时候，应该有可能进行消息体的破坏。如果有可能通过强迫内核花很长的时间来复制所有的描述符来使竞赛变得可靠，或者以某种方式检查竞赛是否失败，并解除对消息的破坏和重试，这种技术就有可能发挥作用。</p>
</li>
</ul>
<p>当接收消息时，端口描述符在<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/ipc/ipc_kmsg.c.auto.html#:~:text=ipc_kmsg_copyout_port_descriptor"><code>ipc_kmsg_copyout_port_descriptor</code></a>中被处理，尽管大部分的逻辑是在<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/ipc/ipc_object.c.auto.html#:~:text=ipc_object_copyout%28"><code>ipc_object_copyout</code></a>中进一步处理。仔细追踪假的<code>ipc</code>对象是如何被处理&#x2F;检查的，这给了我们一些约束，即假端口的一些字段应该如何看才能存活。</p>
<ul>
<li><code>io_bits</code>：偏移量为0的<code>int</code>大小的位域<ul>
<li>高位必须被设置，表示端口处于活动状态 [<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/ipc/ipc_object.c.auto.html#:~:text=if%20%28!io_active%28object%29%29,-%7B%0A%09%09%09io_unlock">1</a>] 。</li>
<li>剩余的高位15位表示对象类型，必须是1以外的任何值（<code>IOT_PORT_SET</code>）。这个值决定了<code>ipc_object_validate</code>需要哪个区，我们希望它是端口区 [<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/ipc/ipc_object.c.auto.html#:~:text=if%20%28io_otype%28object%29%20!=%20IOT_PORT_SET%29">2</a>] 。</li>
<li>掩码为<code>0x400</code>的位必须为0，以表示<code>kobject</code>没有标签(这将触发一些我们宁愿避免的额外检查) [<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/ipc/ipc_object.c.auto.html#:~:text=ip_label_check">3</a>]</li>
</ul>
</li>
<li><code>io_lock_data</code>。8字节的值，位于偏移量8。必须为0，表示没有锁，否则在试图锁定端口时，会发生死锁&#x2F;恐慌 [<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/xnu/xnu-7195.81.3/osfmk/ipc/ipc_object.c.auto.html#:~:text=io_lock%28object%29%3B,-if%20%28!io_active%28object">4</a>]</li>
</ul>
<p>这些是安全接收发送权到假端口的唯一要求。在偏移量0处有一些半控制位，而在偏移量8处有一个零。</p>
<p>对于我们之前泄露的相邻的端口，将第一个端口称为A，第二个称为B。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_fake_port_misalignment.svg" alt="p2o_2021_eop_fake_port_misalignment"></p>
<p><code>io_bits</code> 与 <code>A-&gt;seqno</code> 重叠，是一个序列号。这个值通常在每次向端口发送消息时被递增，但它也可以通过<code>mach_port_set_seqno</code>手动设置（这个调用不再被沙盒允许）。因此，它是一个完全可控的 32 位值，允许我们满足 <code>io_bits</code> 上的约束。</p>
<p><code>io_lock_data</code>与端口<code>A</code>的<code>qcontext</code>、<code>qlimit</code>和<code>msgcount</code>重叠。<code>qcontext</code>通常为0。<code>msgcount</code>是当前在接收队列上的消息数量，如果没有，则为0。<code>qlimit</code>是在接收队列上可以放置多少消息的上限。它的默认值是 5，但是可以用 <code>mach_port_set_attributes</code> 的 <code>MACH_port_LIMITS_INFO</code> 语句设置为 0。因此，所有3个字段都可以是0，满足<code>io_lock_data</code>的约束。</p>
<p><code>ip_srights</code>字段记录了一个端口所存在的发送权限的数量。发送含有发送权的端口描述符的<code>mach</code>消息时，这个字段会增加1。类似地，在同一消息中发送<code>N</code>个有发送权的端口描述符，会增加<code>N</code>个。</p>
<p><code>ikmq_base</code>字段指向接收队列头部的<code>ipc_kmsg</code>。这个结构包含许多有趣的字段，在这种情况下，最相关的将是<code>ikm_header</code>，一个指向消息正文的指针。</p>
<p>由于假端口的<code>ip_srights</code>字段与<code>B-&gt;ikmq_base</code>重叠，我们可以发送假端口的端口描述符来增加<code>B-&gt;ikmq_base</code>，同样也可以接收这些端口描述符来解压缩&#x2F;解扰。这就引出了一个问题：<code>B-&gt;ikmq_base</code>的增量可以指向什么，或者换句话说，通常位于<code>ipc_kmsg</code>结构之后的东西。</p>
<p>在发送消息时，如果消息体足够小，那么消息体就会在<code>ipc_kmsg</code>结构之后内联存储，否则就会放在一个单独的分配中（这个逻辑在<code>ipc_kmsg_alloc</code>中）。如果发送给<code>B</code>的消息是这样的消息，将<code>ikmq_base</code>增加适当的次数将直接指向内联体，这是完全受控的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_kmsg_increment.svg" alt="p2o_2021_eop_kmsg_increment"></p>
<p>我们现在有能力完全伪造<code>B</code>的接收队列头部的<code>ipc_kmsg</code>。具体来说，我们将把对<code>B-&gt;ikmq_base-&gt;ikm_header</code>的控制变成一个受限的任意读取。</p>
<p>一般的想法是重复以下内容：</p>
<ol>
<li>向<code>B</code>发送一个小消息，以假的<code>ipc_kmsg</code>内容为主体；</li>
<li>到一个独立的辅助端口，使用端口描述符向假端口发送<code>N</code>个发送权限，增加<code>B-&gt;ikmq_base</code>；</li>
<li>在<code>B</code>上执行一些非破坏性的操作，以使用假的<code>ikm_header</code>来进行约束性的阅读；</li>
<li>接收端口描述符，将<code>B-&gt;ikmq_base</code>递减到正常值；</li>
<li>从<code>B</code>处接收清空队列，根据需要用一个新的假的<code>ipc_kmsg</code>重复。</li>
</ol>
<h1 id="Pseudo-arbitrary-Kernel-Memory-Read"><a href="#Pseudo-arbitrary-Kernel-Memory-Read" class="headerlink" title="Pseudo-arbitrary Kernel Memory Read"></a>Pseudo-arbitrary Kernel Memory Read</h1><p>我们可以用2种方法将假的<code>ikm_header</code>利用到读原语中。</p>
<h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>第一个使用<code>MACH_RCV_LARGE</code>，这是一个在接收<code>Mach</code>消息时可以指定的标志。如果这个标志被设置，并且要接收的消息大于用户空间接收缓冲区的大小，内核就会把消息留在队列中，并向用户空间写出需要的空间。</p>
<p>所需的大小由<code>ipc_kmsg_copyout_size</code>计算。这个计算是必要的，因为当从用户空间复制进来的时候，端口名（32位）被转换成相应的指针（64位），所以从内核和用户空间的角度来看，有一个大小的差异。所需的大小被计算为<code>ikm_header-&gt;msgh_size - 8</code>，然后如果信息是复杂的，每个端口描述符都会发生额外的减法。</p>
<p>对于<code>text</code>（代码地址）泄露，我们想读出我们之前泄露的数据指针的<code>OSData</code>对象的<code>vtable</code>。我们将把<code>ikm_header</code>指向<code>OSData - 4</code>，然后尝试用一个非常小的接收缓冲区接收消息，并设置<code>MACH_RCV_LARGE</code>选项。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_osdata_leak.svg" alt="p2o_2021_eop_osdata_leak"></p>
<p><code>msgh_size</code>与<code>vtable</code>的低4字节重合。内核<code>ASLR</code>没有提供足够的熵来随机化内核滑块的高32位，所以我们实际上有了我们的<code>text</code>泄漏。</p>
<p>这里的一个限制是<code>OSData</code>之前的内存必须被映射，因为<code>ipc_kmsg_copyout_size</code>会使用<code>msgh_bits</code>检查消息是否复杂。安全的做法是重复泄漏过程，直到找到一个非页对齐的<code>OSData</code>，确保<code>OSData-4</code>将被映射。</p>
<p>第二个潜在的问题是我们不知道<code>msgh_bits</code>是否会有复杂位被设置。如果它没有，一切都很好。如果有，<code>msgh_descriptor_count</code>（复杂信息中描述符的数量）将与<code>OSData</code>的容量重叠。通过分配<code>OSData</code>的大小为0，容量也将同样为0。这将确保不会对端口描述符的<code>msgh_size</code>进行额外减法。</p>
<h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>第二个受限的读取方法使用<code>mach_port_peek</code>。以前，我们用<code>mach_port_peek</code>和一个损坏的<code>msgh_size</code>来读取一个越界的<code>trailer</code>。这一次，我们控制<code>ikm_header</code>来代替。<code>trailer</code>是从<code>ikm_header + ikm_header-&gt;msgh_size</code>读取的，所以我们需要确保有一个合适的假<code>msgh_size</code>。最简单的是在我们希望读取的数值前不久在内存中找到一个零，这样<code>trailer</code>就会直接从假的<code>ikm_header</code>中复制出来，而不用进行加法。</p>
<p>我们将使用这种技术来泄露受控数据的地址。我们首先创建一个辅助端口，用前面使用的老式<code>mach_port_peek</code>技术泄露其地址。然后我们向这个端口发送一个大的<code>mach</code>消息，它将在虚拟内存的末端，在资源缓冲区<code>dbuf0</code>的一个恒定偏移处分配消息体。使用伪任意的<code>mach_port_peek</code>读取，我们就可以遍历<code>ipc_port</code>对象，找到消息体指针。减去适当的偏移量，我们就得到了<code>dbuf0</code>的地址。这个内存是在内核和用户空间之间共享的，所以我们有一个包含受控数据的内核地址。</p>
<h1 id="Arbitrary-Function-Call-Primitive"><a href="#Arbitrary-Function-Call-Primitive" class="headerlink" title="Arbitrary Function Call Primitive"></a>Arbitrary Function Call Primitive</h1><p>有了<code>text</code>泄漏和共享内存资源缓冲区的地址，我们可以继续劫持控制流。我们分配了一个大的<code>OSArray</code>，并破坏了一个指向资源缓冲区的入口。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/p2o_2021_eop_osarray_corruption.svg" alt="p2o_2021_eop_osarray_corruption"></p>
<p>这给了我们一个假的C++对象的控制，即<code>vtable</code>控制。</p>
<p>为了启动一个虚拟调用，我们从其相关的<code>IOSurface</code>查询被破坏的<code>OSArray</code>。代码首先在序列化之前复制被查询的值。在这种情况下，拷贝是由<code>OSArray::copyCollection</code>执行的，它调用<code>OSArray::initWithObjects</code>来使用现有对象初始化一个新数组。这就在后备存储上进行了迭代，并通过虚拟调用 <code>taggedRetain</code> 来保留每个对象（其中第一个对象我们已经损坏了）。这给了我们一个任意的函数调用，其中有一个受控的<code>this</code>参数。</p>
<p>我们把这个调用指向<code>OSSerializer::serialize</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OSSerializer::serialize(OSSerializer* this, OSSerialize* s) &#123;</span><br><span class="line">    <span class="keyword">return</span> this-&gt;callback(this-&gt;target, this-&gt;ref, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在有一个控制前两个参数的任意的函数调用。通过将这个调用引导回<code>OSSerialize::serialize</code>，我们可以利用<code>s</code>参数来获得一个有<code>3</code>个受控参数的任意函数调用。这个方法<a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/eu-17/materials/eu-17-Donenfeld-Rooten-Apples-Vulnerability-Heaven-In-The-IOS-Sandbox.pdf">以前也用过</a>。</p>
<p>从被劫持的<code>taggedRetain</code>调用返回后，我们将回到<code>OSArray::initWithObjects</code>中，如果在数组中遇到一个空条目，它将中止复制。我们使用这种行为来干净地跳出。</p>
<p>有了这个基元，任意的读&#x2F;写就简化为调用<code>copyin</code>和<code>copyout</code>函数。</p>
<h1 id="Kernel-Shellcode-Execution"><a href="#Kernel-Shellcode-Execution" class="headerlink" title="Kernel Shellcode Execution"></a>Kernel Shellcode Execution</h1><p>从这里开始，作为内核获得任意代码执行是相对简单的。</p>
<p>我们用<code>kmem_alloc_external</code>为<code>shellcode</code>分配内存，然后用<code>copyin</code>把它复制进去。似乎没有一个方便的方法来标记这个只有<code>3</code>个受控参数的内存<code>rwx</code>，所以我们使用<code>vm_map_store_lookup_entry</code>来查找与<code>shellcode</code>内存相关的<code>vm_map_entry_t</code>，它包含映射的权限位。覆盖这些位就足以标记该条目为<code>rwx</code>。最后，我们调用<code>shellcode</code>本身。</p>
<p><code>shellcode</code>重写了内核版本字符串（可通过<code>uname -a</code>查看），取消了当前进程（<code>Apple Safari</code>）的沙盒，并给予它<code>root</code>证书。漏洞利用在<a target="_blank" rel="noopener" href="https://github.com/ret2/Pwn2Own-2021-Safari/blob/main/eop/kernel_sc.c">这里</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这个漏洞最困难的部分可能是对信息泄露的需求，这使得这个漏洞偏离了重点，绕过了端口的<code>zone_require</code>缓解。自<code>Pwn2Own 2021</code>以来，沙盒的变化禁止了某些函数调用，这使得这种技术在Safari沙盒中是可行的，尽管有可能稍微修改该技术以绕过这些新限制。</p>
<p>这里讨论的漏洞已经在<code>macOS Big Sur 11.4</code>中打了补丁，并分配了<code>CVE-2021-30735</code>。</p>
<h1 id="复现情况"><a href="#复现情况" class="headerlink" title="复现情况"></a>复现情况</h1><p>虚拟机中运行会说找不到<code>IntelAccelerator</code>这个服务，好像是和虚拟机没有启用3D图形加速有关，但是VMware设置时显示无法为这个虚拟机开启图形加速，或许应该换PD试一试，另外，本地测试获取这个服务是没问题的。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/macos/" rel="tag"># macos</a>
              <a href="/tags/intel/" rel="tag"># intel</a>
              <a href="/tags/safari/" rel="tag"># safari</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/25/%E6%88%91%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%F0%9F%93%99/" rel="prev" title="我的漏洞学习笔记📙">
                  <i class="fa fa-angle-left"></i> 我的漏洞学习笔记📙
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/" rel="next" title="Android 11 魔形女漏洞">
                  Android 11 魔形女漏洞 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
