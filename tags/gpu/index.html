<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="robots" content="noindex"><meta><title>Tag: gpu - buffer0verflooow - Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="buffer0verflooow - Blog"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="buffer0verflooow - Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="buffer0verflooow - Blog"><meta property="og:url" content="https://buffer0verflooow.github.io/"><meta property="og:site_name" content="buffer0verflooow - Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://buffer0verflooow.github.io/img/og_image.png"><meta property="article:author" content="buffer0verflooow"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://buffer0verflooow.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://buffer0verflooow.github.io"},"headline":"buffer0verflooow - Blog","image":["https://buffer0verflooow.github.io/img/og_image.png"],"author":{"@type":"Person","name":"buffer0verflooow"},"publisher":{"@type":"Organization","name":"buffer0verflooow - Blog","logo":{"@type":"ImageObject","url":"https://buffer0verflooow.github.io/img/logo.svg"}},"description":""}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link data-pjax rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">gpu</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-06-18T08:50:51.000Z" title="2022/6/18 16:50:51">2022-06-18</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-06-20T14:08:16.790Z" title="2022/6/20 22:08:16">2022-06-20</time></span><span class="level-item">2 hours read (About 13695 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2022/06/18/Qualcomm-GPU%E9%A9%B1%E5%8A%A8UAF%E6%BC%8F%E6%B4%9E-CVE-2022-22057/">Qualcomm GPU驱动UAF漏洞(CVE-2022-22057)</a></p><div class="content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>又是一篇关于<code>Qualcomm</code>驱动程序的漏洞，然而上一篇关于驱动的漏洞还没去验证呢😮‍💨</p>
<p>今天这一篇是官员<code>Qualcomm GPU</code>的 UAF 漏洞，影响搭载了<code>Snapdragon 888</code>及以上芯片、内核版本为 5.4 及以上的设备，如S21、Galaxy Z Flip3等。</p>
<p>高通的安全公告：<a target="_blank" rel="noopener" href="https://docs.qualcomm.com/product/publicresources/securitybulletin/may-2022-bulletin.html">Qualcomm security bulletin in May 2022</a>。</p>
<h2 id="为什么要挖GPU驱动漏洞呢？"><a href="#为什么要挖GPU驱动漏洞呢？" class="headerlink" title="为什么要挖GPU驱动漏洞呢？"></a>为什么要挖GPU驱动漏洞呢？</h2><ol>
<li>GPU 驱动中有很多缓解措施；</li>
<li>2021年在野利用的 Android 0Day 漏洞有7个，其中5个是关于 GPU 驱动的；</li>
<li>GPU 驱动可以从未信任的应用沙箱中进行访问；</li>
<li>大多数的 GPU 驱动都会处理 GPU 和 CPU 之间的复杂的内存共享逻辑，处理精心制作的恶意代码将导致任意内存读写。由于攻击者滥用GPU 内存管理代码，将导致内存损坏难以检测，以及对现有的缓解措施免疫；<ol>
<li>这里有两个滥用 GPU opcode 的例子：<a target="_blank" rel="noopener" href="https://github.com/secmob/TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices/blob/master/us-20-Gong-TiYunZong-An-Exploit-Chain-to-Remotely-Root-Modern-Android-Devices-wp.pdf">Guang Gong</a> 和 <a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/09/attacking-qualcomm-adreno-gpu.html">Ben Hawkes</a>。</li>
</ol>
</li>
</ol>
<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><p>漏洞是在Qualcomm <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/tree/msm-5.4.r2">msm 5.4 kernel</a> 中引入的，增加了<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/e0952b5cce5bcccbe04a18a9673869e6924ccac0/drivers/gpu/msm/kgsl_timeline.c">kgsl timeline</a>特性和一些<code>ioctl</code>。<code>msm 5.4</code> 内核对内核图形支持层（kgsl）驱动程序（位于<code>drivers/gpu/msm</code>下）进行了一些相当重要的重构，并引入了一些新功能。就是这些新功能和重构，导致了新的安全问题。其中大部分是在内部发现并修复的，然后在公告中作为安全问题公开披露。</p>
<p> <code>kgsl_timeline</code> 对象可以通过<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/e0952b5cce5bcccbe04a18a9673869e6924ccac0/drivers/gpu/msm/kgsl_timeline.c#L323"><code>IOCTL_KGSL_TIMELINE_CREATE</code></a> 和 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/e0952b5cce5bcccbe04a18a9673869e6924ccac0/drivers/gpu/msm/kgsl_timeline.c#L96"><code>IOCTL_KGSL_TIMELINE_DESTROY</code></a>进行创建和销毁。 <code>kgsl_timeline</code>对象在其 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/e0952b5cce5bcccbe04a18a9673869e6924ccac0/drivers/gpu/msm/kgsl_timeline.h#L26"><code>fences</code></a>字段中存储了一个 <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v5.9/driver-api/dma-buf.html"><code>dma_fence</code></a> 对象链表。使用<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/e0952b5cce5bcccbe04a18a9673869e6924ccac0/drivers/gpu/msm/kgsl_timeline.c#L427"><code>IOCTL_KGSL_TIMELINE_FENCE_GET</code></a> 和 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/e0952b5cce5bcccbe04a18a9673869e6924ccac0/drivers/gpu/msm/kgsl_timeline.c#L358"><code>IOCTL_KGSL_TIMELINE_WAIT</code></a>向链表中添加<code>dma_fence</code>对象。添加的<code>dma_fence</code>对象是<code>refcounted</code>对象，<code>dma_fence_put</code>方法用于减少它们的<code>refcount</code>。</p>
<p>有趣的是， <code>timeline-&gt;fences</code> 并没有真的持有一个<code>fences</code>的<code>refcount</code>。反之，为了避免 <code>timeline-&gt;fences</code> 中的 <code>dma_fence</code> 被释放，使用了一个自定义的 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/drivers/gpu/msm/kgsl_timeline.c#L231"><code>release</code></a> 函数： <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/drivers/gpu/msm/kgsl_timeline.c#L165"><code>timeline_fence_release</code></a> ，在<code>dma_fence</code>被释放之前， <code>timeline_fence_release</code> 从 <code>timeline-&gt;fences</code> 中移除该<code>dma_fence</code>。</p>
<p>当存储在 <code>kgsl_timeline::fences</code> 中的 <code>dma_fence</code> 的<code>refcount</code>减少为0时，方法 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/drivers/gpu/msm/kgsl_timeline.c#L165"><code>timeline_fence_release</code></a> 被调用，以从 <code>kgsl_timeline::fences</code> 中移除 <code>dma_fence</code> ，然后调用 <code>dma_fence_free</code> 方法释放 <code>dma_fence</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">timeline_fence_release</span><span class="params">(<span class="keyword">struct</span> dma_fence *fence)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    spin_lock_irqsave(&amp;timeline-&gt;fence_lock, flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the fence is still on the active list, remove it */</span></span><br><span class="line">    list_for_each_entry_safe(cur, temp, &amp;timeline-&gt;fences, node) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f != cur)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        list_del_init(&amp;f-&gt;node);    <span class="comment">//&lt;----- 1. Remove fence</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irqrestore(&amp;timeline-&gt;fence_lock, flags);</span><br><span class="line">    ...</span><br><span class="line">    kgsl_timeline_put(f-&gt;timeline);</span><br><span class="line">    dma_fence_free(fence);     <span class="comment">//&lt;-------    2.  frees the fence</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>尽管移除操作被<code>timeline-&gt;fence_lock</code>所保护，<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/drivers/gpu/msm/kgsl_timeline.c#L515"><code>IOCTL_KGSL_TIMELINE_DESTROY</code></a>仍然可以在 <code>dma_fence</code> 的<code>refcount</code>减少为0时，从 <code>fences</code> 中移除前，获取它的一个引用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_destroy</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    spin_lock(&amp;timeline-&gt;fence_lock);  <span class="comment">//&lt;------------- a.</span></span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;timeline-&gt;fences, node)</span><br><span class="line">        dma_fence_get(&amp;fence-&gt;base);</span><br><span class="line">    list_replace_init(&amp;timeline-&gt;fences, &amp;temp);</span><br><span class="line">    spin_unlock(&amp;timeline-&gt;fence_lock);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123; <span class="comment">//&lt;----- b.</span></span><br><span class="line">        dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">        dma_fence_signal_locked(&amp;fence-&gt;base);</span><br><span class="line">        dma_fence_put(&amp;fence-&gt;base);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>kgsl_ioctl_timeline_destroy</code>中，销毁一个<code>timeline</code>之前，先将<code>timeline-&gt;fences</code>中的<code>fences</code>拷贝到<code>temp</code>中，然后从<code>timeline-&gt;fences</code>中删除（a）。由于<code>timeline-&gt;fences</code>没有保留额外的<code>fence</code>引用，<code>refcount</code>将被增加以阻止它们在<code>temp</code>中被释放。同样的，这里对 <code>timeline-&gt;fences</code> 的操作也受到<code>timeline-&gt;fence_lock</code>的保护。但是，当到达（a）时，<code>fence</code>的<code>refcount</code>已经为0了，方法 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/drivers/gpu/msm/kgsl_timeline.c#L165"><code>timeline_fence_release</code></a> 还没有将其从 <code>kgsl_timeline::fences</code> 中移除时， <code>dma_fence</code> 将被移动到<code>temp</code>中，尽管此时它的引用增加了，但是也已经晚了，因为，随后方法 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/drivers/gpu/msm/kgsl_timeline.c#L165"><code>timeline_fence_release</code></a> 将从 <code>kgsl_timeline::fences</code> 中移除它，无论<code>refcount</code>的值是多少。按照以下流程，UAF 将在（b）处触发。</p>
<img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/Kernel-1.webp" alt="Kernel-1"  />

<p>如上图所示，这是竞争的流程，通过在 <code>timeline-&gt;fence</code>中添加大量的 <code>dma_fence</code> ，可以增加<code>kgsl_ioctl_timeline_destroy</code>代码块运行的时间。如果在线程2中将 <code>timeline-&gt;fence</code>中最后一个 <code>dma_fence</code> 的<code>refcount</code>减少为0，同时保持线程1继续运行，我们可以在线程1的 <code>dma_fence_get</code> 将<code>refcount</code>加1前，调用 <code>timeline_fence_release</code> 。因为线程2也需要等待 <code>timeline-&gt;fence_lock</code>，它只有等线程1结束，才能从 <code>kgsl_timeline::fences</code> 中移除 <code>dma_fence</code> 。到那时， <code>timeline-&gt;fence</code>中所有的 <code>dma_fence</code> 都已经移动到<code>temp</code>中了。这就意味着，当线程2运行时， <code>timeline-&gt;fence</code>是一个空的链表，然后执行流程将很快到达 <code>dma_fence_free</code>。</p>
<p>简而言之，只要在 <code>timeline-&gt;fence</code>中放置足够的 <code>dma_fence</code> ，可以在<code>kgsl_ioctl_timeline_destroy</code>将 <code>timeline-&gt;fence</code>中 <code>dma_fence</code> 移动到<code>temp</code>的过程中，创造一个很大的竞争窗口，只要将 <code>timeline-&gt;fence</code>中最后一个 <code>dma_fence</code> 的<code>refcount</code>减少为0，就可以触发UAF。</p>
<h1 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h1><p>利用这个bug并不复杂，但是，有很多漏洞缓解措施，<a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/debug/kcfi">kCFI</a> (Kernel Control Flow Integrity) 和 <a target="_blank" rel="noopener" href="https://android-developers.googleblog.com/2020/06/system-hardening-in-android-11.html">variable initialization</a> （这些在4.x内核中是关闭的，但是5.x内核全部开启了），还有 <a target="_blank" rel="noopener" href="https://www.samsungknox.com/en">Samsung RKP (Realtime Kernel Protection)</a> 。</p>
<h2 id="kCFI"><a href="#kCFI" class="headerlink" title="kCFI"></a>kCFI</h2><p><code>kCFI</code>可以说是最容易被绕过的缓解措施，特别是在与三星管理程序一起使用时，它保护了内核中许多重要的内存区域。<code>kCFI</code>通过限制动态调用点可以使用函数签名跳转到的位置来防止控制流被劫持。例如，在当前的漏洞中，<code>dma_fence</code>被释放后，函数<code>dma_fence_signal_locked</code>被调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_destroy</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">        dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">        dma_fence_signal_locked(&amp;fence-&gt;base);       <span class="comment">//&lt;---- free&#x27;d fence is used</span></span><br><span class="line">        dma_fence_put(&amp;fence-&gt;base);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dma_fence_signal_locked</code>将调用 <code>cur-&gt;func</code> ，该函数是<code>fence-&gt;cb_list</code>列表中的一个元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dma_fence_signal_locked</span><span class="params">(<span class="keyword">struct</span> dma_fence *fence)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry_safe(cur, tmp, &amp;cb_list, node) &#123;</span><br><span class="line">        INIT_LIST_HEAD(&amp;cur-&gt;node);</span><br><span class="line">        cur-&gt;func(fence, cur);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有<code>kCFI</code>的话，已释放的 <code>fence</code> 将可以被<code>fake object</code>代替，意味着，包括<code>cb_list</code>和<code>func</code>，所有都是假的。只要绕过了<code>KASLR</code>，利用就十分简单了，如这个<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/qualcomm_npu/">利用</a>。但是由于<code>kCFI</code>，现在替换<code>func</code>的函数类型只能为 <a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/include/linux/dma-fence.h#L118"><code>dma_fence_func_t</code></a>。</p>
<p>之前有关于如何绕过 Samsung 控制流完整性校验（JOPP, jump-oriented programming prevention）的<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/qualcomm_npu/">方法</a>，但是对<code>kCFI</code>没什么作用，绕过<code>kCFI</code>的常见方法是通过<code>double free</code>去劫持释放的链表，然后使用<a target="_blank" rel="noopener" href="https://i.blackhat.com/briefings/asia/2018/asia-18-WANG-KSMA-Breaking-Android-kernel-isolation-and-Rooting-with-ARM-MMU-features.pdf">Kernel Space Mirroring Attack (KSMA)</a>，但是，这种方法需要大量的时间，如[Three dark clouds over the Android kernel](<a target="_blank" rel="noopener" href="https://github.com/2freeman/Slides/blob/main/PoC-2020-Three">https://github.com/2freeman/Slides/blob/main/PoC-2020-Three</a> Dark clouds over the Android kernel.pdf) 和 <a target="_blank" rel="noopener" href="https://i.blackhat.com/USA21/Wednesday-Handouts/us-21-Typhoon-Mangkhut-One-Click-Remote-Universal-Root-Formed-With-Two-Vulnerabilities.pdf">Typhoon Mangkhut: One-click remote universal root formed with two vulnerabilities</a> 。</p>
<p>这个bug也能提供<code>double free</code>，就是当 <code>dma_fence_put</code> 在 <code>fence</code> 被释放后调用时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_destroy</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">        dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">        dma_fence_signal_locked(&amp;fence-&gt;base); </span><br><span class="line">        dma_fence_put(&amp;fence-&gt;base);       <span class="comment">//&lt;----- free&#x27;d fence can be freed again</span></span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述做法减少了假 <code>fence</code> 对象的<code>refcount</code>，可以控制为1，这样假 <code>fence</code> 就会再次被释放。然而，这并不能应用<code>KSMA</code>，因为这需要覆盖<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/arch/arm64/include/asm/pgtable.h#L465"><code>swapper_pg_dir</code></a>数据结构，而这个结构是受三星管理程序保护的。</p>
<h2 id="Variable-initialization"><a href="#Variable-initialization" class="headerlink" title="Variable initialization"></a>Variable initialization</h2><p>从Android 11开始，内核可以通过启用各种内核构建标志来实现自动变量初始化。例如，以下是Z Flip3的构建配置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Memory initialization</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="string">CONFIG_CC_HAS_AUTO_VAR_INIT_PATTERN=y</span></span><br><span class="line"><span class="string">CONFIG_CC_HAS_AUTO_VAR_INIT_ZERO=y</span></span><br><span class="line"><span class="comment"># CONFIG_INIT_STACK_NONE is not set</span></span><br><span class="line"><span class="comment"># CONFIG_INIT_STACK_ALL_PATTERN is not set</span></span><br><span class="line"><span class="string">CONFIG_INIT_STACK_ALL_ZERO=y</span></span><br><span class="line"><span class="string">CONFIG_INIT_ON_ALLOC_DEFAULT_ON=y</span></span><br><span class="line"><span class="comment"># CONFIG_INIT_ON_FREE_DEFAULT_ON is not set</span></span><br><span class="line"><span class="comment"># end of Memory initialization</span></span><br></pre></td></tr></table></figure>

<p>这个特征除了保护未初始化的变量以外，还使得替换对象变得困难。特别是，它不再可能执行部分对象替换，即只替换对象的第一个字节，而对象的其余部分仍然有效。如堆喷，<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html">Mitigations are attack surface, too</a>将不再可能。</p>
<p>这个特性将使得这个bug不能进行堆喷。</p>
<h2 id="kfree-rcu"><a href="#kfree-rcu" class="headerlink" title="kfree_rcu"></a>kfree_rcu</h2><p>这不是一个缓解措施，之所以提，是因为它有些类似已提出的 UAF 缓解措施的作用。这个bug中， <code>fence</code> 被 <code>dma_fence_free</code> 释放，不同于常规的 <code>kfree</code>，这里是使用 <code>kfree_rcu</code>。简单来说，<code>kfree_rcu</code>并不直接释放掉对象，只是在遇到某些情况时再进行释放。这有点像一个延迟释放，在对象被释放的时间上引入了一个不确定性（这和 <a target="_blank" rel="noopener" href="https://source.android.com/devices/tech/debug/scudo">Scudo</a>分配器的UAF缓解措施类似），这种不确定性对这个bug的利用还是很有阻碍（竞争窗口很紧张）的。</p>
<p>然而，有许多操纵竞争窗口大小的原语，比如<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2022/03/racing-against-clock-hitting-tiny.html">Racing against the clock—hitting a tiny kernel race window</a>和[Exploiting race conditions on (ancient) Linux](<a target="_blank" rel="noopener" href="https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019">https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019</a> - Exploiting race conditions on Linux.pdf)中的技术，（两者都是由Jann Horn编写的，较早的技术被用于利用当前的bug）任何紧张的竞争窗口都可以被做得足够大，以允许由<code>kfree_rcu</code>引起的延迟，以及随后的对象替换。</p>
<h2 id="Samsung-RKP-Realtime-Kernel-Protection"><a href="#Samsung-RKP-Realtime-Kernel-Protection" class="headerlink" title="Samsung RKP (Realtime Kernel Protection)"></a>Samsung RKP (Realtime Kernel Protection)</h2><p><code>RKP</code>保护内存不被写入，这可以防止进程覆盖自己的证书成为<code>root</code>，也可以保护<code>SELinux</code>设置不被覆盖。它还可以防止内核代码区和其他重要对象，如内核页表，被覆盖。不过在实践中，一旦实现了任意的内核内存读写（受<code>RKP</code>限制），就有办法绕过这些限制。例如，<code>SELinux</code>规则可以通过覆盖<code>avc</code>缓存来修改（例如，见Valentina Palmiotti的这个<a target="_blank" rel="noopener" href="https://github.com/chompie1337/s8_2019_2215_poc/blob/master/poc/selinux_bypass.c">利用</a>），而获得<code>root</code>可以通过<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/qualcomm_npu/">hijacking other processes that run as root</a>实现。</p>
<p>在这个bug中，<code>RKP</code>与<code>kCFI</code>合作，防止任意函数调用。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="Adding-dma-fence-to-timeline-fences"><a href="#Adding-dma-fence-to-timeline-fences" class="headerlink" title="Adding dma_fence to timeline-&gt;fences"></a>Adding <code>dma_fence</code> to <code>timeline-&gt;fences</code></h2><p>有两个选项可以将<code>dma_fence</code>对象添加到<code>kgsl_timeline</code>中，第一个是使用<code>IOCTL_KGSL_TIMELINE_FENCE_GET</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_fence_get</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    timeline = kgsl_timeline_by_id(device, param-&gt;timeline);</span><br><span class="line">    ...</span><br><span class="line">    fence = kgsl_timeline_fence_alloc(timeline, param-&gt;seqno); <span class="comment">//&lt;----- dma_fence created and added to timeline</span></span><br><span class="line">    ...</span><br><span class="line">    sync_file = sync_file_create(fence);</span><br><span class="line">    <span class="keyword">if</span> (sync_file) &#123;</span><br><span class="line">        fd_install(fd, sync_file-&gt;file);</span><br><span class="line">        param-&gt;handle = fd;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kgsl_timeline_fence_alloc</code>创建一个<code>dma_fence</code>，并将其添加到<code>timeline</code>上。然后调用者得到一个与<code>dma_fence</code>对应的<code>sync_file</code>的文件描述符。当<code>sync_file</code>被关闭时，<code>dma_fence</code>的<code>refcount</code>被减少到0。</p>
<p>第二个是 <code>IOCTL_KGSL_TIMELINE_WAIT</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_wait</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    fence = kgsl_timelines_to_fence_array(device, param-&gt;timelines,</span><br><span class="line">        param-&gt;count, param-&gt;timelines_size,</span><br><span class="line">        (param-&gt;flags == KGSL_TIMELINE_WAIT_ANY));     <span class="comment">//&lt;------ dma_fence created and added to timeline</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (!timeout)</span><br><span class="line">        ret = dma_fence_is_signaled(fence) ? <span class="number">0</span> : -EBUSY;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = dma_fence_wait_timeout(fence, <span class="literal">true</span>, timeout);   <span class="comment">//&lt;----- 1.</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dma_fence_put(fence);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>kgsl_timelines_to_fence_array</code>创建<code>dma_fence</code>对象，并将其添加到<code>timeline</code>上。如果指定了一个 <code>timeout</code> ，那么该调用将进入<code>dma_fence_wait_timeout</code>（路径标记为1）进行等待，直到超时或线程收到中断。在<code>dma_fence_wait_timeout</code>结束后，<code>dma_fence_put</code>被调用，以将<code>dma_fence</code>的<code>refcount</code>减少到0，释放被添加到<code>timeline</code>上的<code>dma_fence</code>。</p>
<p>虽然<code>IOCTL_KGSL_TIMELINE_FENCE_GET</code>乍看之下似乎更容易使用和控制，但实际上，关闭<code>sync_file</code>产生的开销使得销毁<code>dma_fence</code>的时间不那么可靠。因此，对于这个bug，这里使用<code>IOCTL_KGSL_TIMELINE_FENCE_GET</code>来创建和添加持久化的<code>dma_fence</code>对象来填充<code>timeline-&gt;fences</code>列表，以扩大竞争窗口，而用于UAF漏洞的最后一个<code>dma_fence</code>对象是使用<code>IOCTL_KGSL_TIMELINE_WAIT</code>添加的，当发送中断信号给调用<code>IOCTL_KGSL_TIMELINE_WAIT</code>的线程，它就被释放。</p>
<h2 id="Widening-the-tiny-race-window"><a href="#Widening-the-tiny-race-window" class="headerlink" title="Widening the tiny race window"></a>Widening the tiny race window</h2><p>为了利用这个漏洞，需要在以下代码块中标记的第一个竞争窗口内删除<code>kgsl_timeline</code>的 <code>fences</code> 列表中的<code>dma_fence</code>的<code>refcount</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_destroy</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//BEGIN OF FIRST RACE WINDOW</span></span><br><span class="line">    spin_lock(&amp;timeline-&gt;fence_lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;timeline-&gt;fences, node)</span><br><span class="line">        dma_fence_get(&amp;fence-&gt;base);</span><br><span class="line">    list_replace_init(&amp;timeline-&gt;fences, &amp;temp);</span><br><span class="line">    spin_unlock(&amp;timeline-&gt;fence_lock);</span><br><span class="line">    <span class="comment">//END OF FIRST RACE WINDOW</span></span><br><span class="line">    <span class="comment">//BEGIN OF SECOND RACE WINDOW</span></span><br><span class="line">    spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">        dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">        dma_fence_signal_locked(&amp;fence-&gt;base);</span><br><span class="line">        dma_fence_put(&amp;fence-&gt;base);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    <span class="comment">//END OF SECOND RACE WINDOW</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如前所述，通过向<code>timeline-&gt;fences</code>添加大量的<code>dma_fence</code>对象，可以扩大第一个竞争窗口，这使得在这个窗口内很容易触发<code>refcount</code>的减少。然而，为了利用这个错误，下面的代码以及对象替换必须在第二个竞争窗口结束前完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_irqsave(&amp;timeline-&gt;fence_lock, flags);</span><br><span class="line">list_for_each_entry_safe(cur, temp, &amp;timeline-&gt;fences, node) &#123;</span><br><span class="line">    <span class="keyword">if</span> (f != cur)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    list_del_init(&amp;f-&gt;node);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irqrestore(&amp;timeline-&gt;fence_lock, flags);</span><br><span class="line">trace_kgsl_timeline_fence_release(f-&gt;timeline-&gt;id, fence-&gt;seqno);</span><br><span class="line">kgsl_timeline_put(f-&gt;timeline);</span><br><span class="line">dma_fence_free(fence);</span><br></pre></td></tr></table></figure>

<p>如前所述，由于<code>spin_lock</code>的存在，在第一个竞争窗口结束之前，上述代码不能执行，但在运行这段代码时，<code>timeline-&gt;fence</code>已经被清空，所以循环会很快运行。然而，由于<code>dma_fence_free</code>使用了<code>kfree_rcu</code>，实际释放<code>fence</code>的时间被推迟了。这使得我们不可能在第二个竞争窗口结束前替换已释放的<code>fence</code>，除非能操纵调度器。这里使用[Exploiting race conditions on (ancient) Linux](<a target="_blank" rel="noopener" href="https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019">https://static.sched.com/hosted_files/lsseu2019/04/LSSEU2019</a> - Exploiting race conditions on Linux.pdf)，另一个Android漏洞中也使用了这项<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/">技术</a>，以扩大这个竞争窗口。</p>
<p><strong>下面是关于这项技术的概述：</strong></p>
<p><strong>为了确保每个任务（线程或进程）有公平的CPU时间片，Linux内核调度程序可以中断一个正在运行的任务，并将其搁置，以便另一个任务可以运行。这种中断和停止任务的行为被称为抢占（被中断的任务被抢占）。一个任务也可以把自己搁置起来，让另一个任务运行，比如当它在等待一些I&#x2F;O输入时，或者当它调用<code>sched_yield()</code>时。在这种情况下，我们说该任务是自愿抢占的。抢占也可以发生在系统调用内部，比如<code>ioctl</code>调用，在Android上，除了一些关键区域（比如持有自旋锁），任务可以被抢占。这种行为可以通过使用CPU亲和力和任务优先级来操纵。</strong></p>
<p><strong>默认情况下，一个任务以<code>SCHED_NORMAL</code>的优先级运行，但也可以使用<code>sched_setscheduler</code>调用（或线程的<code>pthread_setschedparam</code>）设置一个较低的优先级<code>SCHED_IDLE</code>。此外，还可以用<code>sched_setaffinity</code>将其固定在一个CPU上，这将只允许它在一个特定的CPU上运行。通过将两个任务（一个具有<code>SCHED_NORMAL</code>优先级，另一个具有<code>SCHED_IDLE</code>优先级）固定在同一个CPU上，可以控制抢占的时间，如下所示：</strong></p>
<ol>
<li><strong>首先让<code>SCHED_NORMAL</code>任务执行一个系统调用，导致它暂停和等待。例如，它可以从一个没有数据进入的管道中读取数据，然后它将等待更多的数据，并主动抢占自己的位置，以便<code>SCHED_IDLE</code>任务可以运行。</strong></li>
<li><strong>当<code>SCHED_IDLE</code>任务正在运行时，向<code>SCHED_NORMAL</code>任务一直在等待的管道发送一些数据。这将唤醒<code>SCHED_NORMAL</code>任务，使其抢占<code>SCHED_IDLE</code>任务，由于任务的优先级，<code>SCHED_IDLE</code>任务将被抢占并搁置。</strong></li>
<li><strong>然后<code>SCHED_NORMAL</code>任务可以运行一个繁忙循环，以防止<code>SCHED_IDLE</code>任务被唤醒。</strong></li>
</ol>
<p>在这个bug的漏洞利用中，该技术使用如下所示：</p>
<ol>
<li><p>在一个线程上运行<code>IOCTL_KGSL_TIMELINE_WAIT</code>，向<code>kgsl_timeline</code>添加<code>dma_fence</code>对象。将超时设置为一个大值，并使用 <code>sched_setaffinity</code> 将这个任务固定在一个 CPU 上，称之为 <code>SPRAY_CPU</code>。一旦<code>dma_fence</code>对象被添加，这个任务就会变成空闲状态，直到它收到一个中断。</p>
</li>
<li><p>设置一个<code>SCHED_NORMAL</code>任务，并将其固定在另一个CPU上（<code>DESTROY_CPU</code>），该 CPU 监听一个空管道。这将导致这个任务最初变得空闲，并允许<code>DESTROY_CPU</code>运行一个低优先级的任务。一旦空管道收到一些数据，这个任务就会运行一个繁忙的循环。</p>
</li>
<li><p>在<code>DESTROY_CPU上</code>设置一个<code>SCHED_IDLE</code>任务，它将运行<code>IOCTL_KGSL_TIMELINE_DESTROY</code>来销毁步骤一中加入<code>dma_fence</code>的<code>timeline</code>。由于第二步中设置的任务正在等待空管的响应，<code>DESTROY_CPU</code>将首先运行这个任务。</p>
</li>
<li><p>向运行<code>IOCTL_KGSL_TIMELINE_WAIT</code>的任务发送一个中断。然后，在<code>IOCTL_KGSL_TIMELINE_DESTROY</code>在第一个竞争窗口内运行时，该任务将解除封锁并释放<code>dma_fence</code>。</p>
</li>
<li><p>写入<code>SCHED_NORMAL</code>任务正在监听的空管道。这将导致<code>SCHED_NORMAL</code>任务抢占<code>SCHED_IDLE</code>任务。一旦它成功地抢占了任务，<code>DESTROY_CPU</code>将运行繁忙循环，导致<code>SCHED_IDLE</code>任务被搁置。</p>
</li>
<li><p>由于运行<code>IOCTL_KGSL_TIMELINE_DESTROY</code>的<code>SCHED_IDLE</code>任务被搁置，现在有足够的时间来克服<code>kfree_rcu</code>引入的延迟，并允许步骤4中的<code>dma_fence</code>被释放和替换。之后，恢复<code>IOCTL_KGSL_TIMELINE_DESTROY</code>，这样后续的操作将在现在被释放和替换的<code>dma_fence</code>对象上执行。</p>
</li>
</ol>
<p>这里需要注意的是，因为在线程持有自旋锁的时候不能发生抢占，所以<code>IOCTL_KGSL_TIMELINE_DESTROY</code>只能在自旋锁之间的窗口期抢占，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_destroy</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    spin_lock(&amp;timeline-&gt;fence_lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;timeline-&gt;fences, node)</span><br><span class="line">      ...</span><br><span class="line">    spin_unlock(&amp;timeline-&gt;fence_lock);</span><br><span class="line">    <span class="comment">//Preemption window</span></span><br><span class="line">    spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然上面的抢占窗口看起来非常小，但在实践中，只要<code>SCHED_NORMAL</code>任务试图在第一个自旋锁被持有时抢占运行<code>IOCTL_KGSL_TIMELINE_DESTROY</code>的<code>SCHED_IDLE</code>任务，一旦自旋锁被释放，抢占就会发生，这使得在正确的时间抢占<code>IOCTL_KGSL_TIMELINE_DESTROY</code>更容易成功。</p>
<p>下图红色块表示持有自旋锁的区域，因此不可能抢占，虚线表示闲置的任务：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/Kernel-2.webp" alt="Kernel-2"></p>
<p>对于对象的替换，使用<a target="_blank" rel="noopener" href="https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part3.html"><code>sendmsg</code></a>，这是一种标准的方法，可以用受控数据替换linux内核中的已释放的对象。下面是假对象是如何被使用的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">    dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">    dma_fence_signal_locked(&amp;fence-&gt;base);</span><br><span class="line">    dma_fence_put(&amp;fence-&gt;base);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;timeline-&gt;lock);</span><br></pre></td></tr></table></figure>

<p>三个不同的函数，<code>dma_fence_set_error</code>、<code>dma_fence_signal_locked</code>和<code>dma_fence_put</code>将被调用，参数为<code>fence</code>。函数<code>dma_fence_set_error</code>将向<code>fence</code>对象写一个错误代码，这可能对合适的对象替换有用，但对<code>sendmsg</code>对象替换没有用，函数<code>dma_fence_signal_locked</code>如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dma_fence_signal_locked</span><span class="params">(<span class="keyword">struct</span> dma_fence *fence)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (unlikely(test_and_set_bit(DMA_FENCE_FLAG_SIGNALED_BIT,   <span class="comment">//&lt;-- 1.</span></span><br><span class="line">                      &amp;fence-&gt;flags)))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stash the cb_list before replacing it with the timestamp */</span></span><br><span class="line">    list_replace(&amp;fence-&gt;cb_list, &amp;cb_list);                    <span class="comment">//&lt;-- 2.</span></span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry_safe(cur, tmp, &amp;cb_list, node) &#123;        <span class="comment">//&lt;-- 3.</span></span><br><span class="line">        INIT_LIST_HEAD(&amp;cur-&gt;node);</span><br><span class="line">        cur-&gt;func(fence, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先检查<code>fence-&gt;flags</code>（1）：如果<code>DMA_FENCE_FLAG_SIGNALED_BIT</code>标志被设置，那么<code>fence</code>已经被信号化，函数退出。如果<code>fence</code>没有被发出信号，那么会调用<code>list_replace</code>来移除<code>fence-&gt;cb_list</code>中的对象，并将其放入临时<code>cb_list</code>中（2） 之后，存储在<code>cb_list</code>中的函数被调用（3）。正如在 <code>kCFI </code>一节中解释的那样，因为<code>CFI</code>的缓解，这将只允许调用某种类型的函数；此外，在这个阶段，由于对函数地址一无所知，所以如果走到达这个路径，很可能只会让内核崩溃。所以，只能在假对象中设置<code>DMA_FENCE_FLAG_SIGNALED_BIT</code>标志，让<code>dma_fence_signal_locked</code>提前退出。</p>
<p>只剩下了、<code>dma_fence_put</code>函数，它减少<code>fence</code>的<code>refcount</code>，并在<code>refcount</code>达到0时调用<code>dma_fence_release</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dma_fence_release</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (fence-&gt;ops-&gt;release)</span><br><span class="line">        fence-&gt;ops-&gt;release(fence);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dma_fence_free(fence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用<code>dma_fence_release</code>，那么最终会检查<code>fence-&gt;ops</code>并调用<code>fence-&gt;ops-&gt;release</code>。这就有两个问题。首先，<code>fence-&gt;ops</code>需要指向有效的内存，否则解除引用就会失败，即使解除引用成功，<code>fence-&gt;ops-&gt;release</code>要么需要为零，要么必须是一个适当类型的函数的地址。</p>
<p>所有这些给了两个选择。可以遵循标准路径：尝试用另一个对象替换栅栏对象，或者尝试利用<code>dma_fence_put</code>和<code>dma_fence_set_error</code>提供的有限的写原语，同时希望仍然可以控制<code>flags</code>和<code>refcount</code>字段以避免<code>dma_fence_signal_locked</code>或<code>dma_fence_release</code>使内核崩溃。</p>
<h2 id="The-ultimate-fake-object-store"><a href="#The-ultimate-fake-object-store" class="headerlink" title="The ultimate fake object store"></a>The ultimate fake object store</h2><p>在利用另一个<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/one_day_short_of_a_fullchain_android/">错误</a>时，作者发现了软件输入输出转换旁观缓冲区（<code>SWIOTLB</code>），这是一个在启动时很早就分配的内存区域。因此，<code>SWIOTLB</code>的物理地址是非常固定的，只取决于硬件配置。此外，由于该内存位于 “低内存 “区域（Android设备似乎没有 “高内存 “区域），并且不在内核镜像中，因此虚拟地址只是带有固定偏移的物理地址（对细节感兴趣的读者可以关注<code>kmap</code>函数的实现）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __virt_to_phys_nodebug(x) (&#123;                   \</span></span><br><span class="line"><span class="meta">    phys_addr_t __x = (phys_addr_t)(__tag_reset(x));        \</span></span><br><span class="line"><span class="meta">    __is_lm_address(__x) ? __lm_to_phys(__x) : __kimg_to_phys(__x); \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __is_lm_address(addr)  (!(((u64)addr) &amp; BIT(vabits_actual - 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __lm_to_phys(addr) (((addr) + physvirt_offset))</span></span><br></pre></td></tr></table></figure>

<p>上述定义来自<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/arch/arm64/include/asm/memory.h"><code>arch/arm64/include/asm/memory.h</code></a>，它是Android的相关实现。用于翻译地址的变量<code>physvirt_offset</code>是在<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/arch/arm64/mm/init.c#L517"><code>arm64_memblock_init</code></a>中设置的一个固定常数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">arm64_memblock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;...</span><br><span class="line">    memstart_addr = round_down(memblock_start_of_DRAM(),</span><br><span class="line">                   ARM64_MEMSTART_ALIGN);</span><br><span class="line">    physvirt_offset = PHYS_OFFSET - PAGE_OFFSET;</span><br><span class="line"></span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除此之外，<code>SWIOTLB</code>中的内存可以通过<code>adsp</code>驱动访问，而<code>adsp</code>驱动是可以从一个不受信任的应用程序中到达的，所以这似乎是一个存储假对象和重定向假指针的好地方。然而，在5.x版本的内核中，<code>SWIOTLB</code>只有在用<code>CONFIG_DMA_ZONE32</code>标志编译内核时才会被分配，而Z Flip3 不是这种情况。</p>
<p>然而，还有更好的东西。<code>SWIOTLB</code>的早期分配给了它一个可预测的地址，这促使作者检查启动日志，看看是否有其他的内存区域在启动过程中被提前分配，结果发现确实有其他的内存区域在启动过程中被很早地分配。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;6&gt;[    0.000000] [0:        swapper:    0]  Reserved memory: created CMA memory pool at 0x00000000f2800000, size 212 MiB</span><br><span class="line">&lt;6&gt;[    0.000000] [0:        swapper:    0]  OF: reserved mem: initialized node secure_display_region, compatible <span class="built_in">id</span> shared-dma-pool</span><br><span class="line">...</span><br><span class="line">&lt;6&gt;[    0.000000] [0:        swapper:    0]  OF: reserved mem: initialized node user_contig_region, compatible <span class="built_in">id</span> shared-dma-pool</span><br><span class="line">&lt;6&gt;[    0.000000] [0:        swapper:    0]  Reserved memory: created CMA memory pool at 0x00000000f0c00000, size 12 MiB</span><br><span class="line"></span><br><span class="line">&lt;6&gt;[    0.578613] [7:      swapper/0:    1]  platform soc:qcom,ion:qcom,ion-heap@22: assigned reserved memory node sdsp_region</span><br><span class="line">...</span><br><span class="line">&lt;6&gt;[    0.578829] [7:      swapper/0:    1]  platform soc:qcom,ion:qcom,ion-heap@26: assigned reserved memory node user_contig_region</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面的保留内存区域似乎是用于分配<code>ion</code>缓冲区的内存池。</p>
<p>在Android上，<code>ion_allocator</code>被用来分配用于<code>DMA</code>（直接内存访问）的内存区域，允许内核驱动和用户空间进程共享同一底层内存。未受信任的应用程序可以通过<code>/dev/ion</code>文件访问<code>ion</code>分配器，<code>ION_IOC_ALLOC</code> <code>ioctl</code>可以用来分配一个<code>ion</code>缓冲区。该<code>ioctl</code>向用户返回一个新的文件描述符，然后可以在<code>mmap syscall</code>中使用，将<code>ion</code>缓冲区的后备存储映射到用户空间。</p>
<p>使用<code>ion</code>缓冲区的一个特殊原因是，用户可以请求具有连续物理地址的内存。这一点特别重要，因为有些设备（如硬件上的设备，而不是手机本身）直接访问物理内存，拥有连续的内存地址可以大大改善这种内存访问的性能，而有些设备不能处理非连续的物理内存。</p>
<p>与<code>SWIOTLB</code>类似，为了确保具有请求大小的连续物理内存区域可用，<code>ion</code>驱动在启动初期就分配了这些内存区域，并将其作为内存池（”划出的区域”），然后在以后的请求中用于分配<code>ion</code>缓冲区。并非<code>ion</code>设备中的所有内存池都是连续的内存（例如，通用的 “系统堆 “可能不是物理上连续的区域），但是用户可以在使用<code>ION_IOC_ALLOC</code>时指定<code>heap_id_mask</code>来指定具有特定属性（例如，连续的物理内存）的<code>ion</code>堆。</p>
<p>这些内存池在如此早的阶段被分配，意味着它们的地址是可预测的，只取决于硬件的配置（设备树、可用内存、内存起始地址、各种启动参数等）。这尤其意味着，如果使用<code>ION_IOC_ALLOC</code>从一个很少使用的内存池中分配一个<code>ion</code>缓冲区，这个缓冲区很可能被分配到一个可预测的地址。如果使用<code>mmap</code>将缓冲区映射到用户空间，就可以在任何时候访问这个可预测地址的内存了。</p>
<p>经过一些实验，似乎<code>user_contig_region</code>几乎从未被使用，每次都能把整个区域映射到用户空间。所以在这个漏洞中，作者使用了这个内存池，并假设可以分配整个区域以保持简单。(在不影响可靠性的情况下，修改漏洞以适应部分区域不可用的情况是很容易的)。</p>
<p>现在能够把受控的数据放在一个可预测的地址上，可以解决之前在利用中遇到的问题。回顾一下，当<code>dma_fence_release</code>在假 <code>fence</code> 对象上被调用时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dma_fence_release</span><span class="params">(<span class="keyword">struct</span> kref *kref)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (fence-&gt;ops-&gt;release)</span><br><span class="line">        fence-&gt;ops-&gt;release(fence);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        dma_fence_free(fence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个问题，需要<code>fence-&gt;ops</code>指向一个包含所有零的有效地址，这样<code>fence-&gt;ops-&gt;release</code>就不会被调用（因为在这个阶段没有一个有效的函数地址与<code>fence-&gt;ops-&gt;release</code>的签名相匹配，走这个路径会使内核崩溃）。</p>
<p>由于<code>ion</code>缓冲区在一个可预测的地址上，可以简单地把它填为零，让<code>fence-&gt;ops</code>指向那里。这将确保<code>dma_fence_free</code>路径被采取，然后释放假对象，形成一个<code>double free</code>的原形，同时防止内核崩溃。在继续利用这个<code>double free</code>原语之前，还有一个问题需要首先解决。</p>
<h2 id="Escaping-an-infinite-loop"><a href="#Escaping-an-infinite-loop" class="headerlink" title="Escaping an infinite loop"></a>Escaping an infinite loop</h2><p>回顾一下，在<code>kgsl_ioctl_timeline_destroy</code>函数中，在<code>fence</code>对象被销毁和替换后，会执行以下循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">    dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">    dma_fence_signal_locked(&amp;fence-&gt;base);</span><br><span class="line">    dma_fence_put(&amp;fence-&gt;base);</span><br><span class="line">&#125;</span><br><span class="line">spin_unlock_irq(&amp;timeline-&gt;lock);</span><br></pre></td></tr></table></figure>

<p><code>list_for_each_entry_safe</code> 将首先从 <code>list_head</code> <code>temp</code> 中获取下一个指针，找到列表中的第一个<code>fence</code>条目，然后通过跟踪 <code>fence-&gt;node</code> 中的下一个指针进行迭代，直到下一个条目再次指向 <code>temp</code>。如果下一个条目没有指向<code>temp</code>，那么这个循环就会继续。这是一个变量初始化使利用更加困难的地方。看看<code>kgsl_timeline_fence</code>的结构，它嵌入了一个<code>dma_fence</code>对象，被添加到<code>kgsl_timeline</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kgsl_timeline_fence</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dma_fence</span> <span class="title">base</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kgsl_timeline</span> *<span class="title">timeline</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>node</code>字段是<code>kgsl_timeline_fence</code>中的最后一个字段，而为了构建这个漏洞，只需要用受控数据替换<code>base</code>。如果用部分对象替换，上述问题就会很容易解决了。在没有自动变量初始化的情况下，如果只将释放的<code>kgsl_timeline_fence</code>替换成一个<code>dma_fence</code>大小的对象，那么字段<code>timeline</code>和<code>node</code>将保持不变，并包含有效数据。这将导致<code>node</code>中的下一个指针有效，并允许<code>kgsl_ioctl_timeline_destroy</code>的循环正常退出。然而，在自动变量初始化的情况下，即使把释放的<code>kgsl_timeline_fence</code>对象换成一个更小的对象，整个内存块也会首先被设置为零，抹去<code>kgsl_timeline</code>和<code>node</code>，这意味着必须伪造<code>node</code>字段，以便：</p>
<ol>
<li>下一个指针指向一个有效的地址，以避免立即崩溃，事实上，不止如此，它需要指向一个对象，这个对象是另一个假的<code>kgsl_timeline_fence</code>，可以被循环中的函数（<code>dma_fence_set_error</code>、<code>dma_fence_signal_locked</code>和<code>dma_fence_put</code>）操作而不崩溃。这意味着需要制作更多的假对象。</li>
<li>这些假的<code>kgsl_timeline_fence</code>对象中的一个下一个指针指向了退出循环的<code>temp</code>列表，这是一个堆栈分配的变量。</li>
</ol>
<p>第一个要求并不难，因为现在可以使用<code>ion</code>缓冲器来创建这些假的<code>kgsl_timeline_fence</code>对象。然而，第二个要求则要难得多：</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/Kernel-4.webp" alt="Kernel-4"></p>
<p>这将导致一个无限循环，并耽误CPU。虽然它很难看，但假的对象应该能解决取消引用的问题并避免崩溃，所以它可能不是一个致命的问题。不幸的是，由于该循环在自旋锁内运行，在运行了一小段时间后，看门狗似乎会将其标记为占用CPU的问题并触发内核恐慌。所以，需要找到一种方法来退出循环，而且是快速退出。</p>
<p>看看函数<code>dma_fence_signal_locked</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dma_fence_signal_locked</span><span class="params">(<span class="keyword">struct</span> dma_fence *fence)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cb_list</span>;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* Stash the cb_list before replacing it with the timestamp */</span></span><br><span class="line">    list_replace(&amp;fence-&gt;cb_list, &amp;cb_list);             <span class="comment">//&lt;-- 1.</span></span><br><span class="line">    ...</span><br><span class="line">    list_for_each_entry_safe(cur, tmp, &amp;cb_list, node) &#123; <span class="comment">//&lt;-- 2.</span></span><br><span class="line">        INIT_LIST_HEAD(&amp;cur-&gt;node);</span><br><span class="line">        cur-&gt;func(fence, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数将对列表<code>temp</code>中的每个假<code>dma_fence</code>（原始已释放的和替换的<code>dma_fence</code>，加上它在<code>ion buffer</code>中链接的那些）运行。如前所述，如果运行上面2处的代码，那么内核可能会崩溃，因为不能提供一个有效的<code>func</code>，所以还是避免运行这个路径。</p>
<p>为了能够运行这段代码而不是上面2中的循环代码，需要将<code>fence.cb_list</code>初始化为一个空列表，这样它的<code>next</code>和<code>prev</code>都指向它自己。这对于被漏洞释放的初始假<code>dma_fence</code>来说是不可能的，因为<code>fence</code>的地址以及<code>fence.cb_list</code>是未知的，所以不得不对这个第一个假对象完全避免使用<code>list_replace</code>代码。然而，由于随后链接到它的假<code>dma_fence</code>对象是在一个已知地址的<code>ion</code>缓冲区中，现在可以为这些对象创建一个空的<code>cb_list</code>，将<code>next</code>和<code>prev</code>指针都设置为<code>fence.cb_list</code>字段的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_replace</span><span class="params">(<span class="keyword">struct</span> list_head *old,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> list_head *new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//old-&gt;next = &amp;(fence-&gt;cb_list)</span></span><br><span class="line">    new-&gt;next = old-&gt;next;</span><br><span class="line">    <span class="comment">//new-&gt;next = &amp;(fence-&gt;cb_list) =&gt; fence-&gt;cb_list.prev = &amp;cb_list</span></span><br><span class="line">    new-&gt;next-&gt;prev = new;</span><br><span class="line">    <span class="comment">//new-&gt;prev = fence-&gt;cb_list.prev =&gt; &amp;cb_list</span></span><br><span class="line">    new-&gt;prev = old-&gt;prev;</span><br><span class="line">    <span class="comment">//&amp;cb_list-&gt;next = &amp;cb_list</span></span><br><span class="line">    new-&gt;prev-&gt;next = new;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>list_replace</code>之后，堆栈变量<code>cb_list</code>的地址已经被写入了<code>fence-&gt;cb_list.prev</code>，它在<code>ion</code>缓冲区的某处。由于<code>ion</code>缓冲区被映射到了用户空间，可以通过轮询<code>ion</code>缓冲区简单地读取这个地址。由于<code>dma_fence_signal_locked</code>是在堆栈变量<code>temp</code>被分配后在<code>kgsl_ioctl_timeline_destroy</code>里面运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">kgsl_ioctl_timeline_destroy</span><span class="params">(<span class="keyword">struct</span> kgsl_device_private *dev_priv,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">temp</span>;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    spin_lock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    list_for_each_entry_safe(fence, tmp, &amp;temp, node) &#123;</span><br><span class="line">        dma_fence_set_error(&amp;fence-&gt;base, -ENOENT);</span><br><span class="line">        <span class="comment">//cb_list, is a stack variable allocated inside `dma_fence_signal_locked`</span></span><br><span class="line">        dma_fence_signal_locked(&amp;fence-&gt;base);</span><br><span class="line">        dma_fence_put(&amp;fence-&gt;base);</span><br><span class="line">    &#125;</span><br><span class="line">    spin_unlock_irq(&amp;timeline-&gt;lock);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了<code>cb_list</code>的地址，就可以计算<code>temp</code>的地址，（它与<code>cb_list</code>的地址有一个固定的偏移），所以通过轮询<code>cb_list</code>的地址，然后用它来计算<code>temp</code>的地址，并把它写回<code>ion</code>缓冲区中一个假的<code>kgsl_timeline_fence</code>对象的下一个指针，可以在看门狗咬人之前退出循环。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/Kernel-5.webp" alt="Kernel-5"></p>
<h2 id="Hijacking-the-freelist"><a href="#Hijacking-the-freelist" class="headerlink" title="Hijacking the freelist"></a>Hijacking the freelist</h2><p><code>dma_fence_put</code>将减少假对象的<code>refcount</code>，如果<code>refcount</code>达到0，它将调用<code>dma_fence_free</code>，然后用<code>kfree_rcu</code>释放该对象。现在假设假对象将被<code>kfree_rcu</code>释放。通过用另一个对象再次替换这个假对象，就可以得到对同一个对象的两个引用，将能够在任何时候使用这些对象的句柄释放这些对象。一般的想法是，当一个内存块被释放时，指向下一个自由块的<code>freelist</code>指针将被写入内存块的前8字节。如果从一个句柄中释放对象，然后用另一个句柄修改这个被释放的对象的前8字节，那么就可以劫持<code>freelist</code>指针，让它指向选择的地址，这就是下一次分配将发生的地方。</p>
<p>为了能够修改对象分配后的前8字节，这里使用“<a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2020/02/mitigations-are-attack-surface-too.html">Mitigations are attack surface too</a>”中使用的<code>signalfd</code>对象。<code>signalfd</code>系统调用分配了一个8字节的对象来存储<code>signalfd</code>文件的掩码，这个掩码可以由用户指定，但有一些小限制。所分配对象的寿命与返回给用户的<code>signalfd</code>文件相联系，可以通过关闭该文件轻松控制。此外，这个对象的前8个字节可以通过用不同的掩码再次调用<code>signalfd</code>来改变。</p>
<p>为了劫持freelist指针：</p>
<ol>
<li>触发UAF bug，用一个通过<code>sendmsg</code>分配的假的<code>dma_fence</code>对象替换已释放的对象，这样<code>dma_fence_free</code>将被调用，用<code>kfree_rcu</code>释放这个假对象。</li>
<li>用<code>signalfd</code>堆喷，在<code>sendmsg</code>对象被释放后，在同一地址分配另一个对象。</li>
<li>释放<code>sendmsg</code>对象，使<code>freelist</code>指针被写入第二步中<code>signalfd</code>对象的掩码。</li>
<li>修改<code>signalfd</code>对象的掩码，使<code>freelist</code>指针现在指向一个指定的地址，然后再次堆喷，在该地址分配对象。</li>
</ol>
<p>如果将<code>freelist</code>指针的地址设置为我们控制的<code>ion</code>缓冲区的地址，那么随后的分配将把对象放入<code>ion</code>缓冲区，然后可以随时访问和修改，即，可以在一个有读和写权限的区域内伪造自己的内核堆。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/Kernel-6.webp" alt="Kernel-6"></p>
<p>这个方案的主要障碍来自于<code>kfree_rcu</code>和运行<code>dma_fence_put</code>的<code>CPU</code>在调用<code>kfree_rcu</code>后将暂时陷入一个繁忙的循环。回顾上一节，在能够通过将 <code>temp</code> 列表的地址写入假的<code>kgsl_timeline_fence::node</code>对象的下一个指针来退出循环之前，这个循环将一直运行。这意味着，一旦调用<code>kfree_rcu</code>，<code>dma_fence_put</code>被退出，该循环将继续处理运行<code>kfree_rcu</code>的<code>CPU</code>上的其他假<code>dma_fence</code>对象。正如前面所解释的，<code>kfree_rcu</code>不会立即释放一个对象，而是延迟移除。大多数情况下，释放将实际发生在调用<code>kfree_rcu</code>的同一个<code>CPU</code>上。然而，在这种情况下，由于运行<code>kfree_rcu</code>的<code>CPU</code>因为运行循环而在 <code>spinlock</code> 中保持繁忙，对象几乎肯定不会在同一个<code>CPU</code>上被释放。相反，一个不同的<code>CPU</code>将被用来释放该对象。这导致了一个问题，因为对象替换的可靠性取决于用于释放对象的<code>CPU</code>。当一个对象在<code>CPU</code>上被释放时，内存分配器将把它放在每个<code>CPU</code>的缓存中。紧接着在同一<code>CPU</code>上进行的分配将首先在<code>CPU</code>缓存中寻找空闲空间，并且很可能会替换那个新释放的对象。然而，如果分配发生在不同的<code>CPU</code>上，那么它很可能会替换不同<code>CPU</code>缓存中的一个对象，而不是新释放的对象。不知道哪个<code>CPU</code>负责释放对象，再加上对象被释放的时间不确定（因为<code>kfree_rcu</code>引入的延迟），意味着可能很难替换对象。然而，在实践中，简单地运行一个循环，在每个<code>CPU</code>上喷射物体，并以一定的间隔重复喷射，以考虑到时间上的不确定性（成功率大于70%）。</p>
<p>漏洞中使用的另一个小修改是，在<code>sendmsg</code>对象被释放后，用另一轮<code>signalfd</code>堆喷来替换它们。这是为了确保这些<code>sendmsg</code>对象不会意外地被不控制的对象所替换，从而干扰了漏洞的利用，同时也是为了更容易识别实际被破坏的对象。</p>
<p>现在可以劫持<code>freelist</code>并将新的对象分配重定向到可以随时自由访问的<code>ion</code>缓冲区，现在需要将其变成一个任意的内存读写原语。</p>
<h2 id="The-Device-Memory-Mirroring-Attack"><a href="#The-Device-Memory-Mirroring-Attack" class="headerlink" title="The Device Memory Mirroring Attack"></a>The Device Memory Mirroring Attack</h2><p>内核驱动经常需要将内存映射到用户空间，因此，经常有一些结构包含指向<code>page</code>结构或<code>sg_table</code>结构的指针。这些结构通常包含指向页面的指针，这些页面将被映射到用户空间，例如，当调用<code>mmap</code>时。这使得它们成为非常好的破坏目标。例如，<code>ion_buffer</code>对象在所有的Android设备上都可用。它有一个<code>sg_table</code>结构，包含了当<code>mmap</code>被使用时将被映射到用户空间的页面的信息。</p>
<p>除了可以广泛使用和从不可信任的应用程序中访问外，<code>ion_buffer</code>对象还解决了一些其他问题，所以在下面的内容中，将使用上面的<code>freelist</code>劫持原语，在有任意读写权限的<code>ion</code>缓冲区备份存储中分配一个<code>ion_buffer</code>结构。通过这样做，可以随意破坏所有被分配的 <code>ion_buffer</code> 结构中的数据。为了避免混淆，从现在开始，将使用术语 “假内核堆 “来表示用作假内核堆的<code>ion</code>缓冲区备份存储，以及在假内核堆中分配的用作破坏目标的结构的<code>ion_buffer</code>。</p>
<p>这里的总体想法是，通过在假的内核堆中分配<code>ion_buffer</code>结构，将能够修改<code>ion_buffer</code>结构，用受控数据替换其<code>sg_table</code>。<code>sg_table</code>结构包含一个<code>scatterlist</code>结构，表示支持<code>ion_buffer</code>结构的页面集合。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> *<span class="title">sgl</span>;</span>    <span class="comment">/* the list */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> nents;     <span class="comment">/* number of mapped entries */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> orig_nents;    <span class="comment">/* original size of list */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scatterlist</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   page_link;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    offset;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    length;</span><br><span class="line">    <span class="type">dma_addr_t</span>  dma_address;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NEED_SG_DMA_LENGTH</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>    dma_length;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>scatterlist</code>中的<code>page_link</code>字段是一个页面指针的编码形式，表明<code>ion_buffer</code>结构的备份存储所在的实际页面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">sg_page</span><span class="params">(<span class="keyword">struct</span> scatterlist *sg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DEBUG_SG</span></span><br><span class="line">    BUG_ON(sg_is_chain(sg));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> page *)((sg)-&gt;page_link &amp; ~(SG_CHAIN | SG_END));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>mmap</code>被调用时，由<code>page_link</code>编码的页面将被映射到用户空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ion_heap_map_user</span><span class="params">(<span class="keyword">struct</span> ion_heap *heap, <span class="keyword">struct</span> ion_buffer *buffer,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> vm_area_struct *vma)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sg_table</span> *<span class="title">table</span> =</span> buffer-&gt;sg_table;</span><br><span class="line">    ...</span><br><span class="line">    for_each_sg(table-&gt;sgl, sg, table-&gt;nents, i) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> sg_page(sg);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//Maps pages to user space</span></span><br><span class="line">        ret = remap_pfn_range(vma, addr, page_to_pfn(page), len,</span><br><span class="line">                      vma-&gt;vm_page_prot);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>page</code> 指针只是页面物理地址的逻辑移位，然后是一个恒定的线性偏移（见<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/arch/arm64/include/asm/memory.h#L285"><code>phys_to_page</code></a>的定义），能够控制<code>page_link</code>就可以把一个任意的页面映射到用户空间。对于许多设备来说，这就足以实现任意的内核内存读写，因为内核映像是在一个固定的物理地址上映射的（<code>KASLR</code>随机化了这个固定物理地址的虚拟地址偏移），所以在处理物理地址的时候不需要担心<code>KASLR</code>。</p>
<p><img src="/Users/DarkMatter/Documents/Hacking/Blog/source/pictures/Kernel-7.webp" alt="Kernel-7"></p>
<p>然而，三星设备以不同的方式进行<code>KASLR</code>。内核镜像的物理地址不是映射到一个固定的物理地址，而是随机化的（严格来说，是内核认为的中间物理地址，这不是真正的物理地址，而是由管理程序给出的虚拟地址）。所以在我们的案例中，仍然需要泄露一个地址来打败<code>KASLR</code>。然而，有了假的内核堆，这就相当容易实现了。一个<code>ion_buffer</code>对象包含一个指向<code>ion_heap</code>的指针，它负责为<code>ion_buffer</code>分配后备存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>虽然<code>ion_heap</code>在内核镜像中不是一个全局对象，但每个<code>ion_heap</code>都包含一个<code>ion_heap_ops</code>字段，它指向特定<code>ion_heap</code>对象的相应 <code>vtable</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">plist_node</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">ion_heap_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>ops</code>字段是内核镜像中的一个全局对象。如果能够读取<code>ion_buffer-&gt;heap-&gt;ops</code>，那么也能够得到一个地址来打败<code>KASLR</code>，将内核镜像中的地址翻译成物理地址。这可以按以下方法进行。</p>
<ol>
<li>首先在假的内核堆中找到<code>ion_buffer</code>结构的位置。这可以通过<code>ion_buffer</code>中的<code>flags</code>字段来完成。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ion_buffer</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ion_heap</span> *<span class="title">heap</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>这是在创建<code>ion_buffer</code>时从<code>ION_IOC_ALLOC</code> <code>ioctl</code>的参数中传递的4个字节的值。可以将这些设置为特定的 “魔法 “值，并在假的内核堆中搜索它们。</p>
<ol start="2">
<li>一旦找到<code>ion_buffer</code>结构，读取其堆指针。这将是内核镜像之外的低内存区域的一个虚拟地址，因此，它的物理地址可以通过应用常数偏移来获得。</li>
<li>一旦获得相应的<code>ion_heap</code>对象的物理地址，修改<code>ion_buffer</code>的<code>sg_table</code>，使其后备存储指向包含<code>ion_heap</code>的页面。</li>
<li>在<code>ion_buffer</code>的文件描述符上调用<code>mmap</code>，这将把包含<code>ion_heap</code>的页面映射到用户空间。然后可以直接从用户空间读取该页以获得<code>OPS</code>指针，这将提供<code>KASLR</code>的偏移。</li>
</ol>
<p><code>ion_buffer</code>结构的使用也解决了另一个问题。虽然假内核堆很方便，但它并不完美。每当假内核堆中的一个对象被释放时，<code>kfree</code>将使用<code>PageSlab</code>检查来检查包含该对象的页面是否是来自<code>SLUB</code>分配器的单页<code>slab</code>。如果检查失败，那么<code>PageCompound</code>检查将被执行，以检查该页是否是一个更大的<code>slab</code>的一部分。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">void</span> *object = (<span class="type">void</span> *)x;</span><br><span class="line"></span><br><span class="line">    trace_kfree(_RET_IP_, x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unlikely(ZERO_OR_NULL_PTR(x)))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    page = virt_to_head_page(x);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(!PageSlab(page))) &#123;     <span class="comment">//&lt;-------- check if the page allocated is a single page slab</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> order = compound_order(page);</span><br><span class="line"></span><br><span class="line">        BUG_ON(!PageCompound(page));     <span class="comment">//&lt;-------- check if the page is allocated as part of a multipage slab</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于这些检查是在包含页面元数据的页面结构本身上进行的，因此只要有对象被释放，它们就会失败并导致内核崩溃。这可以通过使用现在拥有的任意读写原语来覆盖页面结构中各自的元数据来解决（对应于物理地址的页面结构的地址只是物理地址的逻辑移动，然后是固定偏移量的转换，所以可以将包含页面结构的页面映射到用户空间并修改其内容）。然而，如果能够确保占据假内核堆的对象永远不会被释放，那就更简单了。在<code>ion_buffer</code>结构被释放之前，会调用<code>ion_buffer_destroy</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ion_buffer_destroy</span><span class="params">(<span class="keyword">struct</span> ion_device *dev, <span class="keyword">struct</span> ion_buffer *buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    heap = buffer-&gt;heap;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;flags &amp; ION_HEAP_FLAG_DEFER_FREE)</span><br><span class="line">        ion_heap_freelist_add(heap, buffer);    <span class="comment">//&lt;--------- does not free immediately</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ion_buffer_release(buffer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>ion_heap</code>包含标志<code>ION_HEAP_FLAG_DEFER_FREE</code>，那么<code>ion_buffer</code>不会立即被释放，而是通过<code>ion_heap_freelist_add</code>被添加到<code>ion_heap</code>的<code>free_list</code>。添加到这个列表中的<code>ion_buffer</code>对象只有在以后需要的时候才会被释放，而且只有在<code>ION_HEAP_FLAG_DEFER_FREE</code>标志被设置的情况下。当然，通常情况下，<code>ION_HEAP_FLAG_DEFER_FREE</code>在<code>ION_heap</code>的生命周期内不会改变，但是通过我们的任意内存写入基元，可以简单地将<code>ION_HEAP_FLAG_DEFER_FREE</code>添加到<code>ION_heap-&gt;flags</code>中，释放<code>ION_buffer</code>，然后再次移除<code>ION_HEAP_FLAG_DEFER_FREE</code>，<code>ION_buffer</code>将只是停留在<code>ION_heap</code>的<code>freelist</code>中而永远不会被释放。此外，包含<code>ion_heap</code>对象的页面已经被映射，目的是为了绕过<code>KASLR</code>，所以切换该标志是相当微不足道的。通过喷洒假的内核堆，使其充满了<code>ion_buffer</code>对象及其附属物，可以确保这些对象永远不会被释放，避免内核崩溃。</p>
<h2 id="Bypassing-SELinux"><a href="#Bypassing-SELinux" class="headerlink" title="Bypassing SELinux"></a>Bypassing SELinux</h2><p>当<code>SELinux</code>被启用时，它可以在 <code>permissive</code> 模式或 <code>enforcing</code> 模式下运行。当处于 <code>permissive</code> 模式时，它将只审计和记录未经授权的访问，但不会阻止它们。<code>SELinux</code>的运行模式是由<code>selinux_enforcing</code>变量控制的。如果这个变量为零，那么<code>SELinux</code>就以 <code>permissive</code> 模式运行。通常，对系统安全至关重要的变量会受到三星内核数据保护（KDP）的保护，通过使用<code>__kdp_ro</code>或<code>__rkp_ro</code>属性将其标记为只读。这个属性表明该变量处于只读页面，其修改受到管理程序调用的保护。然而，在5.x分支的高通内核中，三星似乎忘记了保护这个变量（<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/qualcomm_npu/">又是这样吗</a>！）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//In security/selinux/hooks.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY_SELINUX_DEVELOP</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> selinux_enforcing_boot;</span><br><span class="line"><span class="type">int</span> selinux_enforcing;</span><br></pre></td></tr></table></figure>

<p>所以，可以直接将<code>selinux_enforcing</code>覆盖为零，并将<code>SELinux</code>设置为<code>permissive</code>模式。虽然还有其他绕过<code>SELinux</code>的方法（比如Valentina Palmiotti在这个<a target="_blank" rel="noopener" href="https://github.com/chompie1337/s8_2019_2215_poc/blob/master/poc/selinux_bypass.c">漏洞</a>中使用的方法），但此时的捷径更受欢迎，所以将直接设置<code>selinux_enforcing</code>变量。</p>
<h2 id="Running-arbitrary-root-commands-using-ret2kworker-TM"><a href="#Running-arbitrary-root-commands-using-ret2kworker-TM" class="headerlink" title="Running arbitrary root commands using ret2kworker(TM)"></a>Running arbitrary root commands using ret2kworker(TM)</h2><p>在三星设备上获得<code>root</code>权限的一个众所周知的问题是三星的<code>RKP</code>（实时内核保护）所施加的保护。在安卓设备上获得<code>root</code>权限的一个常见方法是用<code>root</code>权限覆盖我们自己进程的证书。然而，三星的<code>RKP</code>写保护每个进程的凭证，所以这在这里是不可能的。在作者的上一次<a target="_blank" rel="noopener" href="https://securitylab.github.com/research/qualcomm_npu/">利用</a>中，能够以<code>root</code>身份执行任意代码，因为所利用的特定UAF导致一个受控函数指针在以<code>root</code>身份运行的<code>kworker</code>的代码中被执行。</p>
<p>当然，通过任意的内存读写原语，可以简单地将对象添加到这些工作队列之一（基本上是包含工作结构的链接列表），并等待一个<code>kworker</code>来接取工作。事实证明，许多这些工作队列确实是静态的全局对象，在内核镜像中具有固定的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ffffffc012c8f7e0 D system_wq</span><br><span class="line">ffffffc012c8f7e8 D system_highpri_wq</span><br><span class="line">ffffffc012c8f7f0 D system_long_wq</span><br><span class="line">ffffffc012c8f7f8 D system_unbound_wq</span><br><span class="line">ffffffc012c8f800 D system_freezable_wq</span><br><span class="line">ffffffc012c8f808 D system_power_efficient_wq</span><br><span class="line">ffffffc012c8f810 D system_freezable_power_efficient_wq</span><br></pre></td></tr></table></figure>

<p>因此，将条目添加到这些工作队列中并让<code>kworker</code>来处理这些工作是比较直接的。然而，由于<code>kCFI</code>，只能调用具有以下签名的函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (func*)(<span class="keyword">struct</span> work_struct *work)</span><br></pre></td></tr></table></figure>

<p>是否能找到一个足够强大的函数来运行？结果相当简单。函数<a target="_blank" rel="noopener" href="https://git.codelinaro.org/clo/la/kernel/msm-5.4/-/blob/5e3cf80f1b6a12fcf54b007f3c9f235f35b9b7f1/kernel/umh.c#L190"><code>call_usermodehelper_exec_work</code></a>，通常在内核漏洞中被用来运行<code>shell</code>命令，它符合这个要求，可以运行提供的<code>shell</code>命令。因此，通过修改，比如说，<code>system_unbound_wq</code>，并在其中添加一个持有<code>call_usermodehelper_exec_work</code>指针的条目，可以绕过三星的<code>RKP</code>和<code>kCFI</code>，以<code>root</code>身份运行任意命令。</p>
<h1 id="复现情况"><a href="#复现情况" class="headerlink" title="复现情况"></a>复现情况</h1><p>需要<code>Snapdragon 888</code>及以上芯片的测试机，目前没有。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://github.blog/2022-06-16-the-android-kernel-mitigations-obstacle-race/">The Android kernel mitigations obstacle race</a></p>
<p><a target="_blank" rel="noopener" href="https://googleprojectzero.blogspot.com/2022/04/the-more-you-know-more-you-know-you.html">The More You Know, The More You Know You Don’t Know</a></p>
</div></article></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://avatars.githubusercontent.com/u/19711495?v=4" alt="buffer0verflooow"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">buffer0verflooow</p><p class="is-size-6 is-block">Security Researcher</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">56</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">0</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">51</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="me noopener">Follow</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Github" href="https://github.com/ppoffice"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="me noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-10-10T06:23:56.000Z">2022-10-10</time></p><p class="title"><a href="/2022/10/10/%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"> </a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-30T07:29:09.000Z">2022-07-30</time></p><p class="title"><a href="/2022/07/30/Android%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0/">Android安全笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-20T12:35:56.000Z">2022-07-20</time></p><p class="title"><a href="/2022/07/20/Android%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/">Android中间人攻击方法整理</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-04T12:34:01.000Z">2022-07-04</time></p><p class="title"><a href="/2022/07/04/Android-11-%E9%AD%94%E5%BD%A2%E5%A5%B3%E6%BC%8F%E6%B4%9E/">Android 11 魔形女漏洞</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-07-01T13:59:36.000Z">2022-07-01</time></p><p class="title"><a href="/2022/07/01/macOS-Intel%E5%9B%BE%E5%BD%A2%E5%86%85%E6%A0%B8%E6%8B%93%E5%B1%95RCE-EOP/">macOS Intel图形内核拓展RCE+EOP</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/10/"><span class="level-start"><span class="level-item">October 2022</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/07/"><span class="level-start"><span class="level-item">July 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/06/"><span class="level-start"><span class="level-item">June 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/05/"><span class="level-start"><span class="level-item">May 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/04/"><span class="level-start"><span class="level-item">April 2022</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/03/"><span class="level-start"><span class="level-item">March 2022</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">February 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">January 2022</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/12/"><span class="level-start"><span class="level-item">December 2021</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/11/"><span class="level-start"><span class="level-item">November 2021</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">August 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/ASN-1/"><span class="tag">ASN.1</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/AppleAVE2/"><span class="tag">AppleAVE2</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ContentProvider/"><span class="tag">ContentProvider</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IOServices/"><span class="tag">IOServices</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LPE/"><span class="tag">LPE</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/PendingIntent/"><span class="tag">PendingIntent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/adobe/"><span class="tag">adobe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/afl/"><span class="tag">afl++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ams/"><span class="tag">ams</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/android/"><span class="tag">android</span><span class="tag">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/aosp/"><span class="tag">aosp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/apple/"><span class="tag">apple</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/arm64/"><span class="tag">arm64</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/cfprefsd/"><span class="tag">cfprefsd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/chrome/"><span class="tag">chrome</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/darwin/"><span class="tag">darwin</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/exploit/"><span class="tag">exploit</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/fuzz/"><span class="tag">fuzz</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/gpu/"><span class="tag">gpu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hook/"><span class="tag">hook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intel/"><span class="tag">intel</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/intent/"><span class="tag">intent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iomfb/"><span class="tag">iomfb</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ios/"><span class="tag">ios</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/logic-vul/"><span class="tag">logic vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/lpe/"><span class="tag">lpe</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mach/"><span class="tag">mach</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/macos/"><span class="tag">macos</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mig/"><span class="tag">mig</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/note/"><span class="tag">note</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npu/"><span class="tag">npu</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pac/"><span class="tag">pac</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pipe/"><span class="tag">pipe</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/pongoOS/"><span class="tag">pongoOS</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qemu/"><span class="tag">qemu</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcom/"><span class="tag">qualcom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qualcomm/"><span class="tag">qualcomm</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rce/"><span class="tag">rce</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/safari/"><span class="tag">safari</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/samsung/"><span class="tag">samsung</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/soot/"><span class="tag">soot</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/static-analysis/"><span class="tag">static analysis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/syzkaller/"><span class="tag">syzkaller</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tcc/"><span class="tag">tcc</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/telecom/"><span class="tag">telecom</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/uaf/"><span class="tag">uaf</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vul/"><span class="tag">vul</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/webaudio/"><span class="tag">webaudio</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xnu/"><span class="tag">xnu</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xpc/"><span class="tag">xpc</span><span class="tag">1</span></a></div></div></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="buffer0verflooow - Blog" height="28"></a><p class="is-size-7"><span>&copy; 2024 buffer0verflooow</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2019</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>